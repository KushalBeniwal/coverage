
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>v1alpha3: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">sigs.k8s.io/cluster-api-provider-azure/api/v1alpha3/azurecluster_conversion.go (61.5%)</option>
				
				<option value="file1">sigs.k8s.io/cluster-api-provider-azure/api/v1alpha3/azurecluster_types.go (33.3%)</option>
				
				<option value="file2">sigs.k8s.io/cluster-api-provider-azure/api/v1alpha3/azureclusteridentity_conversion.go (80.0%)</option>
				
				<option value="file3">sigs.k8s.io/cluster-api-provider-azure/api/v1alpha3/azureclusteridentity_types.go (11.1%)</option>
				
				<option value="file4">sigs.k8s.io/cluster-api-provider-azure/api/v1alpha3/azuremachine_conversion.go (89.4%)</option>
				
				<option value="file5">sigs.k8s.io/cluster-api-provider-azure/api/v1alpha3/azuremachine_types.go (33.3%)</option>
				
				<option value="file6">sigs.k8s.io/cluster-api-provider-azure/api/v1alpha3/azuremachinetemplate_conversion.go (81.2%)</option>
				
				<option value="file7">sigs.k8s.io/cluster-api-provider-azure/api/v1alpha3/azuremachinetemplate_types.go (100.0%)</option>
				
				<option value="file8">sigs.k8s.io/cluster-api-provider-azure/api/v1alpha3/tags.go (6.7%)</option>
				
				<option value="file9">sigs.k8s.io/cluster-api-provider-azure/api/v1alpha3/types.go (0.0%)</option>
				
				<option value="file10">sigs.k8s.io/cluster-api-provider-azure/api/v1alpha3/zz_generated.conversion.go (41.6%)</option>
				
				<option value="file11">sigs.k8s.io/cluster-api-provider-azure/api/v1alpha3/zz_generated.deepcopy.go (16.9%)</option>
				
				<option value="file12">sigs.k8s.io/cluster-api-provider-azure/api/v1alpha4/azurecluster_conversion.go (82.9%)</option>
				
				<option value="file13">sigs.k8s.io/cluster-api-provider-azure/api/v1alpha4/azurecluster_types.go (20.0%)</option>
				
				<option value="file14">sigs.k8s.io/cluster-api-provider-azure/api/v1alpha4/azureclusteridentity_conversion.go (50.0%)</option>
				
				<option value="file15">sigs.k8s.io/cluster-api-provider-azure/api/v1alpha4/azureclusteridentity_types.go (33.3%)</option>
				
				<option value="file16">sigs.k8s.io/cluster-api-provider-azure/api/v1alpha4/azuremachine_conversion.go (80.6%)</option>
				
				<option value="file17">sigs.k8s.io/cluster-api-provider-azure/api/v1alpha4/azuremachine_types.go (20.0%)</option>
				
				<option value="file18">sigs.k8s.io/cluster-api-provider-azure/api/v1alpha4/azuremachinetemplate_conversion.go (73.9%)</option>
				
				<option value="file19">sigs.k8s.io/cluster-api-provider-azure/api/v1alpha4/azuremachinetemplate_types.go (100.0%)</option>
				
				<option value="file20">sigs.k8s.io/cluster-api-provider-azure/api/v1alpha4/tags.go (6.7%)</option>
				
				<option value="file21">sigs.k8s.io/cluster-api-provider-azure/api/v1alpha4/types.go (0.0%)</option>
				
				<option value="file22">sigs.k8s.io/cluster-api-provider-azure/api/v1alpha4/zz_generated.conversion.go (38.2%)</option>
				
				<option value="file23">sigs.k8s.io/cluster-api-provider-azure/api/v1alpha4/zz_generated.deepcopy.go (14.5%)</option>
				
				<option value="file24">sigs.k8s.io/cluster-api-provider-azure/api/v1beta1/azurecluster_conversion.go (0.0%)</option>
				
				<option value="file25">sigs.k8s.io/cluster-api-provider-azure/api/v1beta1/azurecluster_default.go (88.4%)</option>
				
				<option value="file26">sigs.k8s.io/cluster-api-provider-azure/api/v1beta1/azurecluster_types.go (20.0%)</option>
				
				<option value="file27">sigs.k8s.io/cluster-api-provider-azure/api/v1beta1/azurecluster_validation.go (93.3%)</option>
				
				<option value="file28">sigs.k8s.io/cluster-api-provider-azure/api/v1beta1/azurecluster_webhook.go (82.8%)</option>
				
				<option value="file29">sigs.k8s.io/cluster-api-provider-azure/api/v1beta1/azureclusteridentity_conversion.go (0.0%)</option>
				
				<option value="file30">sigs.k8s.io/cluster-api-provider-azure/api/v1beta1/azureclusteridentity_types.go (33.3%)</option>
				
				<option value="file31">sigs.k8s.io/cluster-api-provider-azure/api/v1beta1/azureclusteridentity_webhook.go (0.0%)</option>
				
				<option value="file32">sigs.k8s.io/cluster-api-provider-azure/api/v1beta1/azureclustertemplate_conversion.go (0.0%)</option>
				
				<option value="file33">sigs.k8s.io/cluster-api-provider-azure/api/v1beta1/azureclustertemplate_default.go (74.5%)</option>
				
				<option value="file34">sigs.k8s.io/cluster-api-provider-azure/api/v1beta1/azureclustertemplate_types.go (100.0%)</option>
				
				<option value="file35">sigs.k8s.io/cluster-api-provider-azure/api/v1beta1/azureclustertemplate_validation.go (63.6%)</option>
				
				<option value="file36">sigs.k8s.io/cluster-api-provider-azure/api/v1beta1/azureclustertemplate_webhook.go (54.5%)</option>
				
				<option value="file37">sigs.k8s.io/cluster-api-provider-azure/api/v1beta1/azureimage_validation.go (95.3%)</option>
				
				<option value="file38">sigs.k8s.io/cluster-api-provider-azure/api/v1beta1/azuremachine_conversion.go (0.0%)</option>
				
				<option value="file39">sigs.k8s.io/cluster-api-provider-azure/api/v1beta1/azuremachine_default.go (93.8%)</option>
				
				<option value="file40">sigs.k8s.io/cluster-api-provider-azure/api/v1beta1/azuremachine_types.go (20.0%)</option>
				
				<option value="file41">sigs.k8s.io/cluster-api-provider-azure/api/v1beta1/azuremachine_validation.go (92.4%)</option>
				
				<option value="file42">sigs.k8s.io/cluster-api-provider-azure/api/v1beta1/azuremachine_webhook.go (94.3%)</option>
				
				<option value="file43">sigs.k8s.io/cluster-api-provider-azure/api/v1beta1/azuremachinetemplate_conversion.go (0.0%)</option>
				
				<option value="file44">sigs.k8s.io/cluster-api-provider-azure/api/v1beta1/azuremachinetemplate_types.go (100.0%)</option>
				
				<option value="file45">sigs.k8s.io/cluster-api-provider-azure/api/v1beta1/azuremachinetemplate_webhook.go (84.4%)</option>
				
				<option value="file46">sigs.k8s.io/cluster-api-provider-azure/api/v1beta1/tags.go (6.7%)</option>
				
				<option value="file47">sigs.k8s.io/cluster-api-provider-azure/api/v1beta1/types.go (61.5%)</option>
				
				<option value="file48">sigs.k8s.io/cluster-api-provider-azure/api/v1beta1/types_class.go (77.8%)</option>
				
				<option value="file49">sigs.k8s.io/cluster-api-provider-azure/api/v1beta1/types_template.go (100.0%)</option>
				
				<option value="file50">sigs.k8s.io/cluster-api-provider-azure/api/v1beta1/zz_generated.deepcopy.go (0.0%)</option>
				
				<option value="file51">sigs.k8s.io/cluster-api-provider-azure/azure/converters/dns.go (100.0%)</option>
				
				<option value="file52">sigs.k8s.io/cluster-api-provider-azure/azure/converters/futures.go (90.9%)</option>
				
				<option value="file53">sigs.k8s.io/cluster-api-provider-azure/azure/converters/identity.go (100.0%)</option>
				
				<option value="file54">sigs.k8s.io/cluster-api-provider-azure/azure/converters/image.go (31.8%)</option>
				
				<option value="file55">sigs.k8s.io/cluster-api-provider-azure/azure/converters/loadbalancers.go (100.0%)</option>
				
				<option value="file56">sigs.k8s.io/cluster-api-provider-azure/azure/converters/managedagentpool.go (100.0%)</option>
				
				<option value="file57">sigs.k8s.io/cluster-api-provider-azure/azure/converters/publicips.go (100.0%)</option>
				
				<option value="file58">sigs.k8s.io/cluster-api-provider-azure/azure/converters/rules.go (0.0%)</option>
				
				<option value="file59">sigs.k8s.io/cluster-api-provider-azure/azure/converters/spotinstances.go (91.7%)</option>
				
				<option value="file60">sigs.k8s.io/cluster-api-provider-azure/azure/converters/subnets.go (100.0%)</option>
				
				<option value="file61">sigs.k8s.io/cluster-api-provider-azure/azure/converters/tags.go (50.0%)</option>
				
				<option value="file62">sigs.k8s.io/cluster-api-provider-azure/azure/converters/vm.go (100.0%)</option>
				
				<option value="file63">sigs.k8s.io/cluster-api-provider-azure/azure/converters/vmss.go (80.6%)</option>
				
				<option value="file64">sigs.k8s.io/cluster-api-provider-azure/azure/defaults.go (10.2%)</option>
				
				<option value="file65">sigs.k8s.io/cluster-api-provider-azure/azure/errors.go (0.0%)</option>
				
				<option value="file66">sigs.k8s.io/cluster-api-provider-azure/azure/regional_baseuri.go (87.5%)</option>
				
				<option value="file67">sigs.k8s.io/cluster-api-provider-azure/azure/scope/clients.go (51.5%)</option>
				
				<option value="file68">sigs.k8s.io/cluster-api-provider-azure/azure/scope/cluster.go (54.8%)</option>
				
				<option value="file69">sigs.k8s.io/cluster-api-provider-azure/azure/scope/identity.go (33.7%)</option>
				
				<option value="file70">sigs.k8s.io/cluster-api-provider-azure/azure/scope/machine.go (43.2%)</option>
				
				<option value="file71">sigs.k8s.io/cluster-api-provider-azure/azure/scope/machinepool.go (28.5%)</option>
				
				<option value="file72">sigs.k8s.io/cluster-api-provider-azure/azure/scope/machinepoolmachine.go (28.6%)</option>
				
				<option value="file73">sigs.k8s.io/cluster-api-provider-azure/azure/scope/managedcontrolplane.go (38.1%)</option>
				
				<option value="file74">sigs.k8s.io/cluster-api-provider-azure/azure/scope/managedmachinepool.go (46.5%)</option>
				
				<option value="file75">sigs.k8s.io/cluster-api-provider-azure/azure/scope/strategies/machinepool_deployments/machinepool_deployment_strategy.go (89.1%)</option>
				
				<option value="file76">sigs.k8s.io/cluster-api-provider-azure/azure/services/agentpools/agentpools.go (85.7%)</option>
				
				<option value="file77">sigs.k8s.io/cluster-api-provider-azure/azure/services/agentpools/client.go (0.0%)</option>
				
				<option value="file78">sigs.k8s.io/cluster-api-provider-azure/azure/services/agentpools/spec.go (85.7%)</option>
				
				<option value="file79">sigs.k8s.io/cluster-api-provider-azure/azure/services/async/async.go (97.5%)</option>
				
				<option value="file80">sigs.k8s.io/cluster-api-provider-azure/azure/services/availabilitysets/availabilitysets.go (88.9%)</option>
				
				<option value="file81">sigs.k8s.io/cluster-api-provider-azure/azure/services/availabilitysets/client.go (0.0%)</option>
				
				<option value="file82">sigs.k8s.io/cluster-api-provider-azure/azure/services/availabilitysets/spec.go (73.7%)</option>
				
				<option value="file83">sigs.k8s.io/cluster-api-provider-azure/azure/services/bastionhosts/bastionhosts.go (83.3%)</option>
				
				<option value="file84">sigs.k8s.io/cluster-api-provider-azure/azure/services/bastionhosts/client.go (0.0%)</option>
				
				<option value="file85">sigs.k8s.io/cluster-api-provider-azure/azure/services/bastionhosts/spec.go (0.0%)</option>
				
				<option value="file86">sigs.k8s.io/cluster-api-provider-azure/azure/services/disks/client.go (0.0%)</option>
				
				<option value="file87">sigs.k8s.io/cluster-api-provider-azure/azure/services/disks/disks.go (66.7%)</option>
				
				<option value="file88">sigs.k8s.io/cluster-api-provider-azure/azure/services/disks/spec.go (0.0%)</option>
				
				<option value="file89">sigs.k8s.io/cluster-api-provider-azure/azure/services/groups/client.go (0.0%)</option>
				
				<option value="file90">sigs.k8s.io/cluster-api-provider-azure/azure/services/groups/groups.go (90.9%)</option>
				
				<option value="file91">sigs.k8s.io/cluster-api-provider-azure/azure/services/groups/spec.go (16.7%)</option>
				
				<option value="file92">sigs.k8s.io/cluster-api-provider-azure/azure/services/inboundnatrules/client.go (0.0%)</option>
				
				<option value="file93">sigs.k8s.io/cluster-api-provider-azure/azure/services/inboundnatrules/inboundnatrules.go (88.2%)</option>
				
				<option value="file94">sigs.k8s.io/cluster-api-provider-azure/azure/services/inboundnatrules/spec.go (38.9%)</option>
				
				<option value="file95">sigs.k8s.io/cluster-api-provider-azure/azure/services/loadbalancers/client.go (0.0%)</option>
				
				<option value="file96">sigs.k8s.io/cluster-api-provider-azure/azure/services/loadbalancers/loadbalancers.go (87.5%)</option>
				
				<option value="file97">sigs.k8s.io/cluster-api-provider-azure/azure/services/loadbalancers/spec.go (89.8%)</option>
				
				<option value="file98">sigs.k8s.io/cluster-api-provider-azure/azure/services/managedclusters/client.go (0.0%)</option>
				
				<option value="file99">sigs.k8s.io/cluster-api-provider-azure/azure/services/managedclusters/managedclusters.go (85.3%)</option>
				
				<option value="file100">sigs.k8s.io/cluster-api-provider-azure/azure/services/managedclusters/spec.go (53.5%)</option>
				
				<option value="file101">sigs.k8s.io/cluster-api-provider-azure/azure/services/natgateways/client.go (0.0%)</option>
				
				<option value="file102">sigs.k8s.io/cluster-api-provider-azure/azure/services/natgateways/natgateways.go (90.2%)</option>
				
				<option value="file103">sigs.k8s.io/cluster-api-provider-azure/azure/services/natgateways/spec.go (5.0%)</option>
				
				<option value="file104">sigs.k8s.io/cluster-api-provider-azure/azure/services/networkinterfaces/client.go (0.0%)</option>
				
				<option value="file105">sigs.k8s.io/cluster-api-provider-azure/azure/services/networkinterfaces/networkinterfaces.go (87.5%)</option>
				
				<option value="file106">sigs.k8s.io/cluster-api-provider-azure/azure/services/networkinterfaces/spec.go (81.6%)</option>
				
				<option value="file107">sigs.k8s.io/cluster-api-provider-azure/azure/services/privatedns/link_client.go (0.0%)</option>
				
				<option value="file108">sigs.k8s.io/cluster-api-provider-azure/azure/services/privatedns/link_reconciler.go (85.7%)</option>
				
				<option value="file109">sigs.k8s.io/cluster-api-provider-azure/azure/services/privatedns/link_spec.go (100.0%)</option>
				
				<option value="file110">sigs.k8s.io/cluster-api-provider-azure/azure/services/privatedns/privatedns.go (86.9%)</option>
				
				<option value="file111">sigs.k8s.io/cluster-api-provider-azure/azure/services/privatedns/record_client.go (0.0%)</option>
				
				<option value="file112">sigs.k8s.io/cluster-api-provider-azure/azure/services/privatedns/record_reconciler.go (100.0%)</option>
				
				<option value="file113">sigs.k8s.io/cluster-api-provider-azure/azure/services/privatedns/record_spec.go (76.9%)</option>
				
				<option value="file114">sigs.k8s.io/cluster-api-provider-azure/azure/services/privatedns/zone_client.go (0.0%)</option>
				
				<option value="file115">sigs.k8s.io/cluster-api-provider-azure/azure/services/privatedns/zone_reconciler.go (81.5%)</option>
				
				<option value="file116">sigs.k8s.io/cluster-api-provider-azure/azure/services/privatedns/zone_spec.go (100.0%)</option>
				
				<option value="file117">sigs.k8s.io/cluster-api-provider-azure/azure/services/publicips/client.go (0.0%)</option>
				
				<option value="file118">sigs.k8s.io/cluster-api-provider-azure/azure/services/publicips/publicips.go (85.1%)</option>
				
				<option value="file119">sigs.k8s.io/cluster-api-provider-azure/azure/services/publicips/spec.go (78.6%)</option>
				
				<option value="file120">sigs.k8s.io/cluster-api-provider-azure/azure/services/resourceskus/cache.go (71.6%)</option>
				
				<option value="file121">sigs.k8s.io/cluster-api-provider-azure/azure/services/resourceskus/client.go (0.0%)</option>
				
				<option value="file122">sigs.k8s.io/cluster-api-provider-azure/azure/services/resourceskus/sku.go (0.0%)</option>
				
				<option value="file123">sigs.k8s.io/cluster-api-provider-azure/azure/services/roleassignments/client.go (0.0%)</option>
				
				<option value="file124">sigs.k8s.io/cluster-api-provider-azure/azure/services/roleassignments/roleassignments.go (78.4%)</option>
				
				<option value="file125">sigs.k8s.io/cluster-api-provider-azure/azure/services/roleassignments/spec.go (0.0%)</option>
				
				<option value="file126">sigs.k8s.io/cluster-api-provider-azure/azure/services/routetables/client.go (0.0%)</option>
				
				<option value="file127">sigs.k8s.io/cluster-api-provider-azure/azure/services/routetables/routetables.go (88.6%)</option>
				
				<option value="file128">sigs.k8s.io/cluster-api-provider-azure/azure/services/routetables/spec.go (0.0%)</option>
				
				<option value="file129">sigs.k8s.io/cluster-api-provider-azure/azure/services/scalesets/client.go (0.0%)</option>
				
				<option value="file130">sigs.k8s.io/cluster-api-provider-azure/azure/services/scalesets/scalesets.go (81.2%)</option>
				
				<option value="file131">sigs.k8s.io/cluster-api-provider-azure/azure/services/scalesets/vmssextension_spec.go (22.2%)</option>
				
				<option value="file132">sigs.k8s.io/cluster-api-provider-azure/azure/services/scalesetvms/client.go (15.8%)</option>
				
				<option value="file133">sigs.k8s.io/cluster-api-provider-azure/azure/services/scalesetvms/scalesetvms.go (85.4%)</option>
				
				<option value="file134">sigs.k8s.io/cluster-api-provider-azure/azure/services/securitygroups/client.go (0.0%)</option>
				
				<option value="file135">sigs.k8s.io/cluster-api-provider-azure/azure/services/securitygroups/securitygroups.go (84.1%)</option>
				
				<option value="file136">sigs.k8s.io/cluster-api-provider-azure/azure/services/securitygroups/spec.go (81.8%)</option>
				
				<option value="file137">sigs.k8s.io/cluster-api-provider-azure/azure/services/subnets/client.go (0.0%)</option>
				
				<option value="file138">sigs.k8s.io/cluster-api-provider-azure/azure/services/subnets/spec.go (85.0%)</option>
				
				<option value="file139">sigs.k8s.io/cluster-api-provider-azure/azure/services/subnets/subnets.go (91.3%)</option>
				
				<option value="file140">sigs.k8s.io/cluster-api-provider-azure/azure/services/tags/client.go (0.0%)</option>
				
				<option value="file141">sigs.k8s.io/cluster-api-provider-azure/azure/services/tags/tags.go (85.5%)</option>
				
				<option value="file142">sigs.k8s.io/cluster-api-provider-azure/azure/services/virtualmachineimages/cache.go (90.3%)</option>
				
				<option value="file143">sigs.k8s.io/cluster-api-provider-azure/azure/services/virtualmachineimages/client.go (44.4%)</option>
				
				<option value="file144">sigs.k8s.io/cluster-api-provider-azure/azure/services/virtualmachineimages/images.go (90.8%)</option>
				
				<option value="file145">sigs.k8s.io/cluster-api-provider-azure/azure/services/virtualmachines/client.go (0.0%)</option>
				
				<option value="file146">sigs.k8s.io/cluster-api-provider-azure/azure/services/virtualmachines/spec.go (90.9%)</option>
				
				<option value="file147">sigs.k8s.io/cluster-api-provider-azure/azure/services/virtualmachines/virtualmachines.go (86.0%)</option>
				
				<option value="file148">sigs.k8s.io/cluster-api-provider-azure/azure/services/virtualnetworks/client.go (0.0%)</option>
				
				<option value="file149">sigs.k8s.io/cluster-api-provider-azure/azure/services/virtualnetworks/spec.go (0.0%)</option>
				
				<option value="file150">sigs.k8s.io/cluster-api-provider-azure/azure/services/virtualnetworks/virtualnetworks.go (83.6%)</option>
				
				<option value="file151">sigs.k8s.io/cluster-api-provider-azure/azure/services/vmextensions/client.go (0.0%)</option>
				
				<option value="file152">sigs.k8s.io/cluster-api-provider-azure/azure/services/vmextensions/spec.go (0.0%)</option>
				
				<option value="file153">sigs.k8s.io/cluster-api-provider-azure/azure/services/vmextensions/vmextensions.go (75.0%)</option>
				
				<option value="file154">sigs.k8s.io/cluster-api-provider-azure/azure/services/vnetpeerings/client.go (0.0%)</option>
				
				<option value="file155">sigs.k8s.io/cluster-api-provider-azure/azure/services/vnetpeerings/spec.go (0.0%)</option>
				
				<option value="file156">sigs.k8s.io/cluster-api-provider-azure/azure/services/vnetpeerings/vnetpeerings.go (87.5%)</option>
				
				<option value="file157">sigs.k8s.io/cluster-api-provider-azure/azure/types.go (10.5%)</option>
				
				<option value="file158">sigs.k8s.io/cluster-api-provider-azure/controllers/azurecluster_controller.go (19.3%)</option>
				
				<option value="file159">sigs.k8s.io/cluster-api-provider-azure/controllers/azurecluster_reconciler.go (75.6%)</option>
				
				<option value="file160">sigs.k8s.io/cluster-api-provider-azure/controllers/azureidentity_controller.go (0.0%)</option>
				
				<option value="file161">sigs.k8s.io/cluster-api-provider-azure/controllers/azurejson_machine_controller.go (53.4%)</option>
				
				<option value="file162">sigs.k8s.io/cluster-api-provider-azure/controllers/azurejson_machinepool_controller.go (55.9%)</option>
				
				<option value="file163">sigs.k8s.io/cluster-api-provider-azure/controllers/azurejson_machinetemplate_controller.go (53.1%)</option>
				
				<option value="file164">sigs.k8s.io/cluster-api-provider-azure/controllers/azuremachine_controller.go (25.3%)</option>
				
				<option value="file165">sigs.k8s.io/cluster-api-provider-azure/controllers/azuremachine_reconciler.go (72.2%)</option>
				
				<option value="file166">sigs.k8s.io/cluster-api-provider-azure/controllers/helpers.go (52.7%)</option>
				
				<option value="file167">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1alpha3/azuremachinepool_conversion.go (84.9%)</option>
				
				<option value="file168">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1alpha3/azuremachinepool_types.go (33.3%)</option>
				
				<option value="file169">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1alpha3/azuremanagedcluster_conversion.go (60.0%)</option>
				
				<option value="file170">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1alpha3/azuremanagedcluster_types.go (100.0%)</option>
				
				<option value="file171">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1alpha3/azuremanagedcontrolplane_conversion.go (75.0%)</option>
				
				<option value="file172">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1alpha3/azuremanagedcontrolplane_types.go (100.0%)</option>
				
				<option value="file173">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1alpha3/azuremanagedmachinepool_conversion.go (79.3%)</option>
				
				<option value="file174">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1alpha3/azuremanagedmachinepool_types.go (100.0%)</option>
				
				<option value="file175">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1alpha3/conversion.go (100.0%)</option>
				
				<option value="file176">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1alpha3/zz_generated.conversion.go (41.4%)</option>
				
				<option value="file177">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1alpha3/zz_generated.deepcopy.go (25.0%)</option>
				
				<option value="file178">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1alpha4/azuremachinepool_conversion.go (68.4%)</option>
				
				<option value="file179">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1alpha4/azuremachinepool_types.go (20.0%)</option>
				
				<option value="file180">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1alpha4/azuremachinepoolmachine_conversion.go (50.0%)</option>
				
				<option value="file181">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1alpha4/azuremachinepoolmachine_types.go (20.0%)</option>
				
				<option value="file182">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1alpha4/azuremanagedcluster_conversion.go (50.0%)</option>
				
				<option value="file183">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1alpha4/azuremanagedcluster_types.go (100.0%)</option>
				
				<option value="file184">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1alpha4/azuremanagedcontrolplane_conversion.go (68.4%)</option>
				
				<option value="file185">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1alpha4/azuremanagedcontrolplane_types.go (33.3%)</option>
				
				<option value="file186">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1alpha4/azuremanagedmachinepool_conversion.go (79.3%)</option>
				
				<option value="file187">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1alpha4/azuremanagedmachinepool_types.go (100.0%)</option>
				
				<option value="file188">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1alpha4/conversion.go (100.0%)</option>
				
				<option value="file189">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1alpha4/zz_generated.conversion.go (41.8%)</option>
				
				<option value="file190">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1alpha4/zz_generated.deepcopy.go (22.1%)</option>
				
				<option value="file191">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1/azuremachinepool_conversion.go (0.0%)</option>
				
				<option value="file192">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1/azuremachinepool_default.go (88.9%)</option>
				
				<option value="file193">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1/azuremachinepool_types.go (20.0%)</option>
				
				<option value="file194">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1/azuremachinepool_webhook.go (91.2%)</option>
				
				<option value="file195">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1/azuremachinepoolmachine_conversion.go (0.0%)</option>
				
				<option value="file196">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1/azuremachinepoolmachine_types.go (20.0%)</option>
				
				<option value="file197">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1/azuremachinepoolmachine_webhook.go (0.0%)</option>
				
				<option value="file198">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1/azuremanagedcluster_conversion.go (0.0%)</option>
				
				<option value="file199">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1/azuremanagedcluster_types.go (100.0%)</option>
				
				<option value="file200">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1/azuremanagedcluster_webhook.go (71.4%)</option>
				
				<option value="file201">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1/azuremanagedcontrolplane_conversion.go (0.0%)</option>
				
				<option value="file202">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1/azuremanagedcontrolplane_default.go (94.4%)</option>
				
				<option value="file203">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1/azuremanagedcontrolplane_types.go (20.0%)</option>
				
				<option value="file204">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1/azuremanagedcontrolplane_webhook.go (81.0%)</option>
				
				<option value="file205">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1/azuremanagedmachinepool_conversion.go (0.0%)</option>
				
				<option value="file206">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1/azuremanagedmachinepool_types.go (20.0%)</option>
				
				<option value="file207">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1/azuremanagedmachinepool_webhook.go (72.4%)</option>
				
				<option value="file208">sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1/zz_generated.deepcopy.go (0.0%)</option>
				
				<option value="file209">sigs.k8s.io/cluster-api-provider-azure/exp/controllers/azuremachinepool_annotations.go (0.0%)</option>
				
				<option value="file210">sigs.k8s.io/cluster-api-provider-azure/exp/controllers/azuremachinepool_controller.go (21.8%)</option>
				
				<option value="file211">sigs.k8s.io/cluster-api-provider-azure/exp/controllers/azuremachinepool_reconciler.go (88.9%)</option>
				
				<option value="file212">sigs.k8s.io/cluster-api-provider-azure/exp/controllers/azuremachinepoolmachine_controller.go (45.3%)</option>
				
				<option value="file213">sigs.k8s.io/cluster-api-provider-azure/exp/controllers/azuremanagedcluster_controller.go (22.4%)</option>
				
				<option value="file214">sigs.k8s.io/cluster-api-provider-azure/exp/controllers/azuremanagedcontrolplane_controller.go (12.1%)</option>
				
				<option value="file215">sigs.k8s.io/cluster-api-provider-azure/exp/controllers/azuremanagedcontrolplane_reconciler.go (0.0%)</option>
				
				<option value="file216">sigs.k8s.io/cluster-api-provider-azure/exp/controllers/azuremanagedmachinepool_controller.go (13.6%)</option>
				
				<option value="file217">sigs.k8s.io/cluster-api-provider-azure/exp/controllers/azuremanagedmachinepool_reconciler.go (7.5%)</option>
				
				<option value="file218">sigs.k8s.io/cluster-api-provider-azure/exp/controllers/helpers.go (55.9%)</option>
				
				<option value="file219">sigs.k8s.io/cluster-api-provider-azure/internal/test/env/env.go (69.4%)</option>
				
				<option value="file220">sigs.k8s.io/cluster-api-provider-azure/internal/test/matchers/gomega/matchers.go (54.5%)</option>
				
				<option value="file221">sigs.k8s.io/cluster-api-provider-azure/pkg/coalescing/reconciler.go (68.0%)</option>
				
				<option value="file222">sigs.k8s.io/cluster-api-provider-azure/util/azure/azure.go (100.0%)</option>
				
				<option value="file223">sigs.k8s.io/cluster-api-provider-azure/util/cache/ttllru/ttllru.go (80.0%)</option>
				
				<option value="file224">sigs.k8s.io/cluster-api-provider-azure/util/futures/getter.go (100.0%)</option>
				
				<option value="file225">sigs.k8s.io/cluster-api-provider-azure/util/futures/setter.go (90.0%)</option>
				
				<option value="file226">sigs.k8s.io/cluster-api-provider-azure/util/maps/maps.go (100.0%)</option>
				
				<option value="file227">sigs.k8s.io/cluster-api-provider-azure/util/reconciler/defaults.go (100.0%)</option>
				
				<option value="file228">sigs.k8s.io/cluster-api-provider-azure/util/ssh/ssh.go (71.4%)</option>
				
				<option value="file229">sigs.k8s.io/cluster-api-provider-azure/util/system/namespace.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha3

import (
        apiconversion "k8s.io/apimachinery/pkg/conversion"
        "k8s.io/utils/pointer"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        utilconversion "sigs.k8s.io/cluster-api/util/conversion"
        "sigs.k8s.io/controller-runtime/pkg/conversion"
)

const (
        azureEnvironmentAnnotation = "azurecluster.infrastructure.cluster.x-k8s.io/azureEnvironment"
)

// ConvertTo converts this AzureCluster to the Hub version (v1beta1).
func (src *AzureCluster) ConvertTo(dstRaw conversion.Hub) error <span class="cov8" title="1">{
        dst := dstRaw.(*infrav1.AzureCluster)
        if err := Convert_v1alpha3_AzureCluster_To_v1beta1_AzureCluster(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if azureEnvironment, ok := src.Annotations[azureEnvironmentAnnotation]; ok </span><span class="cov8" title="1">{
                dst.Spec.AzureEnvironment = azureEnvironment
                delete(dst.Annotations, azureEnvironmentAnnotation)
                if len(dst.Annotations) == 0 </span><span class="cov0" title="0">{
                        dst.Annotations = nil
                }</span>
        }

        // set default control plane outbound lb for private v1alpha3 clusters.
        <span class="cov8" title="1">if src.Spec.NetworkSpec.APIServerLB.Type == Internal </span><span class="cov0" title="0">{
                dst.Spec.NetworkSpec.ControlPlaneOutboundLB = &amp;infrav1.LoadBalancerSpec{
                        FrontendIPsCount: pointer.Int32Ptr(1),
                }
                // We also need to set the defaults here because "get" won't set defaults, and hence there is no mismatch when a client
                // gets a v1alpha3 cluster.
                dst.SetControlPlaneOutboundLBDefaults()
        }</span>

        // set default node plane outbound lb for all v1alpha3 clusters.
        <span class="cov8" title="1">dst.Spec.NetworkSpec.NodeOutboundLB = &amp;infrav1.LoadBalancerSpec{
                FrontendIPsCount: pointer.Int32Ptr(1),
        }
        // We also need to set the defaults here because "get" won't set defaults, and hence there is no mismatch when a client
        // gets a v1alpha3 cluster.
        dst.SetNodeOutboundLBDefaults()

        // Manually restore data.
        restored := &amp;infrav1.AzureCluster{}
        if ok, err := utilconversion.UnmarshalData(src, restored); err != nil || !ok </span><span class="cov8" title="1">{
                return err
        }</span>

        // override outbound lb if it's present in restored.
        <span class="cov8" title="1">dst.Spec.NetworkSpec.ControlPlaneOutboundLB = restored.Spec.NetworkSpec.ControlPlaneOutboundLB
        dst.Spec.NetworkSpec.NodeOutboundLB = restored.Spec.NetworkSpec.NodeOutboundLB

        dst.Spec.NetworkSpec.PrivateDNSZoneName = restored.Spec.NetworkSpec.PrivateDNSZoneName

        dst.Spec.NetworkSpec.APIServerLB.FrontendIPsCount = restored.Spec.NetworkSpec.APIServerLB.FrontendIPsCount
        dst.Spec.NetworkSpec.APIServerLB.IdleTimeoutInMinutes = restored.Spec.NetworkSpec.APIServerLB.IdleTimeoutInMinutes

        for _, restoredFrontendIP := range restored.Spec.NetworkSpec.APIServerLB.FrontendIPs </span><span class="cov0" title="0">{
                for i, dstFrontendIP := range dst.Spec.NetworkSpec.APIServerLB.FrontendIPs </span><span class="cov0" title="0">{
                        if restoredFrontendIP.Name == dstFrontendIP.Name &amp;&amp; restoredFrontendIP.PublicIP != nil </span><span class="cov0" title="0">{
                                dst.Spec.NetworkSpec.APIServerLB.FrontendIPs[i].PublicIP.IPTags = restoredFrontendIP.PublicIP.IPTags
                        }</span>
                }
        }

        <span class="cov8" title="1">dst.Spec.CloudProviderConfigOverrides = restored.Spec.CloudProviderConfigOverrides
        dst.Spec.BastionSpec = restored.Spec.BastionSpec

        // Here we manually restore outbound security rules. Since v1alpha3 only supports ingress ("Inbound") rules, all v1alpha4/v1beta1 outbound rules are dropped when an AzureCluster
        // is converted to v1alpha3. We loop through all security group rules. For all previously existing outbound rules we restore the full rule.
        for _, restoredSubnet := range restored.Spec.NetworkSpec.Subnets </span><span class="cov0" title="0">{
                for i, dstSubnet := range dst.Spec.NetworkSpec.Subnets </span><span class="cov0" title="0">{
                        if dstSubnet.Name != restoredSubnet.Name </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">var restoredOutboundRules []infrav1.SecurityRule
                        for _, restoredSecurityRule := range restoredSubnet.SecurityGroup.SecurityRules </span><span class="cov0" title="0">{
                                if restoredSecurityRule.Direction != infrav1.SecurityRuleDirectionInbound </span><span class="cov0" title="0">{
                                        // For non-inbound rules which are only supported starting in v1alpha4/v1beta1, we restore the entire rule.
                                        restoredOutboundRules = append(restoredOutboundRules, restoredSecurityRule)
                                }</span>
                        }
                        <span class="cov0" title="0">dst.Spec.NetworkSpec.Subnets[i].SecurityGroup.SecurityRules = append(dst.Spec.NetworkSpec.Subnets[i].SecurityGroup.SecurityRules, restoredOutboundRules...)
                        dst.Spec.NetworkSpec.Subnets[i].NatGateway = restoredSubnet.NatGateway

                        break</span>
                }
        }

        <span class="cov8" title="1">dst.Status.LongRunningOperationStates = restored.Status.LongRunningOperationStates

        // Restore list of virtual network peerings
        dst.Spec.NetworkSpec.Vnet.Peerings = restored.Spec.NetworkSpec.Vnet.Peerings

        return nil</span>
}

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureCluster) ConvertFrom(srcRaw conversion.Hub) error <span class="cov8" title="1">{
        src := srcRaw.(*infrav1.AzureCluster)
        if err := Convert_v1beta1_AzureCluster_To_v1alpha3_AzureCluster(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Preserve Spec.AzureEnvironment in annotation `azurecluster.infrastructure.cluster.x-k8s.io/azureEnvironment`
        <span class="cov8" title="1">if src.Spec.AzureEnvironment != "" </span><span class="cov8" title="1">{
                if dst.Annotations == nil </span><span class="cov8" title="1">{
                        dst.Annotations = make(map[string]string)
                }</span>
                <span class="cov8" title="1">dst.Annotations[azureEnvironmentAnnotation] = src.Spec.AzureEnvironment</span>
        }

        // Preserve Hub data on down-conversion.
        <span class="cov8" title="1">return utilconversion.MarshalData(src, dst)</span>
}

// ConvertTo converts this AzureClusterList to the Hub version (v1beta1).
func (src *AzureClusterList) ConvertTo(dstRaw conversion.Hub) error <span class="cov0" title="0">{
        dst := dstRaw.(*infrav1.AzureClusterList)
        return Convert_v1alpha3_AzureClusterList_To_v1beta1_AzureClusterList(src, dst, nil)
}</span>

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureClusterList) ConvertFrom(srcRaw conversion.Hub) error <span class="cov0" title="0">{
        src := srcRaw.(*infrav1.AzureClusterList)
        return Convert_v1beta1_AzureClusterList_To_v1alpha3_AzureClusterList(src, dst, nil)
}</span>

// Convert_v1alpha3_AzureClusterStatus_To_v1beta1_AzureClusterStatus converts AzureCluster.Status from v1alpha3 to v1beta1.
func Convert_v1alpha3_AzureClusterStatus_To_v1beta1_AzureClusterStatus(in *AzureClusterStatus, out *infrav1.AzureClusterStatus, s apiconversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha3_AzureClusterStatus_To_v1beta1_AzureClusterStatus(in, out, s)
}</span>

// Convert_v1alpha3_AzureClusterSpec_To_v1beta1_AzureClusterSpec converts AzureCluster.Spec from v1alpha3 to v1beta1.
func Convert_v1alpha3_AzureClusterSpec_To_v1beta1_AzureClusterSpec(in *AzureClusterSpec, out *infrav1.AzureClusterSpec, s apiconversion.Scope) error <span class="cov8" title="1">{
        if err := autoConvert_v1alpha3_AzureClusterSpec_To_v1beta1_AzureClusterSpec(in, out, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // copy AzureClusterClassSpec fields
        <span class="cov8" title="1">out.SubscriptionID = in.SubscriptionID
        out.Location = in.Location
        out.AdditionalTags = *(*infrav1.Tags)(&amp;in.AdditionalTags)
        out.IdentityRef = in.IdentityRef

        return nil</span>
}

// Convert_v1beta1_AzureClusterSpec_To_v1alpha3_AzureClusterSpec converts from the Hub version (v1beta1) of the AzureClusterSpec to this version.
func Convert_v1beta1_AzureClusterSpec_To_v1alpha3_AzureClusterSpec(in *infrav1.AzureClusterSpec, out *AzureClusterSpec, s apiconversion.Scope) error <span class="cov8" title="1">{
        if err := autoConvert_v1beta1_AzureClusterSpec_To_v1alpha3_AzureClusterSpec(in, out, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // copy AzureClusterClassSpec fields
        <span class="cov8" title="1">out.SubscriptionID = in.SubscriptionID
        out.Location = in.Location
        out.AdditionalTags = Tags(in.AdditionalTags)
        out.IdentityRef = in.IdentityRef

        return nil</span>
}

// Convert_v1beta1_AzureClusterStatus_To_v1alpha3_AzureClusterStatus converts an Azure cluster status from v1beta1 to v1alpha3.
func Convert_v1beta1_AzureClusterStatus_To_v1alpha3_AzureClusterStatus(in *infrav1.AzureClusterStatus, out *AzureClusterStatus, s apiconversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureClusterStatus_To_v1alpha3_AzureClusterStatus(in, out, s)
}</span>

// Convert_v1alpha3_NetworkSpec_To_v1beta1_NetworkSpec converts a network spec from v1alpha3 to v1beta1.
func Convert_v1alpha3_NetworkSpec_To_v1beta1_NetworkSpec(in *NetworkSpec, out *infrav1.NetworkSpec, s apiconversion.Scope) error <span class="cov8" title="1">{
        if err := Convert_v1alpha3_VnetSpec_To_v1beta1_VnetSpec(&amp;in.Vnet, &amp;out.Vnet, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">out.Subnets = make(infrav1.Subnets, len(in.Subnets))
        for i := range in.Subnets </span><span class="cov8" title="1">{
                out.Subnets[i] = infrav1.SubnetSpec{}
                if err := Convert_v1alpha3_SubnetSpec_To_v1beta1_SubnetSpec(&amp;in.Subnets[i], &amp;out.Subnets[i], s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return Convert_v1alpha3_LoadBalancerSpec_To_v1beta1_LoadBalancerSpec(&amp;in.APIServerLB, &amp;out.APIServerLB, s)</span>
}

// Convert_v1beta1_NetworkSpec_To_v1alpha3_NetworkSpec converts a network spec from v1beta1 to v1alpha3.
func Convert_v1beta1_NetworkSpec_To_v1alpha3_NetworkSpec(in *infrav1.NetworkSpec, out *NetworkSpec, s apiconversion.Scope) error <span class="cov8" title="1">{
        if err := Convert_v1beta1_VnetSpec_To_v1alpha3_VnetSpec(&amp;in.Vnet, &amp;out.Vnet, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">out.Subnets = make(Subnets, len(in.Subnets))
        for i := range in.Subnets </span><span class="cov8" title="1">{
                out.Subnets[i] = SubnetSpec{}
                if err := Convert_v1beta1_SubnetSpec_To_v1alpha3_SubnetSpec(&amp;in.Subnets[i], &amp;out.Subnets[i], s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return Convert_v1beta1_LoadBalancerSpec_To_v1alpha3_LoadBalancerSpec(&amp;in.APIServerLB, &amp;out.APIServerLB, s)</span>
}

// Convert_v1beta1_VnetSpec_To_v1alpha3_VnetSpec converts a virtual network spec from v1beta1 to v1alpha3.
func Convert_v1beta1_VnetSpec_To_v1alpha3_VnetSpec(in *infrav1.VnetSpec, out *VnetSpec, s apiconversion.Scope) error <span class="cov8" title="1">{
        if err := autoConvert_v1beta1_VnetSpec_To_v1alpha3_VnetSpec(in, out, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // copy VnetClassSpec fields
        <span class="cov8" title="1">out.CIDRBlocks = in.CIDRBlocks
        out.Tags = Tags(in.Tags)

        return nil</span>
}

// Convert_v1alpha3_SubnetSpec_To_v1beta1_SubnetSpec converts a subnet spec from v1alpha3 to v1beta1.
func Convert_v1alpha3_SubnetSpec_To_v1beta1_SubnetSpec(in *SubnetSpec, out *infrav1.SubnetSpec, s apiconversion.Scope) error <span class="cov8" title="1">{
        if err := autoConvert_v1alpha3_SubnetSpec_To_v1beta1_SubnetSpec(in, out, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Convert SubnetClassSpec fields
        <span class="cov8" title="1">out.Role = infrav1.SubnetRole(in.Role)
        out.CIDRBlocks = in.CIDRBlocks

        return nil</span>
}

// Convert_v1beta1_SubnetSpec_To_v1alpha3_SubnetSpec converts a subnet spec from v1beta1 to v1alpha3.
func Convert_v1beta1_SubnetSpec_To_v1alpha3_SubnetSpec(in *infrav1.SubnetSpec, out *SubnetSpec, s apiconversion.Scope) error <span class="cov8" title="1">{
        if err := autoConvert_v1beta1_SubnetSpec_To_v1alpha3_SubnetSpec(in, out, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Convert SubnetClassSpec fields
        <span class="cov8" title="1">out.Role = SubnetRole(in.Role)
        out.CIDRBlocks = in.CIDRBlocks

        return nil</span>
}

// Convert_v1beta1_SecurityGroup_To_v1alpha3_SecurityGroup converts a security group from v1beta1 to v1alpha3.
func Convert_v1beta1_SecurityGroup_To_v1alpha3_SecurityGroup(in *infrav1.SecurityGroup, out *SecurityGroup, s apiconversion.Scope) error <span class="cov8" title="1">{
        out.ID = in.ID
        out.Name = in.Name

        out.IngressRules = make(IngressRules, 0)
        for _, rule := range in.SecurityRules </span><span class="cov0" title="0">{
                rule := rule
                if rule.Direction == infrav1.SecurityRuleDirectionInbound </span><span class="cov0" title="0">{ // only inbound rules are supported in v1alpha3.
                        ingressRule := IngressRule{}
                        if err := Convert_v1beta1_SecurityRule_To_v1alpha3_IngressRule(&amp;rule, &amp;ingressRule, s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">out.IngressRules = append(out.IngressRules, ingressRule)</span>
                }
        }

        <span class="cov8" title="1">out.Tags = *(*Tags)(&amp;in.Tags)
        return nil</span>
}

// Convert_v1alpha3_SecurityGroup_To_v1beta1_SecurityGroup converts a security group from v1alpha3 to v1beta1.
func Convert_v1alpha3_SecurityGroup_To_v1beta1_SecurityGroup(in *SecurityGroup, out *infrav1.SecurityGroup, s apiconversion.Scope) error <span class="cov8" title="1">{
        out.ID = in.ID
        out.Name = in.Name

        out.SecurityRules = make(infrav1.SecurityRules, len(in.IngressRules))
        for i := range in.IngressRules </span><span class="cov0" title="0">{
                out.SecurityRules[i] = infrav1.SecurityRule{}
                if err := Convert_v1alpha3_IngressRule_To_v1beta1_SecurityRule(&amp;in.IngressRules[i], &amp;out.SecurityRules[i], s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">out.Tags = *(*infrav1.Tags)(&amp;in.Tags)
        return nil</span>
}

// Convert_v1alpha3_IngressRule_To_v1beta1_SecurityRule converts from a v1alpha3 IngressRule to a v1beta1 SecurityRule.
func Convert_v1alpha3_IngressRule_To_v1beta1_SecurityRule(in *IngressRule, out *infrav1.SecurityRule, _ apiconversion.Scope) error <span class="cov0" title="0">{
        out.Name = in.Name
        out.Description = in.Description
        out.Protocol = infrav1.SecurityGroupProtocol(in.Protocol)
        out.Priority = in.Priority
        out.SourcePorts = in.SourcePorts
        out.DestinationPorts = in.DestinationPorts
        out.Source = in.Source
        out.Destination = in.Destination
        out.Direction = infrav1.SecurityRuleDirectionInbound // all v1alpha3 rules are inbound.
        return nil
}</span>

// Convert_v1beta1_SecurityRule_To_v1alpha3_IngressRule converts from a v1beta1 SecurityRule to a v1alpha3 IngressRule.
func Convert_v1beta1_SecurityRule_To_v1alpha3_IngressRule(in *infrav1.SecurityRule, out *IngressRule, _ apiconversion.Scope) error <span class="cov0" title="0">{
        out.Name = in.Name
        out.Description = in.Description
        out.Protocol = SecurityGroupProtocol(in.Protocol)
        out.Priority = in.Priority
        out.SourcePorts = in.SourcePorts
        out.DestinationPorts = in.DestinationPorts
        out.Source = in.Source
        out.Destination = in.Destination
        return nil
}</span>

// Convert_v1alpha3_VnetSpec_To_v1beta1_VnetSpec is an autogenerated conversion function.
func Convert_v1alpha3_VnetSpec_To_v1beta1_VnetSpec(in *VnetSpec, out *infrav1.VnetSpec, s apiconversion.Scope) error <span class="cov8" title="1">{
        if err := autoConvert_v1alpha3_VnetSpec_To_v1beta1_VnetSpec(in, out, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // copy VnetClassSpec fields
        <span class="cov8" title="1">out.CIDRBlocks = in.CIDRBlocks
        out.Tags = *(*infrav1.Tags)(&amp;in.Tags)

        return nil</span>
}

// Convert_v1beta1_LoadBalancerSpec_To_v1alpha3_LoadBalancerSpec is an autogenerated conversion function.
func Convert_v1beta1_LoadBalancerSpec_To_v1alpha3_LoadBalancerSpec(in *infrav1.LoadBalancerSpec, out *LoadBalancerSpec, s apiconversion.Scope) error <span class="cov8" title="1">{
        if err := autoConvert_v1beta1_LoadBalancerSpec_To_v1alpha3_LoadBalancerSpec(in, out, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Convert LoadBalancerClassSpec fields
        <span class="cov8" title="1">out.SKU = SKU(in.SKU)
        if in.FrontendIPs != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.FrontendIPs, &amp;out.FrontendIPs
                *out = make([]FrontendIP, len(*in))
                for i := range *in </span><span class="cov8" title="1">{
                        if err := Convert_v1beta1_FrontendIP_To_v1alpha3_FrontendIP(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                out.FrontendIPs = nil
        }</span>
        <span class="cov8" title="1">out.Type = LBType(in.Type)

        return nil</span>
}

// Convert_v1alpha3_LoadBalancerSpec_To_v1beta1_LoadBalancerSpec converts an LB spec from v1alpha3 to v1beta1.
func Convert_v1alpha3_LoadBalancerSpec_To_v1beta1_LoadBalancerSpec(in *LoadBalancerSpec, out *infrav1.LoadBalancerSpec, s apiconversion.Scope) error <span class="cov8" title="1">{
        if err := autoConvert_v1alpha3_LoadBalancerSpec_To_v1beta1_LoadBalancerSpec(in, out, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Convert LoadBalancerClassSpec fields
        <span class="cov8" title="1">out.SKU = infrav1.SKU(in.SKU)
        if in.FrontendIPs != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.FrontendIPs, &amp;out.FrontendIPs
                *out = make([]infrav1.FrontendIP, len(*in))
                for i := range *in </span><span class="cov8" title="1">{
                        if err := Convert_v1alpha3_FrontendIP_To_v1beta1_FrontendIP(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                out.FrontendIPs = nil
        }</span>
        <span class="cov8" title="1">out.Type = infrav1.LBType(in.Type)

        return nil</span>
}

// Convert_v1alpha3_Future_To_v1beta1_Future is an autogenerated conversion function.
func Convert_v1alpha3_Future_To_v1beta1_Future(in *Future, out *infrav1.Future, s apiconversion.Scope) error <span class="cov0" title="0">{
        out.Data = in.FutureData
        return autoConvert_v1alpha3_Future_To_v1beta1_Future(in, out, s)
}</span>

// Convert_v1beta1_Future_To_v1alpha3_Future is an autogenerated conversion function.
func Convert_v1beta1_Future_To_v1alpha3_Future(in *infrav1.Future, out *Future, s apiconversion.Scope) error <span class="cov0" title="0">{
        out.FutureData = in.Data
        return autoConvert_v1beta1_Future_To_v1alpha3_Future(in, out, s)
}</span>

// Convert_v1alpha3_FrontendIP_To_v1beta1_FrontendIP is an autogenerated conversion function.
func Convert_v1alpha3_FrontendIP_To_v1beta1_FrontendIP(in *FrontendIP, out *infrav1.FrontendIP, s apiconversion.Scope) error <span class="cov8" title="1">{
        if err := autoConvert_v1alpha3_FrontendIP_To_v1beta1_FrontendIP(in, out, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Convert FrontendIPClass fields
        <span class="cov8" title="1">out.PrivateIPAddress = in.PrivateIPAddress

        return nil</span>
}

// Convert_v1beta1_FrontendIP_To_v1alpha3_FrontendIP is an autogenerated conversion function.
func Convert_v1beta1_FrontendIP_To_v1alpha3_FrontendIP(in *infrav1.FrontendIP, out *FrontendIP, s apiconversion.Scope) error <span class="cov8" title="1">{
        if err := autoConvert_v1beta1_FrontendIP_To_v1alpha3_FrontendIP(in, out, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Convert FrontendIPClass fields
        <span class="cov8" title="1">out.PrivateIPAddress = in.PrivateIPAddress

        return nil</span>
}

// Convert_v1beta1_PublicIPSpec_To_v1alpha3_PublicIPSpec is an autogenerated conversion function.
func Convert_v1beta1_PublicIPSpec_To_v1alpha3_PublicIPSpec(in *infrav1.PublicIPSpec, out *PublicIPSpec, s apiconversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_PublicIPSpec_To_v1alpha3_PublicIPSpec(in, out, s)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha3

import (
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1alpha3 "sigs.k8s.io/cluster-api/api/v1alpha3"
)

const (
        // ClusterFinalizer allows ReconcileAzureCluster to clean up Azure resources associated with AzureCluster before
        // removing it from the apiserver.
        ClusterFinalizer = "azurecluster.infrastructure.cluster.x-k8s.io"

        // ClusterLabelNamespace indicates the namespace of the cluster.
        ClusterLabelNamespace = "azurecluster.infrastructure.cluster.x-k8s.io/cluster-namespace"
)

// AzureClusterSpec defines the desired state of AzureCluster.
type AzureClusterSpec struct {
        // NetworkSpec encapsulates all things related to Azure network.
        NetworkSpec NetworkSpec `json:"networkSpec,omitempty"`

        // +optional
        ResourceGroup string `json:"resourceGroup,omitempty"`

        // +optional
        SubscriptionID string `json:"subscriptionID,omitempty"`

        Location string `json:"location"`

        // ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
        // +optional
        ControlPlaneEndpoint clusterv1alpha3.APIEndpoint `json:"controlPlaneEndpoint"`

        // AdditionalTags is an optional set of tags to add to Azure resources managed by the Azure provider, in addition to the
        // ones added by default.
        // +optional
        AdditionalTags Tags `json:"additionalTags,omitempty"`

        // IdentityRef is a reference to a AzureIdentity to be used when reconciling this cluster
        // +optional
        IdentityRef *corev1.ObjectReference `json:"identityRef,omitempty"`
}

// AzureClusterStatus defines the observed state of AzureCluster.
type AzureClusterStatus struct {
        // FailureDomains specifies the list of unique failure domains for the location/region of the cluster.
        // A FailureDomain maps to Availability Zone with an Azure Region (if the region support them). An
        // Availability Zone is a separate data center within a region and they can be used to ensure
        // the cluster is more resilient to failure.
        // See: https://docs.microsoft.com/en-us/azure/availability-zones/az-overview
        // This list will be used by Cluster API to try and spread the machines across the failure domains.
        FailureDomains clusterv1alpha3.FailureDomains `json:"failureDomains,omitempty"`

        // Ready is true when the provider resource is ready.
        // +optional
        Ready bool `json:"ready"`

        // Conditions defines current service state of the AzureCluster.
        // +optional
        Conditions clusterv1alpha3.Conditions `json:"conditions,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:printcolumn:name="Cluster",type="string",JSONPath=".metadata.labels.cluster\\.x-k8s\\.io/cluster-name",description="Cluster to which this AzureCluster belongs"
// +kubebuilder:printcolumn:name="Ready",type="boolean",JSONPath=".status.ready"
// +kubebuilder:printcolumn:name="Resource Group",type="string",priority=1,JSONPath=".spec.resourceGroup"
// +kubebuilder:printcolumn:name="SubscriptionID",type="string",priority=1,JSONPath=".spec.subscriptionID"
// +kubebuilder:printcolumn:name="Location",type="string",priority=1,JSONPath=".spec.location"
// +kubebuilder:printcolumn:name="Endpoint",type="string",priority=1,JSONPath=".spec.controlPlaneEndpoint.host",description="Control Plane Endpoint"
// +kubebuilder:resource:path=azureclusters,scope=Namespaced,categories=cluster-api
// +kubebuilder:subresource:status

// AzureCluster is the Schema for the azureclusters API.
type AzureCluster struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   AzureClusterSpec   `json:"spec,omitempty"`
        Status AzureClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AzureClusterList contains a list of AzureClusters.
type AzureClusterList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []AzureCluster `json:"items"`
}

// GetConditions returns the list of conditions for an AzureCluster API object.
func (c *AzureCluster) GetConditions() clusterv1alpha3.Conditions <span class="cov0" title="0">{
        return c.Status.Conditions
}</span>

// SetConditions will set the given conditions on an AzureCluster object.
func (c *AzureCluster) SetConditions(conditions clusterv1alpha3.Conditions) <span class="cov0" title="0">{
        c.Status.Conditions = conditions
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;AzureCluster{}, &amp;AzureClusterList{})
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha3

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        apiconversion "k8s.io/apimachinery/pkg/conversion"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        utilconversion "sigs.k8s.io/cluster-api/util/conversion"
        "sigs.k8s.io/controller-runtime/pkg/conversion"
)

const (
        // AzureClusterKind is the Kubernetes Kind for AzureCluster.
        AzureClusterKind = "AzureCluster"
)

// ConvertTo converts this AzureCluster to the Hub version (v1beta1).
func (src *AzureClusterIdentity) ConvertTo(dstRaw conversion.Hub) error <span class="cov8" title="1">{
        dst := dstRaw.(*infrav1.AzureClusterIdentity)
        if err := Convert_v1alpha3_AzureClusterIdentity_To_v1beta1_AzureClusterIdentity(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Manually restore data.
        <span class="cov8" title="1">restored := &amp;infrav1.AzureClusterIdentity{}
        if ok, err := utilconversion.UnmarshalData(src, restored); err != nil || !ok </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if len(dst.Annotations) == 0 </span><span class="cov8" title="1">{
                dst.Annotations = nil
        }</span>

        <span class="cov8" title="1">if len(src.Spec.AllowedNamespaces) &gt; 0 </span><span class="cov8" title="1">{
                dst.Spec.AllowedNamespaces = &amp;infrav1.AllowedNamespaces{}
                dst.Spec.AllowedNamespaces.NamespaceList = append(dst.Spec.AllowedNamespaces.NamespaceList, src.Spec.AllowedNamespaces...)
        }</span>

        <span class="cov8" title="1">if restored.Spec.AllowedNamespaces != nil &amp;&amp; restored.Spec.AllowedNamespaces.Selector != nil </span><span class="cov8" title="1">{
                if dst.Spec.AllowedNamespaces == nil </span><span class="cov8" title="1">{
                        dst.Spec.AllowedNamespaces = &amp;infrav1.AllowedNamespaces{}
                }</span>
                <span class="cov8" title="1">dst.Spec.AllowedNamespaces.Selector = restored.Spec.AllowedNamespaces.Selector</span>
        }

        // removing ownerReference for AzureCluster as ownerReference is not required from v1alpha4/v1beta1 onwards.
        <span class="cov8" title="1">var restoredOwnerReferences []metav1.OwnerReference
        for _, ownerRef := range dst.OwnerReferences </span><span class="cov8" title="1">{
                if ownerRef.Kind != AzureClusterKind </span><span class="cov8" title="1">{
                        restoredOwnerReferences = append(restoredOwnerReferences, ownerRef)
                }</span>
        }
        <span class="cov8" title="1">dst.OwnerReferences = restoredOwnerReferences

        return nil</span>
}

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureClusterIdentity) ConvertFrom(srcRaw conversion.Hub) error <span class="cov8" title="1">{
        src := srcRaw.(*infrav1.AzureClusterIdentity)
        if err := Convert_v1beta1_AzureClusterIdentity_To_v1alpha3_AzureClusterIdentity(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Preserve Hub data on down-conversion.
        <span class="cov8" title="1">if err := utilconversion.MarshalData(src, dst); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if src.Spec.AllowedNamespaces != nil </span><span class="cov8" title="1">{
                dst.Spec.AllowedNamespaces = append(dst.Spec.AllowedNamespaces, src.Spec.AllowedNamespaces.NamespaceList...)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha3_AzureClusterIdentitySpec_To_v1beta1_AzureClusterIdentitySpec converts an Azure cluster identity spec from v1alpha3 to v1beta1.
func Convert_v1alpha3_AzureClusterIdentitySpec_To_v1beta1_AzureClusterIdentitySpec(in *AzureClusterIdentitySpec, out *infrav1.AzureClusterIdentitySpec, s apiconversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha3_AzureClusterIdentitySpec_To_v1beta1_AzureClusterIdentitySpec(in, out, s)
}</span>

// Convert_v1beta1_AzureClusterIdentitySpec_To_v1alpha3_AzureClusterIdentitySpec converts an Azure cluster identity spec from v1beta1 to v1alpha3.
func Convert_v1beta1_AzureClusterIdentitySpec_To_v1alpha3_AzureClusterIdentitySpec(in *infrav1.AzureClusterIdentitySpec, out *AzureClusterIdentitySpec, s apiconversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureClusterIdentitySpec_To_v1alpha3_AzureClusterIdentitySpec(in, out, s)
}</span>

// ConvertTo converts this AzureClusterIdentityList to the Hub version (v1beta1).
func (src *AzureClusterIdentityList) ConvertTo(dstRaw conversion.Hub) error <span class="cov0" title="0">{
        dst := dstRaw.(*infrav1.AzureClusterIdentityList)
        return Convert_v1alpha3_AzureClusterIdentityList_To_v1beta1_AzureClusterIdentityList(src, dst, nil)
}</span>

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureClusterIdentityList) ConvertFrom(srcRaw conversion.Hub) error <span class="cov0" title="0">{
        src := srcRaw.(*infrav1.AzureClusterIdentityList)
        return Convert_v1beta1_AzureClusterIdentityList_To_v1alpha3_AzureClusterIdentityList(src, dst, nil)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha3

import (
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1alpha3 "sigs.k8s.io/cluster-api/api/v1alpha3"
)

// AzureClusterIdentitySpec defines the parameters that are used to create an AzureIdentity.
type AzureClusterIdentitySpec struct {
        // UserAssignedMSI or Service Principal
        Type IdentityType `json:"type"`
        // User assigned MSI resource id.
        // +optional
        ResourceID string `json:"resourceID,omitempty"`
        // Both User Assigned MSI and SP can use this field.
        ClientID string `json:"clientID"`
        // ClientSecret is a secret reference which should contain either a Service Principal password or certificate secret.
        // +optional
        ClientSecret corev1.SecretReference `json:"clientSecret,omitempty"`
        // Service principal primary tenant id.
        TenantID string `json:"tenantID"`
        // AllowedNamespaces is an array of namespaces that AzureClusters can
        // use this Identity from.
        //
        // An empty list (default) indicates that AzureClusters can use this
        // Identity from any namespace. This field is intentionally not a
        // pointer because the nil behavior (no namespaces) is undesirable here.
        // +optional
        AllowedNamespaces []string `json:"allowedNamespaces"`
}

// AzureClusterIdentityStatus defines the observed state of AzureClusterIdentity.
type AzureClusterIdentityStatus struct {
        // Conditions defines current service state of the AzureClusterIdentity.
        // +optional
        Conditions clusterv1alpha3.Conditions `json:"conditions,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:path=azureclusteridentities,scope=Namespaced,categories=cluster-api
// +kubebuilder:subresource:status

// AzureClusterIdentity is the Schema for the azureclustersidentities API.
type AzureClusterIdentity struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   AzureClusterIdentitySpec   `json:"spec,omitempty"`
        Status AzureClusterIdentityStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AzureClusterIdentityList contains a list of AzureClusterIdentities.
type AzureClusterIdentityList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []AzureClusterIdentity `json:"items"`
}

// GetConditions returns the list of conditions for an AzureClusterIdentity API object.
func (c *AzureClusterIdentity) GetConditions() clusterv1alpha3.Conditions <span class="cov0" title="0">{
        return c.Status.Conditions
}</span>

// SetConditions will set the given conditions on an AzureClusterIdentity object.
func (c *AzureClusterIdentity) SetConditions(conditions clusterv1alpha3.Conditions) <span class="cov0" title="0">{
        c.Status.Conditions = conditions
}</span>

// ClusterNamespaceAllowed indicates if the cluster namespace is allowed.
func (c *AzureClusterIdentity) ClusterNamespaceAllowed(namespace string) bool <span class="cov0" title="0">{
        if len(c.Spec.AllowedNamespaces) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">for _, v := range c.Spec.AllowedNamespaces </span><span class="cov0" title="0">{
                if v == namespace </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;AzureClusterIdentity{}, &amp;AzureClusterIdentityList{})
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha3

import (
        apiconversion "k8s.io/apimachinery/pkg/conversion"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        utilconversion "sigs.k8s.io/cluster-api/util/conversion"
        "sigs.k8s.io/controller-runtime/pkg/conversion"
)

// ConvertTo converts this AzureMachine to the Hub version (v1beta1).
func (src *AzureMachine) ConvertTo(dstRaw conversion.Hub) error <span class="cov8" title="1">{
        dst := dstRaw.(*infrav1.AzureMachine)
        if err := Convert_v1alpha3_AzureMachine_To_v1beta1_AzureMachine(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Manually restore data from annotations
        <span class="cov8" title="1">restored := &amp;infrav1.AzureMachine{}
        if ok, err := utilconversion.UnmarshalData(src, restored); err != nil || !ok </span><span class="cov8" title="1">{
                return err
        }</span>

        // Handle special case for conversion of ManagedDisk to pointer.
        <span class="cov8" title="1">if restored.Spec.OSDisk.ManagedDisk == nil &amp;&amp; dst.Spec.OSDisk.ManagedDisk != nil </span><span class="cov8" title="1">{
                if *dst.Spec.OSDisk.ManagedDisk == (infrav1.ManagedDiskParameters{}) </span><span class="cov8" title="1">{
                        // restore nil value if nothing has changed since conversion
                        dst.Spec.OSDisk.ManagedDisk = nil
                }</span>
        }

        <span class="cov8" title="1">if restored.Spec.Image != nil &amp;&amp; restored.Spec.Image.SharedGallery != nil </span><span class="cov8" title="1">{
                dst.Spec.Image.SharedGallery.Offer = restored.Spec.Image.SharedGallery.Offer
                dst.Spec.Image.SharedGallery.Publisher = restored.Spec.Image.SharedGallery.Publisher
                dst.Spec.Image.SharedGallery.SKU = restored.Spec.Image.SharedGallery.SKU
        }</span>

        <span class="cov8" title="1">if dst.Spec.Image != nil &amp;&amp; restored.Spec.Image.ComputeGallery != nil </span><span class="cov8" title="1">{
                dst.Spec.Image.ComputeGallery = restored.Spec.Image.ComputeGallery
        }</span>

        <span class="cov8" title="1">if restored.Spec.AdditionalCapabilities != nil </span><span class="cov8" title="1">{
                dst.Spec.AdditionalCapabilities = restored.Spec.AdditionalCapabilities
        }</span>

        <span class="cov8" title="1">if len(restored.Spec.DNSServers) &gt; 0 </span><span class="cov8" title="1">{
                dst.Spec.DNSServers = restored.Spec.DNSServers
        }</span>

        <span class="cov8" title="1">dst.Spec.SubnetName = restored.Spec.SubnetName

        dst.Status.LongRunningOperationStates = restored.Status.LongRunningOperationStates

        return nil</span>
}

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureMachine) ConvertFrom(srcRaw conversion.Hub) error <span class="cov8" title="1">{
        src := srcRaw.(*infrav1.AzureMachine)
        if err := Convert_v1beta1_AzureMachine_To_v1alpha3_AzureMachine(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Preserve Hub data on down-conversion.
        <span class="cov8" title="1">return utilconversion.MarshalData(src, dst)</span>
}

// ConvertTo converts this AzureMachineList to the Hub version (v1beta1).
func (src *AzureMachineList) ConvertTo(dstRaw conversion.Hub) error <span class="cov0" title="0">{
        dst := dstRaw.(*infrav1.AzureMachineList)
        return Convert_v1alpha3_AzureMachineList_To_v1beta1_AzureMachineList(src, dst, nil)
}</span>

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureMachineList) ConvertFrom(srcRaw conversion.Hub) error <span class="cov0" title="0">{
        src := srcRaw.(*infrav1.AzureMachineList)
        return Convert_v1beta1_AzureMachineList_To_v1alpha3_AzureMachineList(src, dst, nil)
}</span>

// Convert_v1alpha3_AzureMachineSpec_To_v1beta1_AzureMachineSpec converts this AzureMachineSpec to the Hub version (v1beta1).
func Convert_v1alpha3_AzureMachineSpec_To_v1beta1_AzureMachineSpec(in *AzureMachineSpec, out *infrav1.AzureMachineSpec, s apiconversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha3_AzureMachineSpec_To_v1beta1_AzureMachineSpec(in, out, s)
}</span>

// Convert_v1beta1_AzureMachineSpec_To_v1alpha3_AzureMachineSpec converts from the Hub version (v1beta1) of the AzureMachineSpec to this version.
func Convert_v1beta1_AzureMachineSpec_To_v1alpha3_AzureMachineSpec(in *infrav1.AzureMachineSpec, out *AzureMachineSpec, s apiconversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureMachineSpec_To_v1alpha3_AzureMachineSpec(in, out, s)
}</span>

// Convert_v1alpha3_AzureMachineStatus_To_v1beta1_AzureMachineStatus converts this AzureMachineStatus to the Hub version (v1beta1).
func Convert_v1alpha3_AzureMachineStatus_To_v1beta1_AzureMachineStatus(in *AzureMachineStatus, out *infrav1.AzureMachineStatus, s apiconversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha3_AzureMachineStatus_To_v1beta1_AzureMachineStatus(in, out, s)
}</span>

// Convert_v1beta1_AzureMachineStatus_To_v1alpha3_AzureMachineStatus converts from the Hub version (v1beta1) of the AzureMachineStatus to this version.
func Convert_v1beta1_AzureMachineStatus_To_v1alpha3_AzureMachineStatus(in *infrav1.AzureMachineStatus, out *AzureMachineStatus, s apiconversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureMachineStatus_To_v1alpha3_AzureMachineStatus(in, out, s)
}</span>

// Convert_v1alpha3_OSDisk_To_v1beta1_OSDisk converts this OSDisk to the Hub version (v1beta1).
func Convert_v1alpha3_OSDisk_To_v1beta1_OSDisk(in *OSDisk, out *infrav1.OSDisk, s apiconversion.Scope) error <span class="cov8" title="1">{
        out.OSType = in.OSType
        if in.DiskSizeGB != 0 </span><span class="cov8" title="1">{
                out.DiskSizeGB = &amp;in.DiskSizeGB
        }</span>
        <span class="cov8" title="1">out.DiffDiskSettings = (*infrav1.DiffDiskSettings)(in.DiffDiskSettings)
        out.CachingType = in.CachingType
        out.ManagedDisk = &amp;infrav1.ManagedDiskParameters{}

        return Convert_v1alpha3_ManagedDisk_To_v1beta1_ManagedDiskParameters(&amp;in.ManagedDisk, out.ManagedDisk, s)</span>
}

// Convert_v1beta1_OSDisk_To_v1alpha3_OSDisk converts from the Hub version (v1beta1) of the AzureMachineStatus to this version.
func Convert_v1beta1_OSDisk_To_v1alpha3_OSDisk(in *infrav1.OSDisk, out *OSDisk, s apiconversion.Scope) error <span class="cov8" title="1">{
        out.OSType = in.OSType
        if in.DiskSizeGB != nil </span><span class="cov8" title="1">{
                out.DiskSizeGB = *in.DiskSizeGB
        }</span>
        <span class="cov8" title="1">out.DiffDiskSettings = (*DiffDiskSettings)(in.DiffDiskSettings)
        out.CachingType = in.CachingType

        if in.ManagedDisk != nil </span><span class="cov8" title="1">{
                out.ManagedDisk = ManagedDisk{}
                if err := Convert_v1beta1_ManagedDiskParameters_To_v1alpha3_ManagedDisk(in.ManagedDisk, &amp;out.ManagedDisk, s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha3_ManagedDisk_To_v1beta1_ManagedDiskParameters converts this ManagedDisk to the Hub version (v1beta1).
func Convert_v1alpha3_ManagedDisk_To_v1beta1_ManagedDiskParameters(in *ManagedDisk, out *infrav1.ManagedDiskParameters, s apiconversion.Scope) error <span class="cov8" title="1">{
        out.StorageAccountType = in.StorageAccountType
        out.DiskEncryptionSet = (*infrav1.DiskEncryptionSetParameters)(in.DiskEncryptionSet)
        return nil
}</span>

// Convert_v1beta1_ManagedDiskParameters_To_v1alpha3_ManagedDisk converts from the Hub version (v1beta1) of the ManagedDiskParameters to this version.
func Convert_v1beta1_ManagedDiskParameters_To_v1alpha3_ManagedDisk(in *infrav1.ManagedDiskParameters, out *ManagedDisk, s apiconversion.Scope) error <span class="cov8" title="1">{
        out.StorageAccountType = in.StorageAccountType
        out.DiskEncryptionSet = (*DiskEncryptionSetParameters)(in.DiskEncryptionSet)
        return nil
}</span>

// Convert_v1beta1_AzureMarketplaceImage_To_v1alpha3_AzureMarketplaceImage converts an Azure Marketplace image from v1beta1 to v1alpha3.
func Convert_v1beta1_AzureMarketplaceImage_To_v1alpha3_AzureMarketplaceImage(in *infrav1.AzureMarketplaceImage, out *AzureMarketplaceImage, s apiconversion.Scope) error <span class="cov8" title="1">{
        out.Offer = in.ImagePlan.Offer
        out.Publisher = in.ImagePlan.Publisher
        out.SKU = in.ImagePlan.SKU

        return autoConvert_v1beta1_AzureMarketplaceImage_To_v1alpha3_AzureMarketplaceImage(in, out, s)
}</span>

// Convert_v1alpha3_AzureMarketplaceImage_To_v1beta1_AzureMarketplaceImage converts an Azure Marketplace image from v1alpha3 to v1beta1.
func Convert_v1alpha3_AzureMarketplaceImage_To_v1beta1_AzureMarketplaceImage(in *AzureMarketplaceImage, out *infrav1.AzureMarketplaceImage, s apiconversion.Scope) error <span class="cov8" title="1">{
        out.ImagePlan.Offer = in.Offer
        out.ImagePlan.Publisher = in.Publisher
        out.ImagePlan.SKU = in.SKU

        return autoConvert_v1alpha3_AzureMarketplaceImage_To_v1beta1_AzureMarketplaceImage(in, out, s)
}</span>

// Convert_v1beta1_Image_To_v1alpha3_Image converts an image from v1beta1 to v1alpha3.
func Convert_v1beta1_Image_To_v1alpha3_Image(in *infrav1.Image, out *Image, s apiconversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_Image_To_v1alpha3_Image(in, out, s)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha3

import (
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/resource"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1alpha3 "sigs.k8s.io/cluster-api/api/v1alpha3"
        "sigs.k8s.io/cluster-api/errors"
)

const (
        // MachineFinalizer allows ReconcileAzureMachine to clean up Azure resources associated with AzureMachine before
        // removing it from the apiserver.
        MachineFinalizer = "azuremachine.infrastructure.cluster.x-k8s.io"
)

// AzureMachineSpec defines the desired state of AzureMachine.
type AzureMachineSpec struct {
        // ProviderID is the unique identifier as specified by the cloud provider.
        // +optional
        ProviderID *string `json:"providerID,omitempty"`

        VMSize string `json:"vmSize"`

        // FailureDomain is the failure domain unique identifier this Machine should be attached to,
        // as defined in Cluster API. This relates to an Azure Availability Zone
        FailureDomain *string `json:"failureDomain,omitempty"`

        // Deprecated: use FailureDomain instead
        AvailabilityZone AvailabilityZone `json:"availabilityZone,omitempty"`

        // Image is used to provide details of an image to use during VM creation.
        // If image details are omitted the image will default the Azure Marketplace "capi" offer,
        // which is based on Ubuntu.
        // +kubebuilder:validation:nullable
        // +optional
        Image *Image `json:"image,omitempty"`

        // Identity is the type of identity used for the virtual machine.
        // The type 'SystemAssigned' is an implicitly created identity.
        // The generated identity will be assigned a Subscription contributor role.
        // The type 'UserAssigned' is a standalone Azure resource provided by the user
        // and assigned to the VM
        // +kubebuilder:default=None
        // +optional
        Identity VMIdentity `json:"identity,omitempty"`

        // UserAssignedIdentities is a list of standalone Azure identities provided by the user
        // The lifecycle of a user-assigned identity is managed separately from the lifecycle of
        // the AzureMachine.
        // See https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/how-to-manage-ua-identity-cli
        // +optional
        UserAssignedIdentities []UserAssignedIdentity `json:"userAssignedIdentities,omitempty"`

        // RoleAssignmentName is the name of the role assignment to create for a system assigned identity. It can be any valid GUID.
        // If not specified, a random GUID will be generated.
        // +optional
        RoleAssignmentName string `json:"roleAssignmentName,omitempty"`

        // OSDisk specifies the parameters for the operating system disk of the machine
        OSDisk OSDisk `json:"osDisk"`

        // DataDisk specifies the parameters that are used to add one or more data disks to the machine
        DataDisks []DataDisk `json:"dataDisks,omitempty"`

        // Deprecated: to support old clients, will be removed in v1alpha4/v1beta1
        Location string `json:"location"`

        SSHPublicKey string `json:"sshPublicKey"`

        // AdditionalTags is an optional set of tags to add to an instance, in addition to the ones added by default by the
        // Azure provider. If both the AzureCluster and the AzureMachine specify the same tag name with different values, the
        // AzureMachine's value takes precedence.
        // +optional
        AdditionalTags Tags `json:"additionalTags,omitempty"`

        // AllocatePublicIP allows the ability to create dynamic public ips for machines where this value is true.
        // +optional
        AllocatePublicIP bool `json:"allocatePublicIP,omitempty"`

        // EnableIPForwarding enables IP Forwarding in Azure which is required for some CNI's to send traffic from a pods on one machine
        // to another. This is required for IpV6 with Calico in combination with User Defined Routes (set by the Azure Cloud Controller
        // manager). Default is false for disabled.
        // +optional
        EnableIPForwarding bool `json:"enableIPForwarding,omitempty"`

        // AcceleratedNetworking enables or disables Azure accelerated networking. If omitted, it will be set based on
        // whether the requested VMSize supports accelerated networking.
        // If AcceleratedNetworking is set to true with a VMSize that does not support it, Azure will return an error.
        // +kubebuilder:validation:nullable
        // +optional
        AcceleratedNetworking *bool `json:"acceleratedNetworking,omitempty"`

        // SpotVMOptions allows the ability to specify the Machine should use a Spot VM.
        // +optional
        SpotVMOptions *SpotVMOptions `json:"spotVMOptions,omitempty"`

        // SecurityProfile specifies the Security profile settings for a virtual machine.
        // +optional
        SecurityProfile *SecurityProfile `json:"securityProfile,omitempty"`
}

// SpotVMOptions defines the options relevant to running the Machine on Spot VMs.
type SpotVMOptions struct {
        // MaxPrice defines the maximum price the user is willing to pay for Spot VM instances
        // +optional
        MaxPrice *resource.Quantity `json:"maxPrice,omitempty"`
}

// AzureMachineStatus defines the observed state of AzureMachine.
type AzureMachineStatus struct {
        // Ready is true when the provider resource is ready.
        // +optional
        Ready bool `json:"ready"`

        // Addresses contains the Azure instance associated addresses.
        Addresses []corev1.NodeAddress `json:"addresses,omitempty"`

        // VMState is the provisioning state of the Azure virtual machine.
        // +optional
        VMState *VMState `json:"vmState,omitempty"`

        // ErrorReason will be set in the event that there is a terminal problem
        // reconciling the Machine and will contain a succinct value suitable
        // for machine interpretation.
        //
        // This field should not be set for transitive errors that a controller
        // faces that are expected to be fixed automatically over
        // time (like service outages), but instead indicate that something is
        // fundamentally wrong with the Machine's spec or the configuration of
        // the controller, and that manual intervention is required. Examples
        // of terminal errors would be invalid combinations of settings in the
        // spec, values that are unsupported by the controller, or the
        // responsible controller itself being critically misconfigured.
        //
        // Any transient errors that occur during the reconciliation of Machines
        // can be added as events to the Machine object and/or logged in the
        // controller's output.
        // +optional
        FailureReason *errors.MachineStatusError `json:"failureReason,omitempty"`

        // ErrorMessage will be set in the event that there is a terminal problem
        // reconciling the Machine and will contain a more verbose string suitable
        // for logging and human consumption.
        //
        // This field should not be set for transitive errors that a controller
        // faces that are expected to be fixed automatically over
        // time (like service outages), but instead indicate that something is
        // fundamentally wrong with the Machine's spec or the configuration of
        // the controller, and that manual intervention is required. Examples
        // of terminal errors would be invalid combinations of settings in the
        // spec, values that are unsupported by the controller, or the
        // responsible controller itself being critically misconfigured.
        //
        // Any transient errors that occur during the reconciliation of Machines
        // can be added as events to the Machine object and/or logged in the
        // controller's output.
        // +optional
        FailureMessage *string `json:"failureMessage,omitempty"`

        // Conditions defines current service state of the AzureMachine.
        // +optional
        Conditions clusterv1alpha3.Conditions `json:"conditions,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.ready",description="AzureMachine ready status"
// +kubebuilder:printcolumn:name="State",type="string",JSONPath=".status.vmState",description="Azure VM provisioning state"
// +kubebuilder:printcolumn:name="Cluster",type="string",priority=1,JSONPath=".metadata.labels.cluster\\.x-k8s\\.io/cluster-name",description="Cluster to which this AzureMachine belongs"
// +kubebuilder:printcolumn:name="Machine",type="string",priority=1,JSONPath=".metadata.ownerReferences[?(@.kind==\"Machine\")].name",description="Machine object to which this AzureMachine belongs"
// +kubebuilder:printcolumn:name="VM ID",type="string",priority=1,JSONPath=".spec.providerID",description="Azure VM ID"
// +kubebuilder:printcolumn:name="VM Size",type="string",priority=1,JSONPath=".spec.vmSize",description="Azure VM Size"
// +kubebuilder:resource:path=azuremachines,scope=Namespaced,categories=cluster-api
// +kubebuilder:subresource:status

// AzureMachine is the Schema for the azuremachines API.
type AzureMachine struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   AzureMachineSpec   `json:"spec,omitempty"`
        Status AzureMachineStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AzureMachineList contains a list of AzureMachines.
type AzureMachineList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []AzureMachine `json:"items"`
}

// GetConditions returns the list of conditions for an AzureMachine API object.
func (m *AzureMachine) GetConditions() clusterv1alpha3.Conditions <span class="cov0" title="0">{
        return m.Status.Conditions
}</span>

// SetConditions will set the given conditions on an AzureMachine object.
func (m *AzureMachine) SetConditions(conditions clusterv1alpha3.Conditions) <span class="cov0" title="0">{
        m.Status.Conditions = conditions
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;AzureMachine{}, &amp;AzureMachineList{})
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha3

import (
        apimachineryconversion "k8s.io/apimachinery/pkg/conversion"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        utilconversion "sigs.k8s.io/cluster-api/util/conversion"
        "sigs.k8s.io/controller-runtime/pkg/conversion"
)

// ConvertTo converts this AzureMachineTemplate to the Hub version (v1beta1).
func (src *AzureMachineTemplate) ConvertTo(dstRaw conversion.Hub) error <span class="cov8" title="1">{
        dst := dstRaw.(*infrav1.AzureMachineTemplate)
        if err := Convert_v1alpha3_AzureMachineTemplate_To_v1beta1_AzureMachineTemplate(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Manually restore data from annotations
        <span class="cov8" title="1">restored := &amp;infrav1.AzureMachineTemplate{}
        if ok, err := utilconversion.UnmarshalData(src, restored); err != nil || !ok </span><span class="cov8" title="1">{
                return err
        }</span>

        // Handle special case for conversion of ManagedDisk to pointer.
        <span class="cov8" title="1">if restored.Spec.Template.Spec.OSDisk.ManagedDisk == nil &amp;&amp; dst.Spec.Template.Spec.OSDisk.ManagedDisk != nil </span><span class="cov8" title="1">{
                if *dst.Spec.Template.Spec.OSDisk.ManagedDisk == (infrav1.ManagedDiskParameters{}) </span><span class="cov8" title="1">{
                        // restore nil value if nothing has changed since conversion
                        dst.Spec.Template.Spec.OSDisk.ManagedDisk = nil
                }</span>
        }

        <span class="cov8" title="1">if restored.Spec.Template.Spec.Image != nil &amp;&amp; restored.Spec.Template.Spec.Image.SharedGallery != nil </span><span class="cov8" title="1">{
                dst.Spec.Template.Spec.Image.SharedGallery.Offer = restored.Spec.Template.Spec.Image.SharedGallery.Offer
                dst.Spec.Template.Spec.Image.SharedGallery.Publisher = restored.Spec.Template.Spec.Image.SharedGallery.Publisher
                dst.Spec.Template.Spec.Image.SharedGallery.SKU = restored.Spec.Template.Spec.Image.SharedGallery.SKU
        }</span>

        <span class="cov8" title="1">if dst.Spec.Template.Spec.Image != nil &amp;&amp; restored.Spec.Template.Spec.Image.ComputeGallery != nil </span><span class="cov8" title="1">{
                dst.Spec.Template.Spec.Image.ComputeGallery = restored.Spec.Template.Spec.Image.ComputeGallery
        }</span>

        <span class="cov8" title="1">if restored.Spec.Template.Spec.AdditionalCapabilities != nil </span><span class="cov8" title="1">{
                dst.Spec.Template.Spec.AdditionalCapabilities = restored.Spec.Template.Spec.AdditionalCapabilities
        }</span>

        <span class="cov8" title="1">dst.Spec.Template.Spec.SubnetName = restored.Spec.Template.Spec.SubnetName
        dst.Spec.Template.ObjectMeta = restored.Spec.Template.ObjectMeta

        if len(restored.Spec.Template.Spec.DNSServers) &gt; 0 </span><span class="cov8" title="1">{
                dst.Spec.Template.Spec.DNSServers = restored.Spec.Template.Spec.DNSServers
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureMachineTemplate) ConvertFrom(srcRaw conversion.Hub) error <span class="cov8" title="1">{
        src := srcRaw.(*infrav1.AzureMachineTemplate)
        if err := Convert_v1beta1_AzureMachineTemplate_To_v1alpha3_AzureMachineTemplate(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Preserve Hub data on down-conversion.
        <span class="cov8" title="1">return utilconversion.MarshalData(src, dst)</span>
}

// ConvertTo converts this AzureMachineTemplateList to the Hub version (v1beta1).
func (src *AzureMachineTemplateList) ConvertTo(dstRaw conversion.Hub) error <span class="cov0" title="0">{
        dst := dstRaw.(*infrav1.AzureMachineTemplateList)
        return Convert_v1alpha3_AzureMachineTemplateList_To_v1beta1_AzureMachineTemplateList(src, dst, nil)
}</span>

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureMachineTemplateList) ConvertFrom(srcRaw conversion.Hub) error <span class="cov0" title="0">{
        src := srcRaw.(*infrav1.AzureMachineTemplateList)
        return Convert_v1beta1_AzureMachineTemplateList_To_v1alpha3_AzureMachineTemplateList(src, dst, nil)
}</span>

// Convert_v1beta1_AzureSharedGalleryImage_To_v1alpha3_AzureSharedGalleryImage converts an Azure shared gallery image from v1beta1 to v1alpha3.
func Convert_v1beta1_AzureSharedGalleryImage_To_v1alpha3_AzureSharedGalleryImage(in *infrav1.AzureSharedGalleryImage, out *AzureSharedGalleryImage, s apimachineryconversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureSharedGalleryImage_To_v1alpha3_AzureSharedGalleryImage(in, out, s)
}</span>

// Convert_v1beta1_AzureMachineTemplateResource_To_v1alpha3_AzureMachineTemplateResource converts an Azure machine template resource from v1beta1 to v1alpha3.
func Convert_v1beta1_AzureMachineTemplateResource_To_v1alpha3_AzureMachineTemplateResource(in *infrav1.AzureMachineTemplateResource, out *AzureMachineTemplateResource, s apimachineryconversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureMachineTemplateResource_To_v1alpha3_AzureMachineTemplateResource(in, out, s)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha3

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// AzureMachineTemplateSpec defines the desired state of AzureMachineTemplate.
type AzureMachineTemplateSpec struct {
        Template AzureMachineTemplateResource `json:"template"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:path=azuremachinetemplates,scope=Namespaced,categories=cluster-api

// AzureMachineTemplate is the Schema for the azuremachinetemplates API.
type AzureMachineTemplate struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec AzureMachineTemplateSpec `json:"spec,omitempty"`
}

// +kubebuilder:object:root=true

// AzureMachineTemplateList contains a list of AzureMachineTemplate.
type AzureMachineTemplateList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []AzureMachineTemplate `json:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;AzureMachineTemplate{}, &amp;AzureMachineTemplateList{})
}</span>

// AzureMachineTemplateResource describes the data needed to create an AzureMachine from a template.
type AzureMachineTemplateResource struct {
        // Spec is the specification of the desired behavior of the machine.
        Spec AzureMachineSpec `json:"spec"`
}
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha3

import (
        "fmt"
        "reflect"
)

// Tags defines a map of tags.
type Tags map[string]string

// Equals returns true if the tags are equal.
func (t Tags) Equals(other Tags) bool <span class="cov0" title="0">{
        return reflect.DeepEqual(t, other)
}</span>

// HasMatchingSpecVersionHash returns true if the resource has been tagged with a matching resource spec hash value.
func (t Tags) HasMatchingSpecVersionHash(hash string) bool <span class="cov0" title="0">{
        value, ok := t[SpecVersionHashTagKey()]
        return ok &amp;&amp; value == hash
}</span>

// HasOwned returns true if the tags contains a tag that marks the resource as owned by the cluster from the perspective of this management tooling.
func (t Tags) HasOwned(cluster string) bool <span class="cov0" title="0">{
        value, ok := t[ClusterTagKey(cluster)]
        return ok &amp;&amp; ResourceLifecycle(value) == ResourceLifecycleOwned
}</span>

// HasAzureCloudProviderOwned returns true if the tags contains a tag that marks the resource as owned by the cluster from the perspective of the in-tree cloud provider.
func (t Tags) HasAzureCloudProviderOwned(cluster string) bool <span class="cov0" title="0">{
        value, ok := t[ClusterAzureCloudProviderTagKey(cluster)]
        return ok &amp;&amp; ResourceLifecycle(value) == ResourceLifecycleOwned
}</span>

// GetRole returns the Cluster API role for the tagged resource.
func (t Tags) GetRole() string <span class="cov0" title="0">{
        return t[NameAzureClusterAPIRole]
}</span>

// Difference returns the difference between this map of tags and the other map of tags.
// Items are considered equals if key and value are equals.
func (t Tags) Difference(other Tags) Tags <span class="cov0" title="0">{
        res := make(Tags, len(t))

        for key, value := range t </span><span class="cov0" title="0">{
                if otherValue, ok := other[key]; ok &amp;&amp; value == otherValue </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">res[key] = value</span>
        }

        <span class="cov0" title="0">return res</span>
}

// Merge merges in tags from other. If a tag already exists, it is replaced by the tag in other.
func (t Tags) Merge(other Tags) <span class="cov8" title="1">{
        for k, v := range other </span><span class="cov8" title="1">{
                t[k] = v
        }</span>
}

// AddSpecVersionHashTag adds a spec version hash to the Azure resource tags to determine if state has changed quickly.
func (t Tags) AddSpecVersionHashTag(hash string) Tags <span class="cov0" title="0">{
        t[SpecVersionHashTagKey()] = hash
        return t
}</span>

// ResourceLifecycle configures the lifecycle of a resource.
type ResourceLifecycle string

const (
        // ResourceLifecycleOwned is the value we use when tagging resources to indicate
        // that the resource is considered owned and managed by the cluster,
        // and in particular that the lifecycle is tied to the lifecycle of the cluster.
        ResourceLifecycleOwned = ResourceLifecycle("owned")

        // ResourceLifecycleShared is the value we use when tagging resources to indicate
        // that the resource is shared between multiple clusters, and should not be destroyed
        // if the cluster is destroyed.
        ResourceLifecycleShared = ResourceLifecycle("shared")

        // NameKubernetesAzureCloudProviderPrefix is the tag name used by the cloud provider to logically
        // separate independent cluster resources. We use it to identify which resources we expect
        // to be permissive about state changes.
        // logically independent clusters running in the same AZ.
        // The tag key = NameKubernetesAzureCloudProviderPrefix + clusterID
        // The tag value is an ownership value.
        NameKubernetesAzureCloudProviderPrefix = "kubernetes.io_cluster_"

        // NameAzureProviderPrefix is the tag prefix we use to differentiate
        // cluster-api-provider-azure owned components from other tooling that
        // uses NameKubernetesClusterPrefix.
        NameAzureProviderPrefix = "sigs.k8s.io_cluster-api-provider-azure_"

        // NameAzureProviderOwned is the tag name we use to differentiate
        // cluster-api-provider-azure owned components from other tooling that
        // uses NameKubernetesClusterPrefix.
        NameAzureProviderOwned = NameAzureProviderPrefix + "cluster_"

        // NameAzureClusterAPIRole is the tag name we use to mark roles for resources
        // dedicated to this cluster api provider implementation.
        NameAzureClusterAPIRole = NameAzureProviderPrefix + "role"

        // APIServerRole describes the value for the apiserver role.
        APIServerRole = "apiserver"

        // NodeOutboundRole describes the value for the node outbound LB role.
        NodeOutboundRole = "nodeOutbound"

        // ControlPlaneOutboundRole describes the value for the control plane outbound LB role.
        ControlPlaneOutboundRole = "controlPlaneOutbound"

        // BastionRole describes the value for the bastion role.
        BastionRole = "bastion"

        // CommonRole describes the value for the common role.
        CommonRole = "common"

        // VMTagsLastAppliedAnnotation is the key for the machine object annotation
        // which tracks the AdditionalTags in the Machine Provider Config.
        // See https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        // for annotation formatting rules.
        VMTagsLastAppliedAnnotation = "sigs.k8s.io/cluster-api-provider-azure-last-applied-tags-vm"
)

// SpecVersionHashTagKey is the key for the spec version hash used to enable quick spec difference comparison.
func SpecVersionHashTagKey() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s%s", NameAzureProviderPrefix, "spec-version-hash")
}</span>

// ClusterTagKey generates the key for resources associated with a cluster.
func ClusterTagKey(name string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s%s", NameAzureProviderOwned, name)
}</span>

// ClusterAzureCloudProviderTagKey generates the key for resources associated a cluster's Azure cloud provider.
func ClusterAzureCloudProviderTagKey(name string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s%s", NameKubernetesAzureCloudProviderPrefix, name)
}</span>

// BuildParams is used to build tags around an azure resource.
type BuildParams struct {
        // Lifecycle determines the resource lifecycle.
        Lifecycle ResourceLifecycle

        // ClusterName is the cluster associated with the resource.
        ClusterName string

        // ResourceID is the unique identifier of the resource to be tagged.
        ResourceID string

        // Name is the name of the resource, it's applied as the tag "Name" on Azure.
        // +optional
        Name *string

        // Role is the role associated to the resource.
        // +optional
        Role *string

        // Any additional tags to be added to the resource.
        // +optional
        Additional Tags
}

// Build builds tags including the cluster tag and returns them in map form.
func Build(params BuildParams) Tags <span class="cov0" title="0">{
        tags := make(Tags)
        for k, v := range params.Additional </span><span class="cov0" title="0">{
                tags[k] = v
        }</span>

        <span class="cov0" title="0">tags[ClusterTagKey(params.ClusterName)] = string(params.Lifecycle)
        if params.Role != nil </span><span class="cov0" title="0">{
                tags[NameAzureClusterAPIRole] = *params.Role
        }</span>

        <span class="cov0" title="0">if params.Name != nil </span><span class="cov0" title="0">{
                tags["Name"] = *params.Name
        }</span>

        <span class="cov0" title="0">return tags</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha3

import (
        corev1 "k8s.io/api/core/v1"
)

const (
        // ControlPlane machine label.
        ControlPlane string = "control-plane"
        // Node machine label.
        Node string = "node"
)

// Future contains the data needed for an Azure long-running operation to continue across reconcile loops.
type Future struct {
        // Type describes the type of future, update, create, delete, etc.
        Type string `json:"type"`

        // ResourceGroup is the Azure resource group for the resource.
        // +optional
        ResourceGroup string `json:"resourceGroup,omitempty"`

        // Name is the name of the Azure resource.
        // +optional
        Name string `json:"name,omitempty"`

        // FutureData is the base64 url encoded json Azure AutoRest Future.
        FutureData string `json:"futureData,omitempty"`
}

// NetworkSpec specifies what the Azure networking resources should look like.
type NetworkSpec struct {
        // Vnet is the configuration for the Azure virtual network.
        // +optional
        Vnet VnetSpec `json:"vnet,omitempty"`

        // Subnets is the configuration for the control-plane subnet and the node subnet.
        // +optional
        Subnets Subnets `json:"subnets,omitempty"`

        // APIServerLB is the configuration for the control-plane load balancer.
        // +optional
        APIServerLB LoadBalancerSpec `json:"apiServerLB,omitempty"`
}

// VnetSpec configures an Azure virtual network.
type VnetSpec struct {
        // ResourceGroup is the name of the resource group of the existing virtual network
        // or the resource group where a managed virtual network should be created.
        ResourceGroup string `json:"resourceGroup,omitempty"`

        // ID is the identifier of the virtual network this provider should use to create resources.
        ID string `json:"id,omitempty"`

        // Name defines a name for the virtual network resource.
        Name string `json:"name"`

        // CidrBlock is the CIDR block to be used when the provider creates a managed virtual network.
        // Deprecated: Use CIDRBlocks instead
        // +optional
        CidrBlock string `json:"cidrBlock,omitempty"`

        // CIDRBlocks defines the virtual network's address space, specified as one or more address prefixes in CIDR notation.
        // +optional
        CIDRBlocks []string `json:"cidrBlocks,omitempty"`

        // Tags is a collection of tags describing the resource.
        // +optional
        Tags Tags `json:"tags,omitempty"`
}

// IsManaged returns true if the vnet is managed.
func (v *VnetSpec) IsManaged(clusterName string) bool <span class="cov0" title="0">{
        return v.ID == "" || v.Tags.HasOwned(clusterName)
}</span>

// Subnets is a slice of Subnet.
type Subnets []SubnetSpec

// SecurityGroupRole defines the unique role of a security group.
type SecurityGroupRole string

const (
        // SecurityGroupNode defines a Kubernetes workload node role.
        SecurityGroupNode = SecurityGroupRole(Node)

        // SecurityGroupControlPlane defines a Kubernetes control plane node role.
        SecurityGroupControlPlane = SecurityGroupRole(ControlPlane)
)

// SecurityGroup defines an Azure security group.
type SecurityGroup struct {
        ID           string       `json:"id,omitempty"`
        Name         string       `json:"name,omitempty"`
        IngressRules IngressRules `json:"ingressRule,omitempty"`
        Tags         Tags         `json:"tags,omitempty"`
}

// RouteTable defines an Azure route table.
type RouteTable struct {
        ID   string `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}

// SecurityGroupProtocol defines the protocol type for a security group rule.
type SecurityGroupProtocol string

const (
        // SecurityGroupProtocolAll is a wildcard for all IP protocols.
        SecurityGroupProtocolAll = SecurityGroupProtocol("*")

        // SecurityGroupProtocolTCP represents the TCP protocol in ingress rules.
        SecurityGroupProtocolTCP = SecurityGroupProtocol("Tcp")

        // SecurityGroupProtocolUDP represents the UDP protocol in ingress rules.
        SecurityGroupProtocolUDP = SecurityGroupProtocol("Udp")
)

// IngressRule defines an Azure ingress rule for security groups.
type IngressRule struct {
        Name        string                `json:"name"`
        Description string                `json:"description"`
        Protocol    SecurityGroupProtocol `json:"protocol"`

        // Priority - A number between 100 and 4096. Each rule should have a unique value for priority. Rules are processed in priority order, with lower numbers processed before higher numbers. Once traffic matches a rule, processing stops.
        Priority int32 `json:"priority,omitempty"`

        // SourcePorts - The source port or range. Integer or range between 0 and 65535. Asterix '*' can also be used to match all ports.
        SourcePorts *string `json:"sourcePorts,omitempty"`

        // DestinationPorts - The destination port or range. Integer or range between 0 and 65535. Asterix '*' can also be used to match all ports.
        DestinationPorts *string `json:"destinationPorts,omitempty"`

        // Source - The CIDR or source IP range. Asterix '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used. If this is an ingress rule, specifies where network traffic originates from.
        Source *string `json:"source,omitempty"`

        // Destination - The destination address prefix. CIDR or destination IP range. Asterix '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used.
        Destination *string `json:"destination,omitempty"`
}

// IngressRules is a slice of Azure ingress rules for security groups.
type IngressRules []IngressRule

// LoadBalancerSpec defines an Azure load balancer.
type LoadBalancerSpec struct {
        ID          string       `json:"id,omitempty"`
        Name        string       `json:"name,omitempty"`
        SKU         SKU          `json:"sku,omitempty"`
        FrontendIPs []FrontendIP `json:"frontendIPs,omitempty"`
        Type        LBType       `json:"type,omitempty"`
}

// SKU defines an Azure load balancer SKU.
type SKU string

const (
        // SKUStandard is the value for the Azure load balancer Standard SKU.
        SKUStandard = SKU("Standard")
)

// LBType defines an Azure load balancer Type.
type LBType string

const (
        // Internal is the value for the Azure load balancer internal type.
        Internal = LBType("Internal")
        // Public is the value for the Azure load balancer public type.
        Public = LBType("Public")
)

// FrontendIP defines a load balancer frontend IP configuration.
type FrontendIP struct {
        // +kubebuilder:validation:MinLength=1
        Name string `json:"name"`
        // +optional
        PrivateIPAddress string `json:"privateIP,omitempty"`
        // +optional
        PublicIP *PublicIPSpec `json:"publicIP,omitempty"`
}

// PublicIPSpec defines the inputs to create an Azure public IP address.
type PublicIPSpec struct {
        Name string `json:"name"`
        // +optional
        DNSName string `json:"dnsName,omitempty"`
}

// VMState describes the state of an Azure virtual machine.
type VMState string

const (
        // VMStateCreating ...
        VMStateCreating VMState = "Creating"
        // VMStateDeleting ...
        VMStateDeleting VMState = "Deleting"
        // VMStateFailed ...
        VMStateFailed VMState = "Failed"
        // VMStateMigrating ...
        VMStateMigrating VMState = "Migrating"
        // VMStateSucceeded ...
        VMStateSucceeded VMState = "Succeeded"
        // VMStateUpdating ...
        VMStateUpdating VMState = "Updating"
        // VMStateDeleted represents a deleted VM
        // NOTE: This state is specific to capz, and does not have corresponding mapping in Azure API (https://docs.microsoft.com/en-us/azure/virtual-machines/states-lifecycle#provisioning-states)
        VMStateDeleted VMState = "Deleted"
)

// VM describes an Azure virtual machine.
type VM struct {
        ID               string `json:"id,omitempty"`
        Name             string `json:"name,omitempty"`
        AvailabilityZone string `json:"availabilityZone,omitempty"`
        // Hardware profile
        VMSize string `json:"vmSize,omitempty"`
        // Storage profile
        Image         Image  `json:"image,omitempty"`
        OSDisk        OSDisk `json:"osDisk,omitempty"`
        StartupScript string `json:"startupScript,omitempty"`
        // State - The provisioning state, which only appears in the response.
        State    VMState    `json:"vmState,omitempty"`
        Identity VMIdentity `json:"identity,omitempty"`
        Tags     Tags       `json:"tags,omitempty"`

        // Addresses contains the addresses associated with the Azure VM.
        Addresses []corev1.NodeAddress `json:"addresses,omitempty"`
}

// Image defines information about the image to use for VM creation.
// There are three ways to specify an image: by ID, Marketplace Image or SharedImageGallery
// One of ID, SharedImage or Marketplace should be set.
type Image struct {
        // ID specifies an image to use by ID
        // +optional
        ID *string `json:"id,omitempty"`

        // SharedGallery specifies an image to use from an Azure Shared Image Gallery
        // +optional
        SharedGallery *AzureSharedGalleryImage `json:"sharedGallery,omitempty"`

        // Marketplace specifies an image to use from the Azure Marketplace
        // +optional
        Marketplace *AzureMarketplaceImage `json:"marketplace,omitempty"`
}

// AzureMarketplaceImage defines an image in the Azure Marketplace to use for VM creation.
type AzureMarketplaceImage struct {
        // Publisher is the name of the organization that created the image
        // +kubebuilder:validation:MinLength=1
        Publisher string `json:"publisher"`
        // Offer specifies the name of a group of related images created by the publisher.
        // For example, UbuntuServer, WindowsServer
        // +kubebuilder:validation:MinLength=1
        Offer string `json:"offer"`
        // SKU specifies an instance of an offer, such as a major release of a distribution.
        // For example, 18.04-LTS, 2019-Datacenter
        // +kubebuilder:validation:MinLength=1
        SKU string `json:"sku"`
        // Version specifies the version of an image sku. The allowed formats
        // are Major.Minor.Build or 'latest'. Major, Minor, and Build are decimal numbers.
        // Specify 'latest' to use the latest version of an image available at deploy time.
        // Even if you use 'latest', the VM image will not automatically update after deploy
        // time even if a new version becomes available.
        // +kubebuilder:validation:MinLength=1
        Version string `json:"version"`
        // ThirdPartyImage indicates the image is published by a third party publisher and a Plan
        // will be generated for it.
        // +kubebuilder:default=false
        // +optional
        ThirdPartyImage bool `json:"thirdPartyImage"`
}

// AzureSharedGalleryImage defines an image in a Shared Image Gallery to use for VM creation.
type AzureSharedGalleryImage struct {
        // SubscriptionID is the identifier of the subscription that contains the shared image gallery
        // +kubebuilder:validation:MinLength=1
        SubscriptionID string `json:"subscriptionID"`
        // ResourceGroup specifies the resource group containing the shared image gallery
        // +kubebuilder:validation:MinLength=1
        ResourceGroup string `json:"resourceGroup"`
        // Gallery specifies the name of the shared image gallery that contains the image
        // +kubebuilder:validation:MinLength=1
        Gallery string `json:"gallery"`
        // Name is the name of the image
        // +kubebuilder:validation:MinLength=1
        Name string `json:"name"`
        // Version specifies the version of the marketplace image. The allowed formats
        // are Major.Minor.Build or 'latest'. Major, Minor, and Build are decimal numbers.
        // Specify 'latest' to use the latest version of an image available at deploy time.
        // Even if you use 'latest', the VM image will not automatically update after deploy
        // time even if a new version becomes available.
        // +kubebuilder:validation:MinLength=1
        Version string `json:"version"`
}

// AvailabilityZone specifies an Azure Availability Zone.
//
// Deprecated: Use FailureDomain instead.
type AvailabilityZone struct {
        ID      *string `json:"id,omitempty"`
        Enabled *bool   `json:"enabled,omitempty"`
}

// VMIdentity defines the identity of the virtual machine, if configured.
// +kubebuilder:validation:Enum=None;SystemAssigned;UserAssigned
type VMIdentity string

const (
        // VMIdentityNone ...
        VMIdentityNone VMIdentity = "None"
        // VMIdentitySystemAssigned ...
        VMIdentitySystemAssigned VMIdentity = "SystemAssigned"
        // VMIdentityUserAssigned ...
        VMIdentityUserAssigned VMIdentity = "UserAssigned"
)

// UserAssignedIdentity defines the user-assigned identities provided
// by the user to be assigned to Azure resources.
type UserAssignedIdentity struct {
        // ProviderID is the identification ID of the user-assigned Identity, the format of an identity is:
        // 'azure:///subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'
        ProviderID string `json:"providerID"`
}

const (
        // AzureIdentityBindingSelector is the label used to match with the AzureIdentityBinding
        // For the controller to match an identity binding, it needs a [label] with the key `aadpodidbinding`
        // whose value is that of the `selector:` field in the `AzureIdentityBinding`.
        AzureIdentityBindingSelector = "capz-controller-aadpodidentity-selector"
)

// IdentityType represents different types of identities.
// +kubebuilder:validation:Enum=ServicePrincipal;UserAssignedMSI
type IdentityType string

const (
        // UserAssignedMSI represents a user-assigned identity.
        UserAssignedMSI IdentityType = "UserAssignedMSI"

        // ServicePrincipal represents a service principal.
        ServicePrincipal IdentityType = "ServicePrincipal"
)

// OSDisk defines the operating system disk for a VM.
//
// WARNING: this requires any updates to ManagedDisk to be manually converted. This is due to the odd issue with
// conversion-gen where the warning message generated uses a relative directory import rather than the fully
// qualified import when generating outside of the GOPATH.
// +k8s:conversion-gen=false
type OSDisk struct {
        OSType           string            `json:"osType"`
        DiskSizeGB       int32             `json:"diskSizeGB"`
        ManagedDisk      ManagedDisk       `json:"managedDisk"`
        DiffDiskSettings *DiffDiskSettings `json:"diffDiskSettings,omitempty"`
        // +optional
        CachingType string `json:"cachingType,omitempty"`
}

// DataDisk specifies the parameters that are used to add one or more data disks to the machine.
type DataDisk struct {
        // NameSuffix is the suffix to be appended to the machine name to generate the disk name.
        // Each disk name will be in format &lt;machineName&gt;_&lt;nameSuffix&gt;.
        NameSuffix string `json:"nameSuffix"`
        // DiskSizeGB is the size in GB to assign to the data disk.
        DiskSizeGB int32 `json:"diskSizeGB"`
        // +optional
        ManagedDisk *ManagedDisk `json:"managedDisk,omitempty"`
        // Lun Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and therefore must be unique for each data disk attached to a VM.
        // The value must be between 0 and 63.
        Lun *int32 `json:"lun,omitempty"`
        // +optional
        CachingType string `json:"cachingType,omitempty"`
}

// ManagedDisk defines the managed disk options for a VM.
type ManagedDisk struct {
        StorageAccountType string                       `json:"storageAccountType"`
        DiskEncryptionSet  *DiskEncryptionSetParameters `json:"diskEncryptionSet,omitempty"`
}

// DiskEncryptionSetParameters defines disk encryption options.
type DiskEncryptionSetParameters struct {
        // ID defines resourceID for diskEncryptionSet resource. It must be in the same subscription
        ID string `json:"id,omitempty"`
}

// DiffDiskSettings describe ephemeral disk settings for the os disk.
type DiffDiskSettings struct {
        // Option enables ephemeral OS when set to "Local"
        // See https://docs.microsoft.com/en-us/azure/virtual-machines/ephemeral-os-disks for full details
        // +kubebuilder:validation:Enum=Local
        Option string `json:"option"`
}

// SubnetRole defines the unique role of a subnet.
type SubnetRole string

const (
        // SubnetNode defines a Kubernetes workload node role.
        SubnetNode = SubnetRole(Node)

        // SubnetControlPlane defines a Kubernetes control plane node role.
        SubnetControlPlane = SubnetRole(ControlPlane)
)

// SubnetSpec configures an Azure subnet.
type SubnetSpec struct {
        // Role defines the subnet role (eg. Node, ControlPlane)
        Role SubnetRole `json:"role,omitempty"`

        // ID defines a unique identifier to reference this resource.
        // +optional
        ID string `json:"id,omitempty"`

        // Name defines a name for the subnet resource.
        Name string `json:"name"`

        // CidrBlock is the CIDR block to be used when the provider creates a managed Vnet.
        // Deprecated: Use CIDRBlocks instead
        // +optional
        CidrBlock string `json:"cidrBlock,omitempty"`

        // CIDRBlocks defines the subnet's address space, specified as one or more address prefixes in CIDR notation.
        // +optional
        CIDRBlocks []string `json:"cidrBlocks,omitempty"`

        // InternalLBIPAddress is the IP address that will be used as the internal LB private IP.
        // For the control plane subnet only.
        // +optional
        // Deprecated: Use LoadBalancer private IP instead
        InternalLBIPAddress string `json:"internalLBIPAddress,omitempty"`

        // SecurityGroup defines the NSG (network security group) that should be attached to this subnet.
        // +optional
        SecurityGroup SecurityGroup `json:"securityGroup,omitempty"`

        // RouteTable defines the route table that should be attached to this subnet.
        // +optional
        RouteTable RouteTable `json:"routeTable,omitempty"`
}

// GetControlPlaneSubnet returns the cluster control plane subnet.
func (n *NetworkSpec) GetControlPlaneSubnet() *SubnetSpec <span class="cov0" title="0">{
        for _, sn := range n.Subnets </span><span class="cov0" title="0">{
                if sn.Role == SubnetControlPlane </span><span class="cov0" title="0">{
                        return &amp;sn
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetNodeSubnet returns the cluster node subnet.
func (n *NetworkSpec) GetNodeSubnet() *SubnetSpec <span class="cov0" title="0">{
        for _, sn := range n.Subnets </span><span class="cov0" title="0">{
                if sn.Role == SubnetNode </span><span class="cov0" title="0">{
                        return &amp;sn
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// SecurityProfile specifies the Security profile settings for a
// virtual machine or virtual machine scale set.
type SecurityProfile struct {
        // This field indicates whether Host Encryption should be enabled
        // or disabled for a virtual machine or virtual machine scale
        // set. Default is disabled.
        EncryptionAtHost *bool `json:"encryptionAtHost,omitempty"`
}

// AddressRecord specifies a DNS record mapping a hostname to an IPV4 or IPv6 address.
type AddressRecord struct {
        Hostname string
        IP       string
}
</pre>
		
		<pre class="file" id="file10" style="display: none">//go:build !ignore_autogenerated_core_v1alpha3
// +build !ignore_autogenerated_core_v1alpha3

/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by conversion-gen-v0.23.1. DO NOT EDIT.

package v1alpha3

import (
        unsafe "unsafe"

        v1 "k8s.io/api/core/v1"
        resource "k8s.io/apimachinery/pkg/api/resource"
        conversion "k8s.io/apimachinery/pkg/conversion"
        runtime "k8s.io/apimachinery/pkg/runtime"
        v1beta1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        apiv1alpha3 "sigs.k8s.io/cluster-api/api/v1alpha3"
        apiv1beta1 "sigs.k8s.io/cluster-api/api/v1beta1"
        errors "sigs.k8s.io/cluster-api/errors"
)

func init() <span class="cov8" title="1">{
        localSchemeBuilder.Register(RegisterConversions)
}</span>

// RegisterConversions adds conversion functions to the given scheme.
// Public to allow building arbitrary schemes.
func RegisterConversions(s *runtime.Scheme) error <span class="cov0" title="0">{
        if err := s.AddGeneratedConversionFunc((*AddressRecord)(nil), (*v1beta1.AddressRecord)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AddressRecord_To_v1beta1_AddressRecord(a.(*AddressRecord), b.(*v1beta1.AddressRecord), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AddressRecord)(nil), (*AddressRecord)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AddressRecord_To_v1alpha3_AddressRecord(a.(*v1beta1.AddressRecord), b.(*AddressRecord), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureCluster)(nil), (*v1beta1.AzureCluster)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureCluster_To_v1beta1_AzureCluster(a.(*AzureCluster), b.(*v1beta1.AzureCluster), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureCluster)(nil), (*AzureCluster)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureCluster_To_v1alpha3_AzureCluster(a.(*v1beta1.AzureCluster), b.(*AzureCluster), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureClusterIdentity)(nil), (*v1beta1.AzureClusterIdentity)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureClusterIdentity_To_v1beta1_AzureClusterIdentity(a.(*AzureClusterIdentity), b.(*v1beta1.AzureClusterIdentity), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureClusterIdentity)(nil), (*AzureClusterIdentity)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureClusterIdentity_To_v1alpha3_AzureClusterIdentity(a.(*v1beta1.AzureClusterIdentity), b.(*AzureClusterIdentity), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureClusterIdentityList)(nil), (*v1beta1.AzureClusterIdentityList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureClusterIdentityList_To_v1beta1_AzureClusterIdentityList(a.(*AzureClusterIdentityList), b.(*v1beta1.AzureClusterIdentityList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureClusterIdentityList)(nil), (*AzureClusterIdentityList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureClusterIdentityList_To_v1alpha3_AzureClusterIdentityList(a.(*v1beta1.AzureClusterIdentityList), b.(*AzureClusterIdentityList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureClusterIdentityStatus)(nil), (*v1beta1.AzureClusterIdentityStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureClusterIdentityStatus_To_v1beta1_AzureClusterIdentityStatus(a.(*AzureClusterIdentityStatus), b.(*v1beta1.AzureClusterIdentityStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureClusterIdentityStatus)(nil), (*AzureClusterIdentityStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureClusterIdentityStatus_To_v1alpha3_AzureClusterIdentityStatus(a.(*v1beta1.AzureClusterIdentityStatus), b.(*AzureClusterIdentityStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureClusterList)(nil), (*v1beta1.AzureClusterList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureClusterList_To_v1beta1_AzureClusterList(a.(*AzureClusterList), b.(*v1beta1.AzureClusterList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureClusterList)(nil), (*AzureClusterList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureClusterList_To_v1alpha3_AzureClusterList(a.(*v1beta1.AzureClusterList), b.(*AzureClusterList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureMachine)(nil), (*v1beta1.AzureMachine)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureMachine_To_v1beta1_AzureMachine(a.(*AzureMachine), b.(*v1beta1.AzureMachine), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureMachine)(nil), (*AzureMachine)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachine_To_v1alpha3_AzureMachine(a.(*v1beta1.AzureMachine), b.(*AzureMachine), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureMachineList)(nil), (*v1beta1.AzureMachineList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureMachineList_To_v1beta1_AzureMachineList(a.(*AzureMachineList), b.(*v1beta1.AzureMachineList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureMachineList)(nil), (*AzureMachineList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachineList_To_v1alpha3_AzureMachineList(a.(*v1beta1.AzureMachineList), b.(*AzureMachineList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureMachineTemplate)(nil), (*v1beta1.AzureMachineTemplate)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureMachineTemplate_To_v1beta1_AzureMachineTemplate(a.(*AzureMachineTemplate), b.(*v1beta1.AzureMachineTemplate), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureMachineTemplate)(nil), (*AzureMachineTemplate)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachineTemplate_To_v1alpha3_AzureMachineTemplate(a.(*v1beta1.AzureMachineTemplate), b.(*AzureMachineTemplate), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureMachineTemplateList)(nil), (*v1beta1.AzureMachineTemplateList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureMachineTemplateList_To_v1beta1_AzureMachineTemplateList(a.(*AzureMachineTemplateList), b.(*v1beta1.AzureMachineTemplateList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureMachineTemplateList)(nil), (*AzureMachineTemplateList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachineTemplateList_To_v1alpha3_AzureMachineTemplateList(a.(*v1beta1.AzureMachineTemplateList), b.(*AzureMachineTemplateList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureMachineTemplateResource)(nil), (*v1beta1.AzureMachineTemplateResource)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureMachineTemplateResource_To_v1beta1_AzureMachineTemplateResource(a.(*AzureMachineTemplateResource), b.(*v1beta1.AzureMachineTemplateResource), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureMachineTemplateSpec)(nil), (*v1beta1.AzureMachineTemplateSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureMachineTemplateSpec_To_v1beta1_AzureMachineTemplateSpec(a.(*AzureMachineTemplateSpec), b.(*v1beta1.AzureMachineTemplateSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureMachineTemplateSpec)(nil), (*AzureMachineTemplateSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachineTemplateSpec_To_v1alpha3_AzureMachineTemplateSpec(a.(*v1beta1.AzureMachineTemplateSpec), b.(*AzureMachineTemplateSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureSharedGalleryImage)(nil), (*v1beta1.AzureSharedGalleryImage)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureSharedGalleryImage_To_v1beta1_AzureSharedGalleryImage(a.(*AzureSharedGalleryImage), b.(*v1beta1.AzureSharedGalleryImage), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*BuildParams)(nil), (*v1beta1.BuildParams)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_BuildParams_To_v1beta1_BuildParams(a.(*BuildParams), b.(*v1beta1.BuildParams), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.BuildParams)(nil), (*BuildParams)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_BuildParams_To_v1alpha3_BuildParams(a.(*v1beta1.BuildParams), b.(*BuildParams), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*DataDisk)(nil), (*v1beta1.DataDisk)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_DataDisk_To_v1beta1_DataDisk(a.(*DataDisk), b.(*v1beta1.DataDisk), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.DataDisk)(nil), (*DataDisk)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_DataDisk_To_v1alpha3_DataDisk(a.(*v1beta1.DataDisk), b.(*DataDisk), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*DiffDiskSettings)(nil), (*v1beta1.DiffDiskSettings)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_DiffDiskSettings_To_v1beta1_DiffDiskSettings(a.(*DiffDiskSettings), b.(*v1beta1.DiffDiskSettings), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.DiffDiskSettings)(nil), (*DiffDiskSettings)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_DiffDiskSettings_To_v1alpha3_DiffDiskSettings(a.(*v1beta1.DiffDiskSettings), b.(*DiffDiskSettings), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*DiskEncryptionSetParameters)(nil), (*v1beta1.DiskEncryptionSetParameters)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_DiskEncryptionSetParameters_To_v1beta1_DiskEncryptionSetParameters(a.(*DiskEncryptionSetParameters), b.(*v1beta1.DiskEncryptionSetParameters), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.DiskEncryptionSetParameters)(nil), (*DiskEncryptionSetParameters)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_DiskEncryptionSetParameters_To_v1alpha3_DiskEncryptionSetParameters(a.(*v1beta1.DiskEncryptionSetParameters), b.(*DiskEncryptionSetParameters), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*Image)(nil), (*v1beta1.Image)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_Image_To_v1beta1_Image(a.(*Image), b.(*v1beta1.Image), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*PublicIPSpec)(nil), (*v1beta1.PublicIPSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_PublicIPSpec_To_v1beta1_PublicIPSpec(a.(*PublicIPSpec), b.(*v1beta1.PublicIPSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*RouteTable)(nil), (*v1beta1.RouteTable)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_RouteTable_To_v1beta1_RouteTable(a.(*RouteTable), b.(*v1beta1.RouteTable), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.RouteTable)(nil), (*RouteTable)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_RouteTable_To_v1alpha3_RouteTable(a.(*v1beta1.RouteTable), b.(*RouteTable), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*SecurityProfile)(nil), (*v1beta1.SecurityProfile)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_SecurityProfile_To_v1beta1_SecurityProfile(a.(*SecurityProfile), b.(*v1beta1.SecurityProfile), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.SecurityProfile)(nil), (*SecurityProfile)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_SecurityProfile_To_v1alpha3_SecurityProfile(a.(*v1beta1.SecurityProfile), b.(*SecurityProfile), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*SpotVMOptions)(nil), (*v1beta1.SpotVMOptions)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_SpotVMOptions_To_v1beta1_SpotVMOptions(a.(*SpotVMOptions), b.(*v1beta1.SpotVMOptions), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.SpotVMOptions)(nil), (*SpotVMOptions)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_SpotVMOptions_To_v1alpha3_SpotVMOptions(a.(*v1beta1.SpotVMOptions), b.(*SpotVMOptions), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*UserAssignedIdentity)(nil), (*v1beta1.UserAssignedIdentity)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_UserAssignedIdentity_To_v1beta1_UserAssignedIdentity(a.(*UserAssignedIdentity), b.(*v1beta1.UserAssignedIdentity), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.UserAssignedIdentity)(nil), (*UserAssignedIdentity)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_UserAssignedIdentity_To_v1alpha3_UserAssignedIdentity(a.(*v1beta1.UserAssignedIdentity), b.(*UserAssignedIdentity), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*AzureClusterIdentitySpec)(nil), (*v1beta1.AzureClusterIdentitySpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureClusterIdentitySpec_To_v1beta1_AzureClusterIdentitySpec(a.(*AzureClusterIdentitySpec), b.(*v1beta1.AzureClusterIdentitySpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*AzureClusterSpec)(nil), (*v1beta1.AzureClusterSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureClusterSpec_To_v1beta1_AzureClusterSpec(a.(*AzureClusterSpec), b.(*v1beta1.AzureClusterSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*AzureClusterStatus)(nil), (*v1beta1.AzureClusterStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureClusterStatus_To_v1beta1_AzureClusterStatus(a.(*AzureClusterStatus), b.(*v1beta1.AzureClusterStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*AzureMachineSpec)(nil), (*v1beta1.AzureMachineSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureMachineSpec_To_v1beta1_AzureMachineSpec(a.(*AzureMachineSpec), b.(*v1beta1.AzureMachineSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*AzureMachineStatus)(nil), (*v1beta1.AzureMachineStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureMachineStatus_To_v1beta1_AzureMachineStatus(a.(*AzureMachineStatus), b.(*v1beta1.AzureMachineStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*AzureMarketplaceImage)(nil), (*v1beta1.AzureMarketplaceImage)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureMarketplaceImage_To_v1beta1_AzureMarketplaceImage(a.(*AzureMarketplaceImage), b.(*v1beta1.AzureMarketplaceImage), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*FrontendIP)(nil), (*v1beta1.FrontendIP)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_FrontendIP_To_v1beta1_FrontendIP(a.(*FrontendIP), b.(*v1beta1.FrontendIP), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*Future)(nil), (*v1beta1.Future)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_Future_To_v1beta1_Future(a.(*Future), b.(*v1beta1.Future), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*IngressRule)(nil), (*v1beta1.SecurityRule)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_IngressRule_To_v1beta1_SecurityRule(a.(*IngressRule), b.(*v1beta1.SecurityRule), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*LoadBalancerSpec)(nil), (*v1beta1.LoadBalancerSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_LoadBalancerSpec_To_v1beta1_LoadBalancerSpec(a.(*LoadBalancerSpec), b.(*v1beta1.LoadBalancerSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*ManagedDisk)(nil), (*v1beta1.ManagedDiskParameters)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_ManagedDisk_To_v1beta1_ManagedDiskParameters(a.(*ManagedDisk), b.(*v1beta1.ManagedDiskParameters), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*NetworkSpec)(nil), (*v1beta1.NetworkSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_NetworkSpec_To_v1beta1_NetworkSpec(a.(*NetworkSpec), b.(*v1beta1.NetworkSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*OSDisk)(nil), (*v1beta1.OSDisk)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_OSDisk_To_v1beta1_OSDisk(a.(*OSDisk), b.(*v1beta1.OSDisk), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*SecurityGroup)(nil), (*v1beta1.SecurityGroup)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_SecurityGroup_To_v1beta1_SecurityGroup(a.(*SecurityGroup), b.(*v1beta1.SecurityGroup), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*SubnetSpec)(nil), (*v1beta1.SubnetSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_SubnetSpec_To_v1beta1_SubnetSpec(a.(*SubnetSpec), b.(*v1beta1.SubnetSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*VnetSpec)(nil), (*v1beta1.VnetSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_VnetSpec_To_v1beta1_VnetSpec(a.(*VnetSpec), b.(*v1beta1.VnetSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.AzureClusterIdentitySpec)(nil), (*AzureClusterIdentitySpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureClusterIdentitySpec_To_v1alpha3_AzureClusterIdentitySpec(a.(*v1beta1.AzureClusterIdentitySpec), b.(*AzureClusterIdentitySpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.AzureClusterSpec)(nil), (*AzureClusterSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureClusterSpec_To_v1alpha3_AzureClusterSpec(a.(*v1beta1.AzureClusterSpec), b.(*AzureClusterSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.AzureClusterStatus)(nil), (*AzureClusterStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureClusterStatus_To_v1alpha3_AzureClusterStatus(a.(*v1beta1.AzureClusterStatus), b.(*AzureClusterStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.AzureMachineSpec)(nil), (*AzureMachineSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachineSpec_To_v1alpha3_AzureMachineSpec(a.(*v1beta1.AzureMachineSpec), b.(*AzureMachineSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.AzureMachineStatus)(nil), (*AzureMachineStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachineStatus_To_v1alpha3_AzureMachineStatus(a.(*v1beta1.AzureMachineStatus), b.(*AzureMachineStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.AzureMachineTemplateResource)(nil), (*AzureMachineTemplateResource)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachineTemplateResource_To_v1alpha3_AzureMachineTemplateResource(a.(*v1beta1.AzureMachineTemplateResource), b.(*AzureMachineTemplateResource), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.AzureMarketplaceImage)(nil), (*AzureMarketplaceImage)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMarketplaceImage_To_v1alpha3_AzureMarketplaceImage(a.(*v1beta1.AzureMarketplaceImage), b.(*AzureMarketplaceImage), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.AzureSharedGalleryImage)(nil), (*AzureSharedGalleryImage)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureSharedGalleryImage_To_v1alpha3_AzureSharedGalleryImage(a.(*v1beta1.AzureSharedGalleryImage), b.(*AzureSharedGalleryImage), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.FrontendIP)(nil), (*FrontendIP)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_FrontendIP_To_v1alpha3_FrontendIP(a.(*v1beta1.FrontendIP), b.(*FrontendIP), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.Future)(nil), (*Future)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_Future_To_v1alpha3_Future(a.(*v1beta1.Future), b.(*Future), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.Image)(nil), (*Image)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_Image_To_v1alpha3_Image(a.(*v1beta1.Image), b.(*Image), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.LoadBalancerSpec)(nil), (*LoadBalancerSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_LoadBalancerSpec_To_v1alpha3_LoadBalancerSpec(a.(*v1beta1.LoadBalancerSpec), b.(*LoadBalancerSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.ManagedDiskParameters)(nil), (*ManagedDisk)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_ManagedDiskParameters_To_v1alpha3_ManagedDisk(a.(*v1beta1.ManagedDiskParameters), b.(*ManagedDisk), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.NetworkSpec)(nil), (*NetworkSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_NetworkSpec_To_v1alpha3_NetworkSpec(a.(*v1beta1.NetworkSpec), b.(*NetworkSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.OSDisk)(nil), (*OSDisk)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_OSDisk_To_v1alpha3_OSDisk(a.(*v1beta1.OSDisk), b.(*OSDisk), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.PublicIPSpec)(nil), (*PublicIPSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_PublicIPSpec_To_v1alpha3_PublicIPSpec(a.(*v1beta1.PublicIPSpec), b.(*PublicIPSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.SecurityGroup)(nil), (*SecurityGroup)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_SecurityGroup_To_v1alpha3_SecurityGroup(a.(*v1beta1.SecurityGroup), b.(*SecurityGroup), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.SecurityRule)(nil), (*IngressRule)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_SecurityRule_To_v1alpha3_IngressRule(a.(*v1beta1.SecurityRule), b.(*IngressRule), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.SubnetSpec)(nil), (*SubnetSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_SubnetSpec_To_v1alpha3_SubnetSpec(a.(*v1beta1.SubnetSpec), b.(*SubnetSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.VnetSpec)(nil), (*VnetSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_VnetSpec_To_v1alpha3_VnetSpec(a.(*v1beta1.VnetSpec), b.(*VnetSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func autoConvert_v1alpha3_AddressRecord_To_v1beta1_AddressRecord(in *AddressRecord, out *v1beta1.AddressRecord, s conversion.Scope) error <span class="cov0" title="0">{
        out.Hostname = in.Hostname
        out.IP = in.IP
        return nil
}</span>

// Convert_v1alpha3_AddressRecord_To_v1beta1_AddressRecord is an autogenerated conversion function.
func Convert_v1alpha3_AddressRecord_To_v1beta1_AddressRecord(in *AddressRecord, out *v1beta1.AddressRecord, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha3_AddressRecord_To_v1beta1_AddressRecord(in, out, s)
}</span>

func autoConvert_v1beta1_AddressRecord_To_v1alpha3_AddressRecord(in *v1beta1.AddressRecord, out *AddressRecord, s conversion.Scope) error <span class="cov0" title="0">{
        out.Hostname = in.Hostname
        out.IP = in.IP
        return nil
}</span>

// Convert_v1beta1_AddressRecord_To_v1alpha3_AddressRecord is an autogenerated conversion function.
func Convert_v1beta1_AddressRecord_To_v1alpha3_AddressRecord(in *v1beta1.AddressRecord, out *AddressRecord, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_AddressRecord_To_v1alpha3_AddressRecord(in, out, s)
}</span>

func autoConvert_v1alpha3_AzureCluster_To_v1beta1_AzureCluster(in *AzureCluster, out *v1beta1.AzureCluster, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1alpha3_AzureClusterSpec_To_v1beta1_AzureClusterSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1alpha3_AzureClusterStatus_To_v1beta1_AzureClusterStatus(&amp;in.Status, &amp;out.Status, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha3_AzureCluster_To_v1beta1_AzureCluster is an autogenerated conversion function.
func Convert_v1alpha3_AzureCluster_To_v1beta1_AzureCluster(in *AzureCluster, out *v1beta1.AzureCluster, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha3_AzureCluster_To_v1beta1_AzureCluster(in, out, s)
}</span>

func autoConvert_v1beta1_AzureCluster_To_v1alpha3_AzureCluster(in *v1beta1.AzureCluster, out *AzureCluster, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1beta1_AzureClusterSpec_To_v1alpha3_AzureClusterSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1beta1_AzureClusterStatus_To_v1alpha3_AzureClusterStatus(&amp;in.Status, &amp;out.Status, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1beta1_AzureCluster_To_v1alpha3_AzureCluster is an autogenerated conversion function.
func Convert_v1beta1_AzureCluster_To_v1alpha3_AzureCluster(in *v1beta1.AzureCluster, out *AzureCluster, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureCluster_To_v1alpha3_AzureCluster(in, out, s)
}</span>

func autoConvert_v1alpha3_AzureClusterIdentity_To_v1beta1_AzureClusterIdentity(in *AzureClusterIdentity, out *v1beta1.AzureClusterIdentity, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1alpha3_AzureClusterIdentitySpec_To_v1beta1_AzureClusterIdentitySpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1alpha3_AzureClusterIdentityStatus_To_v1beta1_AzureClusterIdentityStatus(&amp;in.Status, &amp;out.Status, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha3_AzureClusterIdentity_To_v1beta1_AzureClusterIdentity is an autogenerated conversion function.
func Convert_v1alpha3_AzureClusterIdentity_To_v1beta1_AzureClusterIdentity(in *AzureClusterIdentity, out *v1beta1.AzureClusterIdentity, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha3_AzureClusterIdentity_To_v1beta1_AzureClusterIdentity(in, out, s)
}</span>

func autoConvert_v1beta1_AzureClusterIdentity_To_v1alpha3_AzureClusterIdentity(in *v1beta1.AzureClusterIdentity, out *AzureClusterIdentity, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1beta1_AzureClusterIdentitySpec_To_v1alpha3_AzureClusterIdentitySpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1beta1_AzureClusterIdentityStatus_To_v1alpha3_AzureClusterIdentityStatus(&amp;in.Status, &amp;out.Status, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1beta1_AzureClusterIdentity_To_v1alpha3_AzureClusterIdentity is an autogenerated conversion function.
func Convert_v1beta1_AzureClusterIdentity_To_v1alpha3_AzureClusterIdentity(in *v1beta1.AzureClusterIdentity, out *AzureClusterIdentity, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureClusterIdentity_To_v1alpha3_AzureClusterIdentity(in, out, s)
}</span>

func autoConvert_v1alpha3_AzureClusterIdentityList_To_v1beta1_AzureClusterIdentityList(in *AzureClusterIdentityList, out *v1beta1.AzureClusterIdentityList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]v1beta1.AzureClusterIdentity, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1alpha3_AzureClusterIdentity_To_v1beta1_AzureClusterIdentity(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1alpha3_AzureClusterIdentityList_To_v1beta1_AzureClusterIdentityList is an autogenerated conversion function.
func Convert_v1alpha3_AzureClusterIdentityList_To_v1beta1_AzureClusterIdentityList(in *AzureClusterIdentityList, out *v1beta1.AzureClusterIdentityList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha3_AzureClusterIdentityList_To_v1beta1_AzureClusterIdentityList(in, out, s)
}</span>

func autoConvert_v1beta1_AzureClusterIdentityList_To_v1alpha3_AzureClusterIdentityList(in *v1beta1.AzureClusterIdentityList, out *AzureClusterIdentityList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureClusterIdentity, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1beta1_AzureClusterIdentity_To_v1alpha3_AzureClusterIdentity(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1beta1_AzureClusterIdentityList_To_v1alpha3_AzureClusterIdentityList is an autogenerated conversion function.
func Convert_v1beta1_AzureClusterIdentityList_To_v1alpha3_AzureClusterIdentityList(in *v1beta1.AzureClusterIdentityList, out *AzureClusterIdentityList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_AzureClusterIdentityList_To_v1alpha3_AzureClusterIdentityList(in, out, s)
}</span>

func autoConvert_v1alpha3_AzureClusterIdentitySpec_To_v1beta1_AzureClusterIdentitySpec(in *AzureClusterIdentitySpec, out *v1beta1.AzureClusterIdentitySpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.Type = v1beta1.IdentityType(in.Type)
        out.ResourceID = in.ResourceID
        out.ClientID = in.ClientID
        out.ClientSecret = in.ClientSecret
        out.TenantID = in.TenantID
        // WARNING: in.AllowedNamespaces requires manual conversion: inconvertible types ([]string vs *sigs.k8s.io/cluster-api-provider-azure/api/v1beta1.AllowedNamespaces)
        return nil
}</span>

func autoConvert_v1beta1_AzureClusterIdentitySpec_To_v1alpha3_AzureClusterIdentitySpec(in *v1beta1.AzureClusterIdentitySpec, out *AzureClusterIdentitySpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.Type = IdentityType(in.Type)
        out.ResourceID = in.ResourceID
        out.ClientID = in.ClientID
        out.ClientSecret = in.ClientSecret
        out.TenantID = in.TenantID
        // WARNING: in.AllowedNamespaces requires manual conversion: inconvertible types (*sigs.k8s.io/cluster-api-provider-azure/api/v1beta1.AllowedNamespaces vs []string)
        return nil
}</span>

func autoConvert_v1alpha3_AzureClusterIdentityStatus_To_v1beta1_AzureClusterIdentityStatus(in *AzureClusterIdentityStatus, out *v1beta1.AzureClusterIdentityStatus, s conversion.Scope) error <span class="cov8" title="1">{
        if in.Conditions != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make(apiv1beta1.Conditions, len(*in))
                for i := range *in </span><span class="cov8" title="1">{
                        if err := apiv1alpha3.Convert_v1alpha3_Condition_To_v1beta1_Condition(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                out.Conditions = nil
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha3_AzureClusterIdentityStatus_To_v1beta1_AzureClusterIdentityStatus is an autogenerated conversion function.
func Convert_v1alpha3_AzureClusterIdentityStatus_To_v1beta1_AzureClusterIdentityStatus(in *AzureClusterIdentityStatus, out *v1beta1.AzureClusterIdentityStatus, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha3_AzureClusterIdentityStatus_To_v1beta1_AzureClusterIdentityStatus(in, out, s)
}</span>

func autoConvert_v1beta1_AzureClusterIdentityStatus_To_v1alpha3_AzureClusterIdentityStatus(in *v1beta1.AzureClusterIdentityStatus, out *AzureClusterIdentityStatus, s conversion.Scope) error <span class="cov8" title="1">{
        if in.Conditions != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make(apiv1alpha3.Conditions, len(*in))
                for i := range *in </span><span class="cov8" title="1">{
                        if err := apiv1alpha3.Convert_v1beta1_Condition_To_v1alpha3_Condition(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                out.Conditions = nil
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1beta1_AzureClusterIdentityStatus_To_v1alpha3_AzureClusterIdentityStatus is an autogenerated conversion function.
func Convert_v1beta1_AzureClusterIdentityStatus_To_v1alpha3_AzureClusterIdentityStatus(in *v1beta1.AzureClusterIdentityStatus, out *AzureClusterIdentityStatus, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureClusterIdentityStatus_To_v1alpha3_AzureClusterIdentityStatus(in, out, s)
}</span>

func autoConvert_v1alpha3_AzureClusterList_To_v1beta1_AzureClusterList(in *AzureClusterList, out *v1beta1.AzureClusterList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]v1beta1.AzureCluster, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1alpha3_AzureCluster_To_v1beta1_AzureCluster(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1alpha3_AzureClusterList_To_v1beta1_AzureClusterList is an autogenerated conversion function.
func Convert_v1alpha3_AzureClusterList_To_v1beta1_AzureClusterList(in *AzureClusterList, out *v1beta1.AzureClusterList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha3_AzureClusterList_To_v1beta1_AzureClusterList(in, out, s)
}</span>

func autoConvert_v1beta1_AzureClusterList_To_v1alpha3_AzureClusterList(in *v1beta1.AzureClusterList, out *AzureClusterList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureCluster, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1beta1_AzureCluster_To_v1alpha3_AzureCluster(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1beta1_AzureClusterList_To_v1alpha3_AzureClusterList is an autogenerated conversion function.
func Convert_v1beta1_AzureClusterList_To_v1alpha3_AzureClusterList(in *v1beta1.AzureClusterList, out *AzureClusterList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_AzureClusterList_To_v1alpha3_AzureClusterList(in, out, s)
}</span>

func autoConvert_v1alpha3_AzureClusterSpec_To_v1beta1_AzureClusterSpec(in *AzureClusterSpec, out *v1beta1.AzureClusterSpec, s conversion.Scope) error <span class="cov8" title="1">{
        if err := Convert_v1alpha3_NetworkSpec_To_v1beta1_NetworkSpec(&amp;in.NetworkSpec, &amp;out.NetworkSpec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">out.ResourceGroup = in.ResourceGroup
        // WARNING: in.SubscriptionID requires manual conversion: does not exist in peer-type
        // WARNING: in.Location requires manual conversion: does not exist in peer-type
        if err := apiv1alpha3.Convert_v1alpha3_APIEndpoint_To_v1beta1_APIEndpoint(&amp;in.ControlPlaneEndpoint, &amp;out.ControlPlaneEndpoint, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // WARNING: in.AdditionalTags requires manual conversion: does not exist in peer-type
        // WARNING: in.IdentityRef requires manual conversion: does not exist in peer-type
        <span class="cov8" title="1">return nil</span>
}

func autoConvert_v1beta1_AzureClusterSpec_To_v1alpha3_AzureClusterSpec(in *v1beta1.AzureClusterSpec, out *AzureClusterSpec, s conversion.Scope) error <span class="cov8" title="1">{
        // WARNING: in.AzureClusterClassSpec requires manual conversion: does not exist in peer-type
        if err := Convert_v1beta1_NetworkSpec_To_v1alpha3_NetworkSpec(&amp;in.NetworkSpec, &amp;out.NetworkSpec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">out.ResourceGroup = in.ResourceGroup
        // WARNING: in.BastionSpec requires manual conversion: does not exist in peer-type
        if err := apiv1alpha3.Convert_v1beta1_APIEndpoint_To_v1alpha3_APIEndpoint(&amp;in.ControlPlaneEndpoint, &amp;out.ControlPlaneEndpoint, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func autoConvert_v1alpha3_AzureClusterStatus_To_v1beta1_AzureClusterStatus(in *AzureClusterStatus, out *v1beta1.AzureClusterStatus, s conversion.Scope) error <span class="cov8" title="1">{
        if in.FailureDomains != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.FailureDomains, &amp;out.FailureDomains
                *out = make(apiv1beta1.FailureDomains, len(*in))
                for key, val := range *in </span><span class="cov8" title="1">{
                        newVal := new(apiv1beta1.FailureDomainSpec)
                        if err := apiv1alpha3.Convert_v1alpha3_FailureDomainSpec_To_v1beta1_FailureDomainSpec(&amp;val, newVal, s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">(*out)[key] = *newVal</span>
                }
        } else<span class="cov8" title="1"> {
                out.FailureDomains = nil
        }</span>
        <span class="cov8" title="1">out.Ready = in.Ready
        if in.Conditions != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make(apiv1beta1.Conditions, len(*in))
                for i := range *in </span><span class="cov8" title="1">{
                        if err := apiv1alpha3.Convert_v1alpha3_Condition_To_v1beta1_Condition(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                out.Conditions = nil
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func autoConvert_v1beta1_AzureClusterStatus_To_v1alpha3_AzureClusterStatus(in *v1beta1.AzureClusterStatus, out *AzureClusterStatus, s conversion.Scope) error <span class="cov8" title="1">{
        if in.FailureDomains != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.FailureDomains, &amp;out.FailureDomains
                *out = make(apiv1alpha3.FailureDomains, len(*in))
                for key, val := range *in </span><span class="cov8" title="1">{
                        newVal := new(apiv1alpha3.FailureDomainSpec)
                        if err := apiv1alpha3.Convert_v1beta1_FailureDomainSpec_To_v1alpha3_FailureDomainSpec(&amp;val, newVal, s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">(*out)[key] = *newVal</span>
                }
        } else<span class="cov8" title="1"> {
                out.FailureDomains = nil
        }</span>
        <span class="cov8" title="1">out.Ready = in.Ready
        if in.Conditions != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make(apiv1alpha3.Conditions, len(*in))
                for i := range *in </span><span class="cov8" title="1">{
                        if err := apiv1alpha3.Convert_v1beta1_Condition_To_v1alpha3_Condition(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                out.Conditions = nil
        }</span>
        // WARNING: in.LongRunningOperationStates requires manual conversion: does not exist in peer-type
        <span class="cov8" title="1">return nil</span>
}

func autoConvert_v1alpha3_AzureMachine_To_v1beta1_AzureMachine(in *AzureMachine, out *v1beta1.AzureMachine, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1alpha3_AzureMachineSpec_To_v1beta1_AzureMachineSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1alpha3_AzureMachineStatus_To_v1beta1_AzureMachineStatus(&amp;in.Status, &amp;out.Status, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha3_AzureMachine_To_v1beta1_AzureMachine is an autogenerated conversion function.
func Convert_v1alpha3_AzureMachine_To_v1beta1_AzureMachine(in *AzureMachine, out *v1beta1.AzureMachine, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha3_AzureMachine_To_v1beta1_AzureMachine(in, out, s)
}</span>

func autoConvert_v1beta1_AzureMachine_To_v1alpha3_AzureMachine(in *v1beta1.AzureMachine, out *AzureMachine, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1beta1_AzureMachineSpec_To_v1alpha3_AzureMachineSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1beta1_AzureMachineStatus_To_v1alpha3_AzureMachineStatus(&amp;in.Status, &amp;out.Status, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1beta1_AzureMachine_To_v1alpha3_AzureMachine is an autogenerated conversion function.
func Convert_v1beta1_AzureMachine_To_v1alpha3_AzureMachine(in *v1beta1.AzureMachine, out *AzureMachine, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureMachine_To_v1alpha3_AzureMachine(in, out, s)
}</span>

func autoConvert_v1alpha3_AzureMachineList_To_v1beta1_AzureMachineList(in *AzureMachineList, out *v1beta1.AzureMachineList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]v1beta1.AzureMachine, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1alpha3_AzureMachine_To_v1beta1_AzureMachine(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1alpha3_AzureMachineList_To_v1beta1_AzureMachineList is an autogenerated conversion function.
func Convert_v1alpha3_AzureMachineList_To_v1beta1_AzureMachineList(in *AzureMachineList, out *v1beta1.AzureMachineList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha3_AzureMachineList_To_v1beta1_AzureMachineList(in, out, s)
}</span>

func autoConvert_v1beta1_AzureMachineList_To_v1alpha3_AzureMachineList(in *v1beta1.AzureMachineList, out *AzureMachineList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureMachine, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1beta1_AzureMachine_To_v1alpha3_AzureMachine(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1beta1_AzureMachineList_To_v1alpha3_AzureMachineList is an autogenerated conversion function.
func Convert_v1beta1_AzureMachineList_To_v1alpha3_AzureMachineList(in *v1beta1.AzureMachineList, out *AzureMachineList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_AzureMachineList_To_v1alpha3_AzureMachineList(in, out, s)
}</span>

func autoConvert_v1alpha3_AzureMachineSpec_To_v1beta1_AzureMachineSpec(in *AzureMachineSpec, out *v1beta1.AzureMachineSpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.ProviderID = (*string)(unsafe.Pointer(in.ProviderID))
        out.VMSize = in.VMSize
        out.FailureDomain = (*string)(unsafe.Pointer(in.FailureDomain))
        // WARNING: in.AvailabilityZone requires manual conversion: does not exist in peer-type
        if in.Image != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Image, &amp;out.Image
                *out = new(v1beta1.Image)
                if err := Convert_v1alpha3_Image_To_v1beta1_Image(*in, *out, s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                out.Image = nil
        }</span>
        <span class="cov8" title="1">out.Identity = v1beta1.VMIdentity(in.Identity)
        out.UserAssignedIdentities = *(*[]v1beta1.UserAssignedIdentity)(unsafe.Pointer(&amp;in.UserAssignedIdentities))
        out.RoleAssignmentName = in.RoleAssignmentName
        if err := Convert_v1alpha3_OSDisk_To_v1beta1_OSDisk(&amp;in.OSDisk, &amp;out.OSDisk, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if in.DataDisks != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.DataDisks, &amp;out.DataDisks
                *out = make([]v1beta1.DataDisk, len(*in))
                for i := range *in </span><span class="cov8" title="1">{
                        if err := Convert_v1alpha3_DataDisk_To_v1beta1_DataDisk(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                out.DataDisks = nil
        }</span>
        // WARNING: in.Location requires manual conversion: does not exist in peer-type
        <span class="cov8" title="1">out.SSHPublicKey = in.SSHPublicKey
        out.AdditionalTags = *(*v1beta1.Tags)(unsafe.Pointer(&amp;in.AdditionalTags))
        out.AllocatePublicIP = in.AllocatePublicIP
        out.EnableIPForwarding = in.EnableIPForwarding
        out.AcceleratedNetworking = (*bool)(unsafe.Pointer(in.AcceleratedNetworking))
        out.SpotVMOptions = (*v1beta1.SpotVMOptions)(unsafe.Pointer(in.SpotVMOptions))
        out.SecurityProfile = (*v1beta1.SecurityProfile)(unsafe.Pointer(in.SecurityProfile))
        return nil</span>
}

func autoConvert_v1beta1_AzureMachineSpec_To_v1alpha3_AzureMachineSpec(in *v1beta1.AzureMachineSpec, out *AzureMachineSpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.ProviderID = (*string)(unsafe.Pointer(in.ProviderID))
        out.VMSize = in.VMSize
        out.FailureDomain = (*string)(unsafe.Pointer(in.FailureDomain))
        if in.Image != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Image, &amp;out.Image
                *out = new(Image)
                if err := Convert_v1beta1_Image_To_v1alpha3_Image(*in, *out, s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                out.Image = nil
        }</span>
        <span class="cov8" title="1">out.Identity = VMIdentity(in.Identity)
        out.UserAssignedIdentities = *(*[]UserAssignedIdentity)(unsafe.Pointer(&amp;in.UserAssignedIdentities))
        out.RoleAssignmentName = in.RoleAssignmentName
        if err := Convert_v1beta1_OSDisk_To_v1alpha3_OSDisk(&amp;in.OSDisk, &amp;out.OSDisk, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if in.DataDisks != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.DataDisks, &amp;out.DataDisks
                *out = make([]DataDisk, len(*in))
                for i := range *in </span><span class="cov8" title="1">{
                        if err := Convert_v1beta1_DataDisk_To_v1alpha3_DataDisk(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                out.DataDisks = nil
        }</span>
        <span class="cov8" title="1">out.SSHPublicKey = in.SSHPublicKey
        out.AdditionalTags = *(*Tags)(unsafe.Pointer(&amp;in.AdditionalTags))
        // WARNING: in.AdditionalCapabilities requires manual conversion: does not exist in peer-type
        out.AllocatePublicIP = in.AllocatePublicIP
        out.EnableIPForwarding = in.EnableIPForwarding
        out.AcceleratedNetworking = (*bool)(unsafe.Pointer(in.AcceleratedNetworking))
        out.SpotVMOptions = (*SpotVMOptions)(unsafe.Pointer(in.SpotVMOptions))
        out.SecurityProfile = (*SecurityProfile)(unsafe.Pointer(in.SecurityProfile))
        // WARNING: in.SubnetName requires manual conversion: does not exist in peer-type
        // WARNING: in.DNSServers requires manual conversion: does not exist in peer-type
        return nil</span>
}

func autoConvert_v1alpha3_AzureMachineStatus_To_v1beta1_AzureMachineStatus(in *AzureMachineStatus, out *v1beta1.AzureMachineStatus, s conversion.Scope) error <span class="cov8" title="1">{
        out.Ready = in.Ready
        out.Addresses = *(*[]v1.NodeAddress)(unsafe.Pointer(&amp;in.Addresses))
        out.VMState = (*v1beta1.ProvisioningState)(unsafe.Pointer(in.VMState))
        out.FailureReason = (*errors.MachineStatusError)(unsafe.Pointer(in.FailureReason))
        out.FailureMessage = (*string)(unsafe.Pointer(in.FailureMessage))
        if in.Conditions != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make(apiv1beta1.Conditions, len(*in))
                for i := range *in </span><span class="cov8" title="1">{
                        if err := apiv1alpha3.Convert_v1alpha3_Condition_To_v1beta1_Condition(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                out.Conditions = nil
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func autoConvert_v1beta1_AzureMachineStatus_To_v1alpha3_AzureMachineStatus(in *v1beta1.AzureMachineStatus, out *AzureMachineStatus, s conversion.Scope) error <span class="cov8" title="1">{
        out.Ready = in.Ready
        out.Addresses = *(*[]v1.NodeAddress)(unsafe.Pointer(&amp;in.Addresses))
        out.VMState = (*VMState)(unsafe.Pointer(in.VMState))
        out.FailureReason = (*errors.MachineStatusError)(unsafe.Pointer(in.FailureReason))
        out.FailureMessage = (*string)(unsafe.Pointer(in.FailureMessage))
        if in.Conditions != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make(apiv1alpha3.Conditions, len(*in))
                for i := range *in </span><span class="cov8" title="1">{
                        if err := apiv1alpha3.Convert_v1beta1_Condition_To_v1alpha3_Condition(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                out.Conditions = nil
        }</span>
        // WARNING: in.LongRunningOperationStates requires manual conversion: does not exist in peer-type
        <span class="cov8" title="1">return nil</span>
}

func autoConvert_v1alpha3_AzureMachineTemplate_To_v1beta1_AzureMachineTemplate(in *AzureMachineTemplate, out *v1beta1.AzureMachineTemplate, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1alpha3_AzureMachineTemplateSpec_To_v1beta1_AzureMachineTemplateSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha3_AzureMachineTemplate_To_v1beta1_AzureMachineTemplate is an autogenerated conversion function.
func Convert_v1alpha3_AzureMachineTemplate_To_v1beta1_AzureMachineTemplate(in *AzureMachineTemplate, out *v1beta1.AzureMachineTemplate, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha3_AzureMachineTemplate_To_v1beta1_AzureMachineTemplate(in, out, s)
}</span>

func autoConvert_v1beta1_AzureMachineTemplate_To_v1alpha3_AzureMachineTemplate(in *v1beta1.AzureMachineTemplate, out *AzureMachineTemplate, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1beta1_AzureMachineTemplateSpec_To_v1alpha3_AzureMachineTemplateSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1beta1_AzureMachineTemplate_To_v1alpha3_AzureMachineTemplate is an autogenerated conversion function.
func Convert_v1beta1_AzureMachineTemplate_To_v1alpha3_AzureMachineTemplate(in *v1beta1.AzureMachineTemplate, out *AzureMachineTemplate, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureMachineTemplate_To_v1alpha3_AzureMachineTemplate(in, out, s)
}</span>

func autoConvert_v1alpha3_AzureMachineTemplateList_To_v1beta1_AzureMachineTemplateList(in *AzureMachineTemplateList, out *v1beta1.AzureMachineTemplateList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]v1beta1.AzureMachineTemplate, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1alpha3_AzureMachineTemplate_To_v1beta1_AzureMachineTemplate(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1alpha3_AzureMachineTemplateList_To_v1beta1_AzureMachineTemplateList is an autogenerated conversion function.
func Convert_v1alpha3_AzureMachineTemplateList_To_v1beta1_AzureMachineTemplateList(in *AzureMachineTemplateList, out *v1beta1.AzureMachineTemplateList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha3_AzureMachineTemplateList_To_v1beta1_AzureMachineTemplateList(in, out, s)
}</span>

func autoConvert_v1beta1_AzureMachineTemplateList_To_v1alpha3_AzureMachineTemplateList(in *v1beta1.AzureMachineTemplateList, out *AzureMachineTemplateList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureMachineTemplate, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1beta1_AzureMachineTemplate_To_v1alpha3_AzureMachineTemplate(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1beta1_AzureMachineTemplateList_To_v1alpha3_AzureMachineTemplateList is an autogenerated conversion function.
func Convert_v1beta1_AzureMachineTemplateList_To_v1alpha3_AzureMachineTemplateList(in *v1beta1.AzureMachineTemplateList, out *AzureMachineTemplateList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_AzureMachineTemplateList_To_v1alpha3_AzureMachineTemplateList(in, out, s)
}</span>

func autoConvert_v1alpha3_AzureMachineTemplateResource_To_v1beta1_AzureMachineTemplateResource(in *AzureMachineTemplateResource, out *v1beta1.AzureMachineTemplateResource, s conversion.Scope) error <span class="cov8" title="1">{
        if err := Convert_v1alpha3_AzureMachineSpec_To_v1beta1_AzureMachineSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha3_AzureMachineTemplateResource_To_v1beta1_AzureMachineTemplateResource is an autogenerated conversion function.
func Convert_v1alpha3_AzureMachineTemplateResource_To_v1beta1_AzureMachineTemplateResource(in *AzureMachineTemplateResource, out *v1beta1.AzureMachineTemplateResource, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha3_AzureMachineTemplateResource_To_v1beta1_AzureMachineTemplateResource(in, out, s)
}</span>

func autoConvert_v1beta1_AzureMachineTemplateResource_To_v1alpha3_AzureMachineTemplateResource(in *v1beta1.AzureMachineTemplateResource, out *AzureMachineTemplateResource, s conversion.Scope) error <span class="cov8" title="1">{
        // WARNING: in.ObjectMeta requires manual conversion: does not exist in peer-type
        if err := Convert_v1beta1_AzureMachineSpec_To_v1alpha3_AzureMachineSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func autoConvert_v1alpha3_AzureMachineTemplateSpec_To_v1beta1_AzureMachineTemplateSpec(in *AzureMachineTemplateSpec, out *v1beta1.AzureMachineTemplateSpec, s conversion.Scope) error <span class="cov8" title="1">{
        if err := Convert_v1alpha3_AzureMachineTemplateResource_To_v1beta1_AzureMachineTemplateResource(&amp;in.Template, &amp;out.Template, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha3_AzureMachineTemplateSpec_To_v1beta1_AzureMachineTemplateSpec is an autogenerated conversion function.
func Convert_v1alpha3_AzureMachineTemplateSpec_To_v1beta1_AzureMachineTemplateSpec(in *AzureMachineTemplateSpec, out *v1beta1.AzureMachineTemplateSpec, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha3_AzureMachineTemplateSpec_To_v1beta1_AzureMachineTemplateSpec(in, out, s)
}</span>

func autoConvert_v1beta1_AzureMachineTemplateSpec_To_v1alpha3_AzureMachineTemplateSpec(in *v1beta1.AzureMachineTemplateSpec, out *AzureMachineTemplateSpec, s conversion.Scope) error <span class="cov8" title="1">{
        if err := Convert_v1beta1_AzureMachineTemplateResource_To_v1alpha3_AzureMachineTemplateResource(&amp;in.Template, &amp;out.Template, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1beta1_AzureMachineTemplateSpec_To_v1alpha3_AzureMachineTemplateSpec is an autogenerated conversion function.
func Convert_v1beta1_AzureMachineTemplateSpec_To_v1alpha3_AzureMachineTemplateSpec(in *v1beta1.AzureMachineTemplateSpec, out *AzureMachineTemplateSpec, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureMachineTemplateSpec_To_v1alpha3_AzureMachineTemplateSpec(in, out, s)
}</span>

func autoConvert_v1alpha3_AzureMarketplaceImage_To_v1beta1_AzureMarketplaceImage(in *AzureMarketplaceImage, out *v1beta1.AzureMarketplaceImage, s conversion.Scope) error <span class="cov8" title="1">{
        // WARNING: in.Publisher requires manual conversion: does not exist in peer-type
        // WARNING: in.Offer requires manual conversion: does not exist in peer-type
        // WARNING: in.SKU requires manual conversion: does not exist in peer-type
        out.Version = in.Version
        out.ThirdPartyImage = in.ThirdPartyImage
        return nil
}</span>

func autoConvert_v1beta1_AzureMarketplaceImage_To_v1alpha3_AzureMarketplaceImage(in *v1beta1.AzureMarketplaceImage, out *AzureMarketplaceImage, s conversion.Scope) error <span class="cov8" title="1">{
        // WARNING: in.ImagePlan requires manual conversion: does not exist in peer-type
        out.Version = in.Version
        out.ThirdPartyImage = in.ThirdPartyImage
        return nil
}</span>

func autoConvert_v1alpha3_AzureSharedGalleryImage_To_v1beta1_AzureSharedGalleryImage(in *AzureSharedGalleryImage, out *v1beta1.AzureSharedGalleryImage, s conversion.Scope) error <span class="cov8" title="1">{
        out.SubscriptionID = in.SubscriptionID
        out.ResourceGroup = in.ResourceGroup
        out.Gallery = in.Gallery
        out.Name = in.Name
        out.Version = in.Version
        return nil
}</span>

// Convert_v1alpha3_AzureSharedGalleryImage_To_v1beta1_AzureSharedGalleryImage is an autogenerated conversion function.
func Convert_v1alpha3_AzureSharedGalleryImage_To_v1beta1_AzureSharedGalleryImage(in *AzureSharedGalleryImage, out *v1beta1.AzureSharedGalleryImage, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha3_AzureSharedGalleryImage_To_v1beta1_AzureSharedGalleryImage(in, out, s)
}</span>

func autoConvert_v1beta1_AzureSharedGalleryImage_To_v1alpha3_AzureSharedGalleryImage(in *v1beta1.AzureSharedGalleryImage, out *AzureSharedGalleryImage, s conversion.Scope) error <span class="cov8" title="1">{
        out.SubscriptionID = in.SubscriptionID
        out.ResourceGroup = in.ResourceGroup
        out.Gallery = in.Gallery
        out.Name = in.Name
        out.Version = in.Version
        // WARNING: in.Publisher requires manual conversion: does not exist in peer-type
        // WARNING: in.Offer requires manual conversion: does not exist in peer-type
        // WARNING: in.SKU requires manual conversion: does not exist in peer-type
        return nil
}</span>

func autoConvert_v1alpha3_BuildParams_To_v1beta1_BuildParams(in *BuildParams, out *v1beta1.BuildParams, s conversion.Scope) error <span class="cov0" title="0">{
        out.Lifecycle = v1beta1.ResourceLifecycle(in.Lifecycle)
        out.ClusterName = in.ClusterName
        out.ResourceID = in.ResourceID
        out.Name = (*string)(unsafe.Pointer(in.Name))
        out.Role = (*string)(unsafe.Pointer(in.Role))
        out.Additional = *(*v1beta1.Tags)(unsafe.Pointer(&amp;in.Additional))
        return nil
}</span>

// Convert_v1alpha3_BuildParams_To_v1beta1_BuildParams is an autogenerated conversion function.
func Convert_v1alpha3_BuildParams_To_v1beta1_BuildParams(in *BuildParams, out *v1beta1.BuildParams, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha3_BuildParams_To_v1beta1_BuildParams(in, out, s)
}</span>

func autoConvert_v1beta1_BuildParams_To_v1alpha3_BuildParams(in *v1beta1.BuildParams, out *BuildParams, s conversion.Scope) error <span class="cov0" title="0">{
        out.Lifecycle = ResourceLifecycle(in.Lifecycle)
        out.ClusterName = in.ClusterName
        out.ResourceID = in.ResourceID
        out.Name = (*string)(unsafe.Pointer(in.Name))
        out.Role = (*string)(unsafe.Pointer(in.Role))
        out.Additional = *(*Tags)(unsafe.Pointer(&amp;in.Additional))
        return nil
}</span>

// Convert_v1beta1_BuildParams_To_v1alpha3_BuildParams is an autogenerated conversion function.
func Convert_v1beta1_BuildParams_To_v1alpha3_BuildParams(in *v1beta1.BuildParams, out *BuildParams, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_BuildParams_To_v1alpha3_BuildParams(in, out, s)
}</span>

func autoConvert_v1alpha3_DataDisk_To_v1beta1_DataDisk(in *DataDisk, out *v1beta1.DataDisk, s conversion.Scope) error <span class="cov8" title="1">{
        out.NameSuffix = in.NameSuffix
        out.DiskSizeGB = in.DiskSizeGB
        if in.ManagedDisk != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.ManagedDisk, &amp;out.ManagedDisk
                *out = new(v1beta1.ManagedDiskParameters)
                if err := Convert_v1alpha3_ManagedDisk_To_v1beta1_ManagedDiskParameters(*in, *out, s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                out.ManagedDisk = nil
        }</span>
        <span class="cov8" title="1">out.Lun = (*int32)(unsafe.Pointer(in.Lun))
        out.CachingType = in.CachingType
        return nil</span>
}

// Convert_v1alpha3_DataDisk_To_v1beta1_DataDisk is an autogenerated conversion function.
func Convert_v1alpha3_DataDisk_To_v1beta1_DataDisk(in *DataDisk, out *v1beta1.DataDisk, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha3_DataDisk_To_v1beta1_DataDisk(in, out, s)
}</span>

func autoConvert_v1beta1_DataDisk_To_v1alpha3_DataDisk(in *v1beta1.DataDisk, out *DataDisk, s conversion.Scope) error <span class="cov8" title="1">{
        out.NameSuffix = in.NameSuffix
        out.DiskSizeGB = in.DiskSizeGB
        if in.ManagedDisk != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.ManagedDisk, &amp;out.ManagedDisk
                *out = new(ManagedDisk)
                if err := Convert_v1beta1_ManagedDiskParameters_To_v1alpha3_ManagedDisk(*in, *out, s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                out.ManagedDisk = nil
        }</span>
        <span class="cov8" title="1">out.Lun = (*int32)(unsafe.Pointer(in.Lun))
        out.CachingType = in.CachingType
        return nil</span>
}

// Convert_v1beta1_DataDisk_To_v1alpha3_DataDisk is an autogenerated conversion function.
func Convert_v1beta1_DataDisk_To_v1alpha3_DataDisk(in *v1beta1.DataDisk, out *DataDisk, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_DataDisk_To_v1alpha3_DataDisk(in, out, s)
}</span>

func autoConvert_v1alpha3_DiffDiskSettings_To_v1beta1_DiffDiskSettings(in *DiffDiskSettings, out *v1beta1.DiffDiskSettings, s conversion.Scope) error <span class="cov0" title="0">{
        out.Option = in.Option
        return nil
}</span>

// Convert_v1alpha3_DiffDiskSettings_To_v1beta1_DiffDiskSettings is an autogenerated conversion function.
func Convert_v1alpha3_DiffDiskSettings_To_v1beta1_DiffDiskSettings(in *DiffDiskSettings, out *v1beta1.DiffDiskSettings, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha3_DiffDiskSettings_To_v1beta1_DiffDiskSettings(in, out, s)
}</span>

func autoConvert_v1beta1_DiffDiskSettings_To_v1alpha3_DiffDiskSettings(in *v1beta1.DiffDiskSettings, out *DiffDiskSettings, s conversion.Scope) error <span class="cov0" title="0">{
        out.Option = in.Option
        return nil
}</span>

// Convert_v1beta1_DiffDiskSettings_To_v1alpha3_DiffDiskSettings is an autogenerated conversion function.
func Convert_v1beta1_DiffDiskSettings_To_v1alpha3_DiffDiskSettings(in *v1beta1.DiffDiskSettings, out *DiffDiskSettings, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_DiffDiskSettings_To_v1alpha3_DiffDiskSettings(in, out, s)
}</span>

func autoConvert_v1alpha3_DiskEncryptionSetParameters_To_v1beta1_DiskEncryptionSetParameters(in *DiskEncryptionSetParameters, out *v1beta1.DiskEncryptionSetParameters, s conversion.Scope) error <span class="cov0" title="0">{
        out.ID = in.ID
        return nil
}</span>

// Convert_v1alpha3_DiskEncryptionSetParameters_To_v1beta1_DiskEncryptionSetParameters is an autogenerated conversion function.
func Convert_v1alpha3_DiskEncryptionSetParameters_To_v1beta1_DiskEncryptionSetParameters(in *DiskEncryptionSetParameters, out *v1beta1.DiskEncryptionSetParameters, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha3_DiskEncryptionSetParameters_To_v1beta1_DiskEncryptionSetParameters(in, out, s)
}</span>

func autoConvert_v1beta1_DiskEncryptionSetParameters_To_v1alpha3_DiskEncryptionSetParameters(in *v1beta1.DiskEncryptionSetParameters, out *DiskEncryptionSetParameters, s conversion.Scope) error <span class="cov0" title="0">{
        out.ID = in.ID
        return nil
}</span>

// Convert_v1beta1_DiskEncryptionSetParameters_To_v1alpha3_DiskEncryptionSetParameters is an autogenerated conversion function.
func Convert_v1beta1_DiskEncryptionSetParameters_To_v1alpha3_DiskEncryptionSetParameters(in *v1beta1.DiskEncryptionSetParameters, out *DiskEncryptionSetParameters, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_DiskEncryptionSetParameters_To_v1alpha3_DiskEncryptionSetParameters(in, out, s)
}</span>

func autoConvert_v1alpha3_FrontendIP_To_v1beta1_FrontendIP(in *FrontendIP, out *v1beta1.FrontendIP, s conversion.Scope) error <span class="cov8" title="1">{
        out.Name = in.Name
        // WARNING: in.PrivateIPAddress requires manual conversion: does not exist in peer-type
        if in.PublicIP != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.PublicIP, &amp;out.PublicIP
                *out = new(v1beta1.PublicIPSpec)
                if err := Convert_v1alpha3_PublicIPSpec_To_v1beta1_PublicIPSpec(*in, *out, s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                out.PublicIP = nil
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func autoConvert_v1beta1_FrontendIP_To_v1alpha3_FrontendIP(in *v1beta1.FrontendIP, out *FrontendIP, s conversion.Scope) error <span class="cov8" title="1">{
        out.Name = in.Name
        if in.PublicIP != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.PublicIP, &amp;out.PublicIP
                *out = new(PublicIPSpec)
                if err := Convert_v1beta1_PublicIPSpec_To_v1alpha3_PublicIPSpec(*in, *out, s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                out.PublicIP = nil
        }</span>
        // WARNING: in.FrontendIPClass requires manual conversion: does not exist in peer-type
        <span class="cov8" title="1">return nil</span>
}

func autoConvert_v1alpha3_Future_To_v1beta1_Future(in *Future, out *v1beta1.Future, s conversion.Scope) error <span class="cov0" title="0">{
        out.Type = in.Type
        out.ResourceGroup = in.ResourceGroup
        out.Name = in.Name
        // WARNING: in.FutureData requires manual conversion: does not exist in peer-type
        return nil
}</span>

func autoConvert_v1beta1_Future_To_v1alpha3_Future(in *v1beta1.Future, out *Future, s conversion.Scope) error <span class="cov0" title="0">{
        out.Type = in.Type
        out.ResourceGroup = in.ResourceGroup
        // WARNING: in.ServiceName requires manual conversion: does not exist in peer-type
        out.Name = in.Name
        // WARNING: in.Data requires manual conversion: does not exist in peer-type
        return nil
}</span>

func autoConvert_v1alpha3_Image_To_v1beta1_Image(in *Image, out *v1beta1.Image, s conversion.Scope) error <span class="cov8" title="1">{
        out.ID = (*string)(unsafe.Pointer(in.ID))
        if in.SharedGallery != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.SharedGallery, &amp;out.SharedGallery
                *out = new(v1beta1.AzureSharedGalleryImage)
                if err := Convert_v1alpha3_AzureSharedGalleryImage_To_v1beta1_AzureSharedGalleryImage(*in, *out, s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                out.SharedGallery = nil
        }</span>
        <span class="cov8" title="1">if in.Marketplace != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Marketplace, &amp;out.Marketplace
                *out = new(v1beta1.AzureMarketplaceImage)
                if err := Convert_v1alpha3_AzureMarketplaceImage_To_v1beta1_AzureMarketplaceImage(*in, *out, s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                out.Marketplace = nil
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha3_Image_To_v1beta1_Image is an autogenerated conversion function.
func Convert_v1alpha3_Image_To_v1beta1_Image(in *Image, out *v1beta1.Image, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha3_Image_To_v1beta1_Image(in, out, s)
}</span>

func autoConvert_v1beta1_Image_To_v1alpha3_Image(in *v1beta1.Image, out *Image, s conversion.Scope) error <span class="cov8" title="1">{
        out.ID = (*string)(unsafe.Pointer(in.ID))
        if in.SharedGallery != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.SharedGallery, &amp;out.SharedGallery
                *out = new(AzureSharedGalleryImage)
                if err := Convert_v1beta1_AzureSharedGalleryImage_To_v1alpha3_AzureSharedGalleryImage(*in, *out, s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                out.SharedGallery = nil
        }</span>
        <span class="cov8" title="1">if in.Marketplace != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Marketplace, &amp;out.Marketplace
                *out = new(AzureMarketplaceImage)
                if err := Convert_v1beta1_AzureMarketplaceImage_To_v1alpha3_AzureMarketplaceImage(*in, *out, s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                out.Marketplace = nil
        }</span>
        // WARNING: in.ComputeGallery requires manual conversion: does not exist in peer-type
        <span class="cov8" title="1">return nil</span>
}

func autoConvert_v1alpha3_LoadBalancerSpec_To_v1beta1_LoadBalancerSpec(in *LoadBalancerSpec, out *v1beta1.LoadBalancerSpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.ID = in.ID
        out.Name = in.Name
        // WARNING: in.SKU requires manual conversion: does not exist in peer-type
        if in.FrontendIPs != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.FrontendIPs, &amp;out.FrontendIPs
                *out = make([]v1beta1.FrontendIP, len(*in))
                for i := range *in </span><span class="cov8" title="1">{
                        if err := Convert_v1alpha3_FrontendIP_To_v1beta1_FrontendIP(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                out.FrontendIPs = nil
        }</span>
        // WARNING: in.Type requires manual conversion: does not exist in peer-type
        <span class="cov8" title="1">return nil</span>
}

func autoConvert_v1beta1_LoadBalancerSpec_To_v1alpha3_LoadBalancerSpec(in *v1beta1.LoadBalancerSpec, out *LoadBalancerSpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.ID = in.ID
        out.Name = in.Name
        if in.FrontendIPs != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.FrontendIPs, &amp;out.FrontendIPs
                *out = make([]FrontendIP, len(*in))
                for i := range *in </span><span class="cov8" title="1">{
                        if err := Convert_v1beta1_FrontendIP_To_v1alpha3_FrontendIP(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                out.FrontendIPs = nil
        }</span>
        // WARNING: in.FrontendIPsCount requires manual conversion: does not exist in peer-type
        // WARNING: in.LoadBalancerClassSpec requires manual conversion: does not exist in peer-type
        <span class="cov8" title="1">return nil</span>
}

func autoConvert_v1alpha3_NetworkSpec_To_v1beta1_NetworkSpec(in *NetworkSpec, out *v1beta1.NetworkSpec, s conversion.Scope) error <span class="cov0" title="0">{
        if err := Convert_v1alpha3_VnetSpec_To_v1beta1_VnetSpec(&amp;in.Vnet, &amp;out.Vnet, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if in.Subnets != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Subnets, &amp;out.Subnets
                *out = make(v1beta1.Subnets, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1alpha3_SubnetSpec_To_v1beta1_SubnetSpec(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Subnets = nil
        }</span>
        <span class="cov0" title="0">if err := Convert_v1alpha3_LoadBalancerSpec_To_v1beta1_LoadBalancerSpec(&amp;in.APIServerLB, &amp;out.APIServerLB, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func autoConvert_v1beta1_NetworkSpec_To_v1alpha3_NetworkSpec(in *v1beta1.NetworkSpec, out *NetworkSpec, s conversion.Scope) error <span class="cov0" title="0">{
        if err := Convert_v1beta1_VnetSpec_To_v1alpha3_VnetSpec(&amp;in.Vnet, &amp;out.Vnet, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if in.Subnets != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Subnets, &amp;out.Subnets
                *out = make(Subnets, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1beta1_SubnetSpec_To_v1alpha3_SubnetSpec(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Subnets = nil
        }</span>
        <span class="cov0" title="0">if err := Convert_v1beta1_LoadBalancerSpec_To_v1alpha3_LoadBalancerSpec(&amp;in.APIServerLB, &amp;out.APIServerLB, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // WARNING: in.NodeOutboundLB requires manual conversion: does not exist in peer-type
        // WARNING: in.ControlPlaneOutboundLB requires manual conversion: does not exist in peer-type
        // WARNING: in.NetworkClassSpec requires manual conversion: does not exist in peer-type
        <span class="cov0" title="0">return nil</span>
}

func autoConvert_v1alpha3_PublicIPSpec_To_v1beta1_PublicIPSpec(in *PublicIPSpec, out *v1beta1.PublicIPSpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.Name = in.Name
        out.DNSName = in.DNSName
        return nil
}</span>

// Convert_v1alpha3_PublicIPSpec_To_v1beta1_PublicIPSpec is an autogenerated conversion function.
func Convert_v1alpha3_PublicIPSpec_To_v1beta1_PublicIPSpec(in *PublicIPSpec, out *v1beta1.PublicIPSpec, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha3_PublicIPSpec_To_v1beta1_PublicIPSpec(in, out, s)
}</span>

func autoConvert_v1beta1_PublicIPSpec_To_v1alpha3_PublicIPSpec(in *v1beta1.PublicIPSpec, out *PublicIPSpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.Name = in.Name
        out.DNSName = in.DNSName
        // WARNING: in.IPTags requires manual conversion: does not exist in peer-type
        return nil
}</span>

func autoConvert_v1alpha3_RouteTable_To_v1beta1_RouteTable(in *RouteTable, out *v1beta1.RouteTable, s conversion.Scope) error <span class="cov8" title="1">{
        out.ID = in.ID
        out.Name = in.Name
        return nil
}</span>

// Convert_v1alpha3_RouteTable_To_v1beta1_RouteTable is an autogenerated conversion function.
func Convert_v1alpha3_RouteTable_To_v1beta1_RouteTable(in *RouteTable, out *v1beta1.RouteTable, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha3_RouteTable_To_v1beta1_RouteTable(in, out, s)
}</span>

func autoConvert_v1beta1_RouteTable_To_v1alpha3_RouteTable(in *v1beta1.RouteTable, out *RouteTable, s conversion.Scope) error <span class="cov8" title="1">{
        out.ID = in.ID
        out.Name = in.Name
        return nil
}</span>

// Convert_v1beta1_RouteTable_To_v1alpha3_RouteTable is an autogenerated conversion function.
func Convert_v1beta1_RouteTable_To_v1alpha3_RouteTable(in *v1beta1.RouteTable, out *RouteTable, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_RouteTable_To_v1alpha3_RouteTable(in, out, s)
}</span>

func autoConvert_v1alpha3_SecurityGroup_To_v1beta1_SecurityGroup(in *SecurityGroup, out *v1beta1.SecurityGroup, s conversion.Scope) error <span class="cov0" title="0">{
        out.ID = in.ID
        out.Name = in.Name
        // WARNING: in.IngressRules requires manual conversion: does not exist in peer-type
        // WARNING: in.Tags requires manual conversion: does not exist in peer-type
        return nil
}</span>

func autoConvert_v1beta1_SecurityGroup_To_v1alpha3_SecurityGroup(in *v1beta1.SecurityGroup, out *SecurityGroup, s conversion.Scope) error <span class="cov0" title="0">{
        out.ID = in.ID
        out.Name = in.Name
        // WARNING: in.SecurityGroupClass requires manual conversion: does not exist in peer-type
        return nil
}</span>

func autoConvert_v1alpha3_SecurityProfile_To_v1beta1_SecurityProfile(in *SecurityProfile, out *v1beta1.SecurityProfile, s conversion.Scope) error <span class="cov0" title="0">{
        out.EncryptionAtHost = (*bool)(unsafe.Pointer(in.EncryptionAtHost))
        return nil
}</span>

// Convert_v1alpha3_SecurityProfile_To_v1beta1_SecurityProfile is an autogenerated conversion function.
func Convert_v1alpha3_SecurityProfile_To_v1beta1_SecurityProfile(in *SecurityProfile, out *v1beta1.SecurityProfile, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha3_SecurityProfile_To_v1beta1_SecurityProfile(in, out, s)
}</span>

func autoConvert_v1beta1_SecurityProfile_To_v1alpha3_SecurityProfile(in *v1beta1.SecurityProfile, out *SecurityProfile, s conversion.Scope) error <span class="cov0" title="0">{
        out.EncryptionAtHost = (*bool)(unsafe.Pointer(in.EncryptionAtHost))
        return nil
}</span>

// Convert_v1beta1_SecurityProfile_To_v1alpha3_SecurityProfile is an autogenerated conversion function.
func Convert_v1beta1_SecurityProfile_To_v1alpha3_SecurityProfile(in *v1beta1.SecurityProfile, out *SecurityProfile, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_SecurityProfile_To_v1alpha3_SecurityProfile(in, out, s)
}</span>

func autoConvert_v1alpha3_SpotVMOptions_To_v1beta1_SpotVMOptions(in *SpotVMOptions, out *v1beta1.SpotVMOptions, s conversion.Scope) error <span class="cov0" title="0">{
        out.MaxPrice = (*resource.Quantity)(unsafe.Pointer(in.MaxPrice))
        return nil
}</span>

// Convert_v1alpha3_SpotVMOptions_To_v1beta1_SpotVMOptions is an autogenerated conversion function.
func Convert_v1alpha3_SpotVMOptions_To_v1beta1_SpotVMOptions(in *SpotVMOptions, out *v1beta1.SpotVMOptions, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha3_SpotVMOptions_To_v1beta1_SpotVMOptions(in, out, s)
}</span>

func autoConvert_v1beta1_SpotVMOptions_To_v1alpha3_SpotVMOptions(in *v1beta1.SpotVMOptions, out *SpotVMOptions, s conversion.Scope) error <span class="cov0" title="0">{
        out.MaxPrice = (*resource.Quantity)(unsafe.Pointer(in.MaxPrice))
        return nil
}</span>

// Convert_v1beta1_SpotVMOptions_To_v1alpha3_SpotVMOptions is an autogenerated conversion function.
func Convert_v1beta1_SpotVMOptions_To_v1alpha3_SpotVMOptions(in *v1beta1.SpotVMOptions, out *SpotVMOptions, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_SpotVMOptions_To_v1alpha3_SpotVMOptions(in, out, s)
}</span>

func autoConvert_v1alpha3_SubnetSpec_To_v1beta1_SubnetSpec(in *SubnetSpec, out *v1beta1.SubnetSpec, s conversion.Scope) error <span class="cov8" title="1">{
        // WARNING: in.Role requires manual conversion: does not exist in peer-type
        out.ID = in.ID
        out.Name = in.Name
        // WARNING: in.CidrBlock requires manual conversion: does not exist in peer-type
        // WARNING: in.CIDRBlocks requires manual conversion: does not exist in peer-type
        // WARNING: in.InternalLBIPAddress requires manual conversion: does not exist in peer-type
        if err := Convert_v1alpha3_SecurityGroup_To_v1beta1_SecurityGroup(&amp;in.SecurityGroup, &amp;out.SecurityGroup, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1alpha3_RouteTable_To_v1beta1_RouteTable(&amp;in.RouteTable, &amp;out.RouteTable, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func autoConvert_v1beta1_SubnetSpec_To_v1alpha3_SubnetSpec(in *v1beta1.SubnetSpec, out *SubnetSpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.ID = in.ID
        out.Name = in.Name
        if err := Convert_v1beta1_SecurityGroup_To_v1alpha3_SecurityGroup(&amp;in.SecurityGroup, &amp;out.SecurityGroup, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1beta1_RouteTable_To_v1alpha3_RouteTable(&amp;in.RouteTable, &amp;out.RouteTable, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // WARNING: in.NatGateway requires manual conversion: does not exist in peer-type
        // WARNING: in.SubnetClassSpec requires manual conversion: does not exist in peer-type
        <span class="cov8" title="1">return nil</span>
}

func autoConvert_v1alpha3_UserAssignedIdentity_To_v1beta1_UserAssignedIdentity(in *UserAssignedIdentity, out *v1beta1.UserAssignedIdentity, s conversion.Scope) error <span class="cov0" title="0">{
        out.ProviderID = in.ProviderID
        return nil
}</span>

// Convert_v1alpha3_UserAssignedIdentity_To_v1beta1_UserAssignedIdentity is an autogenerated conversion function.
func Convert_v1alpha3_UserAssignedIdentity_To_v1beta1_UserAssignedIdentity(in *UserAssignedIdentity, out *v1beta1.UserAssignedIdentity, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha3_UserAssignedIdentity_To_v1beta1_UserAssignedIdentity(in, out, s)
}</span>

func autoConvert_v1beta1_UserAssignedIdentity_To_v1alpha3_UserAssignedIdentity(in *v1beta1.UserAssignedIdentity, out *UserAssignedIdentity, s conversion.Scope) error <span class="cov0" title="0">{
        out.ProviderID = in.ProviderID
        return nil
}</span>

// Convert_v1beta1_UserAssignedIdentity_To_v1alpha3_UserAssignedIdentity is an autogenerated conversion function.
func Convert_v1beta1_UserAssignedIdentity_To_v1alpha3_UserAssignedIdentity(in *v1beta1.UserAssignedIdentity, out *UserAssignedIdentity, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_UserAssignedIdentity_To_v1alpha3_UserAssignedIdentity(in, out, s)
}</span>

func autoConvert_v1alpha3_VnetSpec_To_v1beta1_VnetSpec(in *VnetSpec, out *v1beta1.VnetSpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.ResourceGroup = in.ResourceGroup
        out.ID = in.ID
        out.Name = in.Name
        // WARNING: in.CidrBlock requires manual conversion: does not exist in peer-type
        // WARNING: in.CIDRBlocks requires manual conversion: does not exist in peer-type
        // WARNING: in.Tags requires manual conversion: does not exist in peer-type
        return nil
}</span>

func autoConvert_v1beta1_VnetSpec_To_v1alpha3_VnetSpec(in *v1beta1.VnetSpec, out *VnetSpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.ResourceGroup = in.ResourceGroup
        out.ID = in.ID
        out.Name = in.Name
        // WARNING: in.Peerings requires manual conversion: does not exist in peer-type
        // WARNING: in.VnetClassSpec requires manual conversion: does not exist in peer-type
        return nil
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha3

import (
        "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/runtime"
        apiv1alpha3 "sigs.k8s.io/cluster-api/api/v1alpha3"
        "sigs.k8s.io/cluster-api/errors"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AddressRecord) DeepCopyInto(out *AddressRecord) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AddressRecord.
func (in *AddressRecord) DeepCopy() *AddressRecord <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AddressRecord)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AvailabilityZone) DeepCopyInto(out *AvailabilityZone) <span class="cov8" title="1">{
        *out = *in
        if in.ID != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ID, &amp;out.ID
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.Enabled != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Enabled, &amp;out.Enabled
                *out = new(bool)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AvailabilityZone.
func (in *AvailabilityZone) DeepCopy() *AvailabilityZone <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AvailabilityZone)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureCluster) DeepCopyInto(out *AzureCluster) <span class="cov8" title="1">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
        in.Status.DeepCopyInto(&amp;out.Status)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureCluster.
func (in *AzureCluster) DeepCopy() *AzureCluster <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">out := new(AzureCluster)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureCluster) DeepCopyObject() runtime.Object <span class="cov8" title="1">{
        if c := in.DeepCopy(); c != nil </span><span class="cov8" title="1">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureClusterIdentity) DeepCopyInto(out *AzureClusterIdentity) <span class="cov8" title="1">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
        in.Status.DeepCopyInto(&amp;out.Status)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureClusterIdentity.
func (in *AzureClusterIdentity) DeepCopy() *AzureClusterIdentity <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">out := new(AzureClusterIdentity)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureClusterIdentity) DeepCopyObject() runtime.Object <span class="cov8" title="1">{
        if c := in.DeepCopy(); c != nil </span><span class="cov8" title="1">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureClusterIdentityList) DeepCopyInto(out *AzureClusterIdentityList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureClusterIdentity, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureClusterIdentityList.
func (in *AzureClusterIdentityList) DeepCopy() *AzureClusterIdentityList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureClusterIdentityList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureClusterIdentityList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureClusterIdentitySpec) DeepCopyInto(out *AzureClusterIdentitySpec) <span class="cov8" title="1">{
        *out = *in
        out.ClientSecret = in.ClientSecret
        if in.AllowedNamespaces != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AllowedNamespaces, &amp;out.AllowedNamespaces
                *out = make([]string, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureClusterIdentitySpec.
func (in *AzureClusterIdentitySpec) DeepCopy() *AzureClusterIdentitySpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureClusterIdentitySpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureClusterIdentityStatus) DeepCopyInto(out *AzureClusterIdentityStatus) <span class="cov8" title="1">{
        *out = *in
        if in.Conditions != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make(apiv1alpha3.Conditions, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureClusterIdentityStatus.
func (in *AzureClusterIdentityStatus) DeepCopy() *AzureClusterIdentityStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureClusterIdentityStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureClusterList) DeepCopyInto(out *AzureClusterList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureCluster, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureClusterList.
func (in *AzureClusterList) DeepCopy() *AzureClusterList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureClusterList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureClusterList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureClusterSpec) DeepCopyInto(out *AzureClusterSpec) <span class="cov8" title="1">{
        *out = *in
        in.NetworkSpec.DeepCopyInto(&amp;out.NetworkSpec)
        out.ControlPlaneEndpoint = in.ControlPlaneEndpoint
        if in.AdditionalTags != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AdditionalTags, &amp;out.AdditionalTags
                *out = make(Tags, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
        <span class="cov8" title="1">if in.IdentityRef != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.IdentityRef, &amp;out.IdentityRef
                *out = new(v1.ObjectReference)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureClusterSpec.
func (in *AzureClusterSpec) DeepCopy() *AzureClusterSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureClusterSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureClusterStatus) DeepCopyInto(out *AzureClusterStatus) <span class="cov8" title="1">{
        *out = *in
        if in.FailureDomains != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.FailureDomains, &amp;out.FailureDomains
                *out = make(apiv1alpha3.FailureDomains, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = *val.DeepCopy()
                }</span>
        }
        <span class="cov8" title="1">if in.Conditions != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make(apiv1alpha3.Conditions, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureClusterStatus.
func (in *AzureClusterStatus) DeepCopy() *AzureClusterStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureClusterStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachine) DeepCopyInto(out *AzureMachine) <span class="cov8" title="1">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
        in.Status.DeepCopyInto(&amp;out.Status)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachine.
func (in *AzureMachine) DeepCopy() *AzureMachine <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">out := new(AzureMachine)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureMachine) DeepCopyObject() runtime.Object <span class="cov8" title="1">{
        if c := in.DeepCopy(); c != nil </span><span class="cov8" title="1">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachineList) DeepCopyInto(out *AzureMachineList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureMachine, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachineList.
func (in *AzureMachineList) DeepCopy() *AzureMachineList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachineList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureMachineList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachineSpec) DeepCopyInto(out *AzureMachineSpec) <span class="cov8" title="1">{
        *out = *in
        if in.ProviderID != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ProviderID, &amp;out.ProviderID
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.FailureDomain != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.FailureDomain, &amp;out.FailureDomain
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov8" title="1">in.AvailabilityZone.DeepCopyInto(&amp;out.AvailabilityZone)
        if in.Image != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Image, &amp;out.Image
                *out = new(Image)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov8" title="1">if in.UserAssignedIdentities != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.UserAssignedIdentities, &amp;out.UserAssignedIdentities
                *out = make([]UserAssignedIdentity, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov8" title="1">in.OSDisk.DeepCopyInto(&amp;out.OSDisk)
        if in.DataDisks != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.DataDisks, &amp;out.DataDisks
                *out = make([]DataDisk, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov8" title="1">if in.AdditionalTags != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AdditionalTags, &amp;out.AdditionalTags
                *out = make(Tags, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
        <span class="cov8" title="1">if in.AcceleratedNetworking != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AcceleratedNetworking, &amp;out.AcceleratedNetworking
                *out = new(bool)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.SpotVMOptions != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.SpotVMOptions, &amp;out.SpotVMOptions
                *out = new(SpotVMOptions)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov8" title="1">if in.SecurityProfile != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.SecurityProfile, &amp;out.SecurityProfile
                *out = new(SecurityProfile)
                (*in).DeepCopyInto(*out)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachineSpec.
func (in *AzureMachineSpec) DeepCopy() *AzureMachineSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachineSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachineStatus) DeepCopyInto(out *AzureMachineStatus) <span class="cov8" title="1">{
        *out = *in
        if in.Addresses != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Addresses, &amp;out.Addresses
                *out = make([]v1.NodeAddress, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov8" title="1">if in.VMState != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.VMState, &amp;out.VMState
                *out = new(VMState)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.FailureReason != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.FailureReason, &amp;out.FailureReason
                *out = new(errors.MachineStatusError)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.FailureMessage != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.FailureMessage, &amp;out.FailureMessage
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.Conditions != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make(apiv1alpha3.Conditions, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachineStatus.
func (in *AzureMachineStatus) DeepCopy() *AzureMachineStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachineStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachineTemplate) DeepCopyInto(out *AzureMachineTemplate) <span class="cov8" title="1">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachineTemplate.
func (in *AzureMachineTemplate) DeepCopy() *AzureMachineTemplate <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">out := new(AzureMachineTemplate)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureMachineTemplate) DeepCopyObject() runtime.Object <span class="cov8" title="1">{
        if c := in.DeepCopy(); c != nil </span><span class="cov8" title="1">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachineTemplateList) DeepCopyInto(out *AzureMachineTemplateList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureMachineTemplate, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachineTemplateList.
func (in *AzureMachineTemplateList) DeepCopy() *AzureMachineTemplateList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachineTemplateList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureMachineTemplateList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachineTemplateResource) DeepCopyInto(out *AzureMachineTemplateResource) <span class="cov8" title="1">{
        *out = *in
        in.Spec.DeepCopyInto(&amp;out.Spec)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachineTemplateResource.
func (in *AzureMachineTemplateResource) DeepCopy() *AzureMachineTemplateResource <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachineTemplateResource)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachineTemplateSpec) DeepCopyInto(out *AzureMachineTemplateSpec) <span class="cov8" title="1">{
        *out = *in
        in.Template.DeepCopyInto(&amp;out.Template)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachineTemplateSpec.
func (in *AzureMachineTemplateSpec) DeepCopy() *AzureMachineTemplateSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachineTemplateSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMarketplaceImage) DeepCopyInto(out *AzureMarketplaceImage) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMarketplaceImage.
func (in *AzureMarketplaceImage) DeepCopy() *AzureMarketplaceImage <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMarketplaceImage)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureSharedGalleryImage) DeepCopyInto(out *AzureSharedGalleryImage) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureSharedGalleryImage.
func (in *AzureSharedGalleryImage) DeepCopy() *AzureSharedGalleryImage <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureSharedGalleryImage)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BuildParams) DeepCopyInto(out *BuildParams) <span class="cov0" title="0">{
        *out = *in
        if in.Name != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Name, &amp;out.Name
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.Role != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Role, &amp;out.Role
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.Additional != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Additional, &amp;out.Additional
                *out = make(Tags, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BuildParams.
func (in *BuildParams) DeepCopy() *BuildParams <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(BuildParams)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DataDisk) DeepCopyInto(out *DataDisk) <span class="cov0" title="0">{
        *out = *in
        if in.ManagedDisk != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ManagedDisk, &amp;out.ManagedDisk
                *out = new(ManagedDisk)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov0" title="0">if in.Lun != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Lun, &amp;out.Lun
                *out = new(int32)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DataDisk.
func (in *DataDisk) DeepCopy() *DataDisk <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(DataDisk)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DiffDiskSettings) DeepCopyInto(out *DiffDiskSettings) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DiffDiskSettings.
func (in *DiffDiskSettings) DeepCopy() *DiffDiskSettings <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(DiffDiskSettings)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DiskEncryptionSetParameters) DeepCopyInto(out *DiskEncryptionSetParameters) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DiskEncryptionSetParameters.
func (in *DiskEncryptionSetParameters) DeepCopy() *DiskEncryptionSetParameters <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(DiskEncryptionSetParameters)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FrontendIP) DeepCopyInto(out *FrontendIP) <span class="cov0" title="0">{
        *out = *in
        if in.PublicIP != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.PublicIP, &amp;out.PublicIP
                *out = new(PublicIPSpec)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FrontendIP.
func (in *FrontendIP) DeepCopy() *FrontendIP <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(FrontendIP)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Future) DeepCopyInto(out *Future) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Future.
func (in *Future) DeepCopy() *Future <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(Future)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Image) DeepCopyInto(out *Image) <span class="cov0" title="0">{
        *out = *in
        if in.ID != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ID, &amp;out.ID
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.SharedGallery != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.SharedGallery, &amp;out.SharedGallery
                *out = new(AzureSharedGalleryImage)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.Marketplace != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Marketplace, &amp;out.Marketplace
                *out = new(AzureMarketplaceImage)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Image.
func (in *Image) DeepCopy() *Image <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(Image)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *IngressRule) DeepCopyInto(out *IngressRule) <span class="cov0" title="0">{
        *out = *in
        if in.SourcePorts != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.SourcePorts, &amp;out.SourcePorts
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.DestinationPorts != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.DestinationPorts, &amp;out.DestinationPorts
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.Source != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Source, &amp;out.Source
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.Destination != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Destination, &amp;out.Destination
                *out = new(string)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new IngressRule.
func (in *IngressRule) DeepCopy() *IngressRule <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(IngressRule)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in IngressRules) DeepCopyInto(out *IngressRules) <span class="cov0" title="0">{
        </span><span class="cov0" title="0">{
                in := &amp;in
                *out = make(IngressRules, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new IngressRules.
func (in IngressRules) DeepCopy() IngressRules <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(IngressRules)
        in.DeepCopyInto(out)
        return *out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LoadBalancerSpec) DeepCopyInto(out *LoadBalancerSpec) <span class="cov8" title="1">{
        *out = *in
        if in.FrontendIPs != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.FrontendIPs, &amp;out.FrontendIPs
                *out = make([]FrontendIP, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LoadBalancerSpec.
func (in *LoadBalancerSpec) DeepCopy() *LoadBalancerSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(LoadBalancerSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ManagedDisk) DeepCopyInto(out *ManagedDisk) <span class="cov8" title="1">{
        *out = *in
        if in.DiskEncryptionSet != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.DiskEncryptionSet, &amp;out.DiskEncryptionSet
                *out = new(DiskEncryptionSetParameters)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ManagedDisk.
func (in *ManagedDisk) DeepCopy() *ManagedDisk <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(ManagedDisk)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NetworkSpec) DeepCopyInto(out *NetworkSpec) <span class="cov8" title="1">{
        *out = *in
        in.Vnet.DeepCopyInto(&amp;out.Vnet)
        if in.Subnets != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Subnets, &amp;out.Subnets
                *out = make(Subnets, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov8" title="1">in.APIServerLB.DeepCopyInto(&amp;out.APIServerLB)</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NetworkSpec.
func (in *NetworkSpec) DeepCopy() *NetworkSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(NetworkSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OSDisk) DeepCopyInto(out *OSDisk) <span class="cov8" title="1">{
        *out = *in
        in.ManagedDisk.DeepCopyInto(&amp;out.ManagedDisk)
        if in.DiffDiskSettings != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.DiffDiskSettings, &amp;out.DiffDiskSettings
                *out = new(DiffDiskSettings)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OSDisk.
func (in *OSDisk) DeepCopy() *OSDisk <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OSDisk)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PublicIPSpec) DeepCopyInto(out *PublicIPSpec) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PublicIPSpec.
func (in *PublicIPSpec) DeepCopy() *PublicIPSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(PublicIPSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RouteTable) DeepCopyInto(out *RouteTable) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RouteTable.
func (in *RouteTable) DeepCopy() *RouteTable <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(RouteTable)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecurityGroup) DeepCopyInto(out *SecurityGroup) <span class="cov0" title="0">{
        *out = *in
        if in.IngressRules != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.IngressRules, &amp;out.IngressRules
                *out = make(IngressRules, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov0" title="0">if in.Tags != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Tags, &amp;out.Tags
                *out = make(Tags, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecurityGroup.
func (in *SecurityGroup) DeepCopy() *SecurityGroup <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(SecurityGroup)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecurityProfile) DeepCopyInto(out *SecurityProfile) <span class="cov0" title="0">{
        *out = *in
        if in.EncryptionAtHost != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.EncryptionAtHost, &amp;out.EncryptionAtHost
                *out = new(bool)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecurityProfile.
func (in *SecurityProfile) DeepCopy() *SecurityProfile <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(SecurityProfile)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SpotVMOptions) DeepCopyInto(out *SpotVMOptions) <span class="cov0" title="0">{
        *out = *in
        if in.MaxPrice != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.MaxPrice, &amp;out.MaxPrice
                x := (*in).DeepCopy()
                *out = &amp;x
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SpotVMOptions.
func (in *SpotVMOptions) DeepCopy() *SpotVMOptions <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(SpotVMOptions)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SubnetSpec) DeepCopyInto(out *SubnetSpec) <span class="cov0" title="0">{
        *out = *in
        if in.CIDRBlocks != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.CIDRBlocks, &amp;out.CIDRBlocks
                *out = make([]string, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov0" title="0">in.SecurityGroup.DeepCopyInto(&amp;out.SecurityGroup)
        out.RouteTable = in.RouteTable</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SubnetSpec.
func (in *SubnetSpec) DeepCopy() *SubnetSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(SubnetSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in Subnets) DeepCopyInto(out *Subnets) <span class="cov0" title="0">{
        </span><span class="cov0" title="0">{
                in := &amp;in
                *out = make(Subnets, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Subnets.
func (in Subnets) DeepCopy() Subnets <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(Subnets)
        in.DeepCopyInto(out)
        return *out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in Tags) DeepCopyInto(out *Tags) <span class="cov0" title="0">{
        </span><span class="cov0" title="0">{
                in := &amp;in
                *out = make(Tags, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Tags.
func (in Tags) DeepCopy() Tags <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(Tags)
        in.DeepCopyInto(out)
        return *out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *UserAssignedIdentity) DeepCopyInto(out *UserAssignedIdentity) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new UserAssignedIdentity.
func (in *UserAssignedIdentity) DeepCopy() *UserAssignedIdentity <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(UserAssignedIdentity)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *VM) DeepCopyInto(out *VM) <span class="cov0" title="0">{
        *out = *in
        in.Image.DeepCopyInto(&amp;out.Image)
        in.OSDisk.DeepCopyInto(&amp;out.OSDisk)
        if in.Tags != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Tags, &amp;out.Tags
                *out = make(Tags, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
        <span class="cov0" title="0">if in.Addresses != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Addresses, &amp;out.Addresses
                *out = make([]v1.NodeAddress, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VM.
func (in *VM) DeepCopy() *VM <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(VM)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *VnetSpec) DeepCopyInto(out *VnetSpec) <span class="cov8" title="1">{
        *out = *in
        if in.CIDRBlocks != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.CIDRBlocks, &amp;out.CIDRBlocks
                *out = make([]string, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov8" title="1">if in.Tags != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Tags, &amp;out.Tags
                *out = make(Tags, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VnetSpec.
func (in *VnetSpec) DeepCopy() *VnetSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(VnetSpec)
        in.DeepCopyInto(out)
        return out</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha4

import (
        "unsafe"

        apiconversion "k8s.io/apimachinery/pkg/conversion"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        utilconversion "sigs.k8s.io/cluster-api/util/conversion"
        "sigs.k8s.io/controller-runtime/pkg/conversion"
)

// ConvertTo converts this AzureCluster to the Hub version (v1beta1).
func (src *AzureCluster) ConvertTo(dstRaw conversion.Hub) error <span class="cov8" title="1">{
        dst := dstRaw.(*infrav1.AzureCluster)
        if err := Convert_v1alpha4_AzureCluster_To_v1beta1_AzureCluster(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Manually restore data.
        <span class="cov8" title="1">restored := &amp;infrav1.AzureCluster{}
        if ok, err := utilconversion.UnmarshalData(src, restored); err != nil || !ok </span><span class="cov8" title="1">{
                return err
        }</span>

        // Restore list of virtual network peerings
        <span class="cov8" title="1">dst.Spec.NetworkSpec.Vnet.Peerings = restored.Spec.NetworkSpec.Vnet.Peerings

        // Restore API Server LB IP tags.
        for _, restoredFrontendIP := range restored.Spec.NetworkSpec.APIServerLB.FrontendIPs </span><span class="cov8" title="1">{
                for i, dstFrontendIP := range dst.Spec.NetworkSpec.APIServerLB.FrontendIPs </span><span class="cov8" title="1">{
                        if restoredFrontendIP.Name == dstFrontendIP.Name &amp;&amp; restoredFrontendIP.PublicIP != nil </span><span class="cov8" title="1">{
                                dst.Spec.NetworkSpec.APIServerLB.FrontendIPs[i].PublicIP.IPTags = restoredFrontendIP.PublicIP.IPTags
                        }</span>
                }
        }

        // Restore outbound LB IP tags.
        <span class="cov8" title="1">if restored.Spec.NetworkSpec.ControlPlaneOutboundLB != nil </span><span class="cov8" title="1">{
                for _, restoredFrontendIP := range restored.Spec.NetworkSpec.ControlPlaneOutboundLB.FrontendIPs </span><span class="cov8" title="1">{
                        for i, dstFrontendIP := range dst.Spec.NetworkSpec.ControlPlaneOutboundLB.FrontendIPs </span><span class="cov8" title="1">{
                                if restoredFrontendIP.Name == dstFrontendIP.Name &amp;&amp; restoredFrontendIP.PublicIP != nil </span><span class="cov8" title="1">{
                                        dst.Spec.NetworkSpec.ControlPlaneOutboundLB.FrontendIPs[i].PublicIP.IPTags = restoredFrontendIP.PublicIP.IPTags
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">if restored.Spec.NetworkSpec.NodeOutboundLB != nil </span><span class="cov8" title="1">{
                for _, restoredFrontendIP := range restored.Spec.NetworkSpec.NodeOutboundLB.FrontendIPs </span><span class="cov8" title="1">{
                        for i, dstFrontendIP := range dst.Spec.NetworkSpec.NodeOutboundLB.FrontendIPs </span><span class="cov8" title="1">{
                                if restoredFrontendIP.Name == dstFrontendIP.Name &amp;&amp; restoredFrontendIP.PublicIP != nil </span><span class="cov8" title="1">{
                                        dst.Spec.NetworkSpec.NodeOutboundLB.FrontendIPs[i].PublicIP.IPTags = restoredFrontendIP.PublicIP.IPTags
                                }</span>
                        }
                }
        }

        // Restore NAT Gateway IP tags.
        <span class="cov8" title="1">for _, restoredSubnet := range restored.Spec.NetworkSpec.Subnets </span><span class="cov8" title="1">{
                for i, dstSubnet := range dst.Spec.NetworkSpec.Subnets </span><span class="cov8" title="1">{
                        if dstSubnet.Name == restoredSubnet.Name </span><span class="cov8" title="1">{
                                dst.Spec.NetworkSpec.Subnets[i].NatGateway.NatGatewayIP.IPTags = restoredSubnet.NatGateway.NatGatewayIP.IPTags
                        }</span>
                }
        }

        // Restore Azure Bastion IP tags.
        <span class="cov8" title="1">if restored.Spec.BastionSpec.AzureBastion != nil &amp;&amp; dst.Spec.BastionSpec.AzureBastion != nil </span><span class="cov8" title="1">{
                if restored.Spec.BastionSpec.AzureBastion.PublicIP.Name == dst.Spec.BastionSpec.AzureBastion.PublicIP.Name </span><span class="cov8" title="1">{
                        dst.Spec.BastionSpec.AzureBastion.PublicIP.IPTags = restored.Spec.BastionSpec.AzureBastion.PublicIP.IPTags
                }</span>
                <span class="cov8" title="1">if restored.Spec.BastionSpec.AzureBastion.Subnet.NatGateway.NatGatewayIP.Name == dst.Spec.BastionSpec.AzureBastion.Subnet.NatGateway.NatGatewayIP.Name </span><span class="cov8" title="1">{
                        dst.Spec.BastionSpec.AzureBastion.Subnet.NatGateway.NatGatewayIP.IPTags = restored.Spec.BastionSpec.AzureBastion.Subnet.NatGateway.NatGatewayIP.IPTags
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureCluster) ConvertFrom(srcRaw conversion.Hub) error <span class="cov8" title="1">{
        src := srcRaw.(*infrav1.AzureCluster)
        if err := Convert_v1beta1_AzureCluster_To_v1alpha4_AzureCluster(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Preserve Hub data on down-conversion.
        <span class="cov8" title="1">return utilconversion.MarshalData(src, dst)</span>
}

// ConvertTo converts this AzureClusterList to the Hub version (v1beta1).
func (src *AzureClusterList) ConvertTo(dstRaw conversion.Hub) error <span class="cov0" title="0">{
        dst := dstRaw.(*infrav1.AzureClusterList)
        return Convert_v1alpha4_AzureClusterList_To_v1beta1_AzureClusterList(src, dst, nil)
}</span>

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureClusterList) ConvertFrom(srcRaw conversion.Hub) error <span class="cov0" title="0">{
        src := srcRaw.(*infrav1.AzureClusterList)
        return Convert_v1beta1_AzureClusterList_To_v1alpha4_AzureClusterList(src, dst, nil)
}</span>

// Convert_v1beta1_VnetSpec_To_v1alpha4_VnetSpec converts from the Hub version (v1beta1) of the VnetSpec to this version.
func Convert_v1beta1_VnetSpec_To_v1alpha4_VnetSpec(in *infrav1.VnetSpec, out *VnetSpec, s apiconversion.Scope) error <span class="cov8" title="1">{
        if err := autoConvert_v1beta1_VnetSpec_To_v1alpha4_VnetSpec(in, out, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Convert VnetClassSpec fields
        <span class="cov8" title="1">out.CIDRBlocks = in.CIDRBlocks
        out.Tags = *(*Tags)(&amp;in.Tags)

        return nil</span>
}

// Convert_v1alpha4_VnetSpec_To_v1beta1_VnetSpec is an autogenerated conversion function.
func Convert_v1alpha4_VnetSpec_To_v1beta1_VnetSpec(in *VnetSpec, out *infrav1.VnetSpec, s apiconversion.Scope) error <span class="cov8" title="1">{
        if err := autoConvert_v1alpha4_VnetSpec_To_v1beta1_VnetSpec(in, out, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Convert VnetClassSpec fields
        <span class="cov8" title="1">out.CIDRBlocks = in.CIDRBlocks
        out.Tags = *(*infrav1.Tags)(&amp;in.Tags)

        return nil</span>
}

// Convert_v1alpha4_AzureClusterSpec_To_v1beta1_AzureClusterSpec is an autogenerated conversion function.
func Convert_v1alpha4_AzureClusterSpec_To_v1beta1_AzureClusterSpec(in *AzureClusterSpec, out *infrav1.AzureClusterSpec, s apiconversion.Scope) error <span class="cov8" title="1">{
        if err := autoConvert_v1alpha4_AzureClusterSpec_To_v1beta1_AzureClusterSpec(in, out, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Convert AzureClusterClassSpec fields
        <span class="cov8" title="1">out.SubscriptionID = in.SubscriptionID
        out.Location = in.Location
        out.AdditionalTags = *(*infrav1.Tags)(&amp;in.AdditionalTags)
        out.IdentityRef = in.IdentityRef
        out.AzureEnvironment = in.AzureEnvironment
        out.CloudProviderConfigOverrides = (*infrav1.CloudProviderConfigOverrides)(unsafe.Pointer(in.CloudProviderConfigOverrides))

        return nil</span>
}

// Convert_v1beta1_AzureClusterSpec_To_v1alpha4_AzureClusterSpec is an autogenerated conversion function.
func Convert_v1beta1_AzureClusterSpec_To_v1alpha4_AzureClusterSpec(in *infrav1.AzureClusterSpec, out *AzureClusterSpec, s apiconversion.Scope) error <span class="cov8" title="1">{
        if err := autoConvert_v1beta1_AzureClusterSpec_To_v1alpha4_AzureClusterSpec(in, out, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Convert AzureClusterClassSpec fields
        <span class="cov8" title="1">out.SubscriptionID = in.SubscriptionID
        out.Location = in.Location
        out.AdditionalTags = Tags(in.AdditionalTags)
        out.IdentityRef = in.IdentityRef
        out.AzureEnvironment = in.AzureEnvironment
        out.CloudProviderConfigOverrides = (*CloudProviderConfigOverrides)(unsafe.Pointer(in.CloudProviderConfigOverrides))

        return nil</span>
}

// Convert_v1alpha4_FrontendIP_To_v1beta1_FrontendIP is an autogenerated conversion function.
func Convert_v1alpha4_FrontendIP_To_v1beta1_FrontendIP(in *FrontendIP, out *infrav1.FrontendIP, s apiconversion.Scope) error <span class="cov8" title="1">{
        if err := autoConvert_v1alpha4_FrontendIP_To_v1beta1_FrontendIP(in, out, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Convert FrontendIPClass fields
        <span class="cov8" title="1">out.PrivateIPAddress = in.PrivateIPAddress

        return nil</span>
}

// Convert_v1beta1_FrontendIP_To_v1alpha4_FrontendIP is an autogenerated conversion function.
func Convert_v1beta1_FrontendIP_To_v1alpha4_FrontendIP(in *infrav1.FrontendIP, out *FrontendIP, s apiconversion.Scope) error <span class="cov8" title="1">{
        if err := autoConvert_v1beta1_FrontendIP_To_v1alpha4_FrontendIP(in, out, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Convert FrontendIPClass fields
        <span class="cov8" title="1">out.PrivateIPAddress = in.PrivateIPAddress

        return nil</span>
}

// Convert_v1alpha4_LoadBalancerSpec_To_v1beta1_LoadBalancerSpec is an autogenerated conversion function.
func Convert_v1alpha4_LoadBalancerSpec_To_v1beta1_LoadBalancerSpec(in *LoadBalancerSpec, out *infrav1.LoadBalancerSpec, s apiconversion.Scope) error <span class="cov8" title="1">{
        if err := autoConvert_v1alpha4_LoadBalancerSpec_To_v1beta1_LoadBalancerSpec(in, out, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Convert LoadBalancerClassSpec fields
        <span class="cov8" title="1">out.SKU = infrav1.SKU(in.SKU)
        if in.FrontendIPs != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.FrontendIPs, &amp;out.FrontendIPs
                *out = make([]infrav1.FrontendIP, len(*in))
                for i := range *in </span><span class="cov8" title="1">{
                        if err := Convert_v1alpha4_FrontendIP_To_v1beta1_FrontendIP(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                out.FrontendIPs = nil
        }</span>
        <span class="cov8" title="1">out.Type = infrav1.LBType(in.Type)
        out.FrontendIPsCount = in.FrontendIPsCount
        out.IdleTimeoutInMinutes = in.IdleTimeoutInMinutes

        return nil</span>
}

// Convert_v1beta1_LoadBalancerSpec_To_v1alpha4_LoadBalancerSpec is an autogenerated conversion function.
func Convert_v1beta1_LoadBalancerSpec_To_v1alpha4_LoadBalancerSpec(in *infrav1.LoadBalancerSpec, out *LoadBalancerSpec, s apiconversion.Scope) error <span class="cov8" title="1">{
        if err := autoConvert_v1beta1_LoadBalancerSpec_To_v1alpha4_LoadBalancerSpec(in, out, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Convert LoadBalancerClassSpec fields
        <span class="cov8" title="1">out.SKU = SKU(in.SKU)
        if in.FrontendIPs != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.FrontendIPs, &amp;out.FrontendIPs
                *out = make([]FrontendIP, len(*in))
                for i := range *in </span><span class="cov8" title="1">{
                        if err := Convert_v1beta1_FrontendIP_To_v1alpha4_FrontendIP(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                out.FrontendIPs = nil
        }</span>
        <span class="cov8" title="1">out.Type = LBType(in.Type)
        out.FrontendIPsCount = in.FrontendIPsCount
        out.IdleTimeoutInMinutes = in.IdleTimeoutInMinutes

        return nil</span>
}

// Convert_v1alpha4_NetworkSpec_To_v1beta1_NetworkSpec is an autogenerated conversion function.
func Convert_v1alpha4_NetworkSpec_To_v1beta1_NetworkSpec(in *NetworkSpec, out *infrav1.NetworkSpec, s apiconversion.Scope) error <span class="cov8" title="1">{
        if err := autoConvert_v1alpha4_NetworkSpec_To_v1beta1_NetworkSpec(in, out, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Convert NetworkClassSpec fields
        <span class="cov8" title="1">out.PrivateDNSZoneName = in.PrivateDNSZoneName

        return nil</span>
}

// Convert_v1beta1_NetworkSpec_To_v1alpha4_NetworkSpec is an autogenerated conversion function.
func Convert_v1beta1_NetworkSpec_To_v1alpha4_NetworkSpec(in *infrav1.NetworkSpec, out *NetworkSpec, s apiconversion.Scope) error <span class="cov8" title="1">{
        if err := autoConvert_v1beta1_NetworkSpec_To_v1alpha4_NetworkSpec(in, out, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Convert NetworkClassSpec fields
        <span class="cov8" title="1">out.PrivateDNSZoneName = in.PrivateDNSZoneName

        return nil</span>
}

// Convert_v1alpha4_SubnetSpec_To_v1beta1_SubnetSpec is an autogenerated conversion function.
func Convert_v1alpha4_SubnetSpec_To_v1beta1_SubnetSpec(in *SubnetSpec, out *infrav1.SubnetSpec, s apiconversion.Scope) error <span class="cov8" title="1">{
        if err := autoConvert_v1alpha4_SubnetSpec_To_v1beta1_SubnetSpec(in, out, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Convert SubnetClassSpec fields
        <span class="cov8" title="1">out.Role = infrav1.SubnetRole(in.Role)
        out.CIDRBlocks = in.CIDRBlocks

        return nil</span>
}

// Convert_v1beta1_SubnetSpec_To_v1alpha4_SubnetSpec is an autogenerated conversion function.
func Convert_v1beta1_SubnetSpec_To_v1alpha4_SubnetSpec(in *infrav1.SubnetSpec, out *SubnetSpec, s apiconversion.Scope) error <span class="cov8" title="1">{
        if err := autoConvert_v1beta1_SubnetSpec_To_v1alpha4_SubnetSpec(in, out, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Convert SubnetClassSpec fields
        <span class="cov8" title="1">out.Role = SubnetRole(in.Role)
        out.CIDRBlocks = in.CIDRBlocks

        return nil</span>
}

// Convert_v1alpha4_SecurityGroup_To_v1beta1_SecurityGroup is an autogenerated conversion function.
func Convert_v1alpha4_SecurityGroup_To_v1beta1_SecurityGroup(in *SecurityGroup, out *infrav1.SecurityGroup, s apiconversion.Scope) error <span class="cov8" title="1">{
        if err := autoConvert_v1alpha4_SecurityGroup_To_v1beta1_SecurityGroup(in, out, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Convert SecurityGroupClass fields
        <span class="cov8" title="1">out.SecurityRules = *(*infrav1.SecurityRules)(unsafe.Pointer(&amp;in.SecurityRules))
        out.Tags = *(*infrav1.Tags)(&amp;in.Tags)

        return nil</span>
}

// Convert_v1beta1_SecurityGroup_To_v1alpha4_SecurityGroup is an autogenerated conversion function.
func Convert_v1beta1_SecurityGroup_To_v1alpha4_SecurityGroup(in *infrav1.SecurityGroup, out *SecurityGroup, s apiconversion.Scope) error <span class="cov8" title="1">{
        if err := autoConvert_v1beta1_SecurityGroup_To_v1alpha4_SecurityGroup(in, out, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Convert SecurityGroupClass fields
        <span class="cov8" title="1">out.SecurityRules = *(*SecurityRules)(unsafe.Pointer(&amp;in.SecurityRules))
        out.Tags = *(*Tags)(&amp;in.Tags)

        return nil</span>
}

// Convert_v1alpha4_NatGateway_To_v1beta1_NatGateway converts a NAT gateway from v1alpha4 to v1beta1.
func Convert_v1alpha4_NatGateway_To_v1beta1_NatGateway(in *NatGateway, out *infrav1.NatGateway, s apiconversion.Scope) error <span class="cov8" title="1">{
        if err := autoConvert_v1alpha4_NatGateway_To_v1beta1_NatGateway(in, out, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Convert Name field
        <span class="cov8" title="1">out.Name = in.Name
        return nil</span>
}

// Convert_v1beta1_NatGateway_To_v1alpha4_NatGateway converts a NatGateway from v1beta1 to v1alpha4.
func Convert_v1beta1_NatGateway_To_v1alpha4_NatGateway(in *infrav1.NatGateway, out *NatGateway, s apiconversion.Scope) error <span class="cov8" title="1">{
        if err := autoConvert_v1beta1_NatGateway_To_v1alpha4_NatGateway(in, out, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Convert Name field
        <span class="cov8" title="1">out.Name = in.Name
        return nil</span>
}

// Convert_v1beta1_PublicIPSpec_To_v1alpha4_PublicIPSpec is an autogenerated conversion function.
func Convert_v1beta1_PublicIPSpec_To_v1alpha4_PublicIPSpec(in *infrav1.PublicIPSpec, out *PublicIPSpec, s apiconversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_PublicIPSpec_To_v1alpha4_PublicIPSpec(in, out, s)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha4

import (
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1alpha4 "sigs.k8s.io/cluster-api/api/v1alpha4"
)

const (
        // ClusterFinalizer allows ReconcileAzureCluster to clean up Azure resources associated with AzureCluster before
        // removing it from the apiserver.
        ClusterFinalizer = "azurecluster.infrastructure.cluster.x-k8s.io"

        // ClusterLabelNamespace indicates the namespace of the cluster.
        ClusterLabelNamespace = "azurecluster.infrastructure.cluster.x-k8s.io/cluster-namespace"
)

// AzureClusterSpec defines the desired state of AzureCluster.
type AzureClusterSpec struct {
        // NetworkSpec encapsulates all things related to Azure network.
        NetworkSpec NetworkSpec `json:"networkSpec,omitempty"`

        // +optional
        ResourceGroup string `json:"resourceGroup,omitempty"`

        // +optional
        SubscriptionID string `json:"subscriptionID,omitempty"`

        Location string `json:"location"`

        // ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
        // +optional
        ControlPlaneEndpoint clusterv1alpha4.APIEndpoint `json:"controlPlaneEndpoint"`

        // AdditionalTags is an optional set of tags to add to Azure resources managed by the Azure provider, in addition to the
        // ones added by default.
        // +optional
        AdditionalTags Tags `json:"additionalTags,omitempty"`

        // IdentityRef is a reference to an AzureIdentity to be used when reconciling this cluster
        // +optional
        IdentityRef *corev1.ObjectReference `json:"identityRef,omitempty"`

        // AzureEnvironment is the name of the AzureCloud to be used.
        // The default value that would be used by most users is "AzurePublicCloud", other values are:
        // - ChinaCloud: "AzureChinaCloud"
        // - GermanCloud: "AzureGermanCloud"
        // - PublicCloud: "AzurePublicCloud"
        // - USGovernmentCloud: "AzureUSGovernmentCloud"
        // +optional
        AzureEnvironment string `json:"azureEnvironment,omitempty"`

        // BastionSpec encapsulates all things related to the Bastions in the cluster.
        // +optional
        BastionSpec BastionSpec `json:"bastionSpec,omitempty"`

        // CloudProviderConfigOverrides is an optional set of configuration values that can be overridden in azure cloud provider config.
        // This is only a subset of options that are available in azure cloud provider config.
        // Some values for the cloud provider config are inferred from other parts of cluster api provider azure spec, and may not be available for overrides.
        // See: https://kubernetes-sigs.github.io/cloud-provider-azure/install/configs
        // Note: All cloud provider config values can be customized by creating the secret beforehand. CloudProviderConfigOverrides is only used when the secret is managed by the Azure Provider.
        // +optional
        CloudProviderConfigOverrides *CloudProviderConfigOverrides `json:"cloudProviderConfigOverrides,omitempty"`
}

// AzureClusterStatus defines the observed state of AzureCluster.
type AzureClusterStatus struct {
        // FailureDomains specifies the list of unique failure domains for the location/region of the cluster.
        // A FailureDomain maps to Availability Zone with an Azure Region (if the region support them). An
        // Availability Zone is a separate data center within a region and they can be used to ensure
        // the cluster is more resilient to failure.
        // See: https://docs.microsoft.com/en-us/azure/availability-zones/az-overview
        // This list will be used by Cluster API to try and spread the machines across the failure domains.
        FailureDomains clusterv1alpha4.FailureDomains `json:"failureDomains,omitempty"`

        // Ready is true when the provider resource is ready.
        // +optional
        Ready bool `json:"ready"`

        // Conditions defines current service state of the AzureCluster.
        // +optional
        Conditions clusterv1alpha4.Conditions `json:"conditions,omitempty"`

        // LongRunningOperationStates saves the states for Azure long-running operations so they can be continued on the
        // next reconciliation loop.
        // +optional
        LongRunningOperationStates Futures `json:"longRunningOperationStates,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:printcolumn:name="Cluster",type="string",JSONPath=".metadata.labels.cluster\\.x-k8s\\.io/cluster-name",description="Cluster to which this AzureCluster belongs"
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",priority=1,JSONPath=".status.conditions[?(@.type=='Ready')].message"
// +kubebuilder:printcolumn:name="Resource Group",type="string",priority=1,JSONPath=".spec.resourceGroup"
// +kubebuilder:printcolumn:name="SubscriptionID",type="string",priority=1,JSONPath=".spec.subscriptionID"
// +kubebuilder:printcolumn:name="Location",type="string",priority=1,JSONPath=".spec.location"
// +kubebuilder:printcolumn:name="Endpoint",type="string",priority=1,JSONPath=".spec.controlPlaneEndpoint.host",description="Control Plane Endpoint"
// +kubebuilder:resource:path=azureclusters,scope=Namespaced,categories=cluster-api
// +kubebuilder:subresource:status

// AzureCluster is the Schema for the azureclusters API.
type AzureCluster struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   AzureClusterSpec   `json:"spec,omitempty"`
        Status AzureClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AzureClusterList contains a list of AzureClusters.
type AzureClusterList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []AzureCluster `json:"items"`
}

// GetConditions returns the list of conditions for an AzureCluster API object.
func (c *AzureCluster) GetConditions() clusterv1alpha4.Conditions <span class="cov0" title="0">{
        return c.Status.Conditions
}</span>

// SetConditions will set the given conditions on an AzureCluster object.
func (c *AzureCluster) SetConditions(conditions clusterv1alpha4.Conditions) <span class="cov0" title="0">{
        c.Status.Conditions = conditions
}</span>

// GetFutures returns the list of long running operation states for an AzureCluster API object.
func (c *AzureCluster) GetFutures() Futures <span class="cov0" title="0">{
        return c.Status.LongRunningOperationStates
}</span>

// SetFutures will set the given long running operation states on an AzureCluster object.
func (c *AzureCluster) SetFutures(futures Futures) <span class="cov0" title="0">{
        c.Status.LongRunningOperationStates = futures
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;AzureCluster{}, &amp;AzureClusterList{})
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha4

import (
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/controller-runtime/pkg/conversion"
)

// ConvertTo converts this AzureCluster to the Hub version (v1beta1).
func (src *AzureClusterIdentity) ConvertTo(dstRaw conversion.Hub) error <span class="cov8" title="1">{
        dst := dstRaw.(*infrav1.AzureClusterIdentity)
        return Convert_v1alpha4_AzureClusterIdentity_To_v1beta1_AzureClusterIdentity(src, dst, nil)
}</span>

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureClusterIdentity) ConvertFrom(srcRaw conversion.Hub) error <span class="cov8" title="1">{
        src := srcRaw.(*infrav1.AzureClusterIdentity)
        return Convert_v1beta1_AzureClusterIdentity_To_v1alpha4_AzureClusterIdentity(src, dst, nil)
}</span>

// ConvertTo converts this AzureCluster to the Hub version (v1beta1).
func (src *AzureClusterIdentityList) ConvertTo(dstRaw conversion.Hub) error <span class="cov0" title="0">{
        dst := dstRaw.(*infrav1.AzureClusterIdentityList)
        return Convert_v1alpha4_AzureClusterIdentityList_To_v1beta1_AzureClusterIdentityList(src, dst, nil)
}</span>

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureClusterIdentityList) ConvertFrom(srcRaw conversion.Hub) error <span class="cov0" title="0">{
        src := srcRaw.(*infrav1.AzureClusterIdentityList)
        return Convert_v1beta1_AzureClusterIdentityList_To_v1alpha4_AzureClusterIdentityList(src, dst, nil)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha4

import (
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1alpha4 "sigs.k8s.io/cluster-api/api/v1alpha4"
)

// AllowedNamespaces defines the namespaces the clusters are allowed to use the identity from
// NamespaceList takes precedence over the Selector.
type AllowedNamespaces struct {
        // A nil or empty list indicates that AzureCluster cannot use the identity from any namespace.
        //
        // +optional
        // +nullable
        NamespaceList []string `json:"list"`
        // Selector is a selector of namespaces that AzureCluster can
        // use this Identity from. This is a standard Kubernetes LabelSelector,
        // a label query over a set of resources. The result of matchLabels and
        // matchExpressions are ANDed.
        //
        // A nil or empty selector indicates that AzureCluster cannot use this
        // AzureClusterIdentity from any namespace.
        // +optional
        Selector *metav1.LabelSelector `json:"selector"`
}

// AzureClusterIdentitySpec defines the parameters that are used to create an AzureIdentity.
type AzureClusterIdentitySpec struct {
        // UserAssignedMSI or Service Principal
        Type IdentityType `json:"type"`
        // User assigned MSI resource id.
        // +optional
        ResourceID string `json:"resourceID,omitempty"`
        // Both User Assigned MSI and SP can use this field.
        ClientID string `json:"clientID"`
        // ClientSecret is a secret reference which should contain either a Service Principal password or certificate secret.
        // +optional
        ClientSecret corev1.SecretReference `json:"clientSecret,omitempty"`
        // Service principal primary tenant id.
        TenantID string `json:"tenantID"`
        // AllowedNamespaces is used to identify the namespaces the clusters are allowed to use the identity from.
        // Namespaces can be selected either using an array of namespaces or with label selector.
        // An empty allowedNamespaces object indicates that AzureClusters can use this identity from any namespace.
        // If this object is nil, no namespaces will be allowed (default behaviour, if this field is not provided)
        // A namespace should be either in the NamespaceList or match with Selector to use the identity.
        //
        // +optional
        // +nullable
        AllowedNamespaces *AllowedNamespaces `json:"allowedNamespaces"`
}

// AzureClusterIdentityStatus defines the observed state of AzureClusterIdentity.
type AzureClusterIdentityStatus struct {
        // Conditions defines current service state of the AzureClusterIdentity.
        // +optional
        Conditions clusterv1alpha4.Conditions `json:"conditions,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:path=azureclusteridentities,scope=Namespaced,categories=cluster-api
// +kubebuilder:subresource:status

// AzureClusterIdentity is the Schema for the azureclustersidentities API.
type AzureClusterIdentity struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   AzureClusterIdentitySpec   `json:"spec,omitempty"`
        Status AzureClusterIdentityStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AzureClusterIdentityList contains a list of AzureClusterIdentity.
type AzureClusterIdentityList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []AzureClusterIdentity `json:"items"`
}

// GetConditions returns the list of conditions for an AzureClusterIdentity API object.
func (c *AzureClusterIdentity) GetConditions() clusterv1alpha4.Conditions <span class="cov0" title="0">{
        return c.Status.Conditions
}</span>

// SetConditions will set the given conditions on an AzureClusterIdentity object.
func (c *AzureClusterIdentity) SetConditions(conditions clusterv1alpha4.Conditions) <span class="cov0" title="0">{
        c.Status.Conditions = conditions
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;AzureClusterIdentity{}, &amp;AzureClusterIdentityList{})
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha4

import (
        apiconversion "k8s.io/apimachinery/pkg/conversion"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        utilconversion "sigs.k8s.io/cluster-api/util/conversion"
        "sigs.k8s.io/controller-runtime/pkg/conversion"
)

// ConvertTo converts this AzureMachine to the Hub version (v1beta1).
func (src *AzureMachine) ConvertTo(dstRaw conversion.Hub) error <span class="cov8" title="1">{
        dst := dstRaw.(*infrav1.AzureMachine)
        if err := Convert_v1alpha4_AzureMachine_To_v1beta1_AzureMachine(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Manually restore data from annotations
        <span class="cov8" title="1">restored := &amp;infrav1.AzureMachine{}
        if ok, err := utilconversion.UnmarshalData(src, restored); err != nil || !ok </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if restored.Spec.Image != nil &amp;&amp; restored.Spec.Image.ComputeGallery != nil </span><span class="cov8" title="1">{
                dst.Spec.Image.ComputeGallery = restored.Spec.Image.ComputeGallery
        }</span>

        <span class="cov8" title="1">if restored.Spec.AdditionalCapabilities != nil </span><span class="cov8" title="1">{
                dst.Spec.AdditionalCapabilities = restored.Spec.AdditionalCapabilities
        }</span>

        <span class="cov8" title="1">if len(restored.Spec.DNSServers) &gt; 0 </span><span class="cov8" title="1">{
                dst.Spec.DNSServers = restored.Spec.DNSServers
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureMachine) ConvertFrom(srcRaw conversion.Hub) error <span class="cov8" title="1">{
        src := srcRaw.(*infrav1.AzureMachine)
        if err := Convert_v1beta1_AzureMachine_To_v1alpha4_AzureMachine(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Preserve Hub data on down-conversion.
        <span class="cov8" title="1">return utilconversion.MarshalData(src, dst)</span>
}

// ConvertTo converts this AzureMachineList to the Hub version (v1beta1).
func (src *AzureMachineList) ConvertTo(dstRaw conversion.Hub) error <span class="cov0" title="0">{
        dst := dstRaw.(*infrav1.AzureMachineList)
        return Convert_v1alpha4_AzureMachineList_To_v1beta1_AzureMachineList(src, dst, nil)
}</span>

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureMachineList) ConvertFrom(srcRaw conversion.Hub) error <span class="cov0" title="0">{
        src := srcRaw.(*infrav1.AzureMachineList)
        return Convert_v1beta1_AzureMachineList_To_v1alpha4_AzureMachineList(src, dst, nil)
}</span>

// Convert_v1beta1_AzureMarketplaceImage_To_v1alpha4_AzureMarketplaceImage converts an Azure Marketplace image from v1beta1 to v1alpha4.
func Convert_v1beta1_AzureMarketplaceImage_To_v1alpha4_AzureMarketplaceImage(in *infrav1.AzureMarketplaceImage, out *AzureMarketplaceImage, s apiconversion.Scope) error <span class="cov8" title="1">{
        out.Offer = in.ImagePlan.Offer
        out.Publisher = in.ImagePlan.Publisher
        out.SKU = in.ImagePlan.SKU

        return autoConvert_v1beta1_AzureMarketplaceImage_To_v1alpha4_AzureMarketplaceImage(in, out, s)
}</span>

// Convert_v1alpha4_AzureMarketplaceImage_To_v1beta1_AzureMarketplaceImage converts an Azure Marketplace image from v1alpha4 to v1beta1.
func Convert_v1alpha4_AzureMarketplaceImage_To_v1beta1_AzureMarketplaceImage(in *AzureMarketplaceImage, out *infrav1.AzureMarketplaceImage, s apiconversion.Scope) error <span class="cov8" title="1">{
        out.ImagePlan.Offer = in.Offer
        out.ImagePlan.Publisher = in.Publisher
        out.ImagePlan.SKU = in.SKU

        return autoConvert_v1alpha4_AzureMarketplaceImage_To_v1beta1_AzureMarketplaceImage(in, out, s)
}</span>

// Convert_v1beta1_Image_To_v1alpha4_Image converts an image from v1beta1 to v1alpha4.
func Convert_v1beta1_Image_To_v1alpha4_Image(in *infrav1.Image, out *Image, s apiconversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_Image_To_v1alpha4_Image(in, out, s)
}</span>

// Convert_v1beta1_AzureMachineSpec_To_v1alpha4_AzureMachineSpec is an autogenerated conversion function.
func Convert_v1beta1_AzureMachineSpec_To_v1alpha4_AzureMachineSpec(in *infrav1.AzureMachineSpec, out *AzureMachineSpec, s apiconversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureMachineSpec_To_v1alpha4_AzureMachineSpec(in, out, s)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha4

import (
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/resource"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1alpha4 "sigs.k8s.io/cluster-api/api/v1alpha4"
        "sigs.k8s.io/cluster-api/errors"
)

const (
        // MachineFinalizer allows ReconcileAzureMachine to clean up Azure resources associated with AzureMachine before
        // removing it from the apiserver.
        MachineFinalizer = "azuremachine.infrastructure.cluster.x-k8s.io"
)

// AzureMachineSpec defines the desired state of AzureMachine.
type AzureMachineSpec struct {
        // ProviderID is the unique identifier as specified by the cloud provider.
        // +optional
        ProviderID *string `json:"providerID,omitempty"`

        VMSize string `json:"vmSize"`

        // FailureDomain is the failure domain unique identifier this Machine should be attached to,
        // as defined in Cluster API. This relates to an Azure Availability Zone
        FailureDomain *string `json:"failureDomain,omitempty"`

        // Image is used to provide details of an image to use during VM creation.
        // If image details are omitted the image will default the Azure Marketplace "capi" offer,
        // which is based on Ubuntu.
        // +kubebuilder:validation:nullable
        // +optional
        Image *Image `json:"image,omitempty"`

        // Identity is the type of identity used for the virtual machine.
        // The type 'SystemAssigned' is an implicitly created identity.
        // The generated identity will be assigned a Subscription contributor role.
        // The type 'UserAssigned' is a standalone Azure resource provided by the user
        // and assigned to the VM
        // +kubebuilder:default=None
        // +optional
        Identity VMIdentity `json:"identity,omitempty"`

        // UserAssignedIdentities is a list of standalone Azure identities provided by the user
        // The lifecycle of a user-assigned identity is managed separately from the lifecycle of
        // the AzureMachine.
        // See https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/how-to-manage-ua-identity-cli
        // +optional
        UserAssignedIdentities []UserAssignedIdentity `json:"userAssignedIdentities,omitempty"`

        // RoleAssignmentName is the name of the role assignment to create for a system assigned identity. It can be any valid GUID.
        // If not specified, a random GUID will be generated.
        // +optional
        RoleAssignmentName string `json:"roleAssignmentName,omitempty"`

        // OSDisk specifies the parameters for the operating system disk of the machine
        OSDisk OSDisk `json:"osDisk"`

        // DataDisk specifies the parameters that are used to add one or more data disks to the machine
        DataDisks []DataDisk `json:"dataDisks,omitempty"`

        SSHPublicKey string `json:"sshPublicKey"`

        // AdditionalTags is an optional set of tags to add to an instance, in addition to the ones added by default by the
        // Azure provider. If both the AzureCluster and the AzureMachine specify the same tag name with different values, the
        // AzureMachine's value takes precedence.
        // +optional
        AdditionalTags Tags `json:"additionalTags,omitempty"`

        // AllocatePublicIP allows the ability to create dynamic public ips for machines where this value is true.
        // +optional
        AllocatePublicIP bool `json:"allocatePublicIP,omitempty"`

        // EnableIPForwarding enables IP Forwarding in Azure which is required for some CNI's to send traffic from a pods on one machine
        // to another. This is required for IpV6 with Calico in combination with User Defined Routes (set by the Azure Cloud Controller
        // manager). Default is false for disabled.
        // +optional
        EnableIPForwarding bool `json:"enableIPForwarding,omitempty"`

        // AcceleratedNetworking enables or disables Azure accelerated networking. If omitted, it will be set based on
        // whether the requested VMSize supports accelerated networking.
        // If AcceleratedNetworking is set to true with a VMSize that does not support it, Azure will return an error.
        // +kubebuilder:validation:nullable
        // +optional
        AcceleratedNetworking *bool `json:"acceleratedNetworking,omitempty"`

        // SpotVMOptions allows the ability to specify the Machine should use a Spot VM
        // +optional
        SpotVMOptions *SpotVMOptions `json:"spotVMOptions,omitempty"`

        // SecurityProfile specifies the Security profile settings for a virtual machine.
        // +optional
        SecurityProfile *SecurityProfile `json:"securityProfile,omitempty"`

        // SubnetName selects the Subnet where the VM will be placed
        // +optional
        SubnetName string `json:"subnetName,omitempty"`
}

// SpotVMOptions defines the options relevant to running the Machine on Spot VMs.
type SpotVMOptions struct {
        // MaxPrice defines the maximum price the user is willing to pay for Spot VM instances
        // +optional
        MaxPrice *resource.Quantity `json:"maxPrice,omitempty"`
}

// AzureMachineStatus defines the observed state of AzureMachine.
type AzureMachineStatus struct {
        // Ready is true when the provider resource is ready.
        // +optional
        Ready bool `json:"ready"`

        // Addresses contains the Azure instance associated addresses.
        Addresses []corev1.NodeAddress `json:"addresses,omitempty"`

        // VMState is the provisioning state of the Azure virtual machine.
        // +optional
        VMState *ProvisioningState `json:"vmState,omitempty"`

        // ErrorReason will be set in the event that there is a terminal problem
        // reconciling the Machine and will contain a succinct value suitable
        // for machine interpretation.
        //
        // This field should not be set for transitive errors that a controller
        // faces that are expected to be fixed automatically over
        // time (like service outages), but instead indicate that something is
        // fundamentally wrong with the Machine's spec or the configuration of
        // the controller, and that manual intervention is required. Examples
        // of terminal errors would be invalid combinations of settings in the
        // spec, values that are unsupported by the controller, or the
        // responsible controller itself being critically misconfigured.
        //
        // Any transient errors that occur during the reconciliation of Machines
        // can be added as events to the Machine object and/or logged in the
        // controller's output.
        // +optional
        FailureReason *errors.MachineStatusError `json:"failureReason,omitempty"`

        // ErrorMessage will be set in the event that there is a terminal problem
        // reconciling the Machine and will contain a more verbose string suitable
        // for logging and human consumption.
        //
        // This field should not be set for transitive errors that a controller
        // faces that are expected to be fixed automatically over
        // time (like service outages), but instead indicate that something is
        // fundamentally wrong with the Machine's spec or the configuration of
        // the controller, and that manual intervention is required. Examples
        // of terminal errors would be invalid combinations of settings in the
        // spec, values that are unsupported by the controller, or the
        // responsible controller itself being critically misconfigured.
        //
        // Any transient errors that occur during the reconciliation of Machines
        // can be added as events to the Machine object and/or logged in the
        // controller's output.
        // +optional
        FailureMessage *string `json:"failureMessage,omitempty"`

        // Conditions defines current service state of the AzureMachine.
        // +optional
        Conditions clusterv1alpha4.Conditions `json:"conditions,omitempty"`

        // LongRunningOperationStates saves the states for Azure long-running operations so they can be continued on the
        // next reconciliation loop.
        // +optional
        LongRunningOperationStates Futures `json:"longRunningOperationStates,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.ready",description="AzureMachine ready status"
// +kubebuilder:printcolumn:name="State",type="string",JSONPath=".status.vmState",description="Azure VM provisioning state"
// +kubebuilder:printcolumn:name="Cluster",type="string",priority=1,JSONPath=".metadata.labels.cluster\\.x-k8s\\.io/cluster-name",description="Cluster to which this AzureMachine belongs"
// +kubebuilder:printcolumn:name="Machine",type="string",priority=1,JSONPath=".metadata.ownerReferences[?(@.kind==\"Machine\")].name",description="Machine object to which this AzureMachine belongs"
// +kubebuilder:printcolumn:name="VM ID",type="string",priority=1,JSONPath=".spec.providerID",description="Azure VM ID"
// +kubebuilder:printcolumn:name="VM Size",type="string",priority=1,JSONPath=".spec.vmSize",description="Azure VM Size"
// +kubebuilder:resource:path=azuremachines,scope=Namespaced,categories=cluster-api
// +kubebuilder:subresource:status

// AzureMachine is the Schema for the azuremachines API.
type AzureMachine struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   AzureMachineSpec   `json:"spec,omitempty"`
        Status AzureMachineStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AzureMachineList contains a list of AzureMachine.
type AzureMachineList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []AzureMachine `json:"items"`
}

// GetConditions returns the list of conditions for an AzureMachine API object.
func (m *AzureMachine) GetConditions() clusterv1alpha4.Conditions <span class="cov0" title="0">{
        return m.Status.Conditions
}</span>

// SetConditions will set the given conditions on an AzureMachine object.
func (m *AzureMachine) SetConditions(conditions clusterv1alpha4.Conditions) <span class="cov0" title="0">{
        m.Status.Conditions = conditions
}</span>

// GetFutures returns the list of long running operation states for an AzureMachine API object.
func (m *AzureMachine) GetFutures() Futures <span class="cov0" title="0">{
        return m.Status.LongRunningOperationStates
}</span>

// SetFutures will set the given long running operation states on an AzureMachine object.
func (m *AzureMachine) SetFutures(futures Futures) <span class="cov0" title="0">{
        m.Status.LongRunningOperationStates = futures
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;AzureMachine{}, &amp;AzureMachineList{})
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha4

import (
        apimachineryconversion "k8s.io/apimachinery/pkg/conversion"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        utilconversion "sigs.k8s.io/cluster-api/util/conversion"
        "sigs.k8s.io/controller-runtime/pkg/conversion"
)

// ConvertTo converts this AzureMachineTemplate to the Hub version (v1beta1).
func (src *AzureMachineTemplate) ConvertTo(dstRaw conversion.Hub) error <span class="cov8" title="1">{
        dst := dstRaw.(*infrav1.AzureMachineTemplate)
        if err := Convert_v1alpha4_AzureMachineTemplate_To_v1beta1_AzureMachineTemplate(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Restore missing fields from annotations
        <span class="cov8" title="1">restored := &amp;infrav1.AzureMachineTemplate{}
        if ok, err := utilconversion.UnmarshalData(src, restored); err != nil || !ok </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if dst.Spec.Template.Spec.Image != nil &amp;&amp; restored.Spec.Template.Spec.Image.ComputeGallery != nil </span><span class="cov8" title="1">{
                dst.Spec.Template.Spec.Image.ComputeGallery = restored.Spec.Template.Spec.Image.ComputeGallery
        }</span>

        <span class="cov8" title="1">if restored.Spec.Template.Spec.AdditionalCapabilities != nil </span><span class="cov8" title="1">{
                dst.Spec.Template.Spec.AdditionalCapabilities = restored.Spec.Template.Spec.AdditionalCapabilities
        }</span>

        <span class="cov8" title="1">dst.Spec.Template.ObjectMeta = restored.Spec.Template.ObjectMeta

        if len(restored.Spec.Template.Spec.DNSServers) &gt; 0 </span><span class="cov8" title="1">{
                dst.Spec.Template.Spec.DNSServers = restored.Spec.Template.Spec.DNSServers
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureMachineTemplate) ConvertFrom(srcRaw conversion.Hub) error <span class="cov8" title="1">{
        src := srcRaw.(*infrav1.AzureMachineTemplate)
        if err := Convert_v1beta1_AzureMachineTemplate_To_v1alpha4_AzureMachineTemplate(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Preserve Hub data on down-conversion.
        <span class="cov8" title="1">return utilconversion.MarshalData(src, dst)</span>
}

// ConvertTo converts this AzureMachineTemplateList to the Hub version (v1beta1).
func (src *AzureMachineTemplateList) ConvertTo(dstRaw conversion.Hub) error <span class="cov0" title="0">{
        dst := dstRaw.(*infrav1.AzureMachineTemplateList)
        return Convert_v1alpha4_AzureMachineTemplateList_To_v1beta1_AzureMachineTemplateList(src, dst, nil)
}</span>

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureMachineTemplateList) ConvertFrom(srcRaw conversion.Hub) error <span class="cov0" title="0">{
        src := srcRaw.(*infrav1.AzureMachineTemplateList)
        return Convert_v1beta1_AzureMachineTemplateList_To_v1alpha4_AzureMachineTemplateList(src, dst, nil)
}</span>

// Convert_v1beta1_AzureMachineTemplateResource_To_v1alpha4_AzureMachineTemplateResource converts an Azure Machine Template Resource from v1beta1 to v1alpha4.
func Convert_v1beta1_AzureMachineTemplateResource_To_v1alpha4_AzureMachineTemplateResource(in *infrav1.AzureMachineTemplateResource, out *AzureMachineTemplateResource, s apimachineryconversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureMachineTemplateResource_To_v1alpha4_AzureMachineTemplateResource(in, out, s)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha4

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// AzureMachineTemplateSpec defines the desired state of AzureMachineTemplate.
type AzureMachineTemplateSpec struct {
        Template AzureMachineTemplateResource `json:"template"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:path=azuremachinetemplates,scope=Namespaced,categories=cluster-api

// AzureMachineTemplate is the Schema for the azuremachinetemplates API.
type AzureMachineTemplate struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec AzureMachineTemplateSpec `json:"spec,omitempty"`
}

// +kubebuilder:object:root=true

// AzureMachineTemplateList contains a list of AzureMachineTemplates.
type AzureMachineTemplateList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []AzureMachineTemplate `json:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;AzureMachineTemplate{}, &amp;AzureMachineTemplateList{})
}</span>

// AzureMachineTemplateResource describes the data needed to create an AzureMachine from a template.
type AzureMachineTemplateResource struct {
        // Spec is the specification of the desired behavior of the machine.
        Spec AzureMachineSpec `json:"spec"`
}
</pre>
		
		<pre class="file" id="file20" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha4

import (
        "fmt"
        "reflect"
)

// Tags defines a map of tags.
type Tags map[string]string

// Equals returns true if the tags are equal.
func (t Tags) Equals(other Tags) bool <span class="cov0" title="0">{
        return reflect.DeepEqual(t, other)
}</span>

// HasMatchingSpecVersionHash returns true if the resource has been tagged with a matching resource spec hash value.
func (t Tags) HasMatchingSpecVersionHash(hash string) bool <span class="cov0" title="0">{
        value, ok := t[SpecVersionHashTagKey()]
        return ok &amp;&amp; value == hash
}</span>

// HasOwned returns true if the tags contains a tag that marks the resource as owned by the cluster from the perspective of this management tooling.
func (t Tags) HasOwned(cluster string) bool <span class="cov0" title="0">{
        value, ok := t[ClusterTagKey(cluster)]
        return ok &amp;&amp; ResourceLifecycle(value) == ResourceLifecycleOwned
}</span>

// HasAzureCloudProviderOwned returns true if the tags contains a tag that marks the resource as owned by the cluster from the perspective of the in-tree cloud provider.
func (t Tags) HasAzureCloudProviderOwned(cluster string) bool <span class="cov0" title="0">{
        value, ok := t[ClusterAzureCloudProviderTagKey(cluster)]
        return ok &amp;&amp; ResourceLifecycle(value) == ResourceLifecycleOwned
}</span>

// GetRole returns the Cluster API role for the tagged resource.
func (t Tags) GetRole() string <span class="cov0" title="0">{
        return t[NameAzureClusterAPIRole]
}</span>

// Difference returns the difference between this map of tags and the other map of tags.
// Items are considered equals if key and value are equals.
func (t Tags) Difference(other Tags) Tags <span class="cov0" title="0">{
        res := make(Tags, len(t))

        for key, value := range t </span><span class="cov0" title="0">{
                if otherValue, ok := other[key]; ok &amp;&amp; value == otherValue </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">res[key] = value</span>
        }

        <span class="cov0" title="0">return res</span>
}

// Merge merges in tags from other. If a tag already exists, it is replaced by the tag in other.
func (t Tags) Merge(other Tags) <span class="cov8" title="1">{
        for k, v := range other </span><span class="cov8" title="1">{
                t[k] = v
        }</span>
}

// AddSpecVersionHashTag adds a spec version hash to the Azure resource tags to determine quickly if state has changed.
func (t Tags) AddSpecVersionHashTag(hash string) Tags <span class="cov0" title="0">{
        t[SpecVersionHashTagKey()] = hash
        return t
}</span>

// ResourceLifecycle configures the lifecycle of a resource.
type ResourceLifecycle string

const (
        // ResourceLifecycleOwned is the value we use when tagging resources to indicate
        // that the resource is considered owned and managed by the cluster,
        // and in particular that the lifecycle is tied to the lifecycle of the cluster.
        ResourceLifecycleOwned = ResourceLifecycle("owned")

        // ResourceLifecycleShared is the value we use when tagging resources to indicate
        // that the resource is shared between multiple clusters, and should not be destroyed
        // if the cluster is destroyed.
        ResourceLifecycleShared = ResourceLifecycle("shared")

        // NameKubernetesAzureCloudProviderPrefix is the tag name used by the cloud provider to logically
        // separate independent cluster resources. We use it to identify which resources we expect
        // to be permissive about state changes.
        // logically independent clusters running in the same AZ.
        // The tag key = NameKubernetesAzureCloudProviderPrefix + clusterID.
        // The tag value is an ownership value.
        NameKubernetesAzureCloudProviderPrefix = "kubernetes.io_cluster_"

        // NameAzureProviderPrefix is the tag prefix we use to differentiate
        // cluster-api-provider-azure owned components from other tooling that
        // uses NameKubernetesClusterPrefix.
        NameAzureProviderPrefix = "sigs.k8s.io_cluster-api-provider-azure_"

        // NameAzureProviderOwned is the tag name we use to differentiate
        // cluster-api-provider-azure owned components from other tooling that
        // uses NameKubernetesClusterPrefix.
        NameAzureProviderOwned = NameAzureProviderPrefix + "cluster_"

        // NameAzureClusterAPIRole is the tag name we use to mark roles for resources
        // dedicated to this cluster api provider implementation.
        NameAzureClusterAPIRole = NameAzureProviderPrefix + "role"

        // APIServerRole describes the value for the apiserver role.
        APIServerRole = "apiserver"

        // NodeOutboundRole describes the value for the node outbound LB role.
        NodeOutboundRole = "nodeOutbound"

        // ControlPlaneOutboundRole describes the value for the control plane outbound LB role.
        ControlPlaneOutboundRole = "controlPlaneOutbound"

        // BastionRole describes the value for the bastion role.
        BastionRole = "bastion"

        // CommonRole describes the value for the common role.
        CommonRole = "common"

        // VMTagsLastAppliedAnnotation is the key for the machine object annotation
        // which tracks the AdditionalTags in the Machine Provider Config.
        // See https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        // for annotation formatting rules.
        VMTagsLastAppliedAnnotation = "sigs.k8s.io/cluster-api-provider-azure-last-applied-tags-vm"
)

// SpecVersionHashTagKey is the key for the spec version hash used to enable quick spec difference comparison.
func SpecVersionHashTagKey() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s%s", NameAzureProviderPrefix, "spec-version-hash")
}</span>

// ClusterTagKey generates the key for resources associated with a cluster.
func ClusterTagKey(name string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s%s", NameAzureProviderOwned, name)
}</span>

// ClusterAzureCloudProviderTagKey generates the key for resources associated a cluster's Azure cloud provider.
func ClusterAzureCloudProviderTagKey(name string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s%s", NameKubernetesAzureCloudProviderPrefix, name)
}</span>

// BuildParams is used to build tags around an azure resource.
type BuildParams struct {
        // Lifecycle determines the resource lifecycle.
        Lifecycle ResourceLifecycle

        // ClusterName is the cluster associated with the resource.
        ClusterName string

        // ResourceID is the unique identifier of the resource to be tagged.
        ResourceID string

        // Name is the name of the resource, it's applied as the tag "Name" on Azure.
        // +optional
        Name *string

        // Role is the role associated to the resource.
        // +optional
        Role *string

        // Any additional tags to be added to the resource.
        // +optional
        Additional Tags
}

// Build builds tags including the cluster tag and returns them in map form.
func Build(params BuildParams) Tags <span class="cov0" title="0">{
        tags := make(Tags)
        for k, v := range params.Additional </span><span class="cov0" title="0">{
                tags[k] = v
        }</span>

        <span class="cov0" title="0">tags[ClusterTagKey(params.ClusterName)] = string(params.Lifecycle)
        if params.Role != nil </span><span class="cov0" title="0">{
                tags[NameAzureClusterAPIRole] = *params.Role
        }</span>

        <span class="cov0" title="0">if params.Name != nil </span><span class="cov0" title="0">{
                tags["Name"] = *params.Name
        }</span>

        <span class="cov0" title="0">return tags</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha4

import (
        "github.com/pkg/errors"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/resource"
)

const (
        // ControlPlane machine label.
        ControlPlane string = "control-plane"
        // Node machine label.
        Node string = "node"
)

// Futures is a slice of Future.
type Futures []Future

const (
        // PatchFuture is a future that was derived from a PATCH request.
        PatchFuture string = "PATCH"
        // PutFuture is a future that was derived from a PUT request.
        PutFuture string = "PUT"
        // DeleteFuture is a future that was derived from a DELETE request.
        DeleteFuture string = "DELETE"
)

// Future contains the data needed for an Azure long-running operation to continue across reconcile loops.
type Future struct {
        // Type describes the type of future, such as update, create, delete, etc.
        Type string `json:"type"`

        // ResourceGroup is the Azure resource group for the resource.
        // +optional
        ResourceGroup string `json:"resourceGroup,omitempty"`

        // ServiceName is the name of the Azure service.
        // Together with the name of the resource, this forms the unique identifier for the future.
        ServiceName string `json:"serviceName"`

        // Name is the name of the Azure resource.
        // Together with the service name, this forms the unique identifier for the future.
        Name string `json:"name"`

        // Data is the base64 url encoded json Azure AutoRest Future.
        Data string `json:"data,omitempty"`
}

// NetworkSpec specifies what the Azure networking resources should look like.
type NetworkSpec struct {
        // Vnet is the configuration for the Azure virtual network.
        // +optional
        Vnet VnetSpec `json:"vnet,omitempty"`

        // Subnets is the configuration for the control-plane subnet and the node subnet.
        // +optional
        Subnets Subnets `json:"subnets,omitempty"`

        // APIServerLB is the configuration for the control-plane load balancer.
        // +optional
        APIServerLB LoadBalancerSpec `json:"apiServerLB,omitempty"`

        // NodeOutboundLB is the configuration for the node outbound load balancer.
        // +optional
        NodeOutboundLB *LoadBalancerSpec `json:"nodeOutboundLB,omitempty"`

        // ControlPlaneOutboundLB is the configuration for the control-plane outbound load balancer.
        // This is different from APIServerLB, and is used only in private clusters (optionally) for enabling outbound traffic.
        // +optional
        ControlPlaneOutboundLB *LoadBalancerSpec `json:"controlPlaneOutboundLB,omitempty"`

        // PrivateDNSZoneName defines the zone name for the Azure Private DNS.
        // +optional
        PrivateDNSZoneName string `json:"privateDNSZoneName,omitempty"`
}

// VnetSpec configures an Azure virtual network.
type VnetSpec struct {
        // ResourceGroup is the name of the resource group of the existing virtual network
        // or the resource group where a managed virtual network should be created.
        ResourceGroup string `json:"resourceGroup,omitempty"`

        // ID is the identifier of the virtual network this provider should use to create resources.
        ID string `json:"id,omitempty"`

        // Name defines a name for the virtual network resource.
        Name string `json:"name"`

        // CIDRBlocks defines the virtual network's address space, specified as one or more address prefixes in CIDR notation.
        // +optional
        CIDRBlocks []string `json:"cidrBlocks,omitempty"`

        // Tags is a collection of tags describing the resource.
        // +optional
        Tags Tags `json:"tags,omitempty"`
}

// IsManaged returns true if the vnet is managed.
func (v *VnetSpec) IsManaged(clusterName string) bool <span class="cov0" title="0">{
        return v.ID == "" || v.Tags.HasOwned(clusterName)
}</span>

// Subnets is a slice of Subnet.
type Subnets []SubnetSpec

// SecurityGroup defines an Azure security group.
type SecurityGroup struct {
        ID            string        `json:"id,omitempty"`
        Name          string        `json:"name,omitempty"`
        SecurityRules SecurityRules `json:"securityRules,omitempty"`
        Tags          Tags          `json:"tags,omitempty"`
}

// RouteTable defines an Azure route table.
type RouteTable struct {
        ID   string `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}

// NatGateway defines an Azure Nat Gateway.
// NAT gateway resources are part of Vnet NAT and provide outbound Internet connectivity for subnets of a virtual network.
type NatGateway struct {
        ID           string       `json:"id,omitempty"`
        Name         string       `json:"name,omitempty"`
        NatGatewayIP PublicIPSpec `json:"ip,omitempty"`
}

// SecurityGroupProtocol defines the protocol type for a security group rule.
type SecurityGroupProtocol string

const (
        // SecurityGroupProtocolAll is a wildcard for all IP protocols.
        SecurityGroupProtocolAll = SecurityGroupProtocol("*")
        // SecurityGroupProtocolTCP represents the TCP protocol.
        SecurityGroupProtocolTCP = SecurityGroupProtocol("Tcp")
        // SecurityGroupProtocolUDP represents the UDP protocol.
        SecurityGroupProtocolUDP = SecurityGroupProtocol("Udp")
        // SecurityGroupProtocolICMP represents the ICMP protocol.
        SecurityGroupProtocolICMP = SecurityGroupProtocol("Icmp")
)

// SecurityRuleDirection defines the direction type for a security group rule.
type SecurityRuleDirection string

const (
        // SecurityRuleDirectionInbound defines an ingress security rule.
        SecurityRuleDirectionInbound = SecurityRuleDirection("Inbound")

        // SecurityRuleDirectionOutbound defines an egress security rule.
        SecurityRuleDirectionOutbound = SecurityRuleDirection("Outbound")
)

// SecurityRule defines an Azure security rule for security groups.
type SecurityRule struct {
        // Name is a unique name within the network security group.
        Name string `json:"name"`
        // A description for this rule. Restricted to 140 chars.
        Description string `json:"description"`
        // Protocol specifies the protocol type. "Tcp", "Udp", "Icmp", or "*".
        // +kubebuilder:validation:Enum=Tcp;Udp;Icmp;*
        Protocol SecurityGroupProtocol `json:"protocol"`
        // Direction indicates whether the rule applies to inbound, or outbound traffic. "Inbound" or "Outbound".
        // +kubebuilder:validation:Enum=Inbound;Outbound
        Direction SecurityRuleDirection `json:"direction"`
        // Priority is a number between 100 and 4096. Each rule should have a unique value for priority. Rules are processed in priority order, with lower numbers processed before higher numbers. Once traffic matches a rule, processing stops.
        Priority int32 `json:"priority,omitempty"`
        // SourcePorts specifies source port or range. Integer or range between 0 and 65535. Asterix '*' can also be used to match all ports.
        SourcePorts *string `json:"sourcePorts,omitempty"`
        // DestinationPorts specifies the destination port or range. Integer or range between 0 and 65535. Asterix '*' can also be used to match all ports.
        DestinationPorts *string `json:"destinationPorts,omitempty"`
        // Source specifies the CIDR or source IP range. Asterix '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used. If this is an ingress rule, specifies where network traffic originates from.
        Source *string `json:"source,omitempty"`
        // Destination is the destination address prefix. CIDR or destination IP range. Asterix '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used.
        Destination *string `json:"destination,omitempty"`
}

// SecurityRules is a slice of Azure security rules for security groups.
type SecurityRules []SecurityRule

// LoadBalancerSpec defines an Azure load balancer.
type LoadBalancerSpec struct {
        ID          string       `json:"id,omitempty"`
        Name        string       `json:"name,omitempty"`
        SKU         SKU          `json:"sku,omitempty"`
        FrontendIPs []FrontendIP `json:"frontendIPs,omitempty"`
        Type        LBType       `json:"type,omitempty"`
        // FrontendIPsCount specifies the number of frontend IP addresses for the load balancer.
        FrontendIPsCount *int32 `json:"frontendIPsCount,omitempty"`
        // IdleTimeoutInMinutes specifies the timeout for the TCP idle connection.
        IdleTimeoutInMinutes *int32 `json:"idleTimeoutInMinutes,omitempty"`
}

// SKU defines an Azure load balancer SKU.
type SKU string

const (
        // SKUStandard is the value for the Azure load balancer Standard SKU.
        SKUStandard = SKU("Standard")
)

// LBType defines an Azure load balancer Type.
type LBType string

const (
        // Internal is the value for the Azure load balancer internal type.
        Internal = LBType("Internal")
        // Public is the value for the Azure load balancer public type.
        Public = LBType("Public")
)

// FrontendIP defines a load balancer frontend IP configuration.
type FrontendIP struct {
        // +kubebuilder:validation:MinLength=1
        Name string `json:"name"`
        // +optional
        PrivateIPAddress string `json:"privateIP,omitempty"`
        // +optional
        PublicIP *PublicIPSpec `json:"publicIP,omitempty"`
}

// PublicIPSpec defines the inputs to create an Azure public IP address.
type PublicIPSpec struct {
        Name string `json:"name"`
        // +optional
        DNSName string `json:"dnsName,omitempty"`
}

// VMState describes the state of an Azure virtual machine.
// Deprecated: use ProvisioningState.
type VMState string

// ProvisioningState describes the provisioning state of an Azure resource.
type ProvisioningState string

const (
        // Creating ...
        Creating ProvisioningState = "Creating"
        // Deleting ...
        Deleting ProvisioningState = "Deleting"
        // Failed ...
        Failed ProvisioningState = "Failed"
        // Migrating ...
        Migrating ProvisioningState = "Migrating"
        // Succeeded ...
        Succeeded ProvisioningState = "Succeeded"
        // Updating ...
        Updating ProvisioningState = "Updating"
        // Canceled represents an action which was initiated but terminated by the user before completion.
        Canceled ProvisioningState = "Canceled"
        // Deleted represents a deleted VM
        // NOTE: This state is specific to capz, and does not have corresponding mapping in Azure API (https://docs.microsoft.com/en-us/azure/virtual-machines/states-billing#provisioning-states)
        Deleted ProvisioningState = "Deleted"
)

// VM describes an Azure virtual machine.
type VM struct {
        ID               string `json:"id,omitempty"`
        Name             string `json:"name,omitempty"`
        AvailabilityZone string `json:"availabilityZone,omitempty"`
        // Hardware profile
        VMSize string `json:"vmSize,omitempty"`
        // Storage profile
        Image         Image  `json:"image,omitempty"`
        OSDisk        OSDisk `json:"osDisk,omitempty"`
        StartupScript string `json:"startupScript,omitempty"`
        // State - The provisioning state, which only appears in the response.
        State    ProvisioningState `json:"vmState,omitempty"`
        Identity VMIdentity        `json:"identity,omitempty"`
        Tags     Tags              `json:"tags,omitempty"`

        // Addresses contains the addresses associated with the Azure VM.
        Addresses []corev1.NodeAddress `json:"addresses,omitempty"`
}

// Image defines information about the image to use for VM creation.
// There are three ways to specify an image: by ID, Marketplace Image or SharedImageGallery
// One of ID, SharedImage or Marketplace should be set.
type Image struct {
        // ID specifies an image to use by ID
        // +optional
        ID *string `json:"id,omitempty"`

        // SharedGallery specifies an image to use from an Azure Shared Image Gallery
        // +optional
        SharedGallery *AzureSharedGalleryImage `json:"sharedGallery,omitempty"`

        // Marketplace specifies an image to use from the Azure Marketplace
        // +optional
        Marketplace *AzureMarketplaceImage `json:"marketplace,omitempty"`
}

// AzureMarketplaceImage defines an image in the Azure Marketplace to use for VM creation.
type AzureMarketplaceImage struct {
        // Publisher is the name of the organization that created the image
        // +kubebuilder:validation:MinLength=1
        Publisher string `json:"publisher"`
        // Offer specifies the name of a group of related images created by the publisher.
        // For example, UbuntuServer, WindowsServer
        // +kubebuilder:validation:MinLength=1
        Offer string `json:"offer"`
        // SKU specifies an instance of an offer, such as a major release of a distribution.
        // For example, 18.04-LTS, 2019-Datacenter
        // +kubebuilder:validation:MinLength=1
        SKU string `json:"sku"`
        // Version specifies the version of an image sku. The allowed formats
        // are Major.Minor.Build or 'latest'. Major, Minor, and Build are decimal numbers.
        // Specify 'latest' to use the latest version of an image available at deploy time.
        // Even if you use 'latest', the VM image will not automatically update after deploy
        // time even if a new version becomes available.
        // +kubebuilder:validation:MinLength=1
        Version string `json:"version"`
        // ThirdPartyImage indicates the image is published by a third party publisher and a Plan
        // will be generated for it.
        // +kubebuilder:default=false
        // +optional
        ThirdPartyImage bool `json:"thirdPartyImage"`
}

// AzureSharedGalleryImage defines an image in a Shared Image Gallery to use for VM creation.
type AzureSharedGalleryImage struct {
        // SubscriptionID is the identifier of the subscription that contains the shared image gallery
        // +kubebuilder:validation:MinLength=1
        SubscriptionID string `json:"subscriptionID"`
        // ResourceGroup specifies the resource group containing the shared image gallery
        // +kubebuilder:validation:MinLength=1
        ResourceGroup string `json:"resourceGroup"`
        // Gallery specifies the name of the shared image gallery that contains the image
        // +kubebuilder:validation:MinLength=1
        Gallery string `json:"gallery"`
        // Name is the name of the image
        // +kubebuilder:validation:MinLength=1
        Name string `json:"name"`
        // Version specifies the version of the marketplace image. The allowed formats
        // are Major.Minor.Build or 'latest'. Major, Minor, and Build are decimal numbers.
        // Specify 'latest' to use the latest version of an image available at deploy time.
        // Even if you use 'latest', the VM image will not automatically update after deploy
        // time even if a new version becomes available.
        // +kubebuilder:validation:MinLength=1
        Version string `json:"version"`
        // Publisher is the name of the organization that created the image.
        // This value will be used to add a `Plan` in the API request when creating the VM/VMSS resource.
        // This is needed when the source image from which this SIG image was built requires the `Plan` to be used.
        // +optional
        Publisher *string `json:"publisher,omitempty"`
        // Offer specifies the name of a group of related images created by the publisher.
        // For example, UbuntuServer, WindowsServer
        // This value will be used to add a `Plan` in the API request when creating the VM/VMSS resource.
        // This is needed when the source image from which this SIG image was built requires the `Plan` to be used.
        // +optional
        Offer *string `json:"offer,omitempty"`
        // SKU specifies an instance of an offer, such as a major release of a distribution.
        // For example, 18.04-LTS, 2019-Datacenter
        // This value will be used to add a `Plan` in the API request when creating the VM/VMSS resource.
        // This is needed when the source image from which this SIG image was built requires the `Plan` to be used.
        // +optional
        SKU *string `json:"sku,omitempty"`
}

// VMIdentity defines the identity of the virtual machine, if configured.
// +kubebuilder:validation:Enum=None;SystemAssigned;UserAssigned
type VMIdentity string

const (
        // VMIdentityNone ...
        VMIdentityNone VMIdentity = "None"
        // VMIdentitySystemAssigned ...
        VMIdentitySystemAssigned VMIdentity = "SystemAssigned"
        // VMIdentityUserAssigned ...
        VMIdentityUserAssigned VMIdentity = "UserAssigned"
)

// UserAssignedIdentity defines the user-assigned identities provided
// by the user to be assigned to Azure resources.
type UserAssignedIdentity struct {
        // ProviderID is the identification ID of the user-assigned Identity, the format of an identity is:
        // 'azure:///subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'
        ProviderID string `json:"providerID"`
}

const (
        // AzureIdentityBindingSelector is the label used to match with the AzureIdentityBinding
        // For the controller to match an identity binding, it needs a [label] with the key `aadpodidbinding`
        // whose value is that of the `selector:` field in the `AzureIdentityBinding`.
        AzureIdentityBindingSelector = "capz-controller-aadpodidentity-selector"
)

// IdentityType represents different types of identities.
// +kubebuilder:validation:Enum=ServicePrincipal;UserAssignedMSI
type IdentityType string

const (
        // UserAssignedMSI represents a user-assigned identity.
        UserAssignedMSI IdentityType = "UserAssignedMSI"

        // ServicePrincipal represents a service principal.
        ServicePrincipal IdentityType = "ServicePrincipal"

        // ManualServicePrincipal represents a manual service principal.
        ManualServicePrincipal IdentityType = "ManualServicePrincipal"
)

// OSDisk defines the operating system disk for a VM.
//
// WARNING: this requires any updates to ManagedDisk to be manually converted. This is due to the odd issue with
// conversion-gen where the warning message generated uses a relative directory import rather than the fully
// qualified import when generating outside of the GOPATH.
type OSDisk struct {
        OSType string `json:"osType"`
        // DiskSizeGB is the size in GB to assign to the OS disk.
        // Will have a default of 30GB if not provided
        // +optional
        DiskSizeGB *int32 `json:"diskSizeGB,omitempty"`
        // ManagedDisk specifies the Managed Disk parameters for the OS disk.
        // +optional
        ManagedDisk      *ManagedDiskParameters `json:"managedDisk,omitempty"`
        DiffDiskSettings *DiffDiskSettings      `json:"diffDiskSettings,omitempty"`
        // CachingType specifies the caching requirements.
        // +optional
        // +kubebuilder:validation:Enum=None;ReadOnly;ReadWrite
        CachingType string `json:"cachingType,omitempty"`
}

// DataDisk specifies the parameters that are used to add one or more data disks to the machine.
type DataDisk struct {
        // NameSuffix is the suffix to be appended to the machine name to generate the disk name.
        // Each disk name will be in format &lt;machineName&gt;_&lt;nameSuffix&gt;.
        NameSuffix string `json:"nameSuffix"`
        // DiskSizeGB is the size in GB to assign to the data disk.
        DiskSizeGB int32 `json:"diskSizeGB"`
        // ManagedDisk specifies the Managed Disk parameters for the data disk.
        // +optional
        ManagedDisk *ManagedDiskParameters `json:"managedDisk,omitempty"`
        // Lun Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and therefore must be unique for each data disk attached to a VM.
        // The value must be between 0 and 63.
        Lun *int32 `json:"lun,omitempty"`
        // CachingType specifies the caching requirements.
        // +optional
        // +kubebuilder:validation:Enum=None;ReadOnly;ReadWrite
        CachingType string `json:"cachingType,omitempty"`
}

// ManagedDiskParameters defines the parameters of a managed disk.
type ManagedDiskParameters struct {
        // +optional
        StorageAccountType string `json:"storageAccountType,omitempty"`
        // +optional
        DiskEncryptionSet *DiskEncryptionSetParameters `json:"diskEncryptionSet,omitempty"`
}

// DiskEncryptionSetParameters defines disk encryption options.
type DiskEncryptionSetParameters struct {
        // ID defines resourceID for diskEncryptionSet resource. It must be in the same subscription
        ID string `json:"id,omitempty"`
}

// DiffDiskSettings describe ephemeral disk settings for the os disk.
type DiffDiskSettings struct {
        // Option enables ephemeral OS when set to "Local"
        // See https://docs.microsoft.com/en-us/azure/virtual-machines/ephemeral-os-disks for full details
        // +kubebuilder:validation:Enum=Local
        Option string `json:"option"`
}

// SubnetRole defines the unique role of a subnet.
type SubnetRole string

const (
        // SubnetNode defines a Kubernetes workload node role.
        SubnetNode = SubnetRole(Node)

        // SubnetControlPlane defines a Kubernetes control plane node role.
        SubnetControlPlane = SubnetRole(ControlPlane)
)

// SubnetSpec configures an Azure subnet.
type SubnetSpec struct {
        // Role defines the subnet role (eg. Node, ControlPlane)
        Role SubnetRole `json:"role,omitempty"`

        // ID defines a unique identifier to reference this resource.
        // +optional
        ID string `json:"id,omitempty"`

        // Name defines a name for the subnet resource.
        Name string `json:"name"`

        // CIDRBlocks defines the subnet's address space, specified as one or more address prefixes in CIDR notation.
        // +optional
        CIDRBlocks []string `json:"cidrBlocks,omitempty"`

        // SecurityGroup defines the NSG (network security group) that should be attached to this subnet.
        // +optional
        SecurityGroup SecurityGroup `json:"securityGroup,omitempty"`

        // RouteTable defines the route table that should be attached to this subnet.
        // +optional
        RouteTable RouteTable `json:"routeTable,omitempty"`

        // NatGateway associated with this subnet.
        // +optional
        NatGateway NatGateway `json:"natGateway,omitempty"`
}

// GetControlPlaneSubnet returns the cluster control plane subnet.
func (n *NetworkSpec) GetControlPlaneSubnet() (SubnetSpec, error) <span class="cov0" title="0">{
        for _, sn := range n.Subnets </span><span class="cov0" title="0">{
                if sn.Role == SubnetControlPlane </span><span class="cov0" title="0">{
                        return sn, nil
                }</span>
        }
        <span class="cov0" title="0">return SubnetSpec{}, errors.Errorf("no subnet found with role %s", SubnetControlPlane)</span>
}

// UpdateControlPlaneSubnet updates the cluster control plane subnet.
func (n *NetworkSpec) UpdateControlPlaneSubnet(subnet SubnetSpec) <span class="cov0" title="0">{
        for i, sn := range n.Subnets </span><span class="cov0" title="0">{
                if sn.Role == SubnetControlPlane </span><span class="cov0" title="0">{
                        n.Subnets[i] = subnet
                }</span>
        }
}

// UpdateNodeSubnet updates the cluster node subnet.
func (n *NetworkSpec) UpdateNodeSubnet(subnet SubnetSpec) <span class="cov0" title="0">{
        for i, sn := range n.Subnets </span><span class="cov0" title="0">{
                if sn.Role == SubnetNode </span><span class="cov0" title="0">{
                        n.Subnets[i] = subnet
                }</span>
        }
}

// IsNatGatewayEnabled returns whether or not a Nat Gateway is enabled on the subnet.
func (s SubnetSpec) IsNatGatewayEnabled() bool <span class="cov0" title="0">{
        return s.NatGateway.Name != ""
}</span>

// SecurityProfile specifies the Security profile settings for a
// virtual machine or virtual machine scale set.
type SecurityProfile struct {
        // This field indicates whether Host Encryption should be enabled
        // or disabled for a virtual machine or virtual machine scale
        // set. Default is disabled.
        EncryptionAtHost *bool `json:"encryptionAtHost,omitempty"`
}

// AddressRecord specifies a DNS record mapping a hostname to an IPV4 or IPv6 address.
type AddressRecord struct {
        Hostname string
        IP       string
}

// CloudProviderConfigOverrides represents the fields that can be overridden in azure cloud provider config.
type CloudProviderConfigOverrides struct {
        RateLimits []RateLimitSpec `json:"rateLimits,omitempty"`
        BackOffs   BackOffConfig   `json:"backOffs,omitempty"`
}

// BackOffConfig indicates the back-off config options.
type BackOffConfig struct {
        CloudProviderBackoff         bool               `json:"cloudProviderBackoff,omitempty"`
        CloudProviderBackoffRetries  int                `json:"cloudProviderBackoffRetries,omitempty"`
        CloudProviderBackoffExponent *resource.Quantity `json:"cloudProviderBackoffExponent,omitempty"`
        CloudProviderBackoffDuration int                `json:"cloudProviderBackoffDuration,omitempty"`
        CloudProviderBackoffJitter   *resource.Quantity `json:"cloudProviderBackoffJitter,omitempty"`
}

// RateLimitSpec represents the rate limit configuration for a particular kind of resource.
// Eg. loadBalancerRateLimit is used to configure rate limits for load balancers.
// This eventually gets converted to CloudProviderRateLimitConfig that cloud-provider-azure expects.
// See: https://github.com/kubernetes-sigs/cloud-provider-azure/blob/d585c2031925b39c925624302f22f8856e29e352/pkg/provider/azure_ratelimit.go#L25
// We cannot use CloudProviderRateLimitConfig directly because floating point values are not supported in controller-tools.
// See: https://github.com/kubernetes-sigs/controller-tools/issues/245
type RateLimitSpec struct {
        // Name is the name of the rate limit spec.
        // +kubebuilder:validation:Enum=defaultRateLimit;routeRateLimit;subnetsRateLimit;interfaceRateLimit;routeTableRateLimit;loadBalancerRateLimit;publicIPAddressRateLimit;securityGroupRateLimit;virtualMachineRateLimit;storageAccountRateLimit;diskRateLimit;snapshotRateLimit;virtualMachineScaleSetRateLimit;virtualMachineSizesRateLimit;availabilitySetRateLimit
        Name   string          `json:"name,omitempty"`
        Config RateLimitConfig `json:"config,omitempty"`
}

// RateLimitConfig indicates the rate limit config options.
type RateLimitConfig struct {
        CloudProviderRateLimit            bool               `json:"cloudProviderRateLimit,omitempty"`
        CloudProviderRateLimitQPS         *resource.Quantity `json:"cloudProviderRateLimitQPS,omitempty"`
        CloudProviderRateLimitBucket      int                `json:"cloudProviderRateLimitBucket,omitempty"`
        CloudProviderRateLimitQPSWrite    *resource.Quantity `json:"cloudProviderRateLimitQPSWrite,omitempty"`
        CloudProviderRateLimitBucketWrite int                `json:"cloudProviderRateLimitBucketWrite,omitempty"`
}

const (
        // DefaultRateLimit ...
        DefaultRateLimit = "defaultRateLimit"
        // RouteRateLimit ...
        RouteRateLimit = "routeRateLimit"
        // SubnetsRateLimit ...
        SubnetsRateLimit = "subnetsRateLimit"
        // InterfaceRateLimit ...
        InterfaceRateLimit = "interfaceRateLimit"
        // RouteTableRateLimit ...
        RouteTableRateLimit = "routeTableRateLimit"
        // LoadBalancerRateLimit ...
        LoadBalancerRateLimit = "loadBalancerRateLimit"
        // PublicIPAddressRateLimit ...
        PublicIPAddressRateLimit = "publicIPAddressRateLimit"
        // SecurityGroupRateLimit ...
        SecurityGroupRateLimit = "securityGroupRateLimit"
        // VirtualMachineRateLimit ...
        VirtualMachineRateLimit = "virtualMachineRateLimit"
        // StorageAccountRateLimit ...
        StorageAccountRateLimit = "storageAccountRateLimit"
        // DiskRateLimit ...
        DiskRateLimit = "diskRateLimit"
        // SnapshotRateLimit ...
        SnapshotRateLimit = "snapshotRateLimit"
        // VirtualMachineScaleSetRateLimit ...
        VirtualMachineScaleSetRateLimit = "virtualMachineScaleSetRateLimit"
        // VirtualMachineSizesRateLimit ...
        VirtualMachineSizesRateLimit = "virtualMachineSizesRateLimit"
        // AvailabilitySetRateLimit ...
        AvailabilitySetRateLimit = "availabilitySetRateLimit"
)

// BastionSpec specifies how the Bastion feature should be set up for the cluster.
type BastionSpec struct {
        // +optional
        AzureBastion *AzureBastion `json:"azureBastion,omitempty"`
}

// AzureBastion specifies how the Azure Bastion cloud component should be configured.
type AzureBastion struct {
        // +optional
        Name string `json:"name,omitempty"`
        // +optional
        Subnet SubnetSpec `json:"subnet,omitempty"`
        // +optional
        PublicIP PublicIPSpec `json:"publicIP,omitempty"`
}

// IsTerminalProvisioningState returns true if the ProvisioningState is a terminal state for an Azure resource.
func IsTerminalProvisioningState(state ProvisioningState) bool <span class="cov0" title="0">{
        return state == Failed || state == Succeeded
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">//go:build !ignore_autogenerated_core_v1alpha4
// +build !ignore_autogenerated_core_v1alpha4

/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by conversion-gen-v0.23.1. DO NOT EDIT.

package v1alpha4

import (
        unsafe "unsafe"

        corev1 "k8s.io/api/core/v1"
        resource "k8s.io/apimachinery/pkg/api/resource"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        conversion "k8s.io/apimachinery/pkg/conversion"
        runtime "k8s.io/apimachinery/pkg/runtime"
        v1beta1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        apiv1alpha4 "sigs.k8s.io/cluster-api/api/v1alpha4"
        apiv1beta1 "sigs.k8s.io/cluster-api/api/v1beta1"
        errors "sigs.k8s.io/cluster-api/errors"
)

func init() <span class="cov8" title="1">{
        localSchemeBuilder.Register(RegisterConversions)
}</span>

// RegisterConversions adds conversion functions to the given scheme.
// Public to allow building arbitrary schemes.
func RegisterConversions(s *runtime.Scheme) error <span class="cov0" title="0">{
        if err := s.AddGeneratedConversionFunc((*AddressRecord)(nil), (*v1beta1.AddressRecord)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AddressRecord_To_v1beta1_AddressRecord(a.(*AddressRecord), b.(*v1beta1.AddressRecord), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AddressRecord)(nil), (*AddressRecord)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AddressRecord_To_v1alpha4_AddressRecord(a.(*v1beta1.AddressRecord), b.(*AddressRecord), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AllowedNamespaces)(nil), (*v1beta1.AllowedNamespaces)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AllowedNamespaces_To_v1beta1_AllowedNamespaces(a.(*AllowedNamespaces), b.(*v1beta1.AllowedNamespaces), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AllowedNamespaces)(nil), (*AllowedNamespaces)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AllowedNamespaces_To_v1alpha4_AllowedNamespaces(a.(*v1beta1.AllowedNamespaces), b.(*AllowedNamespaces), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureBastion)(nil), (*v1beta1.AzureBastion)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureBastion_To_v1beta1_AzureBastion(a.(*AzureBastion), b.(*v1beta1.AzureBastion), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureBastion)(nil), (*AzureBastion)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureBastion_To_v1alpha4_AzureBastion(a.(*v1beta1.AzureBastion), b.(*AzureBastion), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureCluster)(nil), (*v1beta1.AzureCluster)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureCluster_To_v1beta1_AzureCluster(a.(*AzureCluster), b.(*v1beta1.AzureCluster), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureCluster)(nil), (*AzureCluster)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureCluster_To_v1alpha4_AzureCluster(a.(*v1beta1.AzureCluster), b.(*AzureCluster), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureClusterIdentity)(nil), (*v1beta1.AzureClusterIdentity)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureClusterIdentity_To_v1beta1_AzureClusterIdentity(a.(*AzureClusterIdentity), b.(*v1beta1.AzureClusterIdentity), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureClusterIdentity)(nil), (*AzureClusterIdentity)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureClusterIdentity_To_v1alpha4_AzureClusterIdentity(a.(*v1beta1.AzureClusterIdentity), b.(*AzureClusterIdentity), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureClusterIdentityList)(nil), (*v1beta1.AzureClusterIdentityList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureClusterIdentityList_To_v1beta1_AzureClusterIdentityList(a.(*AzureClusterIdentityList), b.(*v1beta1.AzureClusterIdentityList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureClusterIdentityList)(nil), (*AzureClusterIdentityList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureClusterIdentityList_To_v1alpha4_AzureClusterIdentityList(a.(*v1beta1.AzureClusterIdentityList), b.(*AzureClusterIdentityList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureClusterIdentitySpec)(nil), (*v1beta1.AzureClusterIdentitySpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureClusterIdentitySpec_To_v1beta1_AzureClusterIdentitySpec(a.(*AzureClusterIdentitySpec), b.(*v1beta1.AzureClusterIdentitySpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureClusterIdentitySpec)(nil), (*AzureClusterIdentitySpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureClusterIdentitySpec_To_v1alpha4_AzureClusterIdentitySpec(a.(*v1beta1.AzureClusterIdentitySpec), b.(*AzureClusterIdentitySpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureClusterIdentityStatus)(nil), (*v1beta1.AzureClusterIdentityStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureClusterIdentityStatus_To_v1beta1_AzureClusterIdentityStatus(a.(*AzureClusterIdentityStatus), b.(*v1beta1.AzureClusterIdentityStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureClusterIdentityStatus)(nil), (*AzureClusterIdentityStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureClusterIdentityStatus_To_v1alpha4_AzureClusterIdentityStatus(a.(*v1beta1.AzureClusterIdentityStatus), b.(*AzureClusterIdentityStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureClusterList)(nil), (*v1beta1.AzureClusterList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureClusterList_To_v1beta1_AzureClusterList(a.(*AzureClusterList), b.(*v1beta1.AzureClusterList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureClusterList)(nil), (*AzureClusterList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureClusterList_To_v1alpha4_AzureClusterList(a.(*v1beta1.AzureClusterList), b.(*AzureClusterList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureClusterStatus)(nil), (*v1beta1.AzureClusterStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureClusterStatus_To_v1beta1_AzureClusterStatus(a.(*AzureClusterStatus), b.(*v1beta1.AzureClusterStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureClusterStatus)(nil), (*AzureClusterStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureClusterStatus_To_v1alpha4_AzureClusterStatus(a.(*v1beta1.AzureClusterStatus), b.(*AzureClusterStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureMachine)(nil), (*v1beta1.AzureMachine)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureMachine_To_v1beta1_AzureMachine(a.(*AzureMachine), b.(*v1beta1.AzureMachine), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureMachine)(nil), (*AzureMachine)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachine_To_v1alpha4_AzureMachine(a.(*v1beta1.AzureMachine), b.(*AzureMachine), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureMachineList)(nil), (*v1beta1.AzureMachineList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureMachineList_To_v1beta1_AzureMachineList(a.(*AzureMachineList), b.(*v1beta1.AzureMachineList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureMachineList)(nil), (*AzureMachineList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachineList_To_v1alpha4_AzureMachineList(a.(*v1beta1.AzureMachineList), b.(*AzureMachineList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureMachineSpec)(nil), (*v1beta1.AzureMachineSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureMachineSpec_To_v1beta1_AzureMachineSpec(a.(*AzureMachineSpec), b.(*v1beta1.AzureMachineSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureMachineStatus)(nil), (*v1beta1.AzureMachineStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureMachineStatus_To_v1beta1_AzureMachineStatus(a.(*AzureMachineStatus), b.(*v1beta1.AzureMachineStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureMachineStatus)(nil), (*AzureMachineStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachineStatus_To_v1alpha4_AzureMachineStatus(a.(*v1beta1.AzureMachineStatus), b.(*AzureMachineStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureMachineTemplate)(nil), (*v1beta1.AzureMachineTemplate)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureMachineTemplate_To_v1beta1_AzureMachineTemplate(a.(*AzureMachineTemplate), b.(*v1beta1.AzureMachineTemplate), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureMachineTemplate)(nil), (*AzureMachineTemplate)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachineTemplate_To_v1alpha4_AzureMachineTemplate(a.(*v1beta1.AzureMachineTemplate), b.(*AzureMachineTemplate), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureMachineTemplateList)(nil), (*v1beta1.AzureMachineTemplateList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureMachineTemplateList_To_v1beta1_AzureMachineTemplateList(a.(*AzureMachineTemplateList), b.(*v1beta1.AzureMachineTemplateList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureMachineTemplateList)(nil), (*AzureMachineTemplateList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachineTemplateList_To_v1alpha4_AzureMachineTemplateList(a.(*v1beta1.AzureMachineTemplateList), b.(*AzureMachineTemplateList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureMachineTemplateResource)(nil), (*v1beta1.AzureMachineTemplateResource)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureMachineTemplateResource_To_v1beta1_AzureMachineTemplateResource(a.(*AzureMachineTemplateResource), b.(*v1beta1.AzureMachineTemplateResource), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureMachineTemplateSpec)(nil), (*v1beta1.AzureMachineTemplateSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureMachineTemplateSpec_To_v1beta1_AzureMachineTemplateSpec(a.(*AzureMachineTemplateSpec), b.(*v1beta1.AzureMachineTemplateSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureMachineTemplateSpec)(nil), (*AzureMachineTemplateSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachineTemplateSpec_To_v1alpha4_AzureMachineTemplateSpec(a.(*v1beta1.AzureMachineTemplateSpec), b.(*AzureMachineTemplateSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureSharedGalleryImage)(nil), (*v1beta1.AzureSharedGalleryImage)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureSharedGalleryImage_To_v1beta1_AzureSharedGalleryImage(a.(*AzureSharedGalleryImage), b.(*v1beta1.AzureSharedGalleryImage), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureSharedGalleryImage)(nil), (*AzureSharedGalleryImage)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureSharedGalleryImage_To_v1alpha4_AzureSharedGalleryImage(a.(*v1beta1.AzureSharedGalleryImage), b.(*AzureSharedGalleryImage), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*BackOffConfig)(nil), (*v1beta1.BackOffConfig)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_BackOffConfig_To_v1beta1_BackOffConfig(a.(*BackOffConfig), b.(*v1beta1.BackOffConfig), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.BackOffConfig)(nil), (*BackOffConfig)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_BackOffConfig_To_v1alpha4_BackOffConfig(a.(*v1beta1.BackOffConfig), b.(*BackOffConfig), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*BastionSpec)(nil), (*v1beta1.BastionSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_BastionSpec_To_v1beta1_BastionSpec(a.(*BastionSpec), b.(*v1beta1.BastionSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.BastionSpec)(nil), (*BastionSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_BastionSpec_To_v1alpha4_BastionSpec(a.(*v1beta1.BastionSpec), b.(*BastionSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*BuildParams)(nil), (*v1beta1.BuildParams)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_BuildParams_To_v1beta1_BuildParams(a.(*BuildParams), b.(*v1beta1.BuildParams), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.BuildParams)(nil), (*BuildParams)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_BuildParams_To_v1alpha4_BuildParams(a.(*v1beta1.BuildParams), b.(*BuildParams), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*CloudProviderConfigOverrides)(nil), (*v1beta1.CloudProviderConfigOverrides)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_CloudProviderConfigOverrides_To_v1beta1_CloudProviderConfigOverrides(a.(*CloudProviderConfigOverrides), b.(*v1beta1.CloudProviderConfigOverrides), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.CloudProviderConfigOverrides)(nil), (*CloudProviderConfigOverrides)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_CloudProviderConfigOverrides_To_v1alpha4_CloudProviderConfigOverrides(a.(*v1beta1.CloudProviderConfigOverrides), b.(*CloudProviderConfigOverrides), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*DataDisk)(nil), (*v1beta1.DataDisk)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_DataDisk_To_v1beta1_DataDisk(a.(*DataDisk), b.(*v1beta1.DataDisk), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.DataDisk)(nil), (*DataDisk)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_DataDisk_To_v1alpha4_DataDisk(a.(*v1beta1.DataDisk), b.(*DataDisk), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*DiffDiskSettings)(nil), (*v1beta1.DiffDiskSettings)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_DiffDiskSettings_To_v1beta1_DiffDiskSettings(a.(*DiffDiskSettings), b.(*v1beta1.DiffDiskSettings), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.DiffDiskSettings)(nil), (*DiffDiskSettings)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_DiffDiskSettings_To_v1alpha4_DiffDiskSettings(a.(*v1beta1.DiffDiskSettings), b.(*DiffDiskSettings), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*DiskEncryptionSetParameters)(nil), (*v1beta1.DiskEncryptionSetParameters)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_DiskEncryptionSetParameters_To_v1beta1_DiskEncryptionSetParameters(a.(*DiskEncryptionSetParameters), b.(*v1beta1.DiskEncryptionSetParameters), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.DiskEncryptionSetParameters)(nil), (*DiskEncryptionSetParameters)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_DiskEncryptionSetParameters_To_v1alpha4_DiskEncryptionSetParameters(a.(*v1beta1.DiskEncryptionSetParameters), b.(*DiskEncryptionSetParameters), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*Future)(nil), (*v1beta1.Future)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_Future_To_v1beta1_Future(a.(*Future), b.(*v1beta1.Future), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.Future)(nil), (*Future)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_Future_To_v1alpha4_Future(a.(*v1beta1.Future), b.(*Future), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*Image)(nil), (*v1beta1.Image)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_Image_To_v1beta1_Image(a.(*Image), b.(*v1beta1.Image), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*ManagedDiskParameters)(nil), (*v1beta1.ManagedDiskParameters)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_ManagedDiskParameters_To_v1beta1_ManagedDiskParameters(a.(*ManagedDiskParameters), b.(*v1beta1.ManagedDiskParameters), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.ManagedDiskParameters)(nil), (*ManagedDiskParameters)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_ManagedDiskParameters_To_v1alpha4_ManagedDiskParameters(a.(*v1beta1.ManagedDiskParameters), b.(*ManagedDiskParameters), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*OSDisk)(nil), (*v1beta1.OSDisk)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_OSDisk_To_v1beta1_OSDisk(a.(*OSDisk), b.(*v1beta1.OSDisk), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.OSDisk)(nil), (*OSDisk)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_OSDisk_To_v1alpha4_OSDisk(a.(*v1beta1.OSDisk), b.(*OSDisk), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*PublicIPSpec)(nil), (*v1beta1.PublicIPSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_PublicIPSpec_To_v1beta1_PublicIPSpec(a.(*PublicIPSpec), b.(*v1beta1.PublicIPSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*RateLimitConfig)(nil), (*v1beta1.RateLimitConfig)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_RateLimitConfig_To_v1beta1_RateLimitConfig(a.(*RateLimitConfig), b.(*v1beta1.RateLimitConfig), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.RateLimitConfig)(nil), (*RateLimitConfig)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_RateLimitConfig_To_v1alpha4_RateLimitConfig(a.(*v1beta1.RateLimitConfig), b.(*RateLimitConfig), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*RateLimitSpec)(nil), (*v1beta1.RateLimitSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_RateLimitSpec_To_v1beta1_RateLimitSpec(a.(*RateLimitSpec), b.(*v1beta1.RateLimitSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.RateLimitSpec)(nil), (*RateLimitSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_RateLimitSpec_To_v1alpha4_RateLimitSpec(a.(*v1beta1.RateLimitSpec), b.(*RateLimitSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*RouteTable)(nil), (*v1beta1.RouteTable)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_RouteTable_To_v1beta1_RouteTable(a.(*RouteTable), b.(*v1beta1.RouteTable), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.RouteTable)(nil), (*RouteTable)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_RouteTable_To_v1alpha4_RouteTable(a.(*v1beta1.RouteTable), b.(*RouteTable), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*SecurityProfile)(nil), (*v1beta1.SecurityProfile)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_SecurityProfile_To_v1beta1_SecurityProfile(a.(*SecurityProfile), b.(*v1beta1.SecurityProfile), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.SecurityProfile)(nil), (*SecurityProfile)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_SecurityProfile_To_v1alpha4_SecurityProfile(a.(*v1beta1.SecurityProfile), b.(*SecurityProfile), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*SecurityRule)(nil), (*v1beta1.SecurityRule)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_SecurityRule_To_v1beta1_SecurityRule(a.(*SecurityRule), b.(*v1beta1.SecurityRule), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.SecurityRule)(nil), (*SecurityRule)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_SecurityRule_To_v1alpha4_SecurityRule(a.(*v1beta1.SecurityRule), b.(*SecurityRule), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*SpotVMOptions)(nil), (*v1beta1.SpotVMOptions)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_SpotVMOptions_To_v1beta1_SpotVMOptions(a.(*SpotVMOptions), b.(*v1beta1.SpotVMOptions), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.SpotVMOptions)(nil), (*SpotVMOptions)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_SpotVMOptions_To_v1alpha4_SpotVMOptions(a.(*v1beta1.SpotVMOptions), b.(*SpotVMOptions), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*UserAssignedIdentity)(nil), (*v1beta1.UserAssignedIdentity)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_UserAssignedIdentity_To_v1beta1_UserAssignedIdentity(a.(*UserAssignedIdentity), b.(*v1beta1.UserAssignedIdentity), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.UserAssignedIdentity)(nil), (*UserAssignedIdentity)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_UserAssignedIdentity_To_v1alpha4_UserAssignedIdentity(a.(*v1beta1.UserAssignedIdentity), b.(*UserAssignedIdentity), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*AzureClusterSpec)(nil), (*v1beta1.AzureClusterSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureClusterSpec_To_v1beta1_AzureClusterSpec(a.(*AzureClusterSpec), b.(*v1beta1.AzureClusterSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*AzureMarketplaceImage)(nil), (*v1beta1.AzureMarketplaceImage)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureMarketplaceImage_To_v1beta1_AzureMarketplaceImage(a.(*AzureMarketplaceImage), b.(*v1beta1.AzureMarketplaceImage), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*FrontendIP)(nil), (*v1beta1.FrontendIP)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_FrontendIP_To_v1beta1_FrontendIP(a.(*FrontendIP), b.(*v1beta1.FrontendIP), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*LoadBalancerSpec)(nil), (*v1beta1.LoadBalancerSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_LoadBalancerSpec_To_v1beta1_LoadBalancerSpec(a.(*LoadBalancerSpec), b.(*v1beta1.LoadBalancerSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*NatGateway)(nil), (*v1beta1.NatGateway)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_NatGateway_To_v1beta1_NatGateway(a.(*NatGateway), b.(*v1beta1.NatGateway), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*NetworkSpec)(nil), (*v1beta1.NetworkSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_NetworkSpec_To_v1beta1_NetworkSpec(a.(*NetworkSpec), b.(*v1beta1.NetworkSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*SecurityGroup)(nil), (*v1beta1.SecurityGroup)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_SecurityGroup_To_v1beta1_SecurityGroup(a.(*SecurityGroup), b.(*v1beta1.SecurityGroup), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*SubnetSpec)(nil), (*v1beta1.SubnetSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_SubnetSpec_To_v1beta1_SubnetSpec(a.(*SubnetSpec), b.(*v1beta1.SubnetSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*VnetSpec)(nil), (*v1beta1.VnetSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_VnetSpec_To_v1beta1_VnetSpec(a.(*VnetSpec), b.(*v1beta1.VnetSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.AzureClusterSpec)(nil), (*AzureClusterSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureClusterSpec_To_v1alpha4_AzureClusterSpec(a.(*v1beta1.AzureClusterSpec), b.(*AzureClusterSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.AzureMachineSpec)(nil), (*AzureMachineSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachineSpec_To_v1alpha4_AzureMachineSpec(a.(*v1beta1.AzureMachineSpec), b.(*AzureMachineSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.AzureMachineTemplateResource)(nil), (*AzureMachineTemplateResource)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachineTemplateResource_To_v1alpha4_AzureMachineTemplateResource(a.(*v1beta1.AzureMachineTemplateResource), b.(*AzureMachineTemplateResource), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.AzureMarketplaceImage)(nil), (*AzureMarketplaceImage)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMarketplaceImage_To_v1alpha4_AzureMarketplaceImage(a.(*v1beta1.AzureMarketplaceImage), b.(*AzureMarketplaceImage), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.FrontendIP)(nil), (*FrontendIP)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_FrontendIP_To_v1alpha4_FrontendIP(a.(*v1beta1.FrontendIP), b.(*FrontendIP), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.Image)(nil), (*Image)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_Image_To_v1alpha4_Image(a.(*v1beta1.Image), b.(*Image), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.LoadBalancerSpec)(nil), (*LoadBalancerSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_LoadBalancerSpec_To_v1alpha4_LoadBalancerSpec(a.(*v1beta1.LoadBalancerSpec), b.(*LoadBalancerSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.NatGateway)(nil), (*NatGateway)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_NatGateway_To_v1alpha4_NatGateway(a.(*v1beta1.NatGateway), b.(*NatGateway), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.NetworkSpec)(nil), (*NetworkSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_NetworkSpec_To_v1alpha4_NetworkSpec(a.(*v1beta1.NetworkSpec), b.(*NetworkSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.PublicIPSpec)(nil), (*PublicIPSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_PublicIPSpec_To_v1alpha4_PublicIPSpec(a.(*v1beta1.PublicIPSpec), b.(*PublicIPSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.SecurityGroup)(nil), (*SecurityGroup)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_SecurityGroup_To_v1alpha4_SecurityGroup(a.(*v1beta1.SecurityGroup), b.(*SecurityGroup), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.SubnetSpec)(nil), (*SubnetSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_SubnetSpec_To_v1alpha4_SubnetSpec(a.(*v1beta1.SubnetSpec), b.(*SubnetSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.VnetSpec)(nil), (*VnetSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_VnetSpec_To_v1alpha4_VnetSpec(a.(*v1beta1.VnetSpec), b.(*VnetSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func autoConvert_v1alpha4_AddressRecord_To_v1beta1_AddressRecord(in *AddressRecord, out *v1beta1.AddressRecord, s conversion.Scope) error <span class="cov0" title="0">{
        out.Hostname = in.Hostname
        out.IP = in.IP
        return nil
}</span>

// Convert_v1alpha4_AddressRecord_To_v1beta1_AddressRecord is an autogenerated conversion function.
func Convert_v1alpha4_AddressRecord_To_v1beta1_AddressRecord(in *AddressRecord, out *v1beta1.AddressRecord, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_AddressRecord_To_v1beta1_AddressRecord(in, out, s)
}</span>

func autoConvert_v1beta1_AddressRecord_To_v1alpha4_AddressRecord(in *v1beta1.AddressRecord, out *AddressRecord, s conversion.Scope) error <span class="cov0" title="0">{
        out.Hostname = in.Hostname
        out.IP = in.IP
        return nil
}</span>

// Convert_v1beta1_AddressRecord_To_v1alpha4_AddressRecord is an autogenerated conversion function.
func Convert_v1beta1_AddressRecord_To_v1alpha4_AddressRecord(in *v1beta1.AddressRecord, out *AddressRecord, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_AddressRecord_To_v1alpha4_AddressRecord(in, out, s)
}</span>

func autoConvert_v1alpha4_AllowedNamespaces_To_v1beta1_AllowedNamespaces(in *AllowedNamespaces, out *v1beta1.AllowedNamespaces, s conversion.Scope) error <span class="cov0" title="0">{
        out.NamespaceList = *(*[]string)(unsafe.Pointer(&amp;in.NamespaceList))
        out.Selector = (*v1.LabelSelector)(unsafe.Pointer(in.Selector))
        return nil
}</span>

// Convert_v1alpha4_AllowedNamespaces_To_v1beta1_AllowedNamespaces is an autogenerated conversion function.
func Convert_v1alpha4_AllowedNamespaces_To_v1beta1_AllowedNamespaces(in *AllowedNamespaces, out *v1beta1.AllowedNamespaces, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_AllowedNamespaces_To_v1beta1_AllowedNamespaces(in, out, s)
}</span>

func autoConvert_v1beta1_AllowedNamespaces_To_v1alpha4_AllowedNamespaces(in *v1beta1.AllowedNamespaces, out *AllowedNamespaces, s conversion.Scope) error <span class="cov0" title="0">{
        out.NamespaceList = *(*[]string)(unsafe.Pointer(&amp;in.NamespaceList))
        out.Selector = (*v1.LabelSelector)(unsafe.Pointer(in.Selector))
        return nil
}</span>

// Convert_v1beta1_AllowedNamespaces_To_v1alpha4_AllowedNamespaces is an autogenerated conversion function.
func Convert_v1beta1_AllowedNamespaces_To_v1alpha4_AllowedNamespaces(in *v1beta1.AllowedNamespaces, out *AllowedNamespaces, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_AllowedNamespaces_To_v1alpha4_AllowedNamespaces(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureBastion_To_v1beta1_AzureBastion(in *AzureBastion, out *v1beta1.AzureBastion, s conversion.Scope) error <span class="cov8" title="1">{
        out.Name = in.Name
        if err := Convert_v1alpha4_SubnetSpec_To_v1beta1_SubnetSpec(&amp;in.Subnet, &amp;out.Subnet, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1alpha4_PublicIPSpec_To_v1beta1_PublicIPSpec(&amp;in.PublicIP, &amp;out.PublicIP, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha4_AzureBastion_To_v1beta1_AzureBastion is an autogenerated conversion function.
func Convert_v1alpha4_AzureBastion_To_v1beta1_AzureBastion(in *AzureBastion, out *v1beta1.AzureBastion, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_AzureBastion_To_v1beta1_AzureBastion(in, out, s)
}</span>

func autoConvert_v1beta1_AzureBastion_To_v1alpha4_AzureBastion(in *v1beta1.AzureBastion, out *AzureBastion, s conversion.Scope) error <span class="cov8" title="1">{
        out.Name = in.Name
        if err := Convert_v1beta1_SubnetSpec_To_v1alpha4_SubnetSpec(&amp;in.Subnet, &amp;out.Subnet, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1beta1_PublicIPSpec_To_v1alpha4_PublicIPSpec(&amp;in.PublicIP, &amp;out.PublicIP, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1beta1_AzureBastion_To_v1alpha4_AzureBastion is an autogenerated conversion function.
func Convert_v1beta1_AzureBastion_To_v1alpha4_AzureBastion(in *v1beta1.AzureBastion, out *AzureBastion, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureBastion_To_v1alpha4_AzureBastion(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureCluster_To_v1beta1_AzureCluster(in *AzureCluster, out *v1beta1.AzureCluster, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1alpha4_AzureClusterSpec_To_v1beta1_AzureClusterSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1alpha4_AzureClusterStatus_To_v1beta1_AzureClusterStatus(&amp;in.Status, &amp;out.Status, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha4_AzureCluster_To_v1beta1_AzureCluster is an autogenerated conversion function.
func Convert_v1alpha4_AzureCluster_To_v1beta1_AzureCluster(in *AzureCluster, out *v1beta1.AzureCluster, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_AzureCluster_To_v1beta1_AzureCluster(in, out, s)
}</span>

func autoConvert_v1beta1_AzureCluster_To_v1alpha4_AzureCluster(in *v1beta1.AzureCluster, out *AzureCluster, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1beta1_AzureClusterSpec_To_v1alpha4_AzureClusterSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1beta1_AzureClusterStatus_To_v1alpha4_AzureClusterStatus(&amp;in.Status, &amp;out.Status, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1beta1_AzureCluster_To_v1alpha4_AzureCluster is an autogenerated conversion function.
func Convert_v1beta1_AzureCluster_To_v1alpha4_AzureCluster(in *v1beta1.AzureCluster, out *AzureCluster, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureCluster_To_v1alpha4_AzureCluster(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureClusterIdentity_To_v1beta1_AzureClusterIdentity(in *AzureClusterIdentity, out *v1beta1.AzureClusterIdentity, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1alpha4_AzureClusterIdentitySpec_To_v1beta1_AzureClusterIdentitySpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1alpha4_AzureClusterIdentityStatus_To_v1beta1_AzureClusterIdentityStatus(&amp;in.Status, &amp;out.Status, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha4_AzureClusterIdentity_To_v1beta1_AzureClusterIdentity is an autogenerated conversion function.
func Convert_v1alpha4_AzureClusterIdentity_To_v1beta1_AzureClusterIdentity(in *AzureClusterIdentity, out *v1beta1.AzureClusterIdentity, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_AzureClusterIdentity_To_v1beta1_AzureClusterIdentity(in, out, s)
}</span>

func autoConvert_v1beta1_AzureClusterIdentity_To_v1alpha4_AzureClusterIdentity(in *v1beta1.AzureClusterIdentity, out *AzureClusterIdentity, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1beta1_AzureClusterIdentitySpec_To_v1alpha4_AzureClusterIdentitySpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1beta1_AzureClusterIdentityStatus_To_v1alpha4_AzureClusterIdentityStatus(&amp;in.Status, &amp;out.Status, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1beta1_AzureClusterIdentity_To_v1alpha4_AzureClusterIdentity is an autogenerated conversion function.
func Convert_v1beta1_AzureClusterIdentity_To_v1alpha4_AzureClusterIdentity(in *v1beta1.AzureClusterIdentity, out *AzureClusterIdentity, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureClusterIdentity_To_v1alpha4_AzureClusterIdentity(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureClusterIdentityList_To_v1beta1_AzureClusterIdentityList(in *AzureClusterIdentityList, out *v1beta1.AzureClusterIdentityList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]v1beta1.AzureClusterIdentity, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1alpha4_AzureClusterIdentity_To_v1beta1_AzureClusterIdentity(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1alpha4_AzureClusterIdentityList_To_v1beta1_AzureClusterIdentityList is an autogenerated conversion function.
func Convert_v1alpha4_AzureClusterIdentityList_To_v1beta1_AzureClusterIdentityList(in *AzureClusterIdentityList, out *v1beta1.AzureClusterIdentityList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_AzureClusterIdentityList_To_v1beta1_AzureClusterIdentityList(in, out, s)
}</span>

func autoConvert_v1beta1_AzureClusterIdentityList_To_v1alpha4_AzureClusterIdentityList(in *v1beta1.AzureClusterIdentityList, out *AzureClusterIdentityList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureClusterIdentity, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1beta1_AzureClusterIdentity_To_v1alpha4_AzureClusterIdentity(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1beta1_AzureClusterIdentityList_To_v1alpha4_AzureClusterIdentityList is an autogenerated conversion function.
func Convert_v1beta1_AzureClusterIdentityList_To_v1alpha4_AzureClusterIdentityList(in *v1beta1.AzureClusterIdentityList, out *AzureClusterIdentityList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_AzureClusterIdentityList_To_v1alpha4_AzureClusterIdentityList(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureClusterIdentitySpec_To_v1beta1_AzureClusterIdentitySpec(in *AzureClusterIdentitySpec, out *v1beta1.AzureClusterIdentitySpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.Type = v1beta1.IdentityType(in.Type)
        out.ResourceID = in.ResourceID
        out.ClientID = in.ClientID
        out.ClientSecret = in.ClientSecret
        out.TenantID = in.TenantID
        out.AllowedNamespaces = (*v1beta1.AllowedNamespaces)(unsafe.Pointer(in.AllowedNamespaces))
        return nil
}</span>

// Convert_v1alpha4_AzureClusterIdentitySpec_To_v1beta1_AzureClusterIdentitySpec is an autogenerated conversion function.
func Convert_v1alpha4_AzureClusterIdentitySpec_To_v1beta1_AzureClusterIdentitySpec(in *AzureClusterIdentitySpec, out *v1beta1.AzureClusterIdentitySpec, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_AzureClusterIdentitySpec_To_v1beta1_AzureClusterIdentitySpec(in, out, s)
}</span>

func autoConvert_v1beta1_AzureClusterIdentitySpec_To_v1alpha4_AzureClusterIdentitySpec(in *v1beta1.AzureClusterIdentitySpec, out *AzureClusterIdentitySpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.Type = IdentityType(in.Type)
        out.ResourceID = in.ResourceID
        out.ClientID = in.ClientID
        out.ClientSecret = in.ClientSecret
        out.TenantID = in.TenantID
        out.AllowedNamespaces = (*AllowedNamespaces)(unsafe.Pointer(in.AllowedNamespaces))
        return nil
}</span>

// Convert_v1beta1_AzureClusterIdentitySpec_To_v1alpha4_AzureClusterIdentitySpec is an autogenerated conversion function.
func Convert_v1beta1_AzureClusterIdentitySpec_To_v1alpha4_AzureClusterIdentitySpec(in *v1beta1.AzureClusterIdentitySpec, out *AzureClusterIdentitySpec, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureClusterIdentitySpec_To_v1alpha4_AzureClusterIdentitySpec(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureClusterIdentityStatus_To_v1beta1_AzureClusterIdentityStatus(in *AzureClusterIdentityStatus, out *v1beta1.AzureClusterIdentityStatus, s conversion.Scope) error <span class="cov8" title="1">{
        if in.Conditions != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make(apiv1beta1.Conditions, len(*in))
                for i := range *in </span><span class="cov8" title="1">{
                        if err := apiv1alpha4.Convert_v1alpha4_Condition_To_v1beta1_Condition(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                out.Conditions = nil
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha4_AzureClusterIdentityStatus_To_v1beta1_AzureClusterIdentityStatus is an autogenerated conversion function.
func Convert_v1alpha4_AzureClusterIdentityStatus_To_v1beta1_AzureClusterIdentityStatus(in *AzureClusterIdentityStatus, out *v1beta1.AzureClusterIdentityStatus, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_AzureClusterIdentityStatus_To_v1beta1_AzureClusterIdentityStatus(in, out, s)
}</span>

func autoConvert_v1beta1_AzureClusterIdentityStatus_To_v1alpha4_AzureClusterIdentityStatus(in *v1beta1.AzureClusterIdentityStatus, out *AzureClusterIdentityStatus, s conversion.Scope) error <span class="cov8" title="1">{
        if in.Conditions != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make(apiv1alpha4.Conditions, len(*in))
                for i := range *in </span><span class="cov8" title="1">{
                        if err := apiv1alpha4.Convert_v1beta1_Condition_To_v1alpha4_Condition(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                out.Conditions = nil
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1beta1_AzureClusterIdentityStatus_To_v1alpha4_AzureClusterIdentityStatus is an autogenerated conversion function.
func Convert_v1beta1_AzureClusterIdentityStatus_To_v1alpha4_AzureClusterIdentityStatus(in *v1beta1.AzureClusterIdentityStatus, out *AzureClusterIdentityStatus, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureClusterIdentityStatus_To_v1alpha4_AzureClusterIdentityStatus(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureClusterList_To_v1beta1_AzureClusterList(in *AzureClusterList, out *v1beta1.AzureClusterList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]v1beta1.AzureCluster, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1alpha4_AzureCluster_To_v1beta1_AzureCluster(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1alpha4_AzureClusterList_To_v1beta1_AzureClusterList is an autogenerated conversion function.
func Convert_v1alpha4_AzureClusterList_To_v1beta1_AzureClusterList(in *AzureClusterList, out *v1beta1.AzureClusterList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_AzureClusterList_To_v1beta1_AzureClusterList(in, out, s)
}</span>

func autoConvert_v1beta1_AzureClusterList_To_v1alpha4_AzureClusterList(in *v1beta1.AzureClusterList, out *AzureClusterList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureCluster, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1beta1_AzureCluster_To_v1alpha4_AzureCluster(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1beta1_AzureClusterList_To_v1alpha4_AzureClusterList is an autogenerated conversion function.
func Convert_v1beta1_AzureClusterList_To_v1alpha4_AzureClusterList(in *v1beta1.AzureClusterList, out *AzureClusterList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_AzureClusterList_To_v1alpha4_AzureClusterList(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureClusterSpec_To_v1beta1_AzureClusterSpec(in *AzureClusterSpec, out *v1beta1.AzureClusterSpec, s conversion.Scope) error <span class="cov8" title="1">{
        if err := Convert_v1alpha4_NetworkSpec_To_v1beta1_NetworkSpec(&amp;in.NetworkSpec, &amp;out.NetworkSpec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">out.ResourceGroup = in.ResourceGroup
        // WARNING: in.SubscriptionID requires manual conversion: does not exist in peer-type
        // WARNING: in.Location requires manual conversion: does not exist in peer-type
        if err := apiv1alpha4.Convert_v1alpha4_APIEndpoint_To_v1beta1_APIEndpoint(&amp;in.ControlPlaneEndpoint, &amp;out.ControlPlaneEndpoint, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // WARNING: in.AdditionalTags requires manual conversion: does not exist in peer-type
        // WARNING: in.IdentityRef requires manual conversion: does not exist in peer-type
        // WARNING: in.AzureEnvironment requires manual conversion: does not exist in peer-type
        <span class="cov8" title="1">if err := Convert_v1alpha4_BastionSpec_To_v1beta1_BastionSpec(&amp;in.BastionSpec, &amp;out.BastionSpec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // WARNING: in.CloudProviderConfigOverrides requires manual conversion: does not exist in peer-type
        <span class="cov8" title="1">return nil</span>
}

func autoConvert_v1beta1_AzureClusterSpec_To_v1alpha4_AzureClusterSpec(in *v1beta1.AzureClusterSpec, out *AzureClusterSpec, s conversion.Scope) error <span class="cov8" title="1">{
        // WARNING: in.AzureClusterClassSpec requires manual conversion: does not exist in peer-type
        if err := Convert_v1beta1_NetworkSpec_To_v1alpha4_NetworkSpec(&amp;in.NetworkSpec, &amp;out.NetworkSpec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">out.ResourceGroup = in.ResourceGroup
        if err := Convert_v1beta1_BastionSpec_To_v1alpha4_BastionSpec(&amp;in.BastionSpec, &amp;out.BastionSpec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := apiv1alpha4.Convert_v1beta1_APIEndpoint_To_v1alpha4_APIEndpoint(&amp;in.ControlPlaneEndpoint, &amp;out.ControlPlaneEndpoint, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func autoConvert_v1alpha4_AzureClusterStatus_To_v1beta1_AzureClusterStatus(in *AzureClusterStatus, out *v1beta1.AzureClusterStatus, s conversion.Scope) error <span class="cov8" title="1">{
        if in.FailureDomains != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.FailureDomains, &amp;out.FailureDomains
                *out = make(apiv1beta1.FailureDomains, len(*in))
                for key, val := range *in </span><span class="cov8" title="1">{
                        newVal := new(apiv1beta1.FailureDomainSpec)
                        if err := apiv1alpha4.Convert_v1alpha4_FailureDomainSpec_To_v1beta1_FailureDomainSpec(&amp;val, newVal, s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">(*out)[key] = *newVal</span>
                }
        } else<span class="cov8" title="1"> {
                out.FailureDomains = nil
        }</span>
        <span class="cov8" title="1">out.Ready = in.Ready
        if in.Conditions != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make(apiv1beta1.Conditions, len(*in))
                for i := range *in </span><span class="cov8" title="1">{
                        if err := apiv1alpha4.Convert_v1alpha4_Condition_To_v1beta1_Condition(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                out.Conditions = nil
        }</span>
        <span class="cov8" title="1">out.LongRunningOperationStates = *(*v1beta1.Futures)(unsafe.Pointer(&amp;in.LongRunningOperationStates))
        return nil</span>
}

// Convert_v1alpha4_AzureClusterStatus_To_v1beta1_AzureClusterStatus is an autogenerated conversion function.
func Convert_v1alpha4_AzureClusterStatus_To_v1beta1_AzureClusterStatus(in *AzureClusterStatus, out *v1beta1.AzureClusterStatus, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_AzureClusterStatus_To_v1beta1_AzureClusterStatus(in, out, s)
}</span>

func autoConvert_v1beta1_AzureClusterStatus_To_v1alpha4_AzureClusterStatus(in *v1beta1.AzureClusterStatus, out *AzureClusterStatus, s conversion.Scope) error <span class="cov8" title="1">{
        if in.FailureDomains != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.FailureDomains, &amp;out.FailureDomains
                *out = make(apiv1alpha4.FailureDomains, len(*in))
                for key, val := range *in </span><span class="cov8" title="1">{
                        newVal := new(apiv1alpha4.FailureDomainSpec)
                        if err := apiv1alpha4.Convert_v1beta1_FailureDomainSpec_To_v1alpha4_FailureDomainSpec(&amp;val, newVal, s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">(*out)[key] = *newVal</span>
                }
        } else<span class="cov8" title="1"> {
                out.FailureDomains = nil
        }</span>
        <span class="cov8" title="1">out.Ready = in.Ready
        if in.Conditions != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make(apiv1alpha4.Conditions, len(*in))
                for i := range *in </span><span class="cov8" title="1">{
                        if err := apiv1alpha4.Convert_v1beta1_Condition_To_v1alpha4_Condition(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                out.Conditions = nil
        }</span>
        <span class="cov8" title="1">out.LongRunningOperationStates = *(*Futures)(unsafe.Pointer(&amp;in.LongRunningOperationStates))
        return nil</span>
}

// Convert_v1beta1_AzureClusterStatus_To_v1alpha4_AzureClusterStatus is an autogenerated conversion function.
func Convert_v1beta1_AzureClusterStatus_To_v1alpha4_AzureClusterStatus(in *v1beta1.AzureClusterStatus, out *AzureClusterStatus, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureClusterStatus_To_v1alpha4_AzureClusterStatus(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureMachine_To_v1beta1_AzureMachine(in *AzureMachine, out *v1beta1.AzureMachine, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1alpha4_AzureMachineSpec_To_v1beta1_AzureMachineSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1alpha4_AzureMachineStatus_To_v1beta1_AzureMachineStatus(&amp;in.Status, &amp;out.Status, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha4_AzureMachine_To_v1beta1_AzureMachine is an autogenerated conversion function.
func Convert_v1alpha4_AzureMachine_To_v1beta1_AzureMachine(in *AzureMachine, out *v1beta1.AzureMachine, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_AzureMachine_To_v1beta1_AzureMachine(in, out, s)
}</span>

func autoConvert_v1beta1_AzureMachine_To_v1alpha4_AzureMachine(in *v1beta1.AzureMachine, out *AzureMachine, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1beta1_AzureMachineSpec_To_v1alpha4_AzureMachineSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1beta1_AzureMachineStatus_To_v1alpha4_AzureMachineStatus(&amp;in.Status, &amp;out.Status, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1beta1_AzureMachine_To_v1alpha4_AzureMachine is an autogenerated conversion function.
func Convert_v1beta1_AzureMachine_To_v1alpha4_AzureMachine(in *v1beta1.AzureMachine, out *AzureMachine, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureMachine_To_v1alpha4_AzureMachine(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureMachineList_To_v1beta1_AzureMachineList(in *AzureMachineList, out *v1beta1.AzureMachineList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]v1beta1.AzureMachine, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1alpha4_AzureMachine_To_v1beta1_AzureMachine(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1alpha4_AzureMachineList_To_v1beta1_AzureMachineList is an autogenerated conversion function.
func Convert_v1alpha4_AzureMachineList_To_v1beta1_AzureMachineList(in *AzureMachineList, out *v1beta1.AzureMachineList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_AzureMachineList_To_v1beta1_AzureMachineList(in, out, s)
}</span>

func autoConvert_v1beta1_AzureMachineList_To_v1alpha4_AzureMachineList(in *v1beta1.AzureMachineList, out *AzureMachineList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureMachine, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1beta1_AzureMachine_To_v1alpha4_AzureMachine(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1beta1_AzureMachineList_To_v1alpha4_AzureMachineList is an autogenerated conversion function.
func Convert_v1beta1_AzureMachineList_To_v1alpha4_AzureMachineList(in *v1beta1.AzureMachineList, out *AzureMachineList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_AzureMachineList_To_v1alpha4_AzureMachineList(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureMachineSpec_To_v1beta1_AzureMachineSpec(in *AzureMachineSpec, out *v1beta1.AzureMachineSpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.ProviderID = (*string)(unsafe.Pointer(in.ProviderID))
        out.VMSize = in.VMSize
        out.FailureDomain = (*string)(unsafe.Pointer(in.FailureDomain))
        if in.Image != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Image, &amp;out.Image
                *out = new(v1beta1.Image)
                if err := Convert_v1alpha4_Image_To_v1beta1_Image(*in, *out, s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                out.Image = nil
        }</span>
        <span class="cov8" title="1">out.Identity = v1beta1.VMIdentity(in.Identity)
        out.UserAssignedIdentities = *(*[]v1beta1.UserAssignedIdentity)(unsafe.Pointer(&amp;in.UserAssignedIdentities))
        out.RoleAssignmentName = in.RoleAssignmentName
        if err := Convert_v1alpha4_OSDisk_To_v1beta1_OSDisk(&amp;in.OSDisk, &amp;out.OSDisk, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">out.DataDisks = *(*[]v1beta1.DataDisk)(unsafe.Pointer(&amp;in.DataDisks))
        out.SSHPublicKey = in.SSHPublicKey
        out.AdditionalTags = *(*v1beta1.Tags)(unsafe.Pointer(&amp;in.AdditionalTags))
        out.AllocatePublicIP = in.AllocatePublicIP
        out.EnableIPForwarding = in.EnableIPForwarding
        out.AcceleratedNetworking = (*bool)(unsafe.Pointer(in.AcceleratedNetworking))
        out.SpotVMOptions = (*v1beta1.SpotVMOptions)(unsafe.Pointer(in.SpotVMOptions))
        out.SecurityProfile = (*v1beta1.SecurityProfile)(unsafe.Pointer(in.SecurityProfile))
        out.SubnetName = in.SubnetName
        return nil</span>
}

// Convert_v1alpha4_AzureMachineSpec_To_v1beta1_AzureMachineSpec is an autogenerated conversion function.
func Convert_v1alpha4_AzureMachineSpec_To_v1beta1_AzureMachineSpec(in *AzureMachineSpec, out *v1beta1.AzureMachineSpec, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_AzureMachineSpec_To_v1beta1_AzureMachineSpec(in, out, s)
}</span>

func autoConvert_v1beta1_AzureMachineSpec_To_v1alpha4_AzureMachineSpec(in *v1beta1.AzureMachineSpec, out *AzureMachineSpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.ProviderID = (*string)(unsafe.Pointer(in.ProviderID))
        out.VMSize = in.VMSize
        out.FailureDomain = (*string)(unsafe.Pointer(in.FailureDomain))
        if in.Image != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Image, &amp;out.Image
                *out = new(Image)
                if err := Convert_v1beta1_Image_To_v1alpha4_Image(*in, *out, s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                out.Image = nil
        }</span>
        <span class="cov8" title="1">out.Identity = VMIdentity(in.Identity)
        out.UserAssignedIdentities = *(*[]UserAssignedIdentity)(unsafe.Pointer(&amp;in.UserAssignedIdentities))
        out.RoleAssignmentName = in.RoleAssignmentName
        if err := Convert_v1beta1_OSDisk_To_v1alpha4_OSDisk(&amp;in.OSDisk, &amp;out.OSDisk, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">out.DataDisks = *(*[]DataDisk)(unsafe.Pointer(&amp;in.DataDisks))
        out.SSHPublicKey = in.SSHPublicKey
        out.AdditionalTags = *(*Tags)(unsafe.Pointer(&amp;in.AdditionalTags))
        // WARNING: in.AdditionalCapabilities requires manual conversion: does not exist in peer-type
        out.AllocatePublicIP = in.AllocatePublicIP
        out.EnableIPForwarding = in.EnableIPForwarding
        out.AcceleratedNetworking = (*bool)(unsafe.Pointer(in.AcceleratedNetworking))
        out.SpotVMOptions = (*SpotVMOptions)(unsafe.Pointer(in.SpotVMOptions))
        out.SecurityProfile = (*SecurityProfile)(unsafe.Pointer(in.SecurityProfile))
        out.SubnetName = in.SubnetName
        // WARNING: in.DNSServers requires manual conversion: does not exist in peer-type
        return nil</span>
}

func autoConvert_v1alpha4_AzureMachineStatus_To_v1beta1_AzureMachineStatus(in *AzureMachineStatus, out *v1beta1.AzureMachineStatus, s conversion.Scope) error <span class="cov8" title="1">{
        out.Ready = in.Ready
        out.Addresses = *(*[]corev1.NodeAddress)(unsafe.Pointer(&amp;in.Addresses))
        out.VMState = (*v1beta1.ProvisioningState)(unsafe.Pointer(in.VMState))
        out.FailureReason = (*errors.MachineStatusError)(unsafe.Pointer(in.FailureReason))
        out.FailureMessage = (*string)(unsafe.Pointer(in.FailureMessage))
        if in.Conditions != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make(apiv1beta1.Conditions, len(*in))
                for i := range *in </span><span class="cov8" title="1">{
                        if err := apiv1alpha4.Convert_v1alpha4_Condition_To_v1beta1_Condition(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                out.Conditions = nil
        }</span>
        <span class="cov8" title="1">out.LongRunningOperationStates = *(*v1beta1.Futures)(unsafe.Pointer(&amp;in.LongRunningOperationStates))
        return nil</span>
}

// Convert_v1alpha4_AzureMachineStatus_To_v1beta1_AzureMachineStatus is an autogenerated conversion function.
func Convert_v1alpha4_AzureMachineStatus_To_v1beta1_AzureMachineStatus(in *AzureMachineStatus, out *v1beta1.AzureMachineStatus, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_AzureMachineStatus_To_v1beta1_AzureMachineStatus(in, out, s)
}</span>

func autoConvert_v1beta1_AzureMachineStatus_To_v1alpha4_AzureMachineStatus(in *v1beta1.AzureMachineStatus, out *AzureMachineStatus, s conversion.Scope) error <span class="cov8" title="1">{
        out.Ready = in.Ready
        out.Addresses = *(*[]corev1.NodeAddress)(unsafe.Pointer(&amp;in.Addresses))
        out.VMState = (*ProvisioningState)(unsafe.Pointer(in.VMState))
        out.FailureReason = (*errors.MachineStatusError)(unsafe.Pointer(in.FailureReason))
        out.FailureMessage = (*string)(unsafe.Pointer(in.FailureMessage))
        if in.Conditions != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make(apiv1alpha4.Conditions, len(*in))
                for i := range *in </span><span class="cov8" title="1">{
                        if err := apiv1alpha4.Convert_v1beta1_Condition_To_v1alpha4_Condition(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                out.Conditions = nil
        }</span>
        <span class="cov8" title="1">out.LongRunningOperationStates = *(*Futures)(unsafe.Pointer(&amp;in.LongRunningOperationStates))
        return nil</span>
}

// Convert_v1beta1_AzureMachineStatus_To_v1alpha4_AzureMachineStatus is an autogenerated conversion function.
func Convert_v1beta1_AzureMachineStatus_To_v1alpha4_AzureMachineStatus(in *v1beta1.AzureMachineStatus, out *AzureMachineStatus, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureMachineStatus_To_v1alpha4_AzureMachineStatus(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureMachineTemplate_To_v1beta1_AzureMachineTemplate(in *AzureMachineTemplate, out *v1beta1.AzureMachineTemplate, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1alpha4_AzureMachineTemplateSpec_To_v1beta1_AzureMachineTemplateSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha4_AzureMachineTemplate_To_v1beta1_AzureMachineTemplate is an autogenerated conversion function.
func Convert_v1alpha4_AzureMachineTemplate_To_v1beta1_AzureMachineTemplate(in *AzureMachineTemplate, out *v1beta1.AzureMachineTemplate, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_AzureMachineTemplate_To_v1beta1_AzureMachineTemplate(in, out, s)
}</span>

func autoConvert_v1beta1_AzureMachineTemplate_To_v1alpha4_AzureMachineTemplate(in *v1beta1.AzureMachineTemplate, out *AzureMachineTemplate, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1beta1_AzureMachineTemplateSpec_To_v1alpha4_AzureMachineTemplateSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1beta1_AzureMachineTemplate_To_v1alpha4_AzureMachineTemplate is an autogenerated conversion function.
func Convert_v1beta1_AzureMachineTemplate_To_v1alpha4_AzureMachineTemplate(in *v1beta1.AzureMachineTemplate, out *AzureMachineTemplate, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureMachineTemplate_To_v1alpha4_AzureMachineTemplate(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureMachineTemplateList_To_v1beta1_AzureMachineTemplateList(in *AzureMachineTemplateList, out *v1beta1.AzureMachineTemplateList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]v1beta1.AzureMachineTemplate, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1alpha4_AzureMachineTemplate_To_v1beta1_AzureMachineTemplate(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1alpha4_AzureMachineTemplateList_To_v1beta1_AzureMachineTemplateList is an autogenerated conversion function.
func Convert_v1alpha4_AzureMachineTemplateList_To_v1beta1_AzureMachineTemplateList(in *AzureMachineTemplateList, out *v1beta1.AzureMachineTemplateList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_AzureMachineTemplateList_To_v1beta1_AzureMachineTemplateList(in, out, s)
}</span>

func autoConvert_v1beta1_AzureMachineTemplateList_To_v1alpha4_AzureMachineTemplateList(in *v1beta1.AzureMachineTemplateList, out *AzureMachineTemplateList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureMachineTemplate, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1beta1_AzureMachineTemplate_To_v1alpha4_AzureMachineTemplate(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1beta1_AzureMachineTemplateList_To_v1alpha4_AzureMachineTemplateList is an autogenerated conversion function.
func Convert_v1beta1_AzureMachineTemplateList_To_v1alpha4_AzureMachineTemplateList(in *v1beta1.AzureMachineTemplateList, out *AzureMachineTemplateList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_AzureMachineTemplateList_To_v1alpha4_AzureMachineTemplateList(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureMachineTemplateResource_To_v1beta1_AzureMachineTemplateResource(in *AzureMachineTemplateResource, out *v1beta1.AzureMachineTemplateResource, s conversion.Scope) error <span class="cov8" title="1">{
        if err := Convert_v1alpha4_AzureMachineSpec_To_v1beta1_AzureMachineSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha4_AzureMachineTemplateResource_To_v1beta1_AzureMachineTemplateResource is an autogenerated conversion function.
func Convert_v1alpha4_AzureMachineTemplateResource_To_v1beta1_AzureMachineTemplateResource(in *AzureMachineTemplateResource, out *v1beta1.AzureMachineTemplateResource, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_AzureMachineTemplateResource_To_v1beta1_AzureMachineTemplateResource(in, out, s)
}</span>

func autoConvert_v1beta1_AzureMachineTemplateResource_To_v1alpha4_AzureMachineTemplateResource(in *v1beta1.AzureMachineTemplateResource, out *AzureMachineTemplateResource, s conversion.Scope) error <span class="cov8" title="1">{
        // WARNING: in.ObjectMeta requires manual conversion: does not exist in peer-type
        if err := Convert_v1beta1_AzureMachineSpec_To_v1alpha4_AzureMachineSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func autoConvert_v1alpha4_AzureMachineTemplateSpec_To_v1beta1_AzureMachineTemplateSpec(in *AzureMachineTemplateSpec, out *v1beta1.AzureMachineTemplateSpec, s conversion.Scope) error <span class="cov8" title="1">{
        if err := Convert_v1alpha4_AzureMachineTemplateResource_To_v1beta1_AzureMachineTemplateResource(&amp;in.Template, &amp;out.Template, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha4_AzureMachineTemplateSpec_To_v1beta1_AzureMachineTemplateSpec is an autogenerated conversion function.
func Convert_v1alpha4_AzureMachineTemplateSpec_To_v1beta1_AzureMachineTemplateSpec(in *AzureMachineTemplateSpec, out *v1beta1.AzureMachineTemplateSpec, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_AzureMachineTemplateSpec_To_v1beta1_AzureMachineTemplateSpec(in, out, s)
}</span>

func autoConvert_v1beta1_AzureMachineTemplateSpec_To_v1alpha4_AzureMachineTemplateSpec(in *v1beta1.AzureMachineTemplateSpec, out *AzureMachineTemplateSpec, s conversion.Scope) error <span class="cov8" title="1">{
        if err := Convert_v1beta1_AzureMachineTemplateResource_To_v1alpha4_AzureMachineTemplateResource(&amp;in.Template, &amp;out.Template, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1beta1_AzureMachineTemplateSpec_To_v1alpha4_AzureMachineTemplateSpec is an autogenerated conversion function.
func Convert_v1beta1_AzureMachineTemplateSpec_To_v1alpha4_AzureMachineTemplateSpec(in *v1beta1.AzureMachineTemplateSpec, out *AzureMachineTemplateSpec, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureMachineTemplateSpec_To_v1alpha4_AzureMachineTemplateSpec(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureMarketplaceImage_To_v1beta1_AzureMarketplaceImage(in *AzureMarketplaceImage, out *v1beta1.AzureMarketplaceImage, s conversion.Scope) error <span class="cov8" title="1">{
        // WARNING: in.Publisher requires manual conversion: does not exist in peer-type
        // WARNING: in.Offer requires manual conversion: does not exist in peer-type
        // WARNING: in.SKU requires manual conversion: does not exist in peer-type
        out.Version = in.Version
        out.ThirdPartyImage = in.ThirdPartyImage
        return nil
}</span>

func autoConvert_v1beta1_AzureMarketplaceImage_To_v1alpha4_AzureMarketplaceImage(in *v1beta1.AzureMarketplaceImage, out *AzureMarketplaceImage, s conversion.Scope) error <span class="cov8" title="1">{
        // WARNING: in.ImagePlan requires manual conversion: does not exist in peer-type
        out.Version = in.Version
        out.ThirdPartyImage = in.ThirdPartyImage
        return nil
}</span>

func autoConvert_v1alpha4_AzureSharedGalleryImage_To_v1beta1_AzureSharedGalleryImage(in *AzureSharedGalleryImage, out *v1beta1.AzureSharedGalleryImage, s conversion.Scope) error <span class="cov0" title="0">{
        out.SubscriptionID = in.SubscriptionID
        out.ResourceGroup = in.ResourceGroup
        out.Gallery = in.Gallery
        out.Name = in.Name
        out.Version = in.Version
        out.Publisher = (*string)(unsafe.Pointer(in.Publisher))
        out.Offer = (*string)(unsafe.Pointer(in.Offer))
        out.SKU = (*string)(unsafe.Pointer(in.SKU))
        return nil
}</span>

// Convert_v1alpha4_AzureSharedGalleryImage_To_v1beta1_AzureSharedGalleryImage is an autogenerated conversion function.
func Convert_v1alpha4_AzureSharedGalleryImage_To_v1beta1_AzureSharedGalleryImage(in *AzureSharedGalleryImage, out *v1beta1.AzureSharedGalleryImage, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_AzureSharedGalleryImage_To_v1beta1_AzureSharedGalleryImage(in, out, s)
}</span>

func autoConvert_v1beta1_AzureSharedGalleryImage_To_v1alpha4_AzureSharedGalleryImage(in *v1beta1.AzureSharedGalleryImage, out *AzureSharedGalleryImage, s conversion.Scope) error <span class="cov0" title="0">{
        out.SubscriptionID = in.SubscriptionID
        out.ResourceGroup = in.ResourceGroup
        out.Gallery = in.Gallery
        out.Name = in.Name
        out.Version = in.Version
        out.Publisher = (*string)(unsafe.Pointer(in.Publisher))
        out.Offer = (*string)(unsafe.Pointer(in.Offer))
        out.SKU = (*string)(unsafe.Pointer(in.SKU))
        return nil
}</span>

// Convert_v1beta1_AzureSharedGalleryImage_To_v1alpha4_AzureSharedGalleryImage is an autogenerated conversion function.
func Convert_v1beta1_AzureSharedGalleryImage_To_v1alpha4_AzureSharedGalleryImage(in *v1beta1.AzureSharedGalleryImage, out *AzureSharedGalleryImage, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_AzureSharedGalleryImage_To_v1alpha4_AzureSharedGalleryImage(in, out, s)
}</span>

func autoConvert_v1alpha4_BackOffConfig_To_v1beta1_BackOffConfig(in *BackOffConfig, out *v1beta1.BackOffConfig, s conversion.Scope) error <span class="cov0" title="0">{
        out.CloudProviderBackoff = in.CloudProviderBackoff
        out.CloudProviderBackoffRetries = in.CloudProviderBackoffRetries
        out.CloudProviderBackoffExponent = (*resource.Quantity)(unsafe.Pointer(in.CloudProviderBackoffExponent))
        out.CloudProviderBackoffDuration = in.CloudProviderBackoffDuration
        out.CloudProviderBackoffJitter = (*resource.Quantity)(unsafe.Pointer(in.CloudProviderBackoffJitter))
        return nil
}</span>

// Convert_v1alpha4_BackOffConfig_To_v1beta1_BackOffConfig is an autogenerated conversion function.
func Convert_v1alpha4_BackOffConfig_To_v1beta1_BackOffConfig(in *BackOffConfig, out *v1beta1.BackOffConfig, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_BackOffConfig_To_v1beta1_BackOffConfig(in, out, s)
}</span>

func autoConvert_v1beta1_BackOffConfig_To_v1alpha4_BackOffConfig(in *v1beta1.BackOffConfig, out *BackOffConfig, s conversion.Scope) error <span class="cov0" title="0">{
        out.CloudProviderBackoff = in.CloudProviderBackoff
        out.CloudProviderBackoffRetries = in.CloudProviderBackoffRetries
        out.CloudProviderBackoffExponent = (*resource.Quantity)(unsafe.Pointer(in.CloudProviderBackoffExponent))
        out.CloudProviderBackoffDuration = in.CloudProviderBackoffDuration
        out.CloudProviderBackoffJitter = (*resource.Quantity)(unsafe.Pointer(in.CloudProviderBackoffJitter))
        return nil
}</span>

// Convert_v1beta1_BackOffConfig_To_v1alpha4_BackOffConfig is an autogenerated conversion function.
func Convert_v1beta1_BackOffConfig_To_v1alpha4_BackOffConfig(in *v1beta1.BackOffConfig, out *BackOffConfig, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_BackOffConfig_To_v1alpha4_BackOffConfig(in, out, s)
}</span>

func autoConvert_v1alpha4_BastionSpec_To_v1beta1_BastionSpec(in *BastionSpec, out *v1beta1.BastionSpec, s conversion.Scope) error <span class="cov8" title="1">{
        if in.AzureBastion != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.AzureBastion, &amp;out.AzureBastion
                *out = new(v1beta1.AzureBastion)
                if err := Convert_v1alpha4_AzureBastion_To_v1beta1_AzureBastion(*in, *out, s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                out.AzureBastion = nil
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha4_BastionSpec_To_v1beta1_BastionSpec is an autogenerated conversion function.
func Convert_v1alpha4_BastionSpec_To_v1beta1_BastionSpec(in *BastionSpec, out *v1beta1.BastionSpec, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_BastionSpec_To_v1beta1_BastionSpec(in, out, s)
}</span>

func autoConvert_v1beta1_BastionSpec_To_v1alpha4_BastionSpec(in *v1beta1.BastionSpec, out *BastionSpec, s conversion.Scope) error <span class="cov8" title="1">{
        if in.AzureBastion != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.AzureBastion, &amp;out.AzureBastion
                *out = new(AzureBastion)
                if err := Convert_v1beta1_AzureBastion_To_v1alpha4_AzureBastion(*in, *out, s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                out.AzureBastion = nil
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1beta1_BastionSpec_To_v1alpha4_BastionSpec is an autogenerated conversion function.
func Convert_v1beta1_BastionSpec_To_v1alpha4_BastionSpec(in *v1beta1.BastionSpec, out *BastionSpec, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_BastionSpec_To_v1alpha4_BastionSpec(in, out, s)
}</span>

func autoConvert_v1alpha4_BuildParams_To_v1beta1_BuildParams(in *BuildParams, out *v1beta1.BuildParams, s conversion.Scope) error <span class="cov0" title="0">{
        out.Lifecycle = v1beta1.ResourceLifecycle(in.Lifecycle)
        out.ClusterName = in.ClusterName
        out.ResourceID = in.ResourceID
        out.Name = (*string)(unsafe.Pointer(in.Name))
        out.Role = (*string)(unsafe.Pointer(in.Role))
        out.Additional = *(*v1beta1.Tags)(unsafe.Pointer(&amp;in.Additional))
        return nil
}</span>

// Convert_v1alpha4_BuildParams_To_v1beta1_BuildParams is an autogenerated conversion function.
func Convert_v1alpha4_BuildParams_To_v1beta1_BuildParams(in *BuildParams, out *v1beta1.BuildParams, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_BuildParams_To_v1beta1_BuildParams(in, out, s)
}</span>

func autoConvert_v1beta1_BuildParams_To_v1alpha4_BuildParams(in *v1beta1.BuildParams, out *BuildParams, s conversion.Scope) error <span class="cov0" title="0">{
        out.Lifecycle = ResourceLifecycle(in.Lifecycle)
        out.ClusterName = in.ClusterName
        out.ResourceID = in.ResourceID
        out.Name = (*string)(unsafe.Pointer(in.Name))
        out.Role = (*string)(unsafe.Pointer(in.Role))
        out.Additional = *(*Tags)(unsafe.Pointer(&amp;in.Additional))
        return nil
}</span>

// Convert_v1beta1_BuildParams_To_v1alpha4_BuildParams is an autogenerated conversion function.
func Convert_v1beta1_BuildParams_To_v1alpha4_BuildParams(in *v1beta1.BuildParams, out *BuildParams, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_BuildParams_To_v1alpha4_BuildParams(in, out, s)
}</span>

func autoConvert_v1alpha4_CloudProviderConfigOverrides_To_v1beta1_CloudProviderConfigOverrides(in *CloudProviderConfigOverrides, out *v1beta1.CloudProviderConfigOverrides, s conversion.Scope) error <span class="cov0" title="0">{
        out.RateLimits = *(*[]v1beta1.RateLimitSpec)(unsafe.Pointer(&amp;in.RateLimits))
        if err := Convert_v1alpha4_BackOffConfig_To_v1beta1_BackOffConfig(&amp;in.BackOffs, &amp;out.BackOffs, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1alpha4_CloudProviderConfigOverrides_To_v1beta1_CloudProviderConfigOverrides is an autogenerated conversion function.
func Convert_v1alpha4_CloudProviderConfigOverrides_To_v1beta1_CloudProviderConfigOverrides(in *CloudProviderConfigOverrides, out *v1beta1.CloudProviderConfigOverrides, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_CloudProviderConfigOverrides_To_v1beta1_CloudProviderConfigOverrides(in, out, s)
}</span>

func autoConvert_v1beta1_CloudProviderConfigOverrides_To_v1alpha4_CloudProviderConfigOverrides(in *v1beta1.CloudProviderConfigOverrides, out *CloudProviderConfigOverrides, s conversion.Scope) error <span class="cov0" title="0">{
        out.RateLimits = *(*[]RateLimitSpec)(unsafe.Pointer(&amp;in.RateLimits))
        if err := Convert_v1beta1_BackOffConfig_To_v1alpha4_BackOffConfig(&amp;in.BackOffs, &amp;out.BackOffs, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1beta1_CloudProviderConfigOverrides_To_v1alpha4_CloudProviderConfigOverrides is an autogenerated conversion function.
func Convert_v1beta1_CloudProviderConfigOverrides_To_v1alpha4_CloudProviderConfigOverrides(in *v1beta1.CloudProviderConfigOverrides, out *CloudProviderConfigOverrides, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_CloudProviderConfigOverrides_To_v1alpha4_CloudProviderConfigOverrides(in, out, s)
}</span>

func autoConvert_v1alpha4_DataDisk_To_v1beta1_DataDisk(in *DataDisk, out *v1beta1.DataDisk, s conversion.Scope) error <span class="cov0" title="0">{
        out.NameSuffix = in.NameSuffix
        out.DiskSizeGB = in.DiskSizeGB
        out.ManagedDisk = (*v1beta1.ManagedDiskParameters)(unsafe.Pointer(in.ManagedDisk))
        out.Lun = (*int32)(unsafe.Pointer(in.Lun))
        out.CachingType = in.CachingType
        return nil
}</span>

// Convert_v1alpha4_DataDisk_To_v1beta1_DataDisk is an autogenerated conversion function.
func Convert_v1alpha4_DataDisk_To_v1beta1_DataDisk(in *DataDisk, out *v1beta1.DataDisk, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_DataDisk_To_v1beta1_DataDisk(in, out, s)
}</span>

func autoConvert_v1beta1_DataDisk_To_v1alpha4_DataDisk(in *v1beta1.DataDisk, out *DataDisk, s conversion.Scope) error <span class="cov0" title="0">{
        out.NameSuffix = in.NameSuffix
        out.DiskSizeGB = in.DiskSizeGB
        out.ManagedDisk = (*ManagedDiskParameters)(unsafe.Pointer(in.ManagedDisk))
        out.Lun = (*int32)(unsafe.Pointer(in.Lun))
        out.CachingType = in.CachingType
        return nil
}</span>

// Convert_v1beta1_DataDisk_To_v1alpha4_DataDisk is an autogenerated conversion function.
func Convert_v1beta1_DataDisk_To_v1alpha4_DataDisk(in *v1beta1.DataDisk, out *DataDisk, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_DataDisk_To_v1alpha4_DataDisk(in, out, s)
}</span>

func autoConvert_v1alpha4_DiffDiskSettings_To_v1beta1_DiffDiskSettings(in *DiffDiskSettings, out *v1beta1.DiffDiskSettings, s conversion.Scope) error <span class="cov0" title="0">{
        out.Option = in.Option
        return nil
}</span>

// Convert_v1alpha4_DiffDiskSettings_To_v1beta1_DiffDiskSettings is an autogenerated conversion function.
func Convert_v1alpha4_DiffDiskSettings_To_v1beta1_DiffDiskSettings(in *DiffDiskSettings, out *v1beta1.DiffDiskSettings, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_DiffDiskSettings_To_v1beta1_DiffDiskSettings(in, out, s)
}</span>

func autoConvert_v1beta1_DiffDiskSettings_To_v1alpha4_DiffDiskSettings(in *v1beta1.DiffDiskSettings, out *DiffDiskSettings, s conversion.Scope) error <span class="cov0" title="0">{
        out.Option = in.Option
        return nil
}</span>

// Convert_v1beta1_DiffDiskSettings_To_v1alpha4_DiffDiskSettings is an autogenerated conversion function.
func Convert_v1beta1_DiffDiskSettings_To_v1alpha4_DiffDiskSettings(in *v1beta1.DiffDiskSettings, out *DiffDiskSettings, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_DiffDiskSettings_To_v1alpha4_DiffDiskSettings(in, out, s)
}</span>

func autoConvert_v1alpha4_DiskEncryptionSetParameters_To_v1beta1_DiskEncryptionSetParameters(in *DiskEncryptionSetParameters, out *v1beta1.DiskEncryptionSetParameters, s conversion.Scope) error <span class="cov0" title="0">{
        out.ID = in.ID
        return nil
}</span>

// Convert_v1alpha4_DiskEncryptionSetParameters_To_v1beta1_DiskEncryptionSetParameters is an autogenerated conversion function.
func Convert_v1alpha4_DiskEncryptionSetParameters_To_v1beta1_DiskEncryptionSetParameters(in *DiskEncryptionSetParameters, out *v1beta1.DiskEncryptionSetParameters, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_DiskEncryptionSetParameters_To_v1beta1_DiskEncryptionSetParameters(in, out, s)
}</span>

func autoConvert_v1beta1_DiskEncryptionSetParameters_To_v1alpha4_DiskEncryptionSetParameters(in *v1beta1.DiskEncryptionSetParameters, out *DiskEncryptionSetParameters, s conversion.Scope) error <span class="cov0" title="0">{
        out.ID = in.ID
        return nil
}</span>

// Convert_v1beta1_DiskEncryptionSetParameters_To_v1alpha4_DiskEncryptionSetParameters is an autogenerated conversion function.
func Convert_v1beta1_DiskEncryptionSetParameters_To_v1alpha4_DiskEncryptionSetParameters(in *v1beta1.DiskEncryptionSetParameters, out *DiskEncryptionSetParameters, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_DiskEncryptionSetParameters_To_v1alpha4_DiskEncryptionSetParameters(in, out, s)
}</span>

func autoConvert_v1alpha4_FrontendIP_To_v1beta1_FrontendIP(in *FrontendIP, out *v1beta1.FrontendIP, s conversion.Scope) error <span class="cov8" title="1">{
        out.Name = in.Name
        // WARNING: in.PrivateIPAddress requires manual conversion: does not exist in peer-type
        if in.PublicIP != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.PublicIP, &amp;out.PublicIP
                *out = new(v1beta1.PublicIPSpec)
                if err := Convert_v1alpha4_PublicIPSpec_To_v1beta1_PublicIPSpec(*in, *out, s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                out.PublicIP = nil
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func autoConvert_v1beta1_FrontendIP_To_v1alpha4_FrontendIP(in *v1beta1.FrontendIP, out *FrontendIP, s conversion.Scope) error <span class="cov8" title="1">{
        out.Name = in.Name
        if in.PublicIP != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.PublicIP, &amp;out.PublicIP
                *out = new(PublicIPSpec)
                if err := Convert_v1beta1_PublicIPSpec_To_v1alpha4_PublicIPSpec(*in, *out, s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                out.PublicIP = nil
        }</span>
        // WARNING: in.FrontendIPClass requires manual conversion: does not exist in peer-type
        <span class="cov8" title="1">return nil</span>
}

func autoConvert_v1alpha4_Future_To_v1beta1_Future(in *Future, out *v1beta1.Future, s conversion.Scope) error <span class="cov0" title="0">{
        out.Type = in.Type
        out.ResourceGroup = in.ResourceGroup
        out.ServiceName = in.ServiceName
        out.Name = in.Name
        out.Data = in.Data
        return nil
}</span>

// Convert_v1alpha4_Future_To_v1beta1_Future is an autogenerated conversion function.
func Convert_v1alpha4_Future_To_v1beta1_Future(in *Future, out *v1beta1.Future, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_Future_To_v1beta1_Future(in, out, s)
}</span>

func autoConvert_v1beta1_Future_To_v1alpha4_Future(in *v1beta1.Future, out *Future, s conversion.Scope) error <span class="cov0" title="0">{
        out.Type = in.Type
        out.ResourceGroup = in.ResourceGroup
        out.ServiceName = in.ServiceName
        out.Name = in.Name
        out.Data = in.Data
        return nil
}</span>

// Convert_v1beta1_Future_To_v1alpha4_Future is an autogenerated conversion function.
func Convert_v1beta1_Future_To_v1alpha4_Future(in *v1beta1.Future, out *Future, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_Future_To_v1alpha4_Future(in, out, s)
}</span>

func autoConvert_v1alpha4_Image_To_v1beta1_Image(in *Image, out *v1beta1.Image, s conversion.Scope) error <span class="cov8" title="1">{
        out.ID = (*string)(unsafe.Pointer(in.ID))
        out.SharedGallery = (*v1beta1.AzureSharedGalleryImage)(unsafe.Pointer(in.SharedGallery))
        if in.Marketplace != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Marketplace, &amp;out.Marketplace
                *out = new(v1beta1.AzureMarketplaceImage)
                if err := Convert_v1alpha4_AzureMarketplaceImage_To_v1beta1_AzureMarketplaceImage(*in, *out, s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                out.Marketplace = nil
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha4_Image_To_v1beta1_Image is an autogenerated conversion function.
func Convert_v1alpha4_Image_To_v1beta1_Image(in *Image, out *v1beta1.Image, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_Image_To_v1beta1_Image(in, out, s)
}</span>

func autoConvert_v1beta1_Image_To_v1alpha4_Image(in *v1beta1.Image, out *Image, s conversion.Scope) error <span class="cov8" title="1">{
        out.ID = (*string)(unsafe.Pointer(in.ID))
        out.SharedGallery = (*AzureSharedGalleryImage)(unsafe.Pointer(in.SharedGallery))
        if in.Marketplace != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Marketplace, &amp;out.Marketplace
                *out = new(AzureMarketplaceImage)
                if err := Convert_v1beta1_AzureMarketplaceImage_To_v1alpha4_AzureMarketplaceImage(*in, *out, s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                out.Marketplace = nil
        }</span>
        // WARNING: in.ComputeGallery requires manual conversion: does not exist in peer-type
        <span class="cov8" title="1">return nil</span>
}

func autoConvert_v1alpha4_LoadBalancerSpec_To_v1beta1_LoadBalancerSpec(in *LoadBalancerSpec, out *v1beta1.LoadBalancerSpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.ID = in.ID
        out.Name = in.Name
        // WARNING: in.SKU requires manual conversion: does not exist in peer-type
        if in.FrontendIPs != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.FrontendIPs, &amp;out.FrontendIPs
                *out = make([]v1beta1.FrontendIP, len(*in))
                for i := range *in </span><span class="cov8" title="1">{
                        if err := Convert_v1alpha4_FrontendIP_To_v1beta1_FrontendIP(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                out.FrontendIPs = nil
        }</span>
        // WARNING: in.Type requires manual conversion: does not exist in peer-type
        <span class="cov8" title="1">out.FrontendIPsCount = (*int32)(unsafe.Pointer(in.FrontendIPsCount))
        // WARNING: in.IdleTimeoutInMinutes requires manual conversion: does not exist in peer-type
        return nil</span>
}

func autoConvert_v1beta1_LoadBalancerSpec_To_v1alpha4_LoadBalancerSpec(in *v1beta1.LoadBalancerSpec, out *LoadBalancerSpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.ID = in.ID
        out.Name = in.Name
        if in.FrontendIPs != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.FrontendIPs, &amp;out.FrontendIPs
                *out = make([]FrontendIP, len(*in))
                for i := range *in </span><span class="cov8" title="1">{
                        if err := Convert_v1beta1_FrontendIP_To_v1alpha4_FrontendIP(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                out.FrontendIPs = nil
        }</span>
        <span class="cov8" title="1">out.FrontendIPsCount = (*int32)(unsafe.Pointer(in.FrontendIPsCount))
        // WARNING: in.LoadBalancerClassSpec requires manual conversion: does not exist in peer-type
        return nil</span>
}

func autoConvert_v1alpha4_ManagedDiskParameters_To_v1beta1_ManagedDiskParameters(in *ManagedDiskParameters, out *v1beta1.ManagedDiskParameters, s conversion.Scope) error <span class="cov0" title="0">{
        out.StorageAccountType = in.StorageAccountType
        out.DiskEncryptionSet = (*v1beta1.DiskEncryptionSetParameters)(unsafe.Pointer(in.DiskEncryptionSet))
        return nil
}</span>

// Convert_v1alpha4_ManagedDiskParameters_To_v1beta1_ManagedDiskParameters is an autogenerated conversion function.
func Convert_v1alpha4_ManagedDiskParameters_To_v1beta1_ManagedDiskParameters(in *ManagedDiskParameters, out *v1beta1.ManagedDiskParameters, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_ManagedDiskParameters_To_v1beta1_ManagedDiskParameters(in, out, s)
}</span>

func autoConvert_v1beta1_ManagedDiskParameters_To_v1alpha4_ManagedDiskParameters(in *v1beta1.ManagedDiskParameters, out *ManagedDiskParameters, s conversion.Scope) error <span class="cov0" title="0">{
        out.StorageAccountType = in.StorageAccountType
        out.DiskEncryptionSet = (*DiskEncryptionSetParameters)(unsafe.Pointer(in.DiskEncryptionSet))
        return nil
}</span>

// Convert_v1beta1_ManagedDiskParameters_To_v1alpha4_ManagedDiskParameters is an autogenerated conversion function.
func Convert_v1beta1_ManagedDiskParameters_To_v1alpha4_ManagedDiskParameters(in *v1beta1.ManagedDiskParameters, out *ManagedDiskParameters, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_ManagedDiskParameters_To_v1alpha4_ManagedDiskParameters(in, out, s)
}</span>

func autoConvert_v1alpha4_NatGateway_To_v1beta1_NatGateway(in *NatGateway, out *v1beta1.NatGateway, s conversion.Scope) error <span class="cov8" title="1">{
        out.ID = in.ID
        // WARNING: in.Name requires manual conversion: does not exist in peer-type
        if err := Convert_v1alpha4_PublicIPSpec_To_v1beta1_PublicIPSpec(&amp;in.NatGatewayIP, &amp;out.NatGatewayIP, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func autoConvert_v1beta1_NatGateway_To_v1alpha4_NatGateway(in *v1beta1.NatGateway, out *NatGateway, s conversion.Scope) error <span class="cov8" title="1">{
        out.ID = in.ID
        if err := Convert_v1beta1_PublicIPSpec_To_v1alpha4_PublicIPSpec(&amp;in.NatGatewayIP, &amp;out.NatGatewayIP, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // WARNING: in.NatGatewayClassSpec requires manual conversion: does not exist in peer-type
        <span class="cov8" title="1">return nil</span>
}

func autoConvert_v1alpha4_NetworkSpec_To_v1beta1_NetworkSpec(in *NetworkSpec, out *v1beta1.NetworkSpec, s conversion.Scope) error <span class="cov8" title="1">{
        if err := Convert_v1alpha4_VnetSpec_To_v1beta1_VnetSpec(&amp;in.Vnet, &amp;out.Vnet, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if in.Subnets != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Subnets, &amp;out.Subnets
                *out = make(v1beta1.Subnets, len(*in))
                for i := range *in </span><span class="cov8" title="1">{
                        if err := Convert_v1alpha4_SubnetSpec_To_v1beta1_SubnetSpec(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                out.Subnets = nil
        }</span>
        <span class="cov8" title="1">if err := Convert_v1alpha4_LoadBalancerSpec_To_v1beta1_LoadBalancerSpec(&amp;in.APIServerLB, &amp;out.APIServerLB, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if in.NodeOutboundLB != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.NodeOutboundLB, &amp;out.NodeOutboundLB
                *out = new(v1beta1.LoadBalancerSpec)
                if err := Convert_v1alpha4_LoadBalancerSpec_To_v1beta1_LoadBalancerSpec(*in, *out, s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                out.NodeOutboundLB = nil
        }</span>
        <span class="cov8" title="1">if in.ControlPlaneOutboundLB != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.ControlPlaneOutboundLB, &amp;out.ControlPlaneOutboundLB
                *out = new(v1beta1.LoadBalancerSpec)
                if err := Convert_v1alpha4_LoadBalancerSpec_To_v1beta1_LoadBalancerSpec(*in, *out, s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                out.ControlPlaneOutboundLB = nil
        }</span>
        // WARNING: in.PrivateDNSZoneName requires manual conversion: does not exist in peer-type
        <span class="cov8" title="1">return nil</span>
}

func autoConvert_v1beta1_NetworkSpec_To_v1alpha4_NetworkSpec(in *v1beta1.NetworkSpec, out *NetworkSpec, s conversion.Scope) error <span class="cov8" title="1">{
        if err := Convert_v1beta1_VnetSpec_To_v1alpha4_VnetSpec(&amp;in.Vnet, &amp;out.Vnet, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if in.Subnets != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Subnets, &amp;out.Subnets
                *out = make(Subnets, len(*in))
                for i := range *in </span><span class="cov8" title="1">{
                        if err := Convert_v1beta1_SubnetSpec_To_v1alpha4_SubnetSpec(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                out.Subnets = nil
        }</span>
        <span class="cov8" title="1">if err := Convert_v1beta1_LoadBalancerSpec_To_v1alpha4_LoadBalancerSpec(&amp;in.APIServerLB, &amp;out.APIServerLB, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if in.NodeOutboundLB != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.NodeOutboundLB, &amp;out.NodeOutboundLB
                *out = new(LoadBalancerSpec)
                if err := Convert_v1beta1_LoadBalancerSpec_To_v1alpha4_LoadBalancerSpec(*in, *out, s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                out.NodeOutboundLB = nil
        }</span>
        <span class="cov8" title="1">if in.ControlPlaneOutboundLB != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.ControlPlaneOutboundLB, &amp;out.ControlPlaneOutboundLB
                *out = new(LoadBalancerSpec)
                if err := Convert_v1beta1_LoadBalancerSpec_To_v1alpha4_LoadBalancerSpec(*in, *out, s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                out.ControlPlaneOutboundLB = nil
        }</span>
        // WARNING: in.NetworkClassSpec requires manual conversion: does not exist in peer-type
        <span class="cov8" title="1">return nil</span>
}

func autoConvert_v1alpha4_OSDisk_To_v1beta1_OSDisk(in *OSDisk, out *v1beta1.OSDisk, s conversion.Scope) error <span class="cov8" title="1">{
        out.OSType = in.OSType
        out.DiskSizeGB = (*int32)(unsafe.Pointer(in.DiskSizeGB))
        out.ManagedDisk = (*v1beta1.ManagedDiskParameters)(unsafe.Pointer(in.ManagedDisk))
        out.DiffDiskSettings = (*v1beta1.DiffDiskSettings)(unsafe.Pointer(in.DiffDiskSettings))
        out.CachingType = in.CachingType
        return nil
}</span>

// Convert_v1alpha4_OSDisk_To_v1beta1_OSDisk is an autogenerated conversion function.
func Convert_v1alpha4_OSDisk_To_v1beta1_OSDisk(in *OSDisk, out *v1beta1.OSDisk, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_OSDisk_To_v1beta1_OSDisk(in, out, s)
}</span>

func autoConvert_v1beta1_OSDisk_To_v1alpha4_OSDisk(in *v1beta1.OSDisk, out *OSDisk, s conversion.Scope) error <span class="cov8" title="1">{
        out.OSType = in.OSType
        out.DiskSizeGB = (*int32)(unsafe.Pointer(in.DiskSizeGB))
        out.ManagedDisk = (*ManagedDiskParameters)(unsafe.Pointer(in.ManagedDisk))
        out.DiffDiskSettings = (*DiffDiskSettings)(unsafe.Pointer(in.DiffDiskSettings))
        out.CachingType = in.CachingType
        return nil
}</span>

// Convert_v1beta1_OSDisk_To_v1alpha4_OSDisk is an autogenerated conversion function.
func Convert_v1beta1_OSDisk_To_v1alpha4_OSDisk(in *v1beta1.OSDisk, out *OSDisk, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_OSDisk_To_v1alpha4_OSDisk(in, out, s)
}</span>

func autoConvert_v1alpha4_PublicIPSpec_To_v1beta1_PublicIPSpec(in *PublicIPSpec, out *v1beta1.PublicIPSpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.Name = in.Name
        out.DNSName = in.DNSName
        return nil
}</span>

// Convert_v1alpha4_PublicIPSpec_To_v1beta1_PublicIPSpec is an autogenerated conversion function.
func Convert_v1alpha4_PublicIPSpec_To_v1beta1_PublicIPSpec(in *PublicIPSpec, out *v1beta1.PublicIPSpec, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_PublicIPSpec_To_v1beta1_PublicIPSpec(in, out, s)
}</span>

func autoConvert_v1beta1_PublicIPSpec_To_v1alpha4_PublicIPSpec(in *v1beta1.PublicIPSpec, out *PublicIPSpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.Name = in.Name
        out.DNSName = in.DNSName
        // WARNING: in.IPTags requires manual conversion: does not exist in peer-type
        return nil
}</span>

func autoConvert_v1alpha4_RateLimitConfig_To_v1beta1_RateLimitConfig(in *RateLimitConfig, out *v1beta1.RateLimitConfig, s conversion.Scope) error <span class="cov0" title="0">{
        out.CloudProviderRateLimit = in.CloudProviderRateLimit
        out.CloudProviderRateLimitQPS = (*resource.Quantity)(unsafe.Pointer(in.CloudProviderRateLimitQPS))
        out.CloudProviderRateLimitBucket = in.CloudProviderRateLimitBucket
        out.CloudProviderRateLimitQPSWrite = (*resource.Quantity)(unsafe.Pointer(in.CloudProviderRateLimitQPSWrite))
        out.CloudProviderRateLimitBucketWrite = in.CloudProviderRateLimitBucketWrite
        return nil
}</span>

// Convert_v1alpha4_RateLimitConfig_To_v1beta1_RateLimitConfig is an autogenerated conversion function.
func Convert_v1alpha4_RateLimitConfig_To_v1beta1_RateLimitConfig(in *RateLimitConfig, out *v1beta1.RateLimitConfig, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_RateLimitConfig_To_v1beta1_RateLimitConfig(in, out, s)
}</span>

func autoConvert_v1beta1_RateLimitConfig_To_v1alpha4_RateLimitConfig(in *v1beta1.RateLimitConfig, out *RateLimitConfig, s conversion.Scope) error <span class="cov0" title="0">{
        out.CloudProviderRateLimit = in.CloudProviderRateLimit
        out.CloudProviderRateLimitQPS = (*resource.Quantity)(unsafe.Pointer(in.CloudProviderRateLimitQPS))
        out.CloudProviderRateLimitBucket = in.CloudProviderRateLimitBucket
        out.CloudProviderRateLimitQPSWrite = (*resource.Quantity)(unsafe.Pointer(in.CloudProviderRateLimitQPSWrite))
        out.CloudProviderRateLimitBucketWrite = in.CloudProviderRateLimitBucketWrite
        return nil
}</span>

// Convert_v1beta1_RateLimitConfig_To_v1alpha4_RateLimitConfig is an autogenerated conversion function.
func Convert_v1beta1_RateLimitConfig_To_v1alpha4_RateLimitConfig(in *v1beta1.RateLimitConfig, out *RateLimitConfig, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_RateLimitConfig_To_v1alpha4_RateLimitConfig(in, out, s)
}</span>

func autoConvert_v1alpha4_RateLimitSpec_To_v1beta1_RateLimitSpec(in *RateLimitSpec, out *v1beta1.RateLimitSpec, s conversion.Scope) error <span class="cov0" title="0">{
        out.Name = in.Name
        if err := Convert_v1alpha4_RateLimitConfig_To_v1beta1_RateLimitConfig(&amp;in.Config, &amp;out.Config, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1alpha4_RateLimitSpec_To_v1beta1_RateLimitSpec is an autogenerated conversion function.
func Convert_v1alpha4_RateLimitSpec_To_v1beta1_RateLimitSpec(in *RateLimitSpec, out *v1beta1.RateLimitSpec, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_RateLimitSpec_To_v1beta1_RateLimitSpec(in, out, s)
}</span>

func autoConvert_v1beta1_RateLimitSpec_To_v1alpha4_RateLimitSpec(in *v1beta1.RateLimitSpec, out *RateLimitSpec, s conversion.Scope) error <span class="cov0" title="0">{
        out.Name = in.Name
        if err := Convert_v1beta1_RateLimitConfig_To_v1alpha4_RateLimitConfig(&amp;in.Config, &amp;out.Config, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1beta1_RateLimitSpec_To_v1alpha4_RateLimitSpec is an autogenerated conversion function.
func Convert_v1beta1_RateLimitSpec_To_v1alpha4_RateLimitSpec(in *v1beta1.RateLimitSpec, out *RateLimitSpec, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_RateLimitSpec_To_v1alpha4_RateLimitSpec(in, out, s)
}</span>

func autoConvert_v1alpha4_RouteTable_To_v1beta1_RouteTable(in *RouteTable, out *v1beta1.RouteTable, s conversion.Scope) error <span class="cov8" title="1">{
        out.ID = in.ID
        out.Name = in.Name
        return nil
}</span>

// Convert_v1alpha4_RouteTable_To_v1beta1_RouteTable is an autogenerated conversion function.
func Convert_v1alpha4_RouteTable_To_v1beta1_RouteTable(in *RouteTable, out *v1beta1.RouteTable, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_RouteTable_To_v1beta1_RouteTable(in, out, s)
}</span>

func autoConvert_v1beta1_RouteTable_To_v1alpha4_RouteTable(in *v1beta1.RouteTable, out *RouteTable, s conversion.Scope) error <span class="cov8" title="1">{
        out.ID = in.ID
        out.Name = in.Name
        return nil
}</span>

// Convert_v1beta1_RouteTable_To_v1alpha4_RouteTable is an autogenerated conversion function.
func Convert_v1beta1_RouteTable_To_v1alpha4_RouteTable(in *v1beta1.RouteTable, out *RouteTable, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_RouteTable_To_v1alpha4_RouteTable(in, out, s)
}</span>

func autoConvert_v1alpha4_SecurityGroup_To_v1beta1_SecurityGroup(in *SecurityGroup, out *v1beta1.SecurityGroup, s conversion.Scope) error <span class="cov8" title="1">{
        out.ID = in.ID
        out.Name = in.Name
        // WARNING: in.SecurityRules requires manual conversion: does not exist in peer-type
        // WARNING: in.Tags requires manual conversion: does not exist in peer-type
        return nil
}</span>

func autoConvert_v1beta1_SecurityGroup_To_v1alpha4_SecurityGroup(in *v1beta1.SecurityGroup, out *SecurityGroup, s conversion.Scope) error <span class="cov8" title="1">{
        out.ID = in.ID
        out.Name = in.Name
        // WARNING: in.SecurityGroupClass requires manual conversion: does not exist in peer-type
        return nil
}</span>

func autoConvert_v1alpha4_SecurityProfile_To_v1beta1_SecurityProfile(in *SecurityProfile, out *v1beta1.SecurityProfile, s conversion.Scope) error <span class="cov0" title="0">{
        out.EncryptionAtHost = (*bool)(unsafe.Pointer(in.EncryptionAtHost))
        return nil
}</span>

// Convert_v1alpha4_SecurityProfile_To_v1beta1_SecurityProfile is an autogenerated conversion function.
func Convert_v1alpha4_SecurityProfile_To_v1beta1_SecurityProfile(in *SecurityProfile, out *v1beta1.SecurityProfile, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_SecurityProfile_To_v1beta1_SecurityProfile(in, out, s)
}</span>

func autoConvert_v1beta1_SecurityProfile_To_v1alpha4_SecurityProfile(in *v1beta1.SecurityProfile, out *SecurityProfile, s conversion.Scope) error <span class="cov0" title="0">{
        out.EncryptionAtHost = (*bool)(unsafe.Pointer(in.EncryptionAtHost))
        return nil
}</span>

// Convert_v1beta1_SecurityProfile_To_v1alpha4_SecurityProfile is an autogenerated conversion function.
func Convert_v1beta1_SecurityProfile_To_v1alpha4_SecurityProfile(in *v1beta1.SecurityProfile, out *SecurityProfile, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_SecurityProfile_To_v1alpha4_SecurityProfile(in, out, s)
}</span>

func autoConvert_v1alpha4_SecurityRule_To_v1beta1_SecurityRule(in *SecurityRule, out *v1beta1.SecurityRule, s conversion.Scope) error <span class="cov0" title="0">{
        out.Name = in.Name
        out.Description = in.Description
        out.Protocol = v1beta1.SecurityGroupProtocol(in.Protocol)
        out.Direction = v1beta1.SecurityRuleDirection(in.Direction)
        out.Priority = in.Priority
        out.SourcePorts = (*string)(unsafe.Pointer(in.SourcePorts))
        out.DestinationPorts = (*string)(unsafe.Pointer(in.DestinationPorts))
        out.Source = (*string)(unsafe.Pointer(in.Source))
        out.Destination = (*string)(unsafe.Pointer(in.Destination))
        return nil
}</span>

// Convert_v1alpha4_SecurityRule_To_v1beta1_SecurityRule is an autogenerated conversion function.
func Convert_v1alpha4_SecurityRule_To_v1beta1_SecurityRule(in *SecurityRule, out *v1beta1.SecurityRule, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_SecurityRule_To_v1beta1_SecurityRule(in, out, s)
}</span>

func autoConvert_v1beta1_SecurityRule_To_v1alpha4_SecurityRule(in *v1beta1.SecurityRule, out *SecurityRule, s conversion.Scope) error <span class="cov0" title="0">{
        out.Name = in.Name
        out.Description = in.Description
        out.Protocol = SecurityGroupProtocol(in.Protocol)
        out.Direction = SecurityRuleDirection(in.Direction)
        out.Priority = in.Priority
        out.SourcePorts = (*string)(unsafe.Pointer(in.SourcePorts))
        out.DestinationPorts = (*string)(unsafe.Pointer(in.DestinationPorts))
        out.Source = (*string)(unsafe.Pointer(in.Source))
        out.Destination = (*string)(unsafe.Pointer(in.Destination))
        return nil
}</span>

// Convert_v1beta1_SecurityRule_To_v1alpha4_SecurityRule is an autogenerated conversion function.
func Convert_v1beta1_SecurityRule_To_v1alpha4_SecurityRule(in *v1beta1.SecurityRule, out *SecurityRule, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_SecurityRule_To_v1alpha4_SecurityRule(in, out, s)
}</span>

func autoConvert_v1alpha4_SpotVMOptions_To_v1beta1_SpotVMOptions(in *SpotVMOptions, out *v1beta1.SpotVMOptions, s conversion.Scope) error <span class="cov0" title="0">{
        out.MaxPrice = (*resource.Quantity)(unsafe.Pointer(in.MaxPrice))
        return nil
}</span>

// Convert_v1alpha4_SpotVMOptions_To_v1beta1_SpotVMOptions is an autogenerated conversion function.
func Convert_v1alpha4_SpotVMOptions_To_v1beta1_SpotVMOptions(in *SpotVMOptions, out *v1beta1.SpotVMOptions, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_SpotVMOptions_To_v1beta1_SpotVMOptions(in, out, s)
}</span>

func autoConvert_v1beta1_SpotVMOptions_To_v1alpha4_SpotVMOptions(in *v1beta1.SpotVMOptions, out *SpotVMOptions, s conversion.Scope) error <span class="cov0" title="0">{
        out.MaxPrice = (*resource.Quantity)(unsafe.Pointer(in.MaxPrice))
        return nil
}</span>

// Convert_v1beta1_SpotVMOptions_To_v1alpha4_SpotVMOptions is an autogenerated conversion function.
func Convert_v1beta1_SpotVMOptions_To_v1alpha4_SpotVMOptions(in *v1beta1.SpotVMOptions, out *SpotVMOptions, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_SpotVMOptions_To_v1alpha4_SpotVMOptions(in, out, s)
}</span>

func autoConvert_v1alpha4_SubnetSpec_To_v1beta1_SubnetSpec(in *SubnetSpec, out *v1beta1.SubnetSpec, s conversion.Scope) error <span class="cov8" title="1">{
        // WARNING: in.Role requires manual conversion: does not exist in peer-type
        out.ID = in.ID
        out.Name = in.Name
        // WARNING: in.CIDRBlocks requires manual conversion: does not exist in peer-type
        if err := Convert_v1alpha4_SecurityGroup_To_v1beta1_SecurityGroup(&amp;in.SecurityGroup, &amp;out.SecurityGroup, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1alpha4_RouteTable_To_v1beta1_RouteTable(&amp;in.RouteTable, &amp;out.RouteTable, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1alpha4_NatGateway_To_v1beta1_NatGateway(&amp;in.NatGateway, &amp;out.NatGateway, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func autoConvert_v1beta1_SubnetSpec_To_v1alpha4_SubnetSpec(in *v1beta1.SubnetSpec, out *SubnetSpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.ID = in.ID
        out.Name = in.Name
        if err := Convert_v1beta1_SecurityGroup_To_v1alpha4_SecurityGroup(&amp;in.SecurityGroup, &amp;out.SecurityGroup, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1beta1_RouteTable_To_v1alpha4_RouteTable(&amp;in.RouteTable, &amp;out.RouteTable, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1beta1_NatGateway_To_v1alpha4_NatGateway(&amp;in.NatGateway, &amp;out.NatGateway, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // WARNING: in.SubnetClassSpec requires manual conversion: does not exist in peer-type
        <span class="cov8" title="1">return nil</span>
}

func autoConvert_v1alpha4_UserAssignedIdentity_To_v1beta1_UserAssignedIdentity(in *UserAssignedIdentity, out *v1beta1.UserAssignedIdentity, s conversion.Scope) error <span class="cov0" title="0">{
        out.ProviderID = in.ProviderID
        return nil
}</span>

// Convert_v1alpha4_UserAssignedIdentity_To_v1beta1_UserAssignedIdentity is an autogenerated conversion function.
func Convert_v1alpha4_UserAssignedIdentity_To_v1beta1_UserAssignedIdentity(in *UserAssignedIdentity, out *v1beta1.UserAssignedIdentity, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_UserAssignedIdentity_To_v1beta1_UserAssignedIdentity(in, out, s)
}</span>

func autoConvert_v1beta1_UserAssignedIdentity_To_v1alpha4_UserAssignedIdentity(in *v1beta1.UserAssignedIdentity, out *UserAssignedIdentity, s conversion.Scope) error <span class="cov0" title="0">{
        out.ProviderID = in.ProviderID
        return nil
}</span>

// Convert_v1beta1_UserAssignedIdentity_To_v1alpha4_UserAssignedIdentity is an autogenerated conversion function.
func Convert_v1beta1_UserAssignedIdentity_To_v1alpha4_UserAssignedIdentity(in *v1beta1.UserAssignedIdentity, out *UserAssignedIdentity, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_UserAssignedIdentity_To_v1alpha4_UserAssignedIdentity(in, out, s)
}</span>

func autoConvert_v1alpha4_VnetSpec_To_v1beta1_VnetSpec(in *VnetSpec, out *v1beta1.VnetSpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.ResourceGroup = in.ResourceGroup
        out.ID = in.ID
        out.Name = in.Name
        // WARNING: in.CIDRBlocks requires manual conversion: does not exist in peer-type
        // WARNING: in.Tags requires manual conversion: does not exist in peer-type
        return nil
}</span>

func autoConvert_v1beta1_VnetSpec_To_v1alpha4_VnetSpec(in *v1beta1.VnetSpec, out *VnetSpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.ResourceGroup = in.ResourceGroup
        out.ID = in.ID
        out.Name = in.Name
        // WARNING: in.Peerings requires manual conversion: does not exist in peer-type
        // WARNING: in.VnetClassSpec requires manual conversion: does not exist in peer-type
        return nil
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha4

import (
        "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        apiv1alpha4 "sigs.k8s.io/cluster-api/api/v1alpha4"
        "sigs.k8s.io/cluster-api/errors"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AddressRecord) DeepCopyInto(out *AddressRecord) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AddressRecord.
func (in *AddressRecord) DeepCopy() *AddressRecord <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AddressRecord)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AllowedNamespaces) DeepCopyInto(out *AllowedNamespaces) <span class="cov0" title="0">{
        *out = *in
        if in.NamespaceList != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.NamespaceList, &amp;out.NamespaceList
                *out = make([]string, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov0" title="0">if in.Selector != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Selector, &amp;out.Selector
                *out = new(metav1.LabelSelector)
                (*in).DeepCopyInto(*out)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AllowedNamespaces.
func (in *AllowedNamespaces) DeepCopy() *AllowedNamespaces <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AllowedNamespaces)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureBastion) DeepCopyInto(out *AzureBastion) <span class="cov0" title="0">{
        *out = *in
        in.Subnet.DeepCopyInto(&amp;out.Subnet)
        out.PublicIP = in.PublicIP
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureBastion.
func (in *AzureBastion) DeepCopy() *AzureBastion <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureBastion)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureCluster) DeepCopyInto(out *AzureCluster) <span class="cov8" title="1">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
        in.Status.DeepCopyInto(&amp;out.Status)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureCluster.
func (in *AzureCluster) DeepCopy() *AzureCluster <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">out := new(AzureCluster)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureCluster) DeepCopyObject() runtime.Object <span class="cov8" title="1">{
        if c := in.DeepCopy(); c != nil </span><span class="cov8" title="1">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureClusterIdentity) DeepCopyInto(out *AzureClusterIdentity) <span class="cov8" title="1">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
        in.Status.DeepCopyInto(&amp;out.Status)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureClusterIdentity.
func (in *AzureClusterIdentity) DeepCopy() *AzureClusterIdentity <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">out := new(AzureClusterIdentity)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureClusterIdentity) DeepCopyObject() runtime.Object <span class="cov8" title="1">{
        if c := in.DeepCopy(); c != nil </span><span class="cov8" title="1">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureClusterIdentityList) DeepCopyInto(out *AzureClusterIdentityList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureClusterIdentity, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureClusterIdentityList.
func (in *AzureClusterIdentityList) DeepCopy() *AzureClusterIdentityList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureClusterIdentityList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureClusterIdentityList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureClusterIdentitySpec) DeepCopyInto(out *AzureClusterIdentitySpec) <span class="cov8" title="1">{
        *out = *in
        out.ClientSecret = in.ClientSecret
        if in.AllowedNamespaces != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AllowedNamespaces, &amp;out.AllowedNamespaces
                *out = new(AllowedNamespaces)
                (*in).DeepCopyInto(*out)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureClusterIdentitySpec.
func (in *AzureClusterIdentitySpec) DeepCopy() *AzureClusterIdentitySpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureClusterIdentitySpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureClusterIdentityStatus) DeepCopyInto(out *AzureClusterIdentityStatus) <span class="cov8" title="1">{
        *out = *in
        if in.Conditions != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make(apiv1alpha4.Conditions, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureClusterIdentityStatus.
func (in *AzureClusterIdentityStatus) DeepCopy() *AzureClusterIdentityStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureClusterIdentityStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureClusterList) DeepCopyInto(out *AzureClusterList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureCluster, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureClusterList.
func (in *AzureClusterList) DeepCopy() *AzureClusterList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureClusterList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureClusterList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureClusterSpec) DeepCopyInto(out *AzureClusterSpec) <span class="cov8" title="1">{
        *out = *in
        in.NetworkSpec.DeepCopyInto(&amp;out.NetworkSpec)
        out.ControlPlaneEndpoint = in.ControlPlaneEndpoint
        if in.AdditionalTags != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AdditionalTags, &amp;out.AdditionalTags
                *out = make(Tags, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
        <span class="cov8" title="1">if in.IdentityRef != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.IdentityRef, &amp;out.IdentityRef
                *out = new(v1.ObjectReference)
                **out = **in
        }</span>
        <span class="cov8" title="1">in.BastionSpec.DeepCopyInto(&amp;out.BastionSpec)
        if in.CloudProviderConfigOverrides != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.CloudProviderConfigOverrides, &amp;out.CloudProviderConfigOverrides
                *out = new(CloudProviderConfigOverrides)
                (*in).DeepCopyInto(*out)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureClusterSpec.
func (in *AzureClusterSpec) DeepCopy() *AzureClusterSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureClusterSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureClusterStatus) DeepCopyInto(out *AzureClusterStatus) <span class="cov8" title="1">{
        *out = *in
        if in.FailureDomains != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.FailureDomains, &amp;out.FailureDomains
                *out = make(apiv1alpha4.FailureDomains, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = *val.DeepCopy()
                }</span>
        }
        <span class="cov8" title="1">if in.Conditions != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make(apiv1alpha4.Conditions, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov8" title="1">if in.LongRunningOperationStates != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.LongRunningOperationStates, &amp;out.LongRunningOperationStates
                *out = make(Futures, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureClusterStatus.
func (in *AzureClusterStatus) DeepCopy() *AzureClusterStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureClusterStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachine) DeepCopyInto(out *AzureMachine) <span class="cov8" title="1">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
        in.Status.DeepCopyInto(&amp;out.Status)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachine.
func (in *AzureMachine) DeepCopy() *AzureMachine <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">out := new(AzureMachine)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureMachine) DeepCopyObject() runtime.Object <span class="cov8" title="1">{
        if c := in.DeepCopy(); c != nil </span><span class="cov8" title="1">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachineList) DeepCopyInto(out *AzureMachineList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureMachine, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachineList.
func (in *AzureMachineList) DeepCopy() *AzureMachineList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachineList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureMachineList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachineSpec) DeepCopyInto(out *AzureMachineSpec) <span class="cov8" title="1">{
        *out = *in
        if in.ProviderID != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ProviderID, &amp;out.ProviderID
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.FailureDomain != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.FailureDomain, &amp;out.FailureDomain
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.Image != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Image, &amp;out.Image
                *out = new(Image)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov8" title="1">if in.UserAssignedIdentities != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.UserAssignedIdentities, &amp;out.UserAssignedIdentities
                *out = make([]UserAssignedIdentity, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov8" title="1">in.OSDisk.DeepCopyInto(&amp;out.OSDisk)
        if in.DataDisks != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.DataDisks, &amp;out.DataDisks
                *out = make([]DataDisk, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov8" title="1">if in.AdditionalTags != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AdditionalTags, &amp;out.AdditionalTags
                *out = make(Tags, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
        <span class="cov8" title="1">if in.AcceleratedNetworking != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AcceleratedNetworking, &amp;out.AcceleratedNetworking
                *out = new(bool)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.SpotVMOptions != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.SpotVMOptions, &amp;out.SpotVMOptions
                *out = new(SpotVMOptions)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov8" title="1">if in.SecurityProfile != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.SecurityProfile, &amp;out.SecurityProfile
                *out = new(SecurityProfile)
                (*in).DeepCopyInto(*out)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachineSpec.
func (in *AzureMachineSpec) DeepCopy() *AzureMachineSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachineSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachineStatus) DeepCopyInto(out *AzureMachineStatus) <span class="cov8" title="1">{
        *out = *in
        if in.Addresses != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Addresses, &amp;out.Addresses
                *out = make([]v1.NodeAddress, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov8" title="1">if in.VMState != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.VMState, &amp;out.VMState
                *out = new(ProvisioningState)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.FailureReason != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.FailureReason, &amp;out.FailureReason
                *out = new(errors.MachineStatusError)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.FailureMessage != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.FailureMessage, &amp;out.FailureMessage
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.Conditions != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make(apiv1alpha4.Conditions, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov8" title="1">if in.LongRunningOperationStates != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.LongRunningOperationStates, &amp;out.LongRunningOperationStates
                *out = make(Futures, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachineStatus.
func (in *AzureMachineStatus) DeepCopy() *AzureMachineStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachineStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachineTemplate) DeepCopyInto(out *AzureMachineTemplate) <span class="cov8" title="1">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachineTemplate.
func (in *AzureMachineTemplate) DeepCopy() *AzureMachineTemplate <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">out := new(AzureMachineTemplate)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureMachineTemplate) DeepCopyObject() runtime.Object <span class="cov8" title="1">{
        if c := in.DeepCopy(); c != nil </span><span class="cov8" title="1">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachineTemplateList) DeepCopyInto(out *AzureMachineTemplateList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureMachineTemplate, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachineTemplateList.
func (in *AzureMachineTemplateList) DeepCopy() *AzureMachineTemplateList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachineTemplateList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureMachineTemplateList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachineTemplateResource) DeepCopyInto(out *AzureMachineTemplateResource) <span class="cov8" title="1">{
        *out = *in
        in.Spec.DeepCopyInto(&amp;out.Spec)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachineTemplateResource.
func (in *AzureMachineTemplateResource) DeepCopy() *AzureMachineTemplateResource <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachineTemplateResource)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachineTemplateSpec) DeepCopyInto(out *AzureMachineTemplateSpec) <span class="cov8" title="1">{
        *out = *in
        in.Template.DeepCopyInto(&amp;out.Template)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachineTemplateSpec.
func (in *AzureMachineTemplateSpec) DeepCopy() *AzureMachineTemplateSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachineTemplateSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMarketplaceImage) DeepCopyInto(out *AzureMarketplaceImage) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMarketplaceImage.
func (in *AzureMarketplaceImage) DeepCopy() *AzureMarketplaceImage <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMarketplaceImage)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureSharedGalleryImage) DeepCopyInto(out *AzureSharedGalleryImage) <span class="cov0" title="0">{
        *out = *in
        if in.Publisher != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Publisher, &amp;out.Publisher
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.Offer != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Offer, &amp;out.Offer
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.SKU != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.SKU, &amp;out.SKU
                *out = new(string)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureSharedGalleryImage.
func (in *AzureSharedGalleryImage) DeepCopy() *AzureSharedGalleryImage <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureSharedGalleryImage)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BackOffConfig) DeepCopyInto(out *BackOffConfig) <span class="cov0" title="0">{
        *out = *in
        if in.CloudProviderBackoffExponent != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.CloudProviderBackoffExponent, &amp;out.CloudProviderBackoffExponent
                x := (*in).DeepCopy()
                *out = &amp;x
        }</span>
        <span class="cov0" title="0">if in.CloudProviderBackoffJitter != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.CloudProviderBackoffJitter, &amp;out.CloudProviderBackoffJitter
                x := (*in).DeepCopy()
                *out = &amp;x
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BackOffConfig.
func (in *BackOffConfig) DeepCopy() *BackOffConfig <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(BackOffConfig)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BastionSpec) DeepCopyInto(out *BastionSpec) <span class="cov8" title="1">{
        *out = *in
        if in.AzureBastion != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AzureBastion, &amp;out.AzureBastion
                *out = new(AzureBastion)
                (*in).DeepCopyInto(*out)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BastionSpec.
func (in *BastionSpec) DeepCopy() *BastionSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(BastionSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BuildParams) DeepCopyInto(out *BuildParams) <span class="cov0" title="0">{
        *out = *in
        if in.Name != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Name, &amp;out.Name
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.Role != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Role, &amp;out.Role
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.Additional != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Additional, &amp;out.Additional
                *out = make(Tags, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BuildParams.
func (in *BuildParams) DeepCopy() *BuildParams <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(BuildParams)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CloudProviderConfigOverrides) DeepCopyInto(out *CloudProviderConfigOverrides) <span class="cov0" title="0">{
        *out = *in
        if in.RateLimits != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.RateLimits, &amp;out.RateLimits
                *out = make([]RateLimitSpec, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov0" title="0">in.BackOffs.DeepCopyInto(&amp;out.BackOffs)</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CloudProviderConfigOverrides.
func (in *CloudProviderConfigOverrides) DeepCopy() *CloudProviderConfigOverrides <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(CloudProviderConfigOverrides)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DataDisk) DeepCopyInto(out *DataDisk) <span class="cov0" title="0">{
        *out = *in
        if in.ManagedDisk != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ManagedDisk, &amp;out.ManagedDisk
                *out = new(ManagedDiskParameters)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov0" title="0">if in.Lun != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Lun, &amp;out.Lun
                *out = new(int32)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DataDisk.
func (in *DataDisk) DeepCopy() *DataDisk <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(DataDisk)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DiffDiskSettings) DeepCopyInto(out *DiffDiskSettings) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DiffDiskSettings.
func (in *DiffDiskSettings) DeepCopy() *DiffDiskSettings <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(DiffDiskSettings)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DiskEncryptionSetParameters) DeepCopyInto(out *DiskEncryptionSetParameters) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DiskEncryptionSetParameters.
func (in *DiskEncryptionSetParameters) DeepCopy() *DiskEncryptionSetParameters <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(DiskEncryptionSetParameters)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FrontendIP) DeepCopyInto(out *FrontendIP) <span class="cov0" title="0">{
        *out = *in
        if in.PublicIP != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.PublicIP, &amp;out.PublicIP
                *out = new(PublicIPSpec)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FrontendIP.
func (in *FrontendIP) DeepCopy() *FrontendIP <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(FrontendIP)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Future) DeepCopyInto(out *Future) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Future.
func (in *Future) DeepCopy() *Future <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(Future)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in Futures) DeepCopyInto(out *Futures) <span class="cov0" title="0">{
        </span><span class="cov0" title="0">{
                in := &amp;in
                *out = make(Futures, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Futures.
func (in Futures) DeepCopy() Futures <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(Futures)
        in.DeepCopyInto(out)
        return *out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Image) DeepCopyInto(out *Image) <span class="cov0" title="0">{
        *out = *in
        if in.ID != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ID, &amp;out.ID
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.SharedGallery != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.SharedGallery, &amp;out.SharedGallery
                *out = new(AzureSharedGalleryImage)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov0" title="0">if in.Marketplace != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Marketplace, &amp;out.Marketplace
                *out = new(AzureMarketplaceImage)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Image.
func (in *Image) DeepCopy() *Image <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(Image)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LoadBalancerSpec) DeepCopyInto(out *LoadBalancerSpec) <span class="cov8" title="1">{
        *out = *in
        if in.FrontendIPs != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.FrontendIPs, &amp;out.FrontendIPs
                *out = make([]FrontendIP, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov8" title="1">if in.FrontendIPsCount != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.FrontendIPsCount, &amp;out.FrontendIPsCount
                *out = new(int32)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.IdleTimeoutInMinutes != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.IdleTimeoutInMinutes, &amp;out.IdleTimeoutInMinutes
                *out = new(int32)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LoadBalancerSpec.
func (in *LoadBalancerSpec) DeepCopy() *LoadBalancerSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(LoadBalancerSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ManagedDiskParameters) DeepCopyInto(out *ManagedDiskParameters) <span class="cov0" title="0">{
        *out = *in
        if in.DiskEncryptionSet != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.DiskEncryptionSet, &amp;out.DiskEncryptionSet
                *out = new(DiskEncryptionSetParameters)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ManagedDiskParameters.
func (in *ManagedDiskParameters) DeepCopy() *ManagedDiskParameters <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(ManagedDiskParameters)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NatGateway) DeepCopyInto(out *NatGateway) <span class="cov0" title="0">{
        *out = *in
        out.NatGatewayIP = in.NatGatewayIP
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NatGateway.
func (in *NatGateway) DeepCopy() *NatGateway <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(NatGateway)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NetworkSpec) DeepCopyInto(out *NetworkSpec) <span class="cov8" title="1">{
        *out = *in
        in.Vnet.DeepCopyInto(&amp;out.Vnet)
        if in.Subnets != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Subnets, &amp;out.Subnets
                *out = make(Subnets, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov8" title="1">in.APIServerLB.DeepCopyInto(&amp;out.APIServerLB)
        if in.NodeOutboundLB != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.NodeOutboundLB, &amp;out.NodeOutboundLB
                *out = new(LoadBalancerSpec)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov8" title="1">if in.ControlPlaneOutboundLB != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ControlPlaneOutboundLB, &amp;out.ControlPlaneOutboundLB
                *out = new(LoadBalancerSpec)
                (*in).DeepCopyInto(*out)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NetworkSpec.
func (in *NetworkSpec) DeepCopy() *NetworkSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(NetworkSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OSDisk) DeepCopyInto(out *OSDisk) <span class="cov8" title="1">{
        *out = *in
        if in.DiskSizeGB != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.DiskSizeGB, &amp;out.DiskSizeGB
                *out = new(int32)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.ManagedDisk != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ManagedDisk, &amp;out.ManagedDisk
                *out = new(ManagedDiskParameters)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov8" title="1">if in.DiffDiskSettings != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.DiffDiskSettings, &amp;out.DiffDiskSettings
                *out = new(DiffDiskSettings)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OSDisk.
func (in *OSDisk) DeepCopy() *OSDisk <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OSDisk)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PublicIPSpec) DeepCopyInto(out *PublicIPSpec) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PublicIPSpec.
func (in *PublicIPSpec) DeepCopy() *PublicIPSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(PublicIPSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RateLimitConfig) DeepCopyInto(out *RateLimitConfig) <span class="cov0" title="0">{
        *out = *in
        if in.CloudProviderRateLimitQPS != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.CloudProviderRateLimitQPS, &amp;out.CloudProviderRateLimitQPS
                x := (*in).DeepCopy()
                *out = &amp;x
        }</span>
        <span class="cov0" title="0">if in.CloudProviderRateLimitQPSWrite != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.CloudProviderRateLimitQPSWrite, &amp;out.CloudProviderRateLimitQPSWrite
                x := (*in).DeepCopy()
                *out = &amp;x
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RateLimitConfig.
func (in *RateLimitConfig) DeepCopy() *RateLimitConfig <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(RateLimitConfig)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RateLimitSpec) DeepCopyInto(out *RateLimitSpec) <span class="cov0" title="0">{
        *out = *in
        in.Config.DeepCopyInto(&amp;out.Config)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RateLimitSpec.
func (in *RateLimitSpec) DeepCopy() *RateLimitSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(RateLimitSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RouteTable) DeepCopyInto(out *RouteTable) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RouteTable.
func (in *RouteTable) DeepCopy() *RouteTable <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(RouteTable)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecurityGroup) DeepCopyInto(out *SecurityGroup) <span class="cov0" title="0">{
        *out = *in
        if in.SecurityRules != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.SecurityRules, &amp;out.SecurityRules
                *out = make(SecurityRules, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov0" title="0">if in.Tags != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Tags, &amp;out.Tags
                *out = make(Tags, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecurityGroup.
func (in *SecurityGroup) DeepCopy() *SecurityGroup <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(SecurityGroup)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecurityProfile) DeepCopyInto(out *SecurityProfile) <span class="cov0" title="0">{
        *out = *in
        if in.EncryptionAtHost != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.EncryptionAtHost, &amp;out.EncryptionAtHost
                *out = new(bool)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecurityProfile.
func (in *SecurityProfile) DeepCopy() *SecurityProfile <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(SecurityProfile)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecurityRule) DeepCopyInto(out *SecurityRule) <span class="cov0" title="0">{
        *out = *in
        if in.SourcePorts != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.SourcePorts, &amp;out.SourcePorts
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.DestinationPorts != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.DestinationPorts, &amp;out.DestinationPorts
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.Source != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Source, &amp;out.Source
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.Destination != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Destination, &amp;out.Destination
                *out = new(string)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecurityRule.
func (in *SecurityRule) DeepCopy() *SecurityRule <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(SecurityRule)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in SecurityRules) DeepCopyInto(out *SecurityRules) <span class="cov0" title="0">{
        </span><span class="cov0" title="0">{
                in := &amp;in
                *out = make(SecurityRules, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecurityRules.
func (in SecurityRules) DeepCopy() SecurityRules <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(SecurityRules)
        in.DeepCopyInto(out)
        return *out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SpotVMOptions) DeepCopyInto(out *SpotVMOptions) <span class="cov0" title="0">{
        *out = *in
        if in.MaxPrice != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.MaxPrice, &amp;out.MaxPrice
                x := (*in).DeepCopy()
                *out = &amp;x
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SpotVMOptions.
func (in *SpotVMOptions) DeepCopy() *SpotVMOptions <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(SpotVMOptions)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SubnetSpec) DeepCopyInto(out *SubnetSpec) <span class="cov0" title="0">{
        *out = *in
        if in.CIDRBlocks != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.CIDRBlocks, &amp;out.CIDRBlocks
                *out = make([]string, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov0" title="0">in.SecurityGroup.DeepCopyInto(&amp;out.SecurityGroup)
        out.RouteTable = in.RouteTable
        out.NatGateway = in.NatGateway</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SubnetSpec.
func (in *SubnetSpec) DeepCopy() *SubnetSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(SubnetSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in Subnets) DeepCopyInto(out *Subnets) <span class="cov0" title="0">{
        </span><span class="cov0" title="0">{
                in := &amp;in
                *out = make(Subnets, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Subnets.
func (in Subnets) DeepCopy() Subnets <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(Subnets)
        in.DeepCopyInto(out)
        return *out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in Tags) DeepCopyInto(out *Tags) <span class="cov0" title="0">{
        </span><span class="cov0" title="0">{
                in := &amp;in
                *out = make(Tags, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Tags.
func (in Tags) DeepCopy() Tags <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(Tags)
        in.DeepCopyInto(out)
        return *out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *UserAssignedIdentity) DeepCopyInto(out *UserAssignedIdentity) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new UserAssignedIdentity.
func (in *UserAssignedIdentity) DeepCopy() *UserAssignedIdentity <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(UserAssignedIdentity)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *VM) DeepCopyInto(out *VM) <span class="cov0" title="0">{
        *out = *in
        in.Image.DeepCopyInto(&amp;out.Image)
        in.OSDisk.DeepCopyInto(&amp;out.OSDisk)
        if in.Tags != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Tags, &amp;out.Tags
                *out = make(Tags, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
        <span class="cov0" title="0">if in.Addresses != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Addresses, &amp;out.Addresses
                *out = make([]v1.NodeAddress, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VM.
func (in *VM) DeepCopy() *VM <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(VM)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *VnetSpec) DeepCopyInto(out *VnetSpec) <span class="cov8" title="1">{
        *out = *in
        if in.CIDRBlocks != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.CIDRBlocks, &amp;out.CIDRBlocks
                *out = make([]string, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov8" title="1">if in.Tags != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Tags, &amp;out.Tags
                *out = make(Tags, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VnetSpec.
func (in *VnetSpec) DeepCopy() *VnetSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(VnetSpec)
        in.DeepCopyInto(out)
        return out</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

// Hub marks AzureCluster as a conversion hub.
func (*AzureCluster) Hub() {<span class="cov0" title="0">}</span>

// Hub marks AzureClusterList as a conversion hub.
func (*AzureClusterList) Hub() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "fmt"

        "k8s.io/utils/pointer"
)

const (
        // DefaultVnetCIDR is the default Vnet CIDR.
        DefaultVnetCIDR = "10.0.0.0/8"
        // DefaultControlPlaneSubnetCIDR is the default Control Plane Subnet CIDR.
        DefaultControlPlaneSubnetCIDR = "10.0.0.0/16"
        // DefaultNodeSubnetCIDR is the default Node Subnet CIDR.
        DefaultNodeSubnetCIDR = "10.1.0.0/16"
        // DefaultNodeSubnetCIDRPattern is the pattern that will be used to generate the default subnets CIDRs.
        DefaultNodeSubnetCIDRPattern = "10.%d.0.0/16"
        // DefaultAzureBastionSubnetCIDR is the default Subnet CIDR for AzureBastion.
        DefaultAzureBastionSubnetCIDR = "10.255.255.224/27"
        // DefaultAzureBastionSubnetName is the default Subnet Name for AzureBastion.
        DefaultAzureBastionSubnetName = "AzureBastionSubnet"
        // DefaultAzureBastionSubnetRole is the default Subnet role for AzureBastion.
        DefaultAzureBastionSubnetRole = SubnetBastion
        // DefaultInternalLBIPAddress is the default internal load balancer ip address.
        DefaultInternalLBIPAddress = "10.0.0.100"
        // DefaultOutboundRuleIdleTimeoutInMinutes is the default for IdleTimeoutInMinutes for the load balancer.
        DefaultOutboundRuleIdleTimeoutInMinutes = 4
        // DefaultAzureCloud is the public cloud that will be used by most users.
        DefaultAzureCloud = "AzurePublicCloud"
)

func (c *AzureCluster) setDefaults() <span class="cov0" title="0">{
        c.Spec.AzureClusterClassSpec.setDefaults()
        c.setResourceGroupDefault()
        c.setNetworkSpecDefaults()
}</span>

func (c *AzureCluster) setNetworkSpecDefaults() <span class="cov0" title="0">{
        c.setVnetDefaults()
        c.setBastionDefaults()
        c.setSubnetDefaults()
        c.setVnetPeeringDefaults()
        c.setAPIServerLBDefaults()
        c.SetNodeOutboundLBDefaults()
        c.SetControlPlaneOutboundLBDefaults()
}</span>

func (c *AzureCluster) setResourceGroupDefault() <span class="cov8" title="1">{
        if c.Spec.ResourceGroup == "" </span><span class="cov8" title="1">{
                c.Spec.ResourceGroup = c.Name
        }</span>
}

func (c *AzureCluster) setAzureEnvironmentDefault() <span class="cov8" title="1">{
        if c.Spec.AzureEnvironment == "" </span><span class="cov8" title="1">{
                c.Spec.AzureEnvironment = DefaultAzureCloud
        }</span>
}

func (c *AzureCluster) setVnetDefaults() <span class="cov8" title="1">{
        if c.Spec.NetworkSpec.Vnet.ResourceGroup == "" </span><span class="cov8" title="1">{
                c.Spec.NetworkSpec.Vnet.ResourceGroup = c.Spec.ResourceGroup
        }</span>
        <span class="cov8" title="1">if c.Spec.NetworkSpec.Vnet.Name == "" </span><span class="cov8" title="1">{
                c.Spec.NetworkSpec.Vnet.Name = generateVnetName(c.ObjectMeta.Name)
        }</span>
        <span class="cov8" title="1">c.Spec.NetworkSpec.Vnet.VnetClassSpec.setDefaults()</span>
}

func (c *AzureCluster) setSubnetDefaults() <span class="cov8" title="1">{
        cpSubnet, err := c.Spec.NetworkSpec.GetControlPlaneSubnet()
        if err != nil </span><span class="cov8" title="1">{
                cpSubnet = SubnetSpec{SubnetClassSpec: SubnetClassSpec{Role: SubnetControlPlane}}
                c.Spec.NetworkSpec.Subnets = append(c.Spec.NetworkSpec.Subnets, cpSubnet)
        }</span>

        <span class="cov8" title="1">if cpSubnet.Name == "" </span><span class="cov8" title="1">{
                cpSubnet.Name = generateControlPlaneSubnetName(c.ObjectMeta.Name)
        }</span>

        <span class="cov8" title="1">cpSubnet.SubnetClassSpec.setDefaults(DefaultControlPlaneSubnetCIDR)

        if cpSubnet.SecurityGroup.Name == "" </span><span class="cov8" title="1">{
                cpSubnet.SecurityGroup.Name = generateControlPlaneSecurityGroupName(c.ObjectMeta.Name)
        }</span>
        <span class="cov8" title="1">cpSubnet.SecurityGroup.SecurityGroupClass.setDefaults()

        c.Spec.NetworkSpec.UpdateControlPlaneSubnet(cpSubnet)

        var nodeSubnetFound bool
        var nodeSubnetCounter int
        for i, subnet := range c.Spec.NetworkSpec.Subnets </span><span class="cov8" title="1">{
                if subnet.Role != SubnetNode </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">nodeSubnetCounter++
                nodeSubnetFound = true
                if subnet.Name == "" </span><span class="cov0" title="0">{
                        subnet.Name = withIndex(generateNodeSubnetName(c.ObjectMeta.Name), nodeSubnetCounter)
                }</span>
                <span class="cov8" title="1">subnet.SubnetClassSpec.setDefaults(fmt.Sprintf(DefaultNodeSubnetCIDRPattern, nodeSubnetCounter))

                if subnet.SecurityGroup.Name == "" </span><span class="cov8" title="1">{
                        subnet.SecurityGroup.Name = generateNodeSecurityGroupName(c.ObjectMeta.Name)
                }</span>
                <span class="cov8" title="1">cpSubnet.SecurityGroup.SecurityGroupClass.setDefaults()

                if subnet.RouteTable.Name == "" </span><span class="cov8" title="1">{
                        subnet.RouteTable.Name = generateNodeRouteTableName(c.ObjectMeta.Name)
                }</span>
                <span class="cov8" title="1">if subnet.IsNatGatewayEnabled() </span><span class="cov8" title="1">{
                        if subnet.NatGateway.NatGatewayIP.Name == "" </span><span class="cov8" title="1">{
                                subnet.NatGateway.NatGatewayIP.Name = generateNatGatewayIPName(c.ObjectMeta.Name, subnet.Name)
                        }</span>
                }

                <span class="cov8" title="1">c.Spec.NetworkSpec.Subnets[i] = subnet</span>
        }

        <span class="cov8" title="1">if !nodeSubnetFound </span><span class="cov8" title="1">{
                nodeSubnet := SubnetSpec{
                        SubnetClassSpec: SubnetClassSpec{
                                Role:       SubnetNode,
                                CIDRBlocks: []string{DefaultNodeSubnetCIDR},
                        },
                        Name: generateNodeSubnetName(c.ObjectMeta.Name),
                        SecurityGroup: SecurityGroup{
                                Name: generateNodeSecurityGroupName(c.ObjectMeta.Name),
                        },
                        RouteTable: RouteTable{
                                Name: generateNodeRouteTableName(c.ObjectMeta.Name),
                        },
                }
                c.Spec.NetworkSpec.Subnets = append(c.Spec.NetworkSpec.Subnets, nodeSubnet)
        }</span>
}

func (c *AzureCluster) setVnetPeeringDefaults() <span class="cov8" title="1">{
        for i, peering := range c.Spec.NetworkSpec.Vnet.Peerings </span><span class="cov8" title="1">{
                if peering.ResourceGroup == "" </span><span class="cov8" title="1">{
                        c.Spec.NetworkSpec.Vnet.Peerings[i].ResourceGroup = c.Spec.ResourceGroup
                }</span>
        }
}

func (c *AzureCluster) setAPIServerLBDefaults() <span class="cov8" title="1">{
        lb := &amp;c.Spec.NetworkSpec.APIServerLB

        lb.LoadBalancerClassSpec.setAPIServerLBDefaults()

        if lb.Type == Public </span><span class="cov8" title="1">{
                if lb.Name == "" </span><span class="cov8" title="1">{
                        lb.Name = generatePublicLBName(c.ObjectMeta.Name)
                }</span>
                <span class="cov8" title="1">if len(lb.FrontendIPs) == 0 </span><span class="cov8" title="1">{
                        lb.FrontendIPs = []FrontendIP{
                                {
                                        Name: generateFrontendIPConfigName(lb.Name),
                                        PublicIP: &amp;PublicIPSpec{
                                                Name: generatePublicIPName(c.ObjectMeta.Name),
                                        },
                                },
                        }
                }</span>
        } else<span class="cov8" title="1"> if lb.Type == Internal </span><span class="cov8" title="1">{
                if lb.Name == "" </span><span class="cov8" title="1">{
                        lb.Name = generateInternalLBName(c.ObjectMeta.Name)
                }</span>
                <span class="cov8" title="1">if len(lb.FrontendIPs) == 0 </span><span class="cov8" title="1">{
                        lb.FrontendIPs = []FrontendIP{
                                {
                                        Name: generateFrontendIPConfigName(lb.Name),
                                        FrontendIPClass: FrontendIPClass{
                                                PrivateIPAddress: DefaultInternalLBIPAddress,
                                        },
                                },
                        }
                }</span>
        }
}

// SetNodeOutboundLBDefaults sets the default values for the NodeOutboundLB.
func (c *AzureCluster) SetNodeOutboundLBDefaults() <span class="cov8" title="1">{
        if c.Spec.NetworkSpec.NodeOutboundLB == nil </span><span class="cov8" title="1">{
                if c.Spec.NetworkSpec.APIServerLB.Type == Internal </span><span class="cov8" title="1">{
                        return
                }</span>

                <span class="cov8" title="1">var needsOutboundLB bool
                for _, subnet := range c.Spec.NetworkSpec.Subnets </span><span class="cov8" title="1">{
                        if subnet.Role == SubnetNode &amp;&amp; !subnet.IsNatGatewayEnabled() </span><span class="cov8" title="1">{
                                needsOutboundLB = true
                                break</span>
                        }
                }

                // If we don't default the outbound LB when there are some subnets with NAT gateway,
                // and some without, those without wouldn't have outbound traffic. So taking the
                // safer route, we configure the outbound LB in that scenario.
                <span class="cov8" title="1">if !needsOutboundLB </span><span class="cov8" title="1">{
                        return
                }</span>

                <span class="cov8" title="1">c.Spec.NetworkSpec.NodeOutboundLB = &amp;LoadBalancerSpec{}</span>
        }

        <span class="cov8" title="1">lb := c.Spec.NetworkSpec.NodeOutboundLB
        lb.LoadBalancerClassSpec.setNodeOutboundLBDefaults()

        lb.Name = c.ObjectMeta.Name

        if lb.FrontendIPsCount == nil </span><span class="cov8" title="1">{
                lb.FrontendIPsCount = pointer.Int32Ptr(1)
        }</span>

        <span class="cov8" title="1">c.setOutboundLBFrontendIPs(lb, generateNodeOutboundIPName)</span>
}

// SetControlPlaneOutboundLBDefaults sets the default values for the control plane's outbound LB.
func (c *AzureCluster) SetControlPlaneOutboundLBDefaults() <span class="cov8" title="1">{
        lb := c.Spec.NetworkSpec.ControlPlaneOutboundLB

        if lb == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">lb.LoadBalancerClassSpec.setControlPlaneOutboundLBDefaults()
        if lb.Name == "" </span><span class="cov8" title="1">{
                lb.Name = generateControlPlaneOutboundLBName(c.ObjectMeta.Name)
        }</span>
        <span class="cov8" title="1">if lb.FrontendIPsCount == nil </span><span class="cov0" title="0">{
                lb.FrontendIPsCount = pointer.Int32Ptr(1)
        }</span>
        <span class="cov8" title="1">c.setOutboundLBFrontendIPs(lb, generateControlPlaneOutboundIPName)</span>
}

// setOutboundLBFrontendIPs sets the frontend ips for the given load balancer.
// The name of the frontend ip is generated using generatePublicIPName function.
func (c *AzureCluster) setOutboundLBFrontendIPs(lb *LoadBalancerSpec, generatePublicIPName func(string) string) <span class="cov8" title="1">{
        switch *lb.FrontendIPsCount </span>{
        case 0:<span class="cov0" title="0">
                lb.FrontendIPs = []FrontendIP{}</span>
        case 1:<span class="cov8" title="1">
                lb.FrontendIPs = []FrontendIP{
                        {
                                Name: generateFrontendIPConfigName(lb.Name),
                                PublicIP: &amp;PublicIPSpec{
                                        Name: generatePublicIPName(c.ObjectMeta.Name),
                                },
                        },
                }</span>
        default:<span class="cov8" title="1">
                lb.FrontendIPs = make([]FrontendIP, *lb.FrontendIPsCount)
                for i := 0; i &lt; int(*lb.FrontendIPsCount); i++ </span><span class="cov8" title="1">{
                        lb.FrontendIPs[i] = FrontendIP{
                                Name: withIndex(generateFrontendIPConfigName(lb.Name), i+1),
                                PublicIP: &amp;PublicIPSpec{
                                        Name: withIndex(generatePublicIPName(c.ObjectMeta.Name), i+1),
                                },
                        }
                }</span>
        }
}

func (c *AzureCluster) setBastionDefaults() <span class="cov8" title="1">{
        if c.Spec.BastionSpec.AzureBastion != nil </span><span class="cov8" title="1">{
                if c.Spec.BastionSpec.AzureBastion.Name == "" </span><span class="cov8" title="1">{
                        c.Spec.BastionSpec.AzureBastion.Name = generateAzureBastionName(c.ObjectMeta.Name)
                }</span>
                // Ensure defaults for the Subnet settings.
                <span class="cov8" title="1">if c.Spec.BastionSpec.AzureBastion.Subnet.Name == "" </span><span class="cov8" title="1">{
                        c.Spec.BastionSpec.AzureBastion.Subnet.Name = DefaultAzureBastionSubnetName
                }</span>
                <span class="cov8" title="1">if len(c.Spec.BastionSpec.AzureBastion.Subnet.CIDRBlocks) == 0 </span><span class="cov8" title="1">{
                        c.Spec.BastionSpec.AzureBastion.Subnet.CIDRBlocks = []string{DefaultAzureBastionSubnetCIDR}
                }</span>
                <span class="cov8" title="1">if c.Spec.BastionSpec.AzureBastion.Subnet.Role == "" </span><span class="cov8" title="1">{
                        c.Spec.BastionSpec.AzureBastion.Subnet.Role = DefaultAzureBastionSubnetRole
                }</span>
                // Ensure defaults for the PublicIP settings.
                <span class="cov8" title="1">if c.Spec.BastionSpec.AzureBastion.PublicIP.Name == "" </span><span class="cov8" title="1">{
                        c.Spec.BastionSpec.AzureBastion.PublicIP.Name = generateAzureBastionPublicIPName(c.ObjectMeta.Name)
                }</span>
        }
}

func (lb *LoadBalancerClassSpec) setAPIServerLBDefaults() <span class="cov8" title="1">{
        if lb.Type == "" </span><span class="cov8" title="1">{
                lb.Type = Public
        }</span>
        <span class="cov8" title="1">if lb.SKU == "" </span><span class="cov8" title="1">{
                lb.SKU = SKUStandard
        }</span>
        <span class="cov8" title="1">if lb.IdleTimeoutInMinutes == nil </span><span class="cov8" title="1">{
                lb.IdleTimeoutInMinutes = pointer.Int32Ptr(DefaultOutboundRuleIdleTimeoutInMinutes)
        }</span>
}

func (lb *LoadBalancerClassSpec) setNodeOutboundLBDefaults() <span class="cov8" title="1">{
        lb.setOutboundLBDefaults()
}</span>

func (lb *LoadBalancerClassSpec) setControlPlaneOutboundLBDefaults() <span class="cov8" title="1">{
        lb.setOutboundLBDefaults()
}</span>

func (lb *LoadBalancerClassSpec) setOutboundLBDefaults() <span class="cov8" title="1">{
        lb.Type = Public
        lb.SKU = SKUStandard
        if lb.IdleTimeoutInMinutes == nil </span><span class="cov8" title="1">{
                lb.IdleTimeoutInMinutes = pointer.Int32Ptr(DefaultOutboundRuleIdleTimeoutInMinutes)
        }</span>
}

func setControlPlaneOutboundLBDefaults(lb *LoadBalancerClassSpec, apiserverLBType LBType) <span class="cov8" title="1">{
        // public clusters don't need control plane outbound lb
        if apiserverLBType == Public </span><span class="cov8" title="1">{
                return
        }</span>

        // private clusters can disable control plane outbound lb by setting it to nil.
        <span class="cov8" title="1">if lb == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">lb.Type = Public
        lb.SKU = SKUStandard

        if lb.IdleTimeoutInMinutes == nil </span><span class="cov0" title="0">{
                lb.IdleTimeoutInMinutes = pointer.Int32Ptr(DefaultOutboundRuleIdleTimeoutInMinutes)
        }</span>
}

// generateVnetName generates a virtual network name, based on the cluster name.
func generateVnetName(clusterName string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s-%s", clusterName, "vnet")
}</span>

// generateControlPlaneSubnetName generates a node subnet name, based on the cluster name.
func generateControlPlaneSubnetName(clusterName string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s-%s", clusterName, "controlplane-subnet")
}</span>

// generateNodeSubnetName generates a node subnet name, based on the cluster name.
func generateNodeSubnetName(clusterName string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s-%s", clusterName, "node-subnet")
}</span>

// generateAzureBastionName generates an azure bastion name.
func generateAzureBastionName(clusterName string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s-azure-bastion", clusterName)
}</span>

// generateAzureBastionPublicIPName generates an azure bastion public ip name.
func generateAzureBastionPublicIPName(clusterName string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s-azure-bastion-pip", clusterName)
}</span>

// generateControlPlaneSecurityGroupName generates a control plane security group name, based on the cluster name.
func generateControlPlaneSecurityGroupName(clusterName string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s-%s", clusterName, "controlplane-nsg")
}</span>

// generateNodeSecurityGroupName generates a node security group name, based on the cluster name.
func generateNodeSecurityGroupName(clusterName string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s-%s", clusterName, "node-nsg")
}</span>

// generateNodeRouteTableName generates a node route table name, based on the cluster name.
func generateNodeRouteTableName(clusterName string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s-%s", clusterName, "node-routetable")
}</span>

// generateInternalLBName generates a internal load balancer name, based on the cluster name.
func generateInternalLBName(clusterName string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s-%s", clusterName, "internal-lb")
}</span>

// generatePublicLBName generates a public load balancer name, based on the cluster name.
func generatePublicLBName(clusterName string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s-%s", clusterName, "public-lb")
}</span>

// generateControlPlaneOutboundLBName generates the name of the control plane outbound LB.
func generateControlPlaneOutboundLBName(clusterName string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s-outbound-lb", clusterName)
}</span>

// generatePublicIPName generates a public IP name, based on the cluster name and a hash.
func generatePublicIPName(clusterName string) string <span class="cov8" title="1">{
        return fmt.Sprintf("pip-%s-apiserver", clusterName)
}</span>

// generateFrontendIPConfigName generates a load balancer frontend IP config name.
func generateFrontendIPConfigName(lbName string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s-%s", lbName, "frontEnd")
}</span>

// generateNodeOutboundIPName generates a public IP name, based on the cluster name.
func generateNodeOutboundIPName(clusterName string) string <span class="cov8" title="1">{
        return fmt.Sprintf("pip-%s-node-outbound", clusterName)
}</span>

// generateControlPlaneOutboundIPName generates a public IP name, based on the cluster name.
func generateControlPlaneOutboundIPName(clusterName string) string <span class="cov8" title="1">{
        return fmt.Sprintf("pip-%s-controlplane-outbound", clusterName)
}</span>

// generateNatGatewayIPName generates a NAT gateway IP name.
func generateNatGatewayIPName(clusterName, subnetName string) string <span class="cov8" title="1">{
        return fmt.Sprintf("pip-%s-%s-natgw", clusterName, subnetName)
}</span>

// withIndex appends the index as suffix to a generated name.
func withIndex(name string, n int) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s-%d", name, n)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
)

const (
        // ClusterFinalizer allows ReconcileAzureCluster to clean up Azure resources associated with AzureCluster before
        // removing it from the apiserver.
        ClusterFinalizer = "azurecluster.infrastructure.cluster.x-k8s.io"

        // ClusterLabelNamespace indicates the namespace of the cluster.
        ClusterLabelNamespace = "azurecluster.infrastructure.cluster.x-k8s.io/cluster-namespace"
)

// AzureClusterSpec defines the desired state of AzureCluster.
type AzureClusterSpec struct {
        AzureClusterClassSpec `json:",inline"`

        // NetworkSpec encapsulates all things related to Azure network.
        // +optional
        NetworkSpec NetworkSpec `json:"networkSpec,omitempty"`

        // +optional
        ResourceGroup string `json:"resourceGroup,omitempty"`

        // BastionSpec encapsulates all things related to the Bastions in the cluster.
        // +optional
        BastionSpec BastionSpec `json:"bastionSpec,omitempty"`

        // ControlPlaneEndpoint represents the endpoint used to communicate with the control plane. It is not recommended to set
        // this when creating an AzureCluster as CAPZ will set this for you. However, if it is set, CAPZ will not change it.
        // +optional
        ControlPlaneEndpoint clusterv1.APIEndpoint `json:"controlPlaneEndpoint,omitempty"`
}

// AzureClusterStatus defines the observed state of AzureCluster.
type AzureClusterStatus struct {
        // FailureDomains specifies the list of unique failure domains for the location/region of the cluster.
        // A FailureDomain maps to Availability Zone with an Azure Region (if the region support them). An
        // Availability Zone is a separate data center within a region and they can be used to ensure
        // the cluster is more resilient to failure.
        // See: https://docs.microsoft.com/en-us/azure/availability-zones/az-overview
        // This list will be used by Cluster API to try and spread the machines across the failure domains.
        // +optional
        FailureDomains clusterv1.FailureDomains `json:"failureDomains,omitempty"`

        // Ready is true when the provider resource is ready.
        // +optional
        Ready bool `json:"ready"`

        // Conditions defines current service state of the AzureCluster.
        // +optional
        Conditions clusterv1.Conditions `json:"conditions,omitempty"`

        // LongRunningOperationStates saves the states for Azure long-running operations so they can be continued on the
        // next reconciliation loop.
        // +optional
        LongRunningOperationStates Futures `json:"longRunningOperationStates,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:printcolumn:name="Cluster",type="string",JSONPath=".metadata.labels.cluster\\.x-k8s\\.io/cluster-name",description="Cluster to which this AzureCluster belongs"
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",priority=1,JSONPath=".status.conditions[?(@.type=='Ready')].message"
// +kubebuilder:printcolumn:name="Resource Group",type="string",priority=1,JSONPath=".spec.resourceGroup"
// +kubebuilder:printcolumn:name="SubscriptionID",type="string",priority=1,JSONPath=".spec.subscriptionID"
// +kubebuilder:printcolumn:name="Location",type="string",priority=1,JSONPath=".spec.location"
// +kubebuilder:printcolumn:name="Endpoint",type="string",priority=1,JSONPath=".spec.controlPlaneEndpoint.host",description="Control Plane Endpoint"
// +kubebuilder:resource:path=azureclusters,scope=Namespaced,categories=cluster-api
// +kubebuilder:storageversion
// +kubebuilder:subresource:status

// AzureCluster is the Schema for the azureclusters API.
type AzureCluster struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   AzureClusterSpec   `json:"spec,omitempty"`
        Status AzureClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AzureClusterList contains a list of AzureClusters.
type AzureClusterList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []AzureCluster `json:"items"`
}

// GetConditions returns the list of conditions for an AzureCluster API object.
func (c *AzureCluster) GetConditions() clusterv1.Conditions <span class="cov0" title="0">{
        return c.Status.Conditions
}</span>

// SetConditions will set the given conditions on an AzureCluster object.
func (c *AzureCluster) SetConditions(conditions clusterv1.Conditions) <span class="cov0" title="0">{
        c.Status.Conditions = conditions
}</span>

// GetFutures returns the list of long running operation states for an AzureCluster API object.
func (c *AzureCluster) GetFutures() Futures <span class="cov0" title="0">{
        return c.Status.LongRunningOperationStates
}</span>

// SetFutures will set the given long running operation states on an AzureCluster object.
func (c *AzureCluster) SetFutures(futures Futures) <span class="cov0" title="0">{
        c.Status.LongRunningOperationStates = futures
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;AzureCluster{}, &amp;AzureClusterList{})
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "fmt"
        "net"
        "reflect"
        "regexp"

        valid "github.com/asaskevich/govalidator"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/util/validation/field"
        "k8s.io/utils/pointer"
)

const (
        // can't use: \/"'[]:|&lt;&gt;+=;,.?*@&amp;, Can't start with underscore. Can't end with period or hyphen.
        // not using . in the name to avoid issues when the name is part of DNS name.
        clusterNameRegex = `^[a-z0-9][a-z0-9-]{0,42}[a-z0-9]$`
        // max length of 44 to allow for cluster name to be used as a prefix for VMs and other resources that
        // have limitations as outlined here https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/resource-name-rules.
        clusterNameMaxLength = 44
        // obtained from https://docs.microsoft.com/en-us/rest/api/resources/resourcegroups/createorupdate#uri-parameters.
        resourceGroupRegex = `^[-\w\._\(\)]+$`
        // described in https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/resource-name-rules.
        subnetRegex       = `^[-\w\._]+$`
        loadBalancerRegex = `^[-\w\._]+$`
        // MaxLoadBalancerOutboundIPs is the maximum number of outbound IPs in a Standard LoadBalancer frontend configuration.
        MaxLoadBalancerOutboundIPs = 16
        // MinLBIdleTimeoutInMinutes is the minimum number of minutes for the LB idle timeout.
        MinLBIdleTimeoutInMinutes = 4
        // MaxLBIdleTimeoutInMinutes is the maximum number of minutes for the LB idle timeout.
        MaxLBIdleTimeoutInMinutes = 30
        // Network security rules should be a number between 100 and 4096.
        // https://docs.microsoft.com/en-us/azure/virtual-network/network-security-groups-overview#security-rules
        minRulePriority = 100
        maxRulePriority = 4096
)

// validateCluster validates a cluster.
func (c *AzureCluster) validateCluster(old *AzureCluster) error <span class="cov8" title="1">{
        var allErrs field.ErrorList
        allErrs = append(allErrs, c.validateClusterName()...)
        allErrs = append(allErrs, c.validateClusterSpec(old)...)
        if len(allErrs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return apierrors.NewInvalid(
                schema.GroupKind{Group: "infrastructure.cluster.x-k8s.io", Kind: "AzureCluster"},
                c.Name, allErrs)</span>
}

// validateClusterSpec validates a ClusterSpec.
func (c *AzureCluster) validateClusterSpec(old *AzureCluster) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList
        var oldNetworkSpec NetworkSpec
        if old != nil </span><span class="cov8" title="1">{
                oldNetworkSpec = old.Spec.NetworkSpec
        }</span>
        <span class="cov8" title="1">allErrs = append(allErrs, validateNetworkSpec(c.Spec.NetworkSpec, oldNetworkSpec, field.NewPath("spec").Child("networkSpec"))...)

        var oldCloudProviderConfigOverrides *CloudProviderConfigOverrides
        if old != nil </span><span class="cov8" title="1">{
                oldCloudProviderConfigOverrides = old.Spec.CloudProviderConfigOverrides
        }</span>
        <span class="cov8" title="1">allErrs = append(allErrs, validateCloudProviderConfigOverrides(c.Spec.CloudProviderConfigOverrides, oldCloudProviderConfigOverrides,
                field.NewPath("spec").Child("cloudProviderConfigOverrides"))...)

        return allErrs</span>
}

// validateClusterName validates ClusterName.
func (c *AzureCluster) validateClusterName() field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList
        if len(c.Name) &gt; clusterNameMaxLength </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(field.NewPath("metadata").Child("Name"), c.Name,
                        fmt.Sprintf("Cluster Name longer than allowed length of %d characters", clusterNameMaxLength)))
        }</span>
        <span class="cov8" title="1">if success, _ := regexp.MatchString(clusterNameRegex, c.Name); !success </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(field.NewPath("metadata").Child("Name"), c.Name,
                        fmt.Sprintf("Cluster Name doesn't match regex %s, can contain only lowercase alphanumeric characters and '-', must start/end with an alphanumeric character",
                                clusterNameRegex)))
        }</span>
        <span class="cov8" title="1">if len(allErrs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return allErrs</span>
}

// validateNetworkSpec validates a NetworkSpec.
func validateNetworkSpec(networkSpec NetworkSpec, old NetworkSpec, fldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList
        // If the user specifies a resourceGroup for vnet, it means
        // that she intends to use a pre-existing vnet. In this case,
        // we need to verify the information she provides
        if networkSpec.Vnet.ResourceGroup != "" </span><span class="cov8" title="1">{
                if err := validateResourceGroup(networkSpec.Vnet.ResourceGroup,
                        fldPath.Child("vnet").Child("resourceGroup")); err != nil </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, err)
                }</span>

                <span class="cov8" title="1">allErrs = append(allErrs, validateVnetCIDR(networkSpec.Vnet.CIDRBlocks, fldPath.Child("cidrBlocks"))...)

                allErrs = append(allErrs, validateSubnets(networkSpec.Subnets, networkSpec.Vnet, fldPath.Child("subnets"))...)

                allErrs = append(allErrs, validateVnetPeerings(networkSpec.Vnet.Peerings, fldPath.Child("peerings"))...)</span>
        }

        <span class="cov8" title="1">var cidrBlocks []string
        controlPlaneSubnet, err := networkSpec.GetControlPlaneSubnet()
        if err != nil </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(fldPath.Child("subnets"), networkSpec.Subnets, "ControlPlaneSubnet invalid"))
        }</span>

        <span class="cov8" title="1">cidrBlocks = controlPlaneSubnet.CIDRBlocks

        allErrs = append(allErrs, validateAPIServerLB(networkSpec.APIServerLB, old.APIServerLB, cidrBlocks, fldPath.Child("apiServerLB"))...)

        var oneSubnetWithoutNatGateway bool
        for _, subnet := range networkSpec.Subnets </span><span class="cov8" title="1">{
                if subnet.Role == SubnetNode &amp;&amp; !subnet.IsNatGatewayEnabled() </span><span class="cov8" title="1">{
                        oneSubnetWithoutNatGateway = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if oneSubnetWithoutNatGateway </span><span class="cov8" title="1">{
                allErrs = append(allErrs, validateNodeOutboundLB(networkSpec.NodeOutboundLB, old.NodeOutboundLB, networkSpec.APIServerLB, fldPath.Child("nodeOutboundLB"))...)
        }</span>

        <span class="cov8" title="1">allErrs = append(allErrs, validateControlPlaneOutboundLB(networkSpec.ControlPlaneOutboundLB, networkSpec.APIServerLB, fldPath.Child("controlPlaneOutboundLB"))...)

        allErrs = append(allErrs, validatePrivateDNSZoneName(networkSpec.PrivateDNSZoneName, networkSpec.APIServerLB.Type, fldPath.Child("privateDNSZoneName"))...)

        if len(allErrs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return allErrs</span>
}

// validateResourceGroup validates a ResourceGroup.
func validateResourceGroup(resourceGroup string, fldPath *field.Path) *field.Error <span class="cov8" title="1">{
        if success, _ := regexp.MatchString(resourceGroupRegex, resourceGroup); !success </span><span class="cov8" title="1">{
                return field.Invalid(fldPath, resourceGroup,
                        fmt.Sprintf("resourceGroup doesn't match regex %s", resourceGroupRegex))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validateSubnets validates a list of Subnets.
func validateSubnets(subnets Subnets, vnet VnetSpec, fldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList
        subnetNames := make(map[string]bool, len(subnets))
        requiredSubnetRoles := map[string]bool{
                "control-plane": false,
                "node":          false,
        }

        for i, subnet := range subnets </span><span class="cov8" title="1">{
                if err := validateSubnetName(subnet.Name, fldPath.Index(i).Child("name")); err != nil </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, err)
                }</span>
                <span class="cov8" title="1">if _, ok := subnetNames[subnet.Name]; ok </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, field.Duplicate(fldPath, subnet.Name))
                }</span>
                <span class="cov8" title="1">subnetNames[subnet.Name] = true
                for role := range requiredSubnetRoles </span><span class="cov8" title="1">{
                        if role == string(subnet.Role) </span><span class="cov8" title="1">{
                                requiredSubnetRoles[role] = true
                        }</span>
                }
                <span class="cov8" title="1">for _, rule := range subnet.SecurityGroup.SecurityRules </span><span class="cov0" title="0">{
                        if err := validateSecurityRule(
                                rule,
                                fldPath.Index(i).Child("securityGroup").Child("securityRules").Index(i),
                        ); err != nil </span><span class="cov0" title="0">{
                                allErrs = append(allErrs, err)
                        }</span>
                }
                <span class="cov8" title="1">allErrs = append(allErrs, validateSubnetCIDR(subnet.CIDRBlocks, vnet.CIDRBlocks, fldPath.Index(i).Child("cidrBlocks"))...)</span>
        }
        <span class="cov8" title="1">for k, v := range requiredSubnetRoles </span><span class="cov8" title="1">{
                if !v </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, field.Required(fldPath,
                                fmt.Sprintf("required role %s not included in provided subnets", k)))
                }</span>
        }
        <span class="cov8" title="1">return allErrs</span>
}

// validateSubnetName validates the Name of a Subnet.
func validateSubnetName(name string, fldPath *field.Path) *field.Error <span class="cov8" title="1">{
        if success, _ := regexp.Match(subnetRegex, []byte(name)); !success </span><span class="cov8" title="1">{
                return field.Invalid(fldPath, name,
                        fmt.Sprintf("name of subnet doesn't match regex %s", subnetRegex))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validateSubnetCIDR validates the CIDR blocks of a Subnet.
func validateSubnetCIDR(subnetCidrBlocks []string, vnetCidrBlocks []string, fldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList
        var vnetNws []*net.IPNet

        for _, vnetCidr := range vnetCidrBlocks </span><span class="cov8" title="1">{
                if _, vnetNw, err := net.ParseCIDR(vnetCidr); err == nil </span><span class="cov8" title="1">{
                        vnetNws = append(vnetNws, vnetNw)
                }</span>
        }

        <span class="cov8" title="1">for _, subnetCidr := range subnetCidrBlocks </span><span class="cov8" title="1">{
                subnetCidrIP, _, err := net.ParseCIDR(subnetCidr)
                if err != nil </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, field.Invalid(fldPath, subnetCidr, "invalid CIDR format"))
                }</span>

                <span class="cov8" title="1">var found bool
                for _, vnetNw := range vnetNws </span><span class="cov8" title="1">{
                        if vnetNw.Contains(subnetCidrIP) </span><span class="cov8" title="1">{
                                found = true
                                break</span>
                        }
                }

                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, field.Invalid(fldPath, subnetCidr, fmt.Sprintf("subnet CIDR not in vnet address space: %s", vnetCidrBlocks)))
                }</span>
        }

        <span class="cov8" title="1">return allErrs</span>
}

// validateVnetCIDR validates the CIDR blocks of a Vnet.
func validateVnetCIDR(vnetCIDRBlocks []string, fldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList
        for _, vnetCidr := range vnetCIDRBlocks </span><span class="cov8" title="1">{
                if _, _, err := net.ParseCIDR(vnetCidr); err != nil </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, field.Invalid(fldPath, vnetCidr, "invalid CIDR format"))
                }</span>
        }
        <span class="cov8" title="1">return allErrs</span>
}

// validateVnetPeerings validates a list of virtual network peerings.
func validateVnetPeerings(peerings VnetPeerings, fldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList
        vnetIdentifiers := make(map[string]bool, len(peerings))

        for _, peering := range peerings </span><span class="cov0" title="0">{
                vnetIdentifier := peering.ResourceGroup + "/" + peering.RemoteVnetName
                if _, ok := vnetIdentifiers[vnetIdentifier]; ok </span><span class="cov0" title="0">{
                        allErrs = append(allErrs, field.Duplicate(fldPath, vnetIdentifier))
                }</span>
                <span class="cov0" title="0">vnetIdentifiers[vnetIdentifier] = true</span>
        }
        <span class="cov8" title="1">return allErrs</span>
}

// validateLoadBalancerName validates the Name of a Load Balancer.
func validateLoadBalancerName(name string, fldPath *field.Path) *field.Error <span class="cov8" title="1">{
        if success, _ := regexp.Match(loadBalancerRegex, []byte(name)); !success </span><span class="cov8" title="1">{
                return field.Invalid(fldPath, name,
                        fmt.Sprintf("name of load balancer doesn't match regex %s", loadBalancerRegex))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validateInternalLBIPAddress validates a InternalLBIPAddress.
func validateInternalLBIPAddress(address string, cidrs []string, fldPath *field.Path) *field.Error <span class="cov8" title="1">{
        ip := net.ParseIP(address)
        if ip == nil </span><span class="cov8" title="1">{
                return field.Invalid(fldPath, address,
                        "Internal LB IP address isn't a valid IPv4 or IPv6 address")
        }</span>
        <span class="cov8" title="1">for _, cidr := range cidrs </span><span class="cov8" title="1">{
                _, subnet, _ := net.ParseCIDR(cidr)
                if subnet.Contains(ip) </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }
        <span class="cov8" title="1">return field.Invalid(fldPath, address,
                fmt.Sprintf("Internal LB IP address needs to be in control plane subnet range (%s)", cidrs))</span>
}

// validateSecurityRule validates a SecurityRule.
func validateSecurityRule(rule SecurityRule, fldPath *field.Path) *field.Error <span class="cov8" title="1">{
        if rule.Priority &lt; minRulePriority || rule.Priority &gt; maxRulePriority </span><span class="cov8" title="1">{
                return field.Invalid(fldPath, rule.Priority, fmt.Sprintf("security rule priorities should be between %d and %d", minRulePriority, maxRulePriority))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func validateAPIServerLB(lb LoadBalancerSpec, old LoadBalancerSpec, cidrs []string, fldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList

        lbClassSpec := lb.LoadBalancerClassSpec
        olLBClassSpec := old.LoadBalancerClassSpec
        allErrs = append(allErrs, validateClassSpecForAPIServerLB(lbClassSpec, &amp;olLBClassSpec, fldPath)...)

        // Name should be valid.
        if err := validateLoadBalancerName(lb.Name, fldPath.Child("name")); err != nil </span><span class="cov8" title="1">{
                allErrs = append(allErrs, err)
        }</span>
        // Name should be immutable.
        <span class="cov8" title="1">if old.Name != "" &amp;&amp; old.Name != lb.Name </span><span class="cov0" title="0">{
                allErrs = append(allErrs, field.Forbidden(fldPath.Child("name"), "API Server load balancer name should not be modified after AzureCluster creation."))
        }</span>

        // There should only be one IP config.
        <span class="cov8" title="1">if len(lb.FrontendIPs) != 1 || pointer.Int32Deref(lb.FrontendIPsCount, 1) != 1 </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(fldPath.Child("frontendIPConfigs"), lb.FrontendIPs,
                        "API Server Load balancer should have 1 Frontend IP"))
        }</span> else<span class="cov8" title="1"> {
                // if Internal, IP config should not have a public IP.
                if lb.Type == Internal </span><span class="cov8" title="1">{
                        if lb.FrontendIPs[0].PublicIP != nil </span><span class="cov8" title="1">{
                                allErrs = append(allErrs, field.Forbidden(fldPath.Child("frontendIPConfigs").Index(0).Child("publicIP"),
                                        "Internal Load Balancers cannot have a Public IP"))
                        }</span>
                        <span class="cov8" title="1">if lb.FrontendIPs[0].PrivateIPAddress != "" </span><span class="cov8" title="1">{
                                if err := validateInternalLBIPAddress(lb.FrontendIPs[0].PrivateIPAddress, cidrs,
                                        fldPath.Child("frontendIPConfigs").Index(0).Child("privateIP")); err != nil </span><span class="cov8" title="1">{
                                        allErrs = append(allErrs, err)
                                }</span>
                                <span class="cov8" title="1">if len(old.FrontendIPs) != 0 &amp;&amp; old.FrontendIPs[0].PrivateIPAddress != lb.FrontendIPs[0].PrivateIPAddress </span><span class="cov0" title="0">{
                                        allErrs = append(allErrs, field.Forbidden(fldPath.Child("name"), "API Server load balancer private IP should not be modified after AzureCluster creation."))
                                }</span>
                        }
                }

                // if Public, IP config should not have a private IP.
                <span class="cov8" title="1">if lb.Type == Public </span><span class="cov8" title="1">{
                        if lb.FrontendIPs[0].PrivateIPAddress != "" </span><span class="cov8" title="1">{
                                allErrs = append(allErrs, field.Forbidden(fldPath.Child("frontendIPConfigs").Index(0).Child("privateIP"),
                                        "Public Load Balancers cannot have a Private IP"))
                        }</span>
                }
        }

        <span class="cov8" title="1">return allErrs</span>
}

func validateNodeOutboundLB(lb *LoadBalancerSpec, old *LoadBalancerSpec, apiserverLB LoadBalancerSpec, fldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList

        var lbClassSpec, oldClassSpec *LoadBalancerClassSpec
        if lb != nil </span><span class="cov8" title="1">{
                lbClassSpec = &amp;lb.LoadBalancerClassSpec
        }</span>
        <span class="cov8" title="1">if old != nil </span><span class="cov8" title="1">{
                oldClassSpec = &amp;old.LoadBalancerClassSpec
        }</span>
        <span class="cov8" title="1">apiserverLBClassSpec := apiserverLB.LoadBalancerClassSpec

        allErrs = append(allErrs, validateClassSpecForNodeOutboundLB(lbClassSpec, oldClassSpec, apiserverLBClassSpec, fldPath)...)

        if lb == nil </span><span class="cov8" title="1">{
                return allErrs
        }</span>

        <span class="cov8" title="1">if old != nil &amp;&amp; old.ID != lb.ID </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Forbidden(fldPath.Child("id"), "Node outbound load balancer ID should not be modified after AzureCluster creation."))
        }</span>

        <span class="cov8" title="1">if old != nil &amp;&amp; old.Name != lb.Name </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Forbidden(fldPath.Child("name"), "Node outbound load balancer Name should not be modified after AzureCluster creation."))
        }</span>

        <span class="cov8" title="1">if old != nil &amp;&amp; old.FrontendIPsCount == lb.FrontendIPsCount </span><span class="cov8" title="1">{
                if len(old.FrontendIPs) != len(lb.FrontendIPs) </span><span class="cov0" title="0">{
                        allErrs = append(allErrs, field.Forbidden(fldPath.Child("frontendIPs"), "Node outbound load balancer FrontendIPs cannot be modified after AzureCluster creation."))
                }</span>

                <span class="cov8" title="1">if len(old.FrontendIPs) == len(lb.FrontendIPs) </span><span class="cov8" title="1">{
                        for i, frontEndIP := range lb.FrontendIPs </span><span class="cov8" title="1">{
                                oldFrontendIP := old.FrontendIPs[i]
                                if oldFrontendIP.Name != frontEndIP.Name || !reflect.DeepEqual(*oldFrontendIP.PublicIP, *frontEndIP.PublicIP) </span><span class="cov8" title="1">{
                                        allErrs = append(allErrs, field.Forbidden(fldPath.Child("frontendIPs").Index(i),
                                                "Node outbound load balancer FrontendIPs cannot be modified after AzureCluster creation."))
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">if lb.FrontendIPsCount != nil &amp;&amp; *lb.FrontendIPsCount &gt; MaxLoadBalancerOutboundIPs </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(fldPath.Child("frontendIPsCount"), *lb.FrontendIPsCount,
                        fmt.Sprintf("Max front end ips allowed is %d", MaxLoadBalancerOutboundIPs)))
        }</span>

        <span class="cov8" title="1">return allErrs</span>
}

func validateControlPlaneOutboundLB(lb *LoadBalancerSpec, apiserverLB LoadBalancerSpec, fldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList

        var lbClassSpec *LoadBalancerClassSpec
        if lb != nil </span><span class="cov8" title="1">{
                lbClassSpec = &amp;lb.LoadBalancerClassSpec
        }</span>
        <span class="cov8" title="1">apiServerLBClassSpec := apiserverLB.LoadBalancerClassSpec

        allErrs = append(allErrs, validateClassSpecForControlPlaneOutboundLB(lbClassSpec, apiServerLBClassSpec, fldPath)...)

        if apiServerLBClassSpec.Type == Internal &amp;&amp; lb != nil </span><span class="cov8" title="1">{
                if lb.FrontendIPsCount != nil &amp;&amp; *lb.FrontendIPsCount &gt; MaxLoadBalancerOutboundIPs </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, field.Invalid(fldPath.Child("frontendIPsCount"), *lb.FrontendIPsCount,
                                fmt.Sprintf("Max front end ips allowed is %d", MaxLoadBalancerOutboundIPs)))
                }</span>
        }

        <span class="cov8" title="1">return allErrs</span>
}

// validatePrivateDNSZoneName validates the PrivateDNSZoneName.
func validatePrivateDNSZoneName(privateDNSZoneName string, apiserverLBType LBType, fldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList

        if len(privateDNSZoneName) &gt; 0 </span><span class="cov8" title="1">{
                if apiserverLBType != Internal </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, field.Invalid(fldPath, apiserverLBType,
                                "PrivateDNSZoneName is available only if APIServerLB.Type is Internal"))
                }</span>
                <span class="cov8" title="1">if !valid.IsDNSName(privateDNSZoneName) </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, field.Invalid(fldPath, privateDNSZoneName,
                                "PrivateDNSZoneName can only contain alphanumeric characters, underscores and dashes, must end with an alphanumeric character",
                        ))
                }</span>
        }

        <span class="cov8" title="1">return allErrs</span>
}

// validateCloudProviderConfigOverrides validates CloudProviderConfigOverrides.
func validateCloudProviderConfigOverrides(oldConfig, newConfig *CloudProviderConfigOverrides, fldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList
        if !reflect.DeepEqual(oldConfig, newConfig) </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(fldPath, newConfig, "cannot change cloudProviderConfigOverrides cluster creation"))
        }</span>
        <span class="cov8" title="1">return allErrs</span>
}

func validateClassSpecForAPIServerLB(lb LoadBalancerClassSpec, old *LoadBalancerClassSpec, apiServerLBPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList

        // SKU should be Standard
        if lb.SKU != SKUStandard </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.NotSupported(apiServerLBPath.Child("sku"), lb.SKU, []string{string(SKUStandard)}))
        }</span>

        // Type should be Public or Internal.
        <span class="cov8" title="1">if lb.Type != Internal &amp;&amp; lb.Type != Public </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.NotSupported(apiServerLBPath.Child("type"), lb.Type,
                        []string{string(Public), string(Internal)}))
        }</span>

        // SKU should be immutable.
        <span class="cov8" title="1">if old != nil &amp;&amp; old.SKU != "" &amp;&amp; old.SKU != lb.SKU </span><span class="cov0" title="0">{
                allErrs = append(allErrs, field.Forbidden(apiServerLBPath.Child("sku"), "API Server load balancer SKU should not be modified after AzureCluster creation."))
        }</span>

        // Type should be immutable.
        <span class="cov8" title="1">if old != nil &amp;&amp; old.Type != "" &amp;&amp; old.Type != lb.Type </span><span class="cov0" title="0">{
                allErrs = append(allErrs, field.Forbidden(apiServerLBPath.Child("type"), "API Server load balancer type should not be modified after AzureCluster creation."))
        }</span>

        // IdletimeoutInMinutes should be immutable.
        <span class="cov8" title="1">if old != nil &amp;&amp; old.IdleTimeoutInMinutes != nil &amp;&amp; !pointer.Int32Equal(old.IdleTimeoutInMinutes, lb.IdleTimeoutInMinutes) </span><span class="cov0" title="0">{
                allErrs = append(allErrs, field.Forbidden(apiServerLBPath.Child("idleTimeoutInMinutes"), "API Server load balancer idle timeout cannot be modified after AzureCluster creation."))
        }</span>

        <span class="cov8" title="1">if lb.IdleTimeoutInMinutes != nil &amp;&amp; (*lb.IdleTimeoutInMinutes &lt; MinLBIdleTimeoutInMinutes || *lb.IdleTimeoutInMinutes &gt; MaxLBIdleTimeoutInMinutes) </span><span class="cov0" title="0">{
                allErrs = append(allErrs, field.Invalid(apiServerLBPath.Child("idleTimeoutInMinutes"), *lb.IdleTimeoutInMinutes,
                        fmt.Sprintf("Node outbound idle timeout should be between %d and %d minutes", MinLBIdleTimeoutInMinutes, MaxLoadBalancerOutboundIPs)))
        }</span>

        <span class="cov8" title="1">return allErrs</span>
}

func validateClassSpecForNodeOutboundLB(lb *LoadBalancerClassSpec, old *LoadBalancerClassSpec, apiserverLB LoadBalancerClassSpec, fldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList

        // LB can be nil when disabled for private clusters.
        if lb == nil &amp;&amp; apiserverLB.Type == Internal </span><span class="cov8" title="1">{
                return allErrs
        }</span>

        <span class="cov8" title="1">if lb == nil </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Required(fldPath, "Node outbound load balancer cannot be nil for public clusters."))
                return allErrs
        }</span>

        <span class="cov8" title="1">if old != nil &amp;&amp; old.SKU != lb.SKU </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Forbidden(fldPath.Child("sku"), "Node outbound load balancer SKU should not be modified after AzureCluster creation."))
        }</span>

        <span class="cov8" title="1">if old != nil &amp;&amp; old.Type != lb.Type </span><span class="cov0" title="0">{
                allErrs = append(allErrs, field.Forbidden(fldPath.Child("type"), "Node outbound load balancer Type cannot be modified after AzureCluster creation."))
        }</span>

        <span class="cov8" title="1">if old != nil &amp;&amp; !pointer.Int32Equal(old.IdleTimeoutInMinutes, lb.IdleTimeoutInMinutes) </span><span class="cov0" title="0">{
                allErrs = append(allErrs, field.Forbidden(fldPath.Child("idleTimeoutInMinutes"), "Node outbound load balancer idle timeout cannot be modified after AzureCluster creation."))
        }</span>

        <span class="cov8" title="1">if lb.IdleTimeoutInMinutes != nil &amp;&amp; (*lb.IdleTimeoutInMinutes &lt; MinLBIdleTimeoutInMinutes || *lb.IdleTimeoutInMinutes &gt; MaxLBIdleTimeoutInMinutes) </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(fldPath.Child("idleTimeoutInMinutes"), *lb.IdleTimeoutInMinutes,
                        fmt.Sprintf("Node outbound idle timeout should be between %d and %d minutes", MinLBIdleTimeoutInMinutes, MaxLoadBalancerOutboundIPs)))
        }</span>

        <span class="cov8" title="1">return allErrs</span>
}

func validateClassSpecForControlPlaneOutboundLB(lb *LoadBalancerClassSpec, apiserverLB LoadBalancerClassSpec, fldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList

        switch apiserverLB.Type </span>{
        case Public:<span class="cov8" title="1">
                if lb != nil </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, field.Forbidden(fldPath, "Control plane outbound load balancer cannot be set for public clusters."))
                }</span>
        case Internal:<span class="cov8" title="1">
                // Control plane outbound lb can be nil when it's disabled for private clusters.
                if lb == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">if lb.IdleTimeoutInMinutes != nil &amp;&amp; (*lb.IdleTimeoutInMinutes &lt; MinLBIdleTimeoutInMinutes || *lb.IdleTimeoutInMinutes &gt; MaxLBIdleTimeoutInMinutes) </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, field.Invalid(fldPath.Child("idleTimeoutInMinutes"), *lb.IdleTimeoutInMinutes,
                                fmt.Sprintf("Control plane outbound idle timeout should be between %d and %d minutes", MinLBIdleTimeoutInMinutes, MaxLoadBalancerOutboundIPs)))
                }</span>
        }

        <span class="cov8" title="1">return allErrs</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "reflect"

        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/util/validation/field"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/webhook"
)

// SetupWebhookWithManager sets up and registers the webhook with the manager.
func (c *AzureCluster) SetupWebhookWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewWebhookManagedBy(mgr).
                For(c).
                Complete()
}</span>

// +kubebuilder:webhook:verbs=create;update,path=/validate-infrastructure-cluster-x-k8s-io-v1beta1-azurecluster,mutating=false,failurePolicy=fail,matchPolicy=Equivalent,groups=infrastructure.cluster.x-k8s.io,resources=azureclusters,versions=v1beta1,name=validation.azurecluster.infrastructure.cluster.x-k8s.io,sideEffects=None,admissionReviewVersions=v1;v1beta1
// +kubebuilder:webhook:verbs=create;update,path=/mutate-infrastructure-cluster-x-k8s-io-v1beta1-azurecluster,mutating=true,failurePolicy=fail,matchPolicy=Equivalent,groups=infrastructure.cluster.x-k8s.io,resources=azureclusters,versions=v1beta1,name=default.azurecluster.infrastructure.cluster.x-k8s.io,sideEffects=None,admissionReviewVersions=v1;v1beta1

var _ webhook.Validator = &amp;AzureCluster{}
var _ webhook.Defaulter = &amp;AzureCluster{}

// Default implements webhook.Defaulter so a webhook will be registered for the type.
func (c *AzureCluster) Default() <span class="cov0" title="0">{
        c.setDefaults()
}</span>

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type.
func (c *AzureCluster) ValidateCreate() error <span class="cov8" title="1">{
        return c.validateCluster(nil)
}</span>

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type.
func (c *AzureCluster) ValidateUpdate(oldRaw runtime.Object) error <span class="cov8" title="1">{
        var allErrs field.ErrorList
        old := oldRaw.(*AzureCluster)

        if !reflect.DeepEqual(c.Spec.ResourceGroup, old.Spec.ResourceGroup) </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("spec", "ResourceGroup"),
                                c.Spec.ResourceGroup, "field is immutable"),
                )
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(c.Spec.SubscriptionID, old.Spec.SubscriptionID) </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("spec", "SubscriptionID"),
                                c.Spec.SubscriptionID, "field is immutable"),
                )
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(c.Spec.Location, old.Spec.Location) </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("spec", "Location"),
                                c.Spec.Location, "field is immutable"),
                )
        }</span>

        <span class="cov8" title="1">if old.Spec.ControlPlaneEndpoint.Host != "" &amp;&amp; c.Spec.ControlPlaneEndpoint.Host != old.Spec.ControlPlaneEndpoint.Host </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("spec", "ControlPlaneEndpoint", "Host"),
                                c.Spec.ControlPlaneEndpoint.Host, "field is immutable"),
                )
        }</span>

        <span class="cov8" title="1">if old.Spec.ControlPlaneEndpoint.Port != 0 &amp;&amp; c.Spec.ControlPlaneEndpoint.Port != old.Spec.ControlPlaneEndpoint.Port </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("spec", "ControlPlaneEndpoint", "Port"),
                                c.Spec.ControlPlaneEndpoint.Port, "field is immutable"),
                )
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(c.Spec.AzureEnvironment, old.Spec.AzureEnvironment) </span><span class="cov8" title="1">{
                // The equality failure could be because of default mismatch between v1alpha3 and v1beta1. This happens because
                // the new object `r` will have run through the default webhooks but the old object `old` would not have so.
                // This means if the old object was in v1alpha3, it would not get the new defaults set in v1beta1 resulting
                // in object inequality. To workaround this, we set the v1beta1 defaults here so that the old object also gets
                // the new defaults.
                old.setAzureEnvironmentDefault()

                // if it's still not equal, return error.
                if !reflect.DeepEqual(c.Spec.AzureEnvironment, old.Spec.AzureEnvironment) </span><span class="cov8" title="1">{
                        allErrs = append(allErrs,
                                field.Invalid(field.NewPath("spec", "AzureEnvironment"),
                                        c.Spec.AzureEnvironment, "field is immutable"),
                        )
                }</span>
        }

        <span class="cov8" title="1">if !reflect.DeepEqual(c.Spec.NetworkSpec.PrivateDNSZoneName, old.Spec.NetworkSpec.PrivateDNSZoneName) </span><span class="cov0" title="0">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("spec", "NetworkSpec", "PrivateDNSZoneName"),
                                c.Spec.NetworkSpec.PrivateDNSZoneName, "field is immutable"),
                )
        }</span>

        // Allow enabling azure bastion but avoid disabling it.
        <span class="cov8" title="1">if old.Spec.BastionSpec.AzureBastion != nil &amp;&amp; !reflect.DeepEqual(old.Spec.BastionSpec.AzureBastion, c.Spec.BastionSpec.AzureBastion) </span><span class="cov0" title="0">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("spec", "BastionSpec", "AzureBastion"),
                                c.Spec.BastionSpec.AzureBastion, "azure bastion cannot be removed from a cluster"),
                )
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(c.Spec.NetworkSpec.ControlPlaneOutboundLB, old.Spec.NetworkSpec.ControlPlaneOutboundLB) </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("spec", "networkSpec", "controlPlaneOutboundLB"),
                                c.Spec.NetworkSpec.ControlPlaneOutboundLB, "field is immutable"),
                )
        }</span>

        <span class="cov8" title="1">if len(allErrs) == 0 </span><span class="cov8" title="1">{
                return c.validateCluster(old)
        }</span>

        <span class="cov8" title="1">return apierrors.NewInvalid(GroupVersion.WithKind("AzureCluster").GroupKind(), c.Name, allErrs)</span>
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type.
func (c *AzureCluster) ValidateDelete() error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

// Hub marks AzureClusterIdentity as a conversion hub.
func (*AzureClusterIdentity) Hub() {<span class="cov0" title="0">}</span>

// Hub marks AzureClusterIdentityList as a conversion hub.
func (*AzureClusterIdentityList) Hub() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
)

// AllowedNamespaces defines the namespaces the clusters are allowed to use the identity from
// NamespaceList takes precedence over the Selector.
type AllowedNamespaces struct {
        // A nil or empty list indicates that AzureCluster cannot use the identity from any namespace.
        //
        // +optional
        // +nullable
        NamespaceList []string `json:"list"`
        // Selector is a selector of namespaces that AzureCluster can
        // use this Identity from. This is a standard Kubernetes LabelSelector,
        // a label query over a set of resources. The result of matchLabels and
        // matchExpressions are ANDed.
        //
        // A nil or empty selector indicates that AzureCluster cannot use this
        // AzureClusterIdentity from any namespace.
        // +optional
        Selector *metav1.LabelSelector `json:"selector"`
}

// AzureClusterIdentitySpec defines the parameters that are used to create an AzureIdentity.
type AzureClusterIdentitySpec struct {
        // Type is the type of Azure Identity used.
        // ServicePrincipal, ServicePrincipalCertificate, UserAssignedMSI or ManualServicePrincipal.
        Type IdentityType `json:"type"`
        // ResourceID is the Azure resource ID for the User Assigned MSI resource.
        // Only applicable when type is UserAssignedMSI.
        // +optional
        ResourceID string `json:"resourceID,omitempty"`
        // ClientID is the service principal client ID.
        // Both User Assigned MSI and SP can use this field.
        ClientID string `json:"clientID"`
        // ClientSecret is a secret reference which should contain either a Service Principal password or certificate secret.
        // +optional
        ClientSecret corev1.SecretReference `json:"clientSecret,omitempty"`
        // TenantID is the service principal primary tenant id.
        TenantID string `json:"tenantID"`
        // AllowedNamespaces is used to identify the namespaces the clusters are allowed to use the identity from.
        // Namespaces can be selected either using an array of namespaces or with label selector.
        // An empty allowedNamespaces object indicates that AzureClusters can use this identity from any namespace.
        // If this object is nil, no namespaces will be allowed (default behaviour, if this field is not provided)
        // A namespace should be either in the NamespaceList or match with Selector to use the identity.
        //
        // +optional
        // +nullable
        AllowedNamespaces *AllowedNamespaces `json:"allowedNamespaces"`
}

// AzureClusterIdentityStatus defines the observed state of AzureClusterIdentity.
type AzureClusterIdentityStatus struct {
        // Conditions defines current service state of the AzureClusterIdentity.
        // +optional
        Conditions clusterv1.Conditions `json:"conditions,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:path=azureclusteridentities,scope=Namespaced,categories=cluster-api
// +kubebuilder:storageversion
// +kubebuilder:subresource:status

// AzureClusterIdentity is the Schema for the azureclustersidentities API.
type AzureClusterIdentity struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   AzureClusterIdentitySpec   `json:"spec,omitempty"`
        Status AzureClusterIdentityStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AzureClusterIdentityList contains a list of AzureClusterIdentity.
type AzureClusterIdentityList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []AzureClusterIdentity `json:"items"`
}

// GetConditions returns the list of conditions for an AzureClusterIdentity API object.
func (c *AzureClusterIdentity) GetConditions() clusterv1.Conditions <span class="cov0" title="0">{
        return c.Status.Conditions
}</span>

// SetConditions will set the given conditions on an AzureClusterIdentity object.
func (c *AzureClusterIdentity) SetConditions(conditions clusterv1.Conditions) <span class="cov0" title="0">{
        c.Status.Conditions = conditions
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;AzureClusterIdentity{}, &amp;AzureClusterIdentityList{})
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        ctrl "sigs.k8s.io/controller-runtime"
)

// SetupWebhookWithManager sets up and registers the webhook with the manager.
func (c *AzureClusterIdentity) SetupWebhookWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewWebhookManagedBy(mgr).
                For(c).
                Complete()
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

// Hub marks AzureCluster as a conversion hub.
func (*AzureClusterTemplate) Hub() {<span class="cov0" title="0">}</span>

// Hub marks AzureClusterList as a conversion hub.
func (*AzureClusterTemplateList) Hub() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "fmt"
)

func (c *AzureClusterTemplate) setDefaults() <span class="cov0" title="0">{
        c.Spec.Template.Spec.AzureClusterClassSpec.setDefaults()
        c.setNetworkTemplateSpecDefaults()
}</span>

func (c *AzureClusterTemplate) setNetworkTemplateSpecDefaults() <span class="cov0" title="0">{
        c.setVnetTemplateDefaults()
        c.setBastionTemplateDefaults()
        c.setSubnetsTemplateDefaults()

        apiServerLB := &amp;c.Spec.Template.Spec.NetworkSpec.APIServerLB
        apiServerLB.setAPIServerLBDefaults()
        c.setNodeOutboundLBDefaults()
        c.setControlPlaneOutboundLBDefaults()
}</span>

func (c *AzureClusterTemplate) setVnetTemplateDefaults() <span class="cov8" title="1">{
        c.Spec.Template.Spec.NetworkSpec.Vnet.VnetClassSpec.setDefaults()
}</span>

func (c *AzureClusterTemplate) setBastionTemplateDefaults() <span class="cov8" title="1">{
        if c.Spec.Template.Spec.BastionSpec.AzureBastion != nil </span><span class="cov8" title="1">{
                // Ensure defaults for Subnet settings.
                if len(c.Spec.Template.Spec.BastionSpec.AzureBastion.Subnet.CIDRBlocks) == 0 </span><span class="cov8" title="1">{
                        c.Spec.Template.Spec.BastionSpec.AzureBastion.Subnet.CIDRBlocks = []string{DefaultAzureBastionSubnetCIDR}
                }</span>
                <span class="cov8" title="1">if c.Spec.Template.Spec.BastionSpec.AzureBastion.Subnet.Role == "" </span><span class="cov8" title="1">{
                        c.Spec.Template.Spec.BastionSpec.AzureBastion.Subnet.Role = DefaultAzureBastionSubnetRole
                }</span>
        }
}

func (c *AzureClusterTemplate) setSubnetsTemplateDefaults() <span class="cov8" title="1">{
        cpSubnet, err := c.Spec.Template.Spec.NetworkSpec.GetControlPlaneSubnetTemplate()
        if err != nil </span><span class="cov8" title="1">{
                cpSubnet = SubnetTemplateSpec{SubnetClassSpec: SubnetClassSpec{Role: SubnetControlPlane}}
                c.Spec.Template.Spec.NetworkSpec.Subnets = append(c.Spec.Template.Spec.NetworkSpec.Subnets, cpSubnet)
        }</span>
        <span class="cov8" title="1">cpSubnet.SubnetClassSpec.setDefaults(DefaultControlPlaneSubnetCIDR)
        cpSubnet.SecurityGroup.setDefaults()
        c.Spec.Template.Spec.NetworkSpec.UpdateControlPlaneSubnetTemplate(cpSubnet)

        var nodeSubnetFound bool
        var nodeSubnetCounter int
        for i, subnet := range c.Spec.Template.Spec.NetworkSpec.Subnets </span><span class="cov8" title="1">{
                if subnet.Role != SubnetNode </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">nodeSubnetCounter++
                nodeSubnetFound = true
                subnet.SubnetClassSpec.setDefaults(fmt.Sprintf(DefaultNodeSubnetCIDRPattern, nodeSubnetCounter))
                cpSubnet.SecurityGroup.setDefaults()
                c.Spec.Template.Spec.NetworkSpec.Subnets[i] = subnet</span>
        }

        <span class="cov8" title="1">if !nodeSubnetFound </span><span class="cov8" title="1">{
                nodeSubnet := SubnetTemplateSpec{
                        SubnetClassSpec: SubnetClassSpec{
                                Role:       SubnetNode,
                                CIDRBlocks: []string{DefaultNodeSubnetCIDR},
                        },
                }
                c.Spec.Template.Spec.NetworkSpec.Subnets = append(c.Spec.Template.Spec.NetworkSpec.Subnets, nodeSubnet)
        }</span>
}

func (c *AzureClusterTemplate) setNodeOutboundLBDefaults() <span class="cov8" title="1">{
        if c.Spec.Template.Spec.NetworkSpec.NodeOutboundLB == nil </span><span class="cov8" title="1">{
                if c.Spec.Template.Spec.NetworkSpec.APIServerLB.Type == Internal </span><span class="cov8" title="1">{
                        return
                }</span>

                <span class="cov8" title="1">var needsOutboundLB bool
                for _, subnet := range c.Spec.Template.Spec.NetworkSpec.Subnets </span><span class="cov8" title="1">{
                        if subnet.Role == SubnetNode &amp;&amp; !subnet.IsNatGatewayEnabled() </span><span class="cov8" title="1">{
                                needsOutboundLB = true
                                break</span>
                        }
                }

                // If we don't default the outbound LB when there are some subnets with NAT gateway,
                // and some without, those without wouldn't have outbound traffic. So taking the
                // safer route, we configure the outbound LB in that scenario.
                <span class="cov8" title="1">if !needsOutboundLB </span><span class="cov8" title="1">{
                        return
                }</span>

                <span class="cov8" title="1">c.Spec.Template.Spec.NetworkSpec.NodeOutboundLB = &amp;LoadBalancerClassSpec{}</span>
        }

        <span class="cov8" title="1">c.Spec.Template.Spec.NetworkSpec.NodeOutboundLB.setNodeOutboundLBDefaults()</span>
}

func (c *AzureClusterTemplate) setControlPlaneOutboundLBDefaults() <span class="cov0" title="0">{
        lb := c.Spec.Template.Spec.NetworkSpec.ControlPlaneOutboundLB
        if lb == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lb.setControlPlaneOutboundLBDefaults()</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// AzureClusterTemplateSpec defines the desired state of AzureClusterTemplate.
type AzureClusterTemplateSpec struct {
        Template AzureClusterTemplateResource `json:"template"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:path=azureclustertemplates,scope=Namespaced,categories=cluster-api
// +kubebuilder:storageversion

// AzureClusterTemplate is the Schema for the azureclustertemplates API.
type AzureClusterTemplate struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec AzureClusterTemplateSpec `json:"spec,omitempty"`
}

// +kubebuilder:object:root=true

// AzureClusterTemplateList contains a list of AzureClusterTemplate.
type AzureClusterTemplateList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []AzureClusterTemplate `json:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;AzureClusterTemplate{}, &amp;AzureClusterTemplateList{})
}</span>

// AzureClusterTemplateResource describes the data needed to create an AzureCluster from a template.
type AzureClusterTemplateResource struct {
        Spec AzureClusterTemplateResourceSpec `json:"spec"`
}
</pre>
		
		<pre class="file" id="file35" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "fmt"

        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/util/validation/field"
)

func (c *AzureClusterTemplate) validateClusterTemplate() error <span class="cov0" title="0">{
        var allErrs field.ErrorList
        allErrs = append(allErrs, c.validateClusterTemplateSpec()...)

        if len(allErrs) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return apierrors.NewInvalid(
                schema.GroupKind{Group: "infrastructure.cluster.x-k8s.io", Kind: "AzureClusterTemplate"},
                c.Name, allErrs)</span>
}

func (c *AzureClusterTemplate) validateClusterTemplateSpec() field.ErrorList <span class="cov0" title="0">{
        var allErrs field.ErrorList

        allErrs = append(allErrs, validateVnetCIDR(
                c.Spec.Template.Spec.NetworkSpec.Vnet.CIDRBlocks,
                field.NewPath("spec").Child("template").Child("spec").
                        Child("networkSpec").Child("vnet").Child("cidrBlocks"))...)

        allErrs = append(allErrs, validateSubnetTemplates(
                c.Spec.Template.Spec.NetworkSpec.Subnets,
                c.Spec.Template.Spec.NetworkSpec.Vnet,
                field.NewPath("spec").Child("template").Child("spec").Child("networkSpec").Child("subnets"),
        )...)

        allErrs = append(allErrs, c.validateAPIServerLB(
                field.NewPath("spec").Child("template").Child("spec").Child("networkSpec").Child("apiServerLB"),
        )...)

        var oneSubnetWithoutNatGateway bool
        networkSpec := c.Spec.Template.Spec.NetworkSpec
        for _, subnet := range networkSpec.Subnets </span><span class="cov0" title="0">{
                if subnet.Role == SubnetNode &amp;&amp; !subnet.IsNatGatewayEnabled() </span><span class="cov0" title="0">{
                        oneSubnetWithoutNatGateway = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if oneSubnetWithoutNatGateway </span><span class="cov0" title="0">{
                allErrs = append(allErrs, c.validateNodeOutboundLB()...)
        }</span>

        <span class="cov0" title="0">allErrs = append(allErrs, c.validateControlPlaneOutboundLB()...)

        allErrs = append(allErrs, c.validatePrivateDNSZoneName()...)

        return allErrs</span>
}

func validateSubnetTemplates(subnets SubnetTemplatesSpec, vnet VnetTemplateSpec, fld *field.Path) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList
        requiredSubnetRoles := map[string]bool{
                "control-plane": false,
                "node":          false,
        }

        for i, subnet := range subnets </span><span class="cov8" title="1">{
                for role := range requiredSubnetRoles </span><span class="cov8" title="1">{
                        if role == string(subnet.Role) </span><span class="cov8" title="1">{
                                requiredSubnetRoles[role] = true
                        }</span>
                }
                <span class="cov8" title="1">for j, rule := range subnet.SecurityGroup.SecurityRules </span><span class="cov8" title="1">{
                        if err := validateSecurityRule(
                                rule,
                                fld.Index(i).Child("securityGroup").Child("securityGroup").Child("securityRules").Index(j),
                        ); err != nil </span><span class="cov8" title="1">{
                                allErrs = append(allErrs, err)
                        }</span>
                }
                <span class="cov8" title="1">allErrs = append(allErrs, validateSubnetCIDR(subnet.CIDRBlocks, vnet.CIDRBlocks, fld.Index(i).Child("cidrBlocks"))...)</span>
        }
        <span class="cov8" title="1">for k, v := range requiredSubnetRoles </span><span class="cov8" title="1">{
                if !v </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, field.Required(fld,
                                fmt.Sprintf("required role %s not included in provided subnets", k)))
                }</span>
        }
        <span class="cov8" title="1">return allErrs</span>
}

func (c *AzureClusterTemplate) validateAPIServerLB(apiServerLBPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList
        lb := c.Spec.Template.Spec.NetworkSpec.APIServerLB
        allErrs = append(allErrs, validateClassSpecForAPIServerLB(lb, nil, apiServerLBPath)...)
        return allErrs
}</span>

func (c *AzureClusterTemplate) validateNodeOutboundLB() field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList

        fldPath := field.NewPath("spec").Child("template").Child("spec").Child("networkSpec").Child("nodeOutboundLB")
        apiserverLB := c.Spec.Template.Spec.NetworkSpec.APIServerLB
        lb := c.Spec.Template.Spec.NetworkSpec.NodeOutboundLB

        allErrs = append(allErrs, validateClassSpecForNodeOutboundLB(lb, nil, apiserverLB, fldPath)...)

        return allErrs
}</span>

func (c *AzureClusterTemplate) validateControlPlaneOutboundLB() field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList

        fldPath := field.NewPath("spec").Child("template").Child("spec").Child("networkSpec").Child("controlPlaneOutboundLB")
        apiserverLB := c.Spec.Template.Spec.NetworkSpec.APIServerLB
        lb := c.Spec.Template.Spec.NetworkSpec.ControlPlaneOutboundLB

        allErrs = append(allErrs, validateClassSpecForControlPlaneOutboundLB(lb, apiserverLB, fldPath)...)

        return allErrs
}</span>

func (c *AzureClusterTemplate) validatePrivateDNSZoneName() field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList

        fldPath := field.NewPath("spec").Child("template").Child("spec").Child("networkSpec").Child("privateDNSZoneName")
        networkSpec := c.Spec.Template.Spec.NetworkSpec

        allErrs = append(allErrs, validatePrivateDNSZoneName(
                networkSpec.PrivateDNSZoneName,
                networkSpec.APIServerLB.Type,
                fldPath,
        )...)

        return allErrs
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "reflect"

        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/util/validation/field"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/webhook"
)

// AzureClusterTemplateImmutableMsg is the message used for errors on fields that are immutable.
const AzureClusterTemplateImmutableMsg = "AzureClusterTemplate spec.template.spec field is immutable. Please create new resource instead. ref doc: https://cluster-api.sigs.k8s.io/tasks/experimental-features/cluster-class/change-clusterclass.html"

// SetupWebhookWithManager will set up the webhook to be managed by the specified manager.
func (c *AzureClusterTemplate) SetupWebhookWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewWebhookManagedBy(mgr).
                For(c).
                Complete()
}</span>

// +kubebuilder:webhook:verbs=create;update,path=/validate-infrastructure-cluster-x-k8s-io-v1beta1-azureclustertemplate,mutating=false,failurePolicy=fail,matchPolicy=Equivalent,groups=infrastructure.cluster.x-k8s.io,resources=azureclustertemplates,versions=v1beta1,name=validation.azureclustertemplate.infrastructure.cluster.x-k8s.io,sideEffects=None,admissionReviewVersions=v1;v1beta1
// +kubebuilder:webhook:verbs=create;update,path=/mutate-infrastructure-cluster-x-k8s-io-v1beta1-azureclustertemplate,mutating=true,failurePolicy=fail,matchPolicy=Equivalent,groups=infrastructure.cluster.x-k8s.io,resources=azureclustertemplates,versions=v1beta1,name=default.azureclustertemplate.infrastructure.cluster.x-k8s.io,sideEffects=None,admissionReviewVersions=v1;v1beta1

var _ webhook.Defaulter = &amp;AzureClusterTemplate{}

// Default implements webhook.Defaulter so a webhook will be registered for the type.
func (c *AzureClusterTemplate) Default() <span class="cov0" title="0">{
        c.setDefaults()
}</span>

var _ webhook.Validator = &amp;AzureClusterTemplate{}

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type.
func (c *AzureClusterTemplate) ValidateCreate() error <span class="cov0" title="0">{
        return c.validateClusterTemplate()
}</span>

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type.
func (c *AzureClusterTemplate) ValidateUpdate(oldRaw runtime.Object) error <span class="cov8" title="1">{
        var allErrs field.ErrorList
        old := oldRaw.(*AzureClusterTemplate)
        if !reflect.DeepEqual(c.Spec.Template.Spec, old.Spec.Template.Spec) </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("AzureClusterTemplate", "spec", "template", "spec"), c, AzureClusterTemplateImmutableMsg),
                )
        }</span>

        <span class="cov8" title="1">if len(allErrs) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return apierrors.NewInvalid(GroupVersion.WithKind("AzureClusterTemplate").GroupKind(), c.Name, allErrs)</span>
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type.
func (c *AzureClusterTemplate) ValidateDelete() error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "k8s.io/apimachinery/pkg/util/validation/field"
)

// ValidateImage validates an image.
func ValidateImage(image *Image, fldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        allErrs := field.ErrorList{}

        if image == nil </span><span class="cov8" title="1">{
                // allow empty image as it is defaulted in the AzureMachine controller
                return allErrs
        }</span>

        <span class="cov8" title="1">allErrs = append(allErrs, validateSingleDetailsOnly(image, fldPath)...)

        if image.Marketplace != nil </span><span class="cov8" title="1">{
                allErrs = append(allErrs, validateMarketplaceImage(image, fldPath)...)
        }</span>
        <span class="cov8" title="1">if image.SharedGallery != nil </span><span class="cov8" title="1">{
                allErrs = append(allErrs, validateSharedGalleryImage(image, fldPath)...)
        }</span>
        <span class="cov8" title="1">if image.ID != nil </span><span class="cov8" title="1">{
                allErrs = append(allErrs, validateSpecificImage(image, fldPath)...)
        }</span>
        <span class="cov8" title="1">if image.ComputeGallery != nil </span><span class="cov8" title="1">{
                allErrs = append(allErrs, validateComputeGalleryImage(image, fldPath)...)
        }</span>

        <span class="cov8" title="1">return allErrs</span>
}

func validateSingleDetailsOnly(image *Image, fldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        allErrs := field.ErrorList{}
        imageDetailsFound := false

        if image.ID != nil </span><span class="cov8" title="1">{
                imageDetailsFound = true
        }</span>

        <span class="cov8" title="1">if image.Marketplace != nil </span><span class="cov8" title="1">{
                if imageDetailsFound </span><span class="cov0" title="0">{
                        allErrs = append(allErrs, field.Forbidden(fldPath.Child("Marketplace"), "Marketplace cannot be used as an image ID has been specified"))
                }</span> else<span class="cov8" title="1"> {
                        imageDetailsFound = true
                }</span>
        }

        <span class="cov8" title="1">if image.SharedGallery != nil </span><span class="cov8" title="1">{
                if imageDetailsFound </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, field.Forbidden(fldPath.Child("SharedGallery"), "SharedGallery cannot be used as an image ID. Marketplace or ComputeGallery images has been specified"))
                }</span> else<span class="cov8" title="1"> {
                        imageDetailsFound = true
                }</span>
        }

        <span class="cov8" title="1">if image.ComputeGallery != nil </span><span class="cov8" title="1">{
                if imageDetailsFound </span><span class="cov0" title="0">{
                        allErrs = append(allErrs, field.Forbidden(fldPath.Child("ComputeGallery"), "ComputeGallery cannot be used as an image ID. Marketplace or SharedGallery images has been specified"))
                }</span> else<span class="cov8" title="1"> {
                        imageDetailsFound = true
                }</span>
        }

        <span class="cov8" title="1">if !imageDetailsFound </span><span class="cov0" title="0">{
                allErrs = append(allErrs, field.Required(fldPath, "You must supply an ID, Marketplace or ComputeGallery image details"))
        }</span>

        <span class="cov8" title="1">return allErrs</span>
}

func validateComputeGalleryImage(image *Image, fldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        allErrs := field.ErrorList{}

        if image.ComputeGallery.SubscriptionID != nil &amp;&amp; image.ComputeGallery.ResourceGroup == nil </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(fldPath.Child("ResourceGroup"), "", "ResourceGroup cannot be empty when SubscriptionID is specified"))
        }</span>
        <span class="cov8" title="1">if image.ComputeGallery.ResourceGroup != nil &amp;&amp; image.ComputeGallery.SubscriptionID == nil </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(fldPath.Child("SubscriptionID"), "", "SubscriptionID cannot be empty when ResourceGroup is specified"))
        }</span>

        <span class="cov8" title="1">return allErrs</span>
}

func validateSharedGalleryImage(image *Image, fldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        allErrs := field.ErrorList{}

        if image.SharedGallery.SubscriptionID == "" </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(fldPath.Child("SubscriptionID"), "", "SubscriptionID cannot be empty when specifying an AzureSharedGalleryImage"))
        }</span>
        <span class="cov8" title="1">if image.SharedGallery.ResourceGroup == "" </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(fldPath.Child("ResourceGroup"), "", "ResourceGroup cannot be empty when specifying an AzureSharedGalleryImage"))
        }</span>
        <span class="cov8" title="1">if image.SharedGallery.Gallery == "" </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(fldPath.Child("Gallery"), "", "Gallery cannot be empty when specifying an AzureSharedGalleryImage"))
        }</span>
        <span class="cov8" title="1">if image.SharedGallery.Name == "" </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(fldPath.Child("Name"), "", "Name cannot be empty when specifying an AzureSharedGalleryImage"))
        }</span>
        <span class="cov8" title="1">if image.SharedGallery.Version == "" </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(fldPath.Child("Version"), "", "Version cannot be empty when specifying an AzureSharedGalleryImage"))
        }</span>

        <span class="cov8" title="1">return allErrs</span>
}

func validateMarketplaceImage(image *Image, fldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        allErrs := field.ErrorList{}

        if image.Marketplace.Publisher == "" </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(fldPath.Child("Publisher"), "", "Publisher cannot be empty when specifying an AzureMarketplaceImage"))
        }</span>
        <span class="cov8" title="1">if image.Marketplace.Offer == "" </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(fldPath.Child("Offer"), "", "Offer cannot be empty when specifying an AzureMarketplaceImage"))
        }</span>
        <span class="cov8" title="1">if image.Marketplace.SKU == "" </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(fldPath.Child("SKU"), "", "SKU cannot be empty when specifying an AzureMarketplaceImage"))
        }</span>
        <span class="cov8" title="1">if image.Marketplace.Version == "" </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(fldPath.Child("Version"), "", "Version cannot be empty when specifying an AzureMarketplaceImage"))
        }</span>
        <span class="cov8" title="1">return allErrs</span>
}

func validateSpecificImage(image *Image, fldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        allErrs := field.ErrorList{}

        if *image.ID == "" </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(fldPath.Child("ID"), "", "ID cannot be empty when specifying an AzureImageByID"))
        }</span>

        <span class="cov8" title="1">return allErrs</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

// Hub marks AzureMachine as a conversion hub.
func (*AzureMachine) Hub() {<span class="cov0" title="0">}</span>

// Hub marks AzureMachineList as a conversion hub.
func (*AzureMachineList) Hub() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "encoding/base64"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-11-01/compute"
        "golang.org/x/crypto/ssh"
        "k8s.io/apimachinery/pkg/util/uuid"
        utilSSH "sigs.k8s.io/cluster-api-provider-azure/util/ssh"
        ctrl "sigs.k8s.io/controller-runtime"
)

// SetDefaultSSHPublicKey sets the default SSHPublicKey for an AzureMachine.
func (s *AzureMachineSpec) SetDefaultSSHPublicKey() error <span class="cov8" title="1">{
        if sshKeyData := s.SSHPublicKey; sshKeyData == "" </span><span class="cov8" title="1">{
                _, publicRsaKey, err := utilSSH.GenerateSSHKey()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">s.SSHPublicKey = base64.StdEncoding.EncodeToString(ssh.MarshalAuthorizedKey(publicRsaKey))</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// SetDefaultCachingType sets the default cache type for an AzureMachine.
func (s *AzureMachineSpec) SetDefaultCachingType() <span class="cov8" title="1">{
        if s.OSDisk.CachingType == "" </span><span class="cov8" title="1">{
                s.OSDisk.CachingType = "None"
        }</span>
}

// SetDataDisksDefaults sets the data disk defaults for an AzureMachine.
func (s *AzureMachineSpec) SetDataDisksDefaults() <span class="cov8" title="1">{
        set := make(map[int32]struct{})
        // populate all the existing values in the set
        for _, disk := range s.DataDisks </span><span class="cov8" title="1">{
                if disk.Lun != nil </span><span class="cov8" title="1">{
                        set[*disk.Lun] = struct{}{}
                }</span>
        }
        // Look for unique values for unassigned LUNs
        <span class="cov8" title="1">for i, disk := range s.DataDisks </span><span class="cov8" title="1">{
                if disk.Lun == nil </span><span class="cov8" title="1">{
                        for l := range s.DataDisks </span><span class="cov8" title="1">{
                                lun := int32(l)
                                if _, ok := set[lun]; !ok </span><span class="cov8" title="1">{
                                        s.DataDisks[i].Lun = &amp;lun
                                        set[lun] = struct{}{}
                                        break</span>
                                }
                        }
                }
                <span class="cov8" title="1">if disk.CachingType == "" </span><span class="cov8" title="1">{
                        if s.DataDisks[i].ManagedDisk != nil &amp;&amp;
                                s.DataDisks[i].ManagedDisk.StorageAccountType == string(compute.StorageAccountTypesUltraSSDLRS) </span><span class="cov8" title="1">{
                                s.DataDisks[i].CachingType = string(compute.CachingTypesNone)
                        }</span> else<span class="cov8" title="1"> {
                                s.DataDisks[i].CachingType = string(compute.CachingTypesReadWrite)
                        }</span>
                }
        }
}

// SetIdentityDefaults sets the defaults for VM Identity.
func (s *AzureMachineSpec) SetIdentityDefaults() <span class="cov8" title="1">{
        if s.Identity == VMIdentitySystemAssigned </span><span class="cov8" title="1">{
                if s.RoleAssignmentName == "" </span><span class="cov8" title="1">{
                        s.RoleAssignmentName = string(uuid.NewUUID())
                }</span>
        }
}

// SetDefaults sets to the defaults for the AzureMachineSpec.
func (s *AzureMachineSpec) SetDefaults() <span class="cov8" title="1">{
        if err := s.SetDefaultSSHPublicKey(); err != nil </span><span class="cov0" title="0">{
                ctrl.Log.WithName("SetDefault").Error(err, "SetDefaultSshPublicKey failed")
        }</span>
        <span class="cov8" title="1">s.SetDefaultCachingType()
        s.SetDataDisksDefaults()
        s.SetIdentityDefaults()</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/resource"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        "sigs.k8s.io/cluster-api/errors"
)

const (
        // MachineFinalizer allows ReconcileAzureMachine to clean up Azure resources associated with AzureMachine before
        // removing it from the apiserver.
        MachineFinalizer = "azuremachine.infrastructure.cluster.x-k8s.io"
)

// AzureMachineSpec defines the desired state of AzureMachine.
type AzureMachineSpec struct {
        // ProviderID is the unique identifier as specified by the cloud provider.
        // +optional
        ProviderID *string `json:"providerID,omitempty"`

        VMSize string `json:"vmSize"`

        // FailureDomain is the failure domain unique identifier this Machine should be attached to,
        // as defined in Cluster API. This relates to an Azure Availability Zone
        // +optional
        FailureDomain *string `json:"failureDomain,omitempty"`

        // Image is used to provide details of an image to use during VM creation.
        // If image details are omitted the image will default the Azure Marketplace "capi" offer,
        // which is based on Ubuntu.
        // +kubebuilder:validation:nullable
        // +optional
        Image *Image `json:"image,omitempty"`

        // Identity is the type of identity used for the virtual machine.
        // The type 'SystemAssigned' is an implicitly created identity.
        // The generated identity will be assigned a Subscription contributor role.
        // The type 'UserAssigned' is a standalone Azure resource provided by the user
        // and assigned to the VM
        // +kubebuilder:default=None
        // +optional
        Identity VMIdentity `json:"identity,omitempty"`

        // UserAssignedIdentities is a list of standalone Azure identities provided by the user
        // The lifecycle of a user-assigned identity is managed separately from the lifecycle of
        // the AzureMachine.
        // See https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/how-to-manage-ua-identity-cli
        // +optional
        UserAssignedIdentities []UserAssignedIdentity `json:"userAssignedIdentities,omitempty"`

        // RoleAssignmentName is the name of the role assignment to create for a system assigned identity. It can be any valid GUID.
        // If not specified, a random GUID will be generated.
        // +optional
        RoleAssignmentName string `json:"roleAssignmentName,omitempty"`

        // OSDisk specifies the parameters for the operating system disk of the machine
        OSDisk OSDisk `json:"osDisk"`

        // DataDisk specifies the parameters that are used to add one or more data disks to the machine
        // +optional
        DataDisks []DataDisk `json:"dataDisks,omitempty"`

        SSHPublicKey string `json:"sshPublicKey"`

        // AdditionalTags is an optional set of tags to add to an instance, in addition to the ones added by default by the
        // Azure provider. If both the AzureCluster and the AzureMachine specify the same tag name with different values, the
        // AzureMachine's value takes precedence.
        // +optional
        AdditionalTags Tags `json:"additionalTags,omitempty"`

        // AdditionalCapabilities specifies additional capabilities enabled or disabled on the virtual machine.
        // +optional
        AdditionalCapabilities *AdditionalCapabilities `json:"additionalCapabilities,omitempty"`

        // AllocatePublicIP allows the ability to create dynamic public ips for machines where this value is true.
        // +optional
        AllocatePublicIP bool `json:"allocatePublicIP,omitempty"`

        // EnableIPForwarding enables IP Forwarding in Azure which is required for some CNI's to send traffic from a pods on one machine
        // to another. This is required for IpV6 with Calico in combination with User Defined Routes (set by the Azure Cloud Controller
        // manager). Default is false for disabled.
        // +optional
        EnableIPForwarding bool `json:"enableIPForwarding,omitempty"`

        // AcceleratedNetworking enables or disables Azure accelerated networking. If omitted, it will be set based on
        // whether the requested VMSize supports accelerated networking.
        // If AcceleratedNetworking is set to true with a VMSize that does not support it, Azure will return an error.
        // +kubebuilder:validation:nullable
        // +optional
        AcceleratedNetworking *bool `json:"acceleratedNetworking,omitempty"`

        // SpotVMOptions allows the ability to specify the Machine should use a Spot VM
        // +optional
        SpotVMOptions *SpotVMOptions `json:"spotVMOptions,omitempty"`

        // SecurityProfile specifies the Security profile settings for a virtual machine.
        // +optional
        SecurityProfile *SecurityProfile `json:"securityProfile,omitempty"`

        // SubnetName selects the Subnet where the VM will be placed
        // +optional
        SubnetName string `json:"subnetName,omitempty"`

        // DNSServers adds a list of DNS Server IP addresses to the VM NICs.
        // +optional
        DNSServers []string `json:"dnsServers,omitempty"`
}

// SpotVMOptions defines the options relevant to running the Machine on Spot VMs.
type SpotVMOptions struct {
        // MaxPrice defines the maximum price the user is willing to pay for Spot VM instances
        // +optional
        MaxPrice *resource.Quantity `json:"maxPrice,omitempty"`
}

// AzureMachineStatus defines the observed state of AzureMachine.
type AzureMachineStatus struct {
        // Ready is true when the provider resource is ready.
        // +optional
        Ready bool `json:"ready"`

        // Addresses contains the Azure instance associated addresses.
        // +optional
        Addresses []corev1.NodeAddress `json:"addresses,omitempty"`

        // VMState is the provisioning state of the Azure virtual machine.
        // +optional
        VMState *ProvisioningState `json:"vmState,omitempty"`

        // ErrorReason will be set in the event that there is a terminal problem
        // reconciling the Machine and will contain a succinct value suitable
        // for machine interpretation.
        //
        // This field should not be set for transitive errors that a controller
        // faces that are expected to be fixed automatically over
        // time (like service outages), but instead indicate that something is
        // fundamentally wrong with the Machine's spec or the configuration of
        // the controller, and that manual intervention is required. Examples
        // of terminal errors would be invalid combinations of settings in the
        // spec, values that are unsupported by the controller, or the
        // responsible controller itself being critically misconfigured.
        //
        // Any transient errors that occur during the reconciliation of Machines
        // can be added as events to the Machine object and/or logged in the
        // controller's output.
        // +optional
        FailureReason *errors.MachineStatusError `json:"failureReason,omitempty"`

        // ErrorMessage will be set in the event that there is a terminal problem
        // reconciling the Machine and will contain a more verbose string suitable
        // for logging and human consumption.
        //
        // This field should not be set for transitive errors that a controller
        // faces that are expected to be fixed automatically over
        // time (like service outages), but instead indicate that something is
        // fundamentally wrong with the Machine's spec or the configuration of
        // the controller, and that manual intervention is required. Examples
        // of terminal errors would be invalid combinations of settings in the
        // spec, values that are unsupported by the controller, or the
        // responsible controller itself being critically misconfigured.
        //
        // Any transient errors that occur during the reconciliation of Machines
        // can be added as events to the Machine object and/or logged in the
        // controller's output.
        // +optional
        FailureMessage *string `json:"failureMessage,omitempty"`

        // Conditions defines current service state of the AzureMachine.
        // +optional
        Conditions clusterv1.Conditions `json:"conditions,omitempty"`

        // LongRunningOperationStates saves the states for Azure long-running operations so they can be continued on the
        // next reconciliation loop.
        // +optional
        LongRunningOperationStates Futures `json:"longRunningOperationStates,omitempty"`
}

// AdditionalCapabilities enables or disables a capability on the virtual machine.
type AdditionalCapabilities struct {
        // UltraSSDEnabled enables or disables Azure UltraSSD capability for the virtual machine.
        // Defaults to true if Ultra SSD data disks are specified,
        // otherwise it doesn't set the capability on the VM.
        // +optional
        UltraSSDEnabled *bool `json:"ultraSSDEnabled,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",priority=1,JSONPath=".status.conditions[?(@.type=='Ready')].message"
// +kubebuilder:printcolumn:name="State",type="string",JSONPath=".status.vmState",description="Azure VM provisioning state"
// +kubebuilder:printcolumn:name="Cluster",type="string",priority=1,JSONPath=".metadata.labels.cluster\\.x-k8s\\.io/cluster-name",description="Cluster to which this AzureMachine belongs"
// +kubebuilder:printcolumn:name="Machine",type="string",priority=1,JSONPath=".metadata.ownerReferences[?(@.kind==\"Machine\")].name",description="Machine object to which this AzureMachine belongs"
// +kubebuilder:printcolumn:name="VM ID",type="string",priority=1,JSONPath=".spec.providerID",description="Azure VM ID"
// +kubebuilder:printcolumn:name="VM Size",type="string",priority=1,JSONPath=".spec.vmSize",description="Azure VM Size"
// +kubebuilder:resource:path=azuremachines,scope=Namespaced,categories=cluster-api
// +kubebuilder:storageversion
// +kubebuilder:subresource:status

// AzureMachine is the Schema for the azuremachines API.
type AzureMachine struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   AzureMachineSpec   `json:"spec,omitempty"`
        Status AzureMachineStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AzureMachineList contains a list of AzureMachine.
type AzureMachineList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []AzureMachine `json:"items"`
}

// GetConditions returns the list of conditions for an AzureMachine API object.
func (m *AzureMachine) GetConditions() clusterv1.Conditions <span class="cov0" title="0">{
        return m.Status.Conditions
}</span>

// SetConditions will set the given conditions on an AzureMachine object.
func (m *AzureMachine) SetConditions(conditions clusterv1.Conditions) <span class="cov0" title="0">{
        m.Status.Conditions = conditions
}</span>

// GetFutures returns the list of long running operation states for an AzureMachine API object.
func (m *AzureMachine) GetFutures() Futures <span class="cov0" title="0">{
        return m.Status.LongRunningOperationStates
}</span>

// SetFutures will set the given long running operation states on an AzureMachine object.
func (m *AzureMachine) SetFutures(futures Futures) <span class="cov0" title="0">{
        m.Status.LongRunningOperationStates = futures
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;AzureMachine{}, &amp;AzureMachineList{})
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "encoding/base64"
        "fmt"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-11-01/compute"
        "github.com/google/uuid"
        "golang.org/x/crypto/ssh"
        "k8s.io/apimachinery/pkg/util/validation/field"
)

// ValidateAzureMachineSpec check for validation errors of azuremachine.spec.
func ValidateAzureMachineSpec(spec AzureMachineSpec) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList

        if errs := ValidateImage(spec.Image, field.NewPath("image")); len(errs) &gt; 0 </span><span class="cov8" title="1">{
                allErrs = append(allErrs, errs...)
        }</span>

        <span class="cov8" title="1">if errs := ValidateOSDisk(spec.OSDisk, field.NewPath("osDisk")); len(errs) &gt; 0 </span><span class="cov8" title="1">{
                allErrs = append(allErrs, errs...)
        }</span>

        <span class="cov8" title="1">if errs := ValidateSSHKey(spec.SSHPublicKey, field.NewPath("sshPublicKey")); len(errs) &gt; 0 </span><span class="cov8" title="1">{
                allErrs = append(allErrs, errs...)
        }</span>

        <span class="cov8" title="1">if errs := ValidateSystemAssignedIdentity(spec.Identity, "", spec.RoleAssignmentName, field.NewPath("roleAssignmentName")); len(errs) &gt; 0 </span><span class="cov0" title="0">{
                allErrs = append(allErrs, errs...)
        }</span>

        <span class="cov8" title="1">if errs := ValidateUserAssignedIdentity(spec.Identity, spec.UserAssignedIdentities, field.NewPath("userAssignedIdentities")); len(errs) &gt; 0 </span><span class="cov8" title="1">{
                allErrs = append(allErrs, errs...)
        }</span>

        <span class="cov8" title="1">if errs := ValidateDataDisks(spec.DataDisks, field.NewPath("dataDisks")); len(errs) &gt; 0 </span><span class="cov0" title="0">{
                allErrs = append(allErrs, errs...)
        }</span>

        <span class="cov8" title="1">return allErrs</span>
}

// ValidateSSHKey validates an SSHKey.
func ValidateSSHKey(sshKey string, fldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        allErrs := field.ErrorList{}

        decoded, err := base64.StdEncoding.DecodeString(sshKey)
        if err != nil </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(fldPath, sshKey, "the SSH public key is not properly base64 encoded"))
                return allErrs
        }</span>

        <span class="cov8" title="1">if _, _, _, _, err := ssh.ParseAuthorizedKey(decoded); err != nil </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(fldPath, sshKey, "the SSH public key is not valid"))
                return allErrs
        }</span>

        <span class="cov8" title="1">return allErrs</span>
}

// ValidateSystemAssignedIdentity validates the system-assigned identities list.
func ValidateSystemAssignedIdentity(identityType VMIdentity, oldIdentity, newIdentity string, fldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        allErrs := field.ErrorList{}

        if identityType == VMIdentitySystemAssigned </span><span class="cov8" title="1">{
                if _, err := uuid.Parse(newIdentity); err != nil </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, field.Invalid(fldPath, newIdentity, "Role assignment name must be a valid GUID. It is optional and will be auto-generated when not specified."))
                }</span>
                <span class="cov8" title="1">if oldIdentity != "" &amp;&amp; oldIdentity != newIdentity </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, field.Invalid(fldPath, newIdentity, "Role assignment name should not be modified after AzureMachine creation."))
                }</span>
        } else<span class="cov8" title="1"> if newIdentity != "" </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Forbidden(fldPath, "Role assignment name should only be set when using system assigned identity."))
        }</span>

        <span class="cov8" title="1">return allErrs</span>
}

// ValidateUserAssignedIdentity validates the user-assigned identities list.
func ValidateUserAssignedIdentity(identityType VMIdentity, userAssignedIdenteties []UserAssignedIdentity, fldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        allErrs := field.ErrorList{}

        if identityType == VMIdentityUserAssigned &amp;&amp; len(userAssignedIdenteties) == 0 </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Required(fldPath, "must be specified for the 'UserAssigned' identity type"))
        }</span>
        <span class="cov8" title="1">return allErrs</span>
}

// ValidateDataDisks validates a list of data disks.
func ValidateDataDisks(dataDisks []DataDisk, fieldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        allErrs := field.ErrorList{}
        lunSet := make(map[int32]struct{})
        nameSet := make(map[string]struct{})
        for _, disk := range dataDisks </span><span class="cov8" title="1">{
                // validate that the disk size is between 4 and 32767.
                if disk.DiskSizeGB &lt; 4 || disk.DiskSizeGB &gt; 32767 </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, field.Invalid(fieldPath.Child("DiskSizeGB"), "", "the disk size should be a value between 4 and 32767"))
                }</span>

                // validate that all names are unique
                <span class="cov8" title="1">if disk.NameSuffix == "" </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, field.Required(fieldPath.Child("NameSuffix"), "the name suffix cannot be empty"))
                }</span>
                <span class="cov8" title="1">if _, ok := nameSet[disk.NameSuffix]; ok </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, field.Duplicate(fieldPath, disk.NameSuffix))
                }</span> else<span class="cov8" title="1"> {
                        nameSet[disk.NameSuffix] = struct{}{}
                }</span>

                // validate optional managed disk option
                <span class="cov8" title="1">if disk.ManagedDisk != nil </span><span class="cov8" title="1">{
                        if errs := validateManagedDisk(disk.ManagedDisk, fieldPath.Child("managedDisk"), false); len(errs) &gt; 0 </span><span class="cov8" title="1">{
                                allErrs = append(allErrs, errs...)
                        }</span>
                }

                // validate that all LUNs are unique and between 0 and 63.
                <span class="cov8" title="1">if disk.Lun == nil </span><span class="cov0" title="0">{
                        allErrs = append(allErrs, field.Required(fieldPath, "LUN should not be nil"))
                }</span> else<span class="cov8" title="1"> if *disk.Lun &lt; 0 || *disk.Lun &gt; 63 </span><span class="cov0" title="0">{
                        allErrs = append(allErrs, field.Invalid(fieldPath, disk.Lun, "logical unit number must be between 0 and 63"))
                }</span> else<span class="cov8" title="1"> if _, ok := lunSet[*disk.Lun]; ok </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, field.Duplicate(fieldPath, disk.Lun))
                }</span> else<span class="cov8" title="1"> {
                        lunSet[*disk.Lun] = struct{}{}
                }</span>

                // validate cachingType
                <span class="cov8" title="1">allErrs = append(allErrs, validateCachingType(disk.CachingType, fieldPath, disk.ManagedDisk)...)</span>
        }
        <span class="cov8" title="1">return allErrs</span>
}

// ValidateOSDisk validates the OSDisk spec.
func ValidateOSDisk(osDisk OSDisk, fieldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        allErrs := field.ErrorList{}

        if osDisk.DiskSizeGB != nil </span><span class="cov8" title="1">{
                if *osDisk.DiskSizeGB &lt;= 0 || *osDisk.DiskSizeGB &gt; 2048 </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, field.Invalid(fieldPath.Child("DiskSizeGB"), "", "the Disk size should be a value between 1 and 2048"))
                }</span>
        }

        <span class="cov8" title="1">if osDisk.OSType == "" </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Required(fieldPath.Child("OSType"), "the OS type cannot be empty"))
        }</span>

        <span class="cov8" title="1">allErrs = append(allErrs, validateCachingType(osDisk.CachingType, fieldPath, osDisk.ManagedDisk)...)

        if osDisk.ManagedDisk != nil </span><span class="cov8" title="1">{
                if errs := validateManagedDisk(osDisk.ManagedDisk, fieldPath.Child("managedDisk"), true); len(errs) &gt; 0 </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, errs...)
                }</span>
        }

        <span class="cov8" title="1">if osDisk.DiffDiskSettings != nil &amp;&amp; osDisk.ManagedDisk != nil &amp;&amp; osDisk.ManagedDisk.DiskEncryptionSet != nil </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(
                        fieldPath.Child("managedDisks").Child("diskEncryptionSet"),
                        osDisk.ManagedDisk.DiskEncryptionSet.ID,
                        "diskEncryptionSet is not supported when diffDiskSettings.option is 'Local'",
                ))
        }</span>

        <span class="cov8" title="1">return allErrs</span>
}

// validateManagedDisk validates updates to the ManagedDiskParameters field.
func validateManagedDisk(m *ManagedDiskParameters, fieldPath *field.Path, isOSDisk bool) field.ErrorList <span class="cov8" title="1">{
        allErrs := field.ErrorList{}

        if m != nil </span><span class="cov8" title="1">{
                allErrs = append(allErrs, validateStorageAccountType(m.StorageAccountType, fieldPath.Child("StorageAccountType"), isOSDisk)...)
        }</span>

        <span class="cov8" title="1">return allErrs</span>
}

// ValidateDataDisksUpdate validates updates to Data disks.
func ValidateDataDisksUpdate(oldDataDisks, newDataDisks []DataDisk, fieldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        allErrs := field.ErrorList{}

        diskErrMsg := "adding/removing data disks after machine creation is not allowed"
        fieldErrMsg := "modifying data disk's fields after machine creation is not allowed"

        if len(oldDataDisks) != len(newDataDisks) </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(fieldPath, newDataDisks, diskErrMsg))
                return allErrs
        }</span>

        <span class="cov8" title="1">oldDisks := make(map[string]DataDisk)

        for _, disk := range oldDataDisks </span><span class="cov8" title="1">{
                oldDisks[disk.NameSuffix] = disk
        }</span>

        <span class="cov8" title="1">for i, newDisk := range newDataDisks </span><span class="cov8" title="1">{
                if oldDisk, ok := oldDisks[newDisk.NameSuffix]; ok </span><span class="cov8" title="1">{
                        if newDisk.DiskSizeGB != oldDisk.DiskSizeGB </span><span class="cov8" title="1">{
                                allErrs = append(allErrs, field.Invalid(fieldPath.Index(i).Child("diskSizeGB"), newDataDisks, fieldErrMsg))
                        }</span>

                        <span class="cov8" title="1">allErrs = append(allErrs, validateManagedDisksUpdate(oldDisk.ManagedDisk, newDisk.ManagedDisk, fieldPath.Index(i).Child("managedDisk"))...)

                        if (newDisk.Lun != nil &amp;&amp; oldDisk.Lun != nil) &amp;&amp; (*newDisk.Lun != *oldDisk.Lun) </span><span class="cov0" title="0">{
                                allErrs = append(allErrs, field.Invalid(fieldPath.Index(i).Child("lun"), newDataDisks, fieldErrMsg))
                        }</span> else<span class="cov8" title="1"> if (newDisk.Lun != nil &amp;&amp; oldDisk.Lun == nil) || (newDisk.Lun == nil &amp;&amp; oldDisk.Lun != nil) </span><span class="cov8" title="1">{
                                allErrs = append(allErrs, field.Invalid(fieldPath.Index(i).Child("lun"), newDataDisks, fieldErrMsg))
                        }</span>

                        <span class="cov8" title="1">if newDisk.CachingType != oldDisk.CachingType </span><span class="cov8" title="1">{
                                allErrs = append(allErrs, field.Invalid(fieldPath.Index(i).Child("cachingType"), newDataDisks, fieldErrMsg))
                        }</span>
                } else<span class="cov0" title="0"> {
                        allErrs = append(allErrs, field.Invalid(fieldPath.Index(i).Child("nameSuffix"), newDataDisks, diskErrMsg))
                }</span>
        }

        <span class="cov8" title="1">return allErrs</span>
}

func validateManagedDisksUpdate(oldDiskParams, newDiskParams *ManagedDiskParameters, fieldPath *field.Path) field.ErrorList <span class="cov8" title="1">{
        allErrs := field.ErrorList{}
        fieldErrMsg := "changing managed disk options after machine creation is not allowed"

        if newDiskParams != nil &amp;&amp; oldDiskParams != nil </span><span class="cov8" title="1">{
                if newDiskParams.StorageAccountType != oldDiskParams.StorageAccountType </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, field.Invalid(fieldPath.Child("storageAccountType"), newDiskParams, fieldErrMsg))
                }</span>
                <span class="cov8" title="1">if newDiskParams.DiskEncryptionSet != nil &amp;&amp; oldDiskParams.DiskEncryptionSet != nil </span><span class="cov0" title="0">{
                        if newDiskParams.DiskEncryptionSet.ID != oldDiskParams.DiskEncryptionSet.ID </span><span class="cov0" title="0">{
                                allErrs = append(allErrs, field.Invalid(fieldPath.Child("diskEncryptionSet").Child("ID"), newDiskParams, fieldErrMsg))
                        }</span>
                } else<span class="cov8" title="1"> if (newDiskParams.DiskEncryptionSet != nil &amp;&amp; oldDiskParams.DiskEncryptionSet == nil) || (newDiskParams.DiskEncryptionSet == nil &amp;&amp; oldDiskParams.DiskEncryptionSet != nil) </span><span class="cov0" title="0">{
                        allErrs = append(allErrs, field.Invalid(fieldPath.Child("diskEncryptionSet"), newDiskParams, fieldErrMsg))
                }</span>
        } else<span class="cov8" title="1"> if (newDiskParams != nil &amp;&amp; oldDiskParams == nil) || (newDiskParams == nil &amp;&amp; oldDiskParams != nil) </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Invalid(fieldPath, newDiskParams, fieldErrMsg))
        }</span>

        <span class="cov8" title="1">return allErrs</span>
}

func validateStorageAccountType(storageAccountType string, fieldPath *field.Path, isOSDisk bool) field.ErrorList <span class="cov8" title="1">{
        allErrs := field.ErrorList{}

        if isOSDisk &amp;&amp; storageAccountType == string(compute.StorageAccountTypesUltraSSDLRS) </span><span class="cov0" title="0">{
                allErrs = append(allErrs, field.Invalid(fieldPath.Child("managedDisks").Child("storageAccountType"), storageAccountType, "UltraSSD_LRS can only be used with data disks, it cannot be used with OS Disks"))
        }</span>

        <span class="cov8" title="1">if storageAccountType == "" </span><span class="cov8" title="1">{
                allErrs = append(allErrs, field.Required(fieldPath, "the Storage Account Type for Managed Disk cannot be empty"))
                return allErrs
        }</span>

        <span class="cov8" title="1">for _, possibleStorageAccountType := range compute.PossibleDiskStorageAccountTypesValues() </span><span class="cov8" title="1">{
                if string(possibleStorageAccountType) == storageAccountType </span><span class="cov8" title="1">{
                        return allErrs
                }</span>
        }
        <span class="cov8" title="1">allErrs = append(allErrs, field.Invalid(fieldPath, "", fmt.Sprintf("allowed values are %v", compute.PossibleDiskStorageAccountTypesValues())))
        return allErrs</span>
}

func validateCachingType(cachingType string, fieldPath *field.Path, managedDisk *ManagedDiskParameters) field.ErrorList <span class="cov8" title="1">{
        allErrs := field.ErrorList{}
        cachingTypeChildPath := fieldPath.Child("CachingType")

        if managedDisk != nil &amp;&amp; managedDisk.StorageAccountType == string(compute.StorageAccountTypesUltraSSDLRS) </span><span class="cov8" title="1">{
                if cachingType != string(compute.CachingTypesNone) </span><span class="cov8" title="1">{
                        allErrs = append(allErrs, field.Invalid(cachingTypeChildPath, cachingType, fmt.Sprintf("cachingType '%s' is not supported when storageAccountType is '%s'. Allowed values are: '%s'", cachingType, compute.StorageAccountTypesUltraSSDLRS, compute.CachingTypesNone)))
                }</span>
        }

        <span class="cov8" title="1">for _, possibleCachingType := range compute.PossibleCachingTypesValues() </span><span class="cov8" title="1">{
                if string(possibleCachingType) == cachingType </span><span class="cov8" title="1">{
                        return allErrs
                }</span>
        }

        <span class="cov8" title="1">allErrs = append(allErrs, field.Invalid(cachingTypeChildPath, cachingType, fmt.Sprintf("allowed values are %v", compute.PossibleCachingTypesValues())))
        return allErrs</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "reflect"

        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/util/validation/field"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/webhook"
)

// SetupWebhookWithManager sets up and registers the webhook with the manager.
func (m *AzureMachine) SetupWebhookWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewWebhookManagedBy(mgr).
                For(m).
                Complete()
}</span>

// +kubebuilder:webhook:verbs=create;update,path=/validate-infrastructure-cluster-x-k8s-io-v1beta1-azuremachine,mutating=false,failurePolicy=fail,matchPolicy=Equivalent,groups=infrastructure.cluster.x-k8s.io,resources=azuremachines,versions=v1beta1,name=validation.azuremachine.infrastructure.cluster.x-k8s.io,sideEffects=None,admissionReviewVersions=v1;v1beta1
// +kubebuilder:webhook:verbs=create;update,path=/mutate-infrastructure-cluster-x-k8s-io-v1beta1-azuremachine,mutating=true,failurePolicy=fail,matchPolicy=Equivalent,groups=infrastructure.cluster.x-k8s.io,resources=azuremachines,versions=v1beta1,name=default.azuremachine.infrastructure.cluster.x-k8s.io,sideEffects=None,admissionReviewVersions=v1;v1beta1

var _ webhook.Validator = &amp;AzureMachine{}

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type.
func (m *AzureMachine) ValidateCreate() error <span class="cov8" title="1">{
        if allErrs := ValidateAzureMachineSpec(m.Spec); len(allErrs) &gt; 0 </span><span class="cov8" title="1">{
                return apierrors.NewInvalid(GroupVersion.WithKind("AzureMachine").GroupKind(), m.Name, allErrs)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type.
func (m *AzureMachine) ValidateUpdate(oldRaw runtime.Object) error <span class="cov8" title="1">{
        var allErrs field.ErrorList
        old := oldRaw.(*AzureMachine)

        if !reflect.DeepEqual(m.Spec.Image, old.Spec.Image) </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("spec", "image"),
                                m.Spec.Image, "field is immutable"),
                )
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(m.Spec.Identity, old.Spec.Identity) </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("spec", "identity"),
                                m.Spec.Identity, "field is immutable"),
                )
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(m.Spec.UserAssignedIdentities, old.Spec.UserAssignedIdentities) </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("spec", "userAssignedIdentities"),
                                m.Spec.UserAssignedIdentities, "field is immutable"),
                )
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(m.Spec.RoleAssignmentName, old.Spec.RoleAssignmentName) </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("spec", "roleAssignmentName"),
                                m.Spec.RoleAssignmentName, "field is immutable"),
                )
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(m.Spec.OSDisk, old.Spec.OSDisk) </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("spec", "osDisk"),
                                m.Spec.OSDisk, "field is immutable"),
                )
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(m.Spec.DataDisks, old.Spec.DataDisks) </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("spec", "dataDisks"),
                                m.Spec.DataDisks, "field is immutable"),
                )
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(m.Spec.SSHPublicKey, old.Spec.SSHPublicKey) </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("spec", "sshPublicKey"),
                                m.Spec.SSHPublicKey, "field is immutable"),
                )
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(m.Spec.AllocatePublicIP, old.Spec.AllocatePublicIP) </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("spec", "allocatePublicIP"),
                                m.Spec.AllocatePublicIP, "field is immutable"),
                )
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(m.Spec.EnableIPForwarding, old.Spec.EnableIPForwarding) </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("spec", "enableIPForwarding"),
                                m.Spec.EnableIPForwarding, "field is immutable"),
                )
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(m.Spec.AcceleratedNetworking, old.Spec.AcceleratedNetworking) </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("spec", "acceleratedNetworking"),
                                m.Spec.AcceleratedNetworking, "field is immutable"),
                )
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(m.Spec.SpotVMOptions, old.Spec.SpotVMOptions) </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("spec", "spotVMOptions"),
                                m.Spec.SpotVMOptions, "field is immutable"),
                )
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(m.Spec.SecurityProfile, old.Spec.SecurityProfile) </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("spec", "securityProfile"),
                                m.Spec.SecurityProfile, "field is immutable"),
                )
        }</span>

        <span class="cov8" title="1">if len(allErrs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return apierrors.NewInvalid(GroupVersion.WithKind("AzureMachine").GroupKind(), m.Name, allErrs)</span>
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type.
func (m *AzureMachine) ValidateDelete() error <span class="cov0" title="0">{
        return nil
}</span>

// Default implements webhookutil.defaulter so a webhook will be registered for the type.
func (m *AzureMachine) Default() <span class="cov8" title="1">{
        m.Spec.SetDefaults()
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

// Hub marks AzureMachineTemplate as a conversion hub.
func (*AzureMachineTemplate) Hub() {<span class="cov0" title="0">}</span>

// Hub marks AzureMachineTemplateList as a conversion hub.
func (*AzureMachineTemplateList) Hub() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
)

// AzureMachineTemplateSpec defines the desired state of AzureMachineTemplate.
type AzureMachineTemplateSpec struct {
        Template AzureMachineTemplateResource `json:"template"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:path=azuremachinetemplates,scope=Namespaced,categories=cluster-api
// +kubebuilder:storageversion

// AzureMachineTemplate is the Schema for the azuremachinetemplates API.
type AzureMachineTemplate struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec AzureMachineTemplateSpec `json:"spec,omitempty"`
}

// +kubebuilder:object:root=true

// AzureMachineTemplateList contains a list of AzureMachineTemplates.
type AzureMachineTemplateList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []AzureMachineTemplate `json:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;AzureMachineTemplate{}, &amp;AzureMachineTemplateList{})
}</span>

// AzureMachineTemplateResource describes the data needed to create an AzureMachine from a template.
type AzureMachineTemplateResource struct {
        // +optional
        ObjectMeta clusterv1.ObjectMeta `json:"metadata,omitempty"`
        // Spec is the specification of the desired behavior of the machine.
        Spec AzureMachineSpec `json:"spec"`
}
</pre>
		
		<pre class="file" id="file45" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "fmt"
        "reflect"

        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/util/validation/field"
        "sigs.k8s.io/cluster-api/util/topology"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/webhook"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// AzureMachineTemplateImmutableMsg ...
const (
        AzureMachineTemplateImmutableMsg          = "AzureMachineTemplate spec.template.spec field is immutable. Please create new resource instead. ref doc: https://cluster-api.sigs.k8s.io/tasks/updating-machine-templates.html"
        AzureMachineTemplateRoleAssignmentNameMsg = "AzureMachineTemplate spec.template.spec.roleAssignmentName field can't be set"
)

// SetupWebhookWithManager sets up and registers the webhook with the manager.
func (r *AzureMachineTemplate) SetupWebhookWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewWebhookManagedBy(mgr).
                For(r).
                WithValidator(r).
                WithDefaulter(r).
                Complete()
}</span>

// +kubebuilder:webhook:verbs=create;update,path=/mutate-infrastructure-cluster-x-k8s-io-v1beta1-azuremachinetemplate,mutating=true,failurePolicy=fail,matchPolicy=Equivalent,groups=infrastructure.cluster.x-k8s.io,resources=azuremachinetemplates,versions=v1beta1,name=default.azuremachinetemplate.infrastructure.cluster.x-k8s.io,sideEffects=None,admissionReviewVersions=v1;v1beta1
// +kubebuilder:webhook:verbs=create;update,path=/validate-infrastructure-cluster-x-k8s-io-v1beta1-azuremachinetemplate,mutating=false,failurePolicy=fail,matchPolicy=Equivalent,groups=infrastructure.cluster.x-k8s.io,resources=azuremachinetemplates,versions=v1beta1,name=validation.azuremachinetemplate.infrastructure.cluster.x-k8s.io,sideEffects=None,admissionReviewVersions=v1;v1beta1

var _ webhook.CustomDefaulter = &amp;AzureMachineTemplate{}
var _ webhook.CustomValidator = &amp;AzureMachineTemplate{}

// ValidateCreate implements webhook.CustomValidator so a webhook will be registered for the type.
func (r *AzureMachineTemplate) ValidateCreate(ctx context.Context, obj runtime.Object) error <span class="cov8" title="1">{
        t := obj.(*AzureMachineTemplate)
        spec := t.Spec.Template.Spec

        allErrs := ValidateAzureMachineSpec(spec)

        if spec.RoleAssignmentName != "" </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("AzureMachineTemplate", "spec", "template", "spec", "roleAssignmentName"), t, AzureMachineTemplateRoleAssignmentNameMsg),
                )
        }</span>

        <span class="cov8" title="1">if len(allErrs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return apierrors.NewInvalid(GroupVersion.WithKind("AzureMachineTemplate").GroupKind(), t.Name, allErrs)</span>
}

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type.
func (r *AzureMachineTemplate) ValidateUpdate(ctx context.Context, oldRaw runtime.Object, newRaw runtime.Object) error <span class="cov8" title="1">{
        var allErrs field.ErrorList
        old := oldRaw.(*AzureMachineTemplate)
        t := newRaw.(*AzureMachineTemplate)

        req, err := admission.RequestFromContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return apierrors.NewBadRequest(fmt.Sprintf("expected a admission.Request inside context: %v", err))
        }</span>

        <span class="cov8" title="1">if !topology.ShouldSkipImmutabilityChecks(req, t) &amp;&amp;
                !reflect.DeepEqual(t.Spec.Template.Spec, old.Spec.Template.Spec) </span><span class="cov8" title="1">{
                // The equality failure could be because of default mismatch between v1alpha3 and v1beta1. This happens because
                // the new object `r` will have run through the default webhooks but the old object `old` would not have so.
                // This means if the old object was in v1alpha3, it would not get the new defaults set in v1beta1 resulting
                // in object inequality. To workaround this, we set the v1beta1 defaults here so that the old object also gets
                // the new defaults.

                // We need to set ssh key explicitly, otherwise Default() will create a new one.
                if old.Spec.Template.Spec.SSHPublicKey == "" </span><span class="cov8" title="1">{
                        old.Spec.Template.Spec.SSHPublicKey = t.Spec.Template.Spec.SSHPublicKey
                }</span>

                <span class="cov8" title="1">if err := r.Default(ctx, old); err != nil </span><span class="cov0" title="0">{
                        allErrs = append(allErrs,
                                field.Invalid(field.NewPath("AzureMachineTemplate"), r, fmt.Sprintf("Unable to apply defaults: %v", err)),
                        )
                }</span>

                // if it's still not equal, return error.
                <span class="cov8" title="1">if !reflect.DeepEqual(t.Spec.Template.Spec, old.Spec.Template.Spec) </span><span class="cov8" title="1">{
                        allErrs = append(allErrs,
                                field.Invalid(field.NewPath("AzureMachineTemplate", "spec", "template", "spec"), t, AzureMachineTemplateImmutableMsg),
                        )
                }</span>
        }

        <span class="cov8" title="1">if len(allErrs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return apierrors.NewInvalid(GroupVersion.WithKind("AzureMachineTemplate").GroupKind(), t.Name, allErrs)</span>
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type.
func (r *AzureMachineTemplate) ValidateDelete(ctx context.Context, obj runtime.Object) error <span class="cov0" title="0">{
        return nil
}</span>

// Default implements webhookutil.defaulter so a webhook will be registered for the type.
func (r *AzureMachineTemplate) Default(ctx context.Context, obj runtime.Object) error <span class="cov8" title="1">{
        t := obj.(*AzureMachineTemplate)
        if err := t.Spec.Template.Spec.SetDefaultSSHPublicKey(); err != nil </span><span class="cov0" title="0">{
                ctrl.Log.WithName("SetDefault").Error(err, "SetDefaultSSHPublicKey failed")
        }</span>
        <span class="cov8" title="1">t.Spec.Template.Spec.SetDefaultCachingType()
        t.Spec.Template.Spec.SetDataDisksDefaults()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "fmt"
        "reflect"
)

// Tags defines a map of tags.
type Tags map[string]string

// Equals returns true if the tags are equal.
func (t Tags) Equals(other Tags) bool <span class="cov0" title="0">{
        return reflect.DeepEqual(t, other)
}</span>

// HasMatchingSpecVersionHash returns true if the resource has been tagged with a matching resource spec hash value.
func (t Tags) HasMatchingSpecVersionHash(hash string) bool <span class="cov0" title="0">{
        value, ok := t[SpecVersionHashTagKey()]
        return ok &amp;&amp; value == hash
}</span>

// HasOwned returns true if the tags contains a tag that marks the resource as owned by the cluster from the perspective of this management tooling.
func (t Tags) HasOwned(cluster string) bool <span class="cov0" title="0">{
        value, ok := t[ClusterTagKey(cluster)]
        return ok &amp;&amp; ResourceLifecycle(value) == ResourceLifecycleOwned
}</span>

// HasAzureCloudProviderOwned returns true if the tags contains a tag that marks the resource as owned by the cluster from the perspective of the in-tree cloud provider.
func (t Tags) HasAzureCloudProviderOwned(cluster string) bool <span class="cov0" title="0">{
        value, ok := t[ClusterAzureCloudProviderTagKey(cluster)]
        return ok &amp;&amp; ResourceLifecycle(value) == ResourceLifecycleOwned
}</span>

// GetRole returns the Cluster API role for the tagged resource.
func (t Tags) GetRole() string <span class="cov0" title="0">{
        return t[NameAzureClusterAPIRole]
}</span>

// Difference returns the difference between this map of tags and the other map of tags.
// Items are considered equals if key and value are equals.
func (t Tags) Difference(other Tags) Tags <span class="cov0" title="0">{
        res := make(Tags, len(t))

        for key, value := range t </span><span class="cov0" title="0">{
                if otherValue, ok := other[key]; ok &amp;&amp; value == otherValue </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">res[key] = value</span>
        }

        <span class="cov0" title="0">return res</span>
}

// Merge merges in tags from other. If a tag already exists, it is replaced by the tag in other.
func (t Tags) Merge(other Tags) <span class="cov8" title="1">{
        for k, v := range other </span><span class="cov8" title="1">{
                t[k] = v
        }</span>
}

// AddSpecVersionHashTag adds a spec version hash to the Azure resource tags to determine quickly if state has changed.
func (t Tags) AddSpecVersionHashTag(hash string) Tags <span class="cov0" title="0">{
        t[SpecVersionHashTagKey()] = hash
        return t
}</span>

// ResourceLifecycle configures the lifecycle of a resource.
type ResourceLifecycle string

const (
        // ResourceLifecycleOwned is the value we use when tagging resources to indicate
        // that the resource is considered owned and managed by the cluster,
        // and in particular that the lifecycle is tied to the lifecycle of the cluster.
        ResourceLifecycleOwned = ResourceLifecycle("owned")

        // ResourceLifecycleShared is the value we use when tagging resources to indicate
        // that the resource is shared between multiple clusters, and should not be destroyed
        // if the cluster is destroyed.
        ResourceLifecycleShared = ResourceLifecycle("shared")

        // NameKubernetesAzureCloudProviderPrefix is the tag name used by the cloud provider to logically
        // separate independent cluster resources. We use it to identify which resources we expect
        // to be permissive about state changes.
        // logically independent clusters running in the same AZ.
        // The tag key = NameKubernetesAzureCloudProviderPrefix + clusterID.
        // The tag value is an ownership value.
        NameKubernetesAzureCloudProviderPrefix = "kubernetes.io_cluster_"

        // NameAzureProviderPrefix is the tag prefix we use to differentiate
        // cluster-api-provider-azure owned components from other tooling that
        // uses NameKubernetesClusterPrefix.
        NameAzureProviderPrefix = "sigs.k8s.io_cluster-api-provider-azure_"

        // NameAzureProviderOwned is the tag name we use to differentiate
        // cluster-api-provider-azure owned components from other tooling that
        // uses NameKubernetesClusterPrefix.
        NameAzureProviderOwned = NameAzureProviderPrefix + "cluster_"

        // NameAzureClusterAPIRole is the tag name we use to mark roles for resources
        // dedicated to this cluster api provider implementation.
        NameAzureClusterAPIRole = NameAzureProviderPrefix + "role"

        // APIServerRole describes the value for the apiserver role.
        APIServerRole = "apiserver"

        // NodeOutboundRole describes the value for the node outbound LB role.
        NodeOutboundRole = "nodeOutbound"

        // ControlPlaneOutboundRole describes the value for the control plane outbound LB role.
        ControlPlaneOutboundRole = "controlPlaneOutbound"

        // BastionRole describes the value for the bastion role.
        BastionRole = Bastion

        // CommonRole describes the value for the common role.
        CommonRole = "common"

        // VMTagsLastAppliedAnnotation is the key for the machine object annotation
        // which tracks the AdditionalTags in the Machine Provider Config.
        // See https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        // for annotation formatting rules.
        // Deprecated: use azure.VMTagsLastAppliedAnnotation instead. This constant will be removed in v1beta2.
        VMTagsLastAppliedAnnotation = "sigs.k8s.io/cluster-api-provider-azure-last-applied-tags-vm"

        // RGTagsLastAppliedAnnotation is the key for the Azure Cluster object annotation
        // which tracks the AdditionalTags for Resource Group which is part in the Azure Cluster.
        // See https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        // for annotation formatting rules.
        // Deprecated: use azure.RGTagsLastAppliedAnnotation instead. This constant will be removed in v1beta2.
        RGTagsLastAppliedAnnotation = "sigs.k8s.io/cluster-api-provider-azure-last-applied-tags-rg"
)

// SpecVersionHashTagKey is the key for the spec version hash used to enable quick spec difference comparison.
func SpecVersionHashTagKey() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s%s", NameAzureProviderPrefix, "spec-version-hash")
}</span>

// ClusterTagKey generates the key for resources associated with a cluster.
func ClusterTagKey(name string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s%s", NameAzureProviderOwned, name)
}</span>

// ClusterAzureCloudProviderTagKey generates the key for resources associated a cluster's Azure cloud provider.
func ClusterAzureCloudProviderTagKey(name string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s%s", NameKubernetesAzureCloudProviderPrefix, name)
}</span>

// BuildParams is used to build tags around an azure resource.
type BuildParams struct {
        // Lifecycle determines the resource lifecycle.
        Lifecycle ResourceLifecycle

        // ClusterName is the cluster associated with the resource.
        ClusterName string

        // ResourceID is the unique identifier of the resource to be tagged.
        ResourceID string

        // Name is the name of the resource, it's applied as the tag "Name" on Azure.
        // +optional
        Name *string

        // Role is the role associated to the resource.
        // +optional
        Role *string

        // Any additional tags to be added to the resource.
        // +optional
        Additional Tags
}

// Build builds tags including the cluster tag and returns them in map form.
func Build(params BuildParams) Tags <span class="cov0" title="0">{
        tags := make(Tags)
        for k, v := range params.Additional </span><span class="cov0" title="0">{
                tags[k] = v
        }</span>

        <span class="cov0" title="0">tags[ClusterTagKey(params.ClusterName)] = string(params.Lifecycle)
        if params.Role != nil </span><span class="cov0" title="0">{
                tags[NameAzureClusterAPIRole] = *params.Role
        }</span>

        <span class="cov0" title="0">if params.Name != nil </span><span class="cov0" title="0">{
                tags["Name"] = *params.Name
        }</span>

        <span class="cov0" title="0">return tags</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "github.com/pkg/errors"
        "k8s.io/apimachinery/pkg/api/resource"
)

const (
        // ControlPlane machine label.
        ControlPlane string = "control-plane"
        // Node machine label.
        Node string = "node"
        // Bastion subnet label.
        Bastion string = "bastion"
)

// Futures is a slice of Future.
type Futures []Future

const (
        // PatchFuture is a future that was derived from a PATCH request.
        PatchFuture string = "PATCH"
        // PutFuture is a future that was derived from a PUT request.
        PutFuture string = "PUT"
        // DeleteFuture is a future that was derived from a DELETE request.
        DeleteFuture string = "DELETE"
)

// Future contains the data needed for an Azure long-running operation to continue across reconcile loops.
type Future struct {
        // Type describes the type of future, such as update, create, delete, etc.
        Type string `json:"type"`

        // ResourceGroup is the Azure resource group for the resource.
        // +optional
        ResourceGroup string `json:"resourceGroup,omitempty"`

        // ServiceName is the name of the Azure service.
        // Together with the name of the resource, this forms the unique identifier for the future.
        ServiceName string `json:"serviceName"`

        // Name is the name of the Azure resource.
        // Together with the service name, this forms the unique identifier for the future.
        Name string `json:"name"`

        // Data is the base64 url encoded json Azure AutoRest Future.
        Data string `json:"data"`
}

// NetworkSpec specifies what the Azure networking resources should look like.
type NetworkSpec struct {
        // Vnet is the configuration for the Azure virtual network.
        // +optional
        Vnet VnetSpec `json:"vnet,omitempty"`

        // Subnets is the configuration for the control-plane subnet and the node subnet.
        // +optional
        Subnets Subnets `json:"subnets,omitempty"`

        // APIServerLB is the configuration for the control-plane load balancer.
        // +optional
        APIServerLB LoadBalancerSpec `json:"apiServerLB,omitempty"`

        // NodeOutboundLB is the configuration for the node outbound load balancer.
        // +optional
        NodeOutboundLB *LoadBalancerSpec `json:"nodeOutboundLB,omitempty"`

        // ControlPlaneOutboundLB is the configuration for the control-plane outbound load balancer.
        // This is different from APIServerLB, and is used only in private clusters (optionally) for enabling outbound traffic.
        // +optional
        ControlPlaneOutboundLB *LoadBalancerSpec `json:"controlPlaneOutboundLB,omitempty"`

        NetworkClassSpec `json:",inline"`
}

// VnetSpec configures an Azure virtual network.
type VnetSpec struct {
        // ResourceGroup is the name of the resource group of the existing virtual network
        // or the resource group where a managed virtual network should be created.
        // +optional
        ResourceGroup string `json:"resourceGroup,omitempty"`

        // ID is the Azure resource ID of the virtual network.
        // READ-ONLY
        // +optional
        ID string `json:"id,omitempty"`

        // Name defines a name for the virtual network resource.
        Name string `json:"name"`

        // Peerings defines a list of peerings of the newly created virtual network with existing virtual networks.
        // +optional
        Peerings VnetPeerings `json:"peerings,omitempty"`

        VnetClassSpec `json:",inline"`
}

// VnetPeeringSpec specifies an existing remote virtual network to peer with the AzureCluster's virtual network.
type VnetPeeringSpec struct {
        // ResourceGroup is the resource group name of the remote virtual network.
        // +optional
        ResourceGroup string `json:"resourceGroup,omitempty"`

        VnetPeeringClassSpec `json:",inline"`
}

// VnetPeeringClassSpec specifies a virtual network peering class.
type VnetPeeringClassSpec struct {
        // RemoteVnetName defines name of the remote virtual network.
        RemoteVnetName string `json:"remoteVnetName"`
}

// VnetPeerings is a slice of VnetPeering.
type VnetPeerings []VnetPeeringSpec

// IsManaged returns true if the vnet is managed.
func (v *VnetSpec) IsManaged(clusterName string) bool <span class="cov0" title="0">{
        return v.ID == "" || v.Tags.HasOwned(clusterName)
}</span>

// Subnets is a slice of Subnet.
type Subnets []SubnetSpec

// SecurityGroup defines an Azure security group.
type SecurityGroup struct {
        // ID is the Azure resource ID of the security group.
        // READ-ONLY
        // +optional
        ID   string `json:"id,omitempty"`
        Name string `json:"name"`

        SecurityGroupClass `json:",inline"`
}

// RouteTable defines an Azure route table.
type RouteTable struct {
        // ID is the Azure resource ID of the route table.
        // READ-ONLY
        // +optional
        ID   string `json:"id,omitempty"`
        Name string `json:"name"`
}

// NatGateway defines an Azure NAT gateway.
// NAT gateway resources are part of Vnet NAT and provide outbound Internet connectivity for subnets of a virtual network.
type NatGateway struct {
        // ID is the Azure resource ID of the NAT gateway.
        // READ-ONLY
        // +optional
        ID string `json:"id,omitempty"`
        // +optional
        NatGatewayIP PublicIPSpec `json:"ip,omitempty"`

        NatGatewayClassSpec `json:",inline"`
}

// NatGatewayClassSpec defines a NAT gateway class specification.
type NatGatewayClassSpec struct {
        Name string `json:"name"`
}

// SecurityGroupProtocol defines the protocol type for a security group rule.
type SecurityGroupProtocol string

const (
        // SecurityGroupProtocolAll is a wildcard for all IP protocols.
        SecurityGroupProtocolAll = SecurityGroupProtocol("*")
        // SecurityGroupProtocolTCP represents the TCP protocol.
        SecurityGroupProtocolTCP = SecurityGroupProtocol("Tcp")
        // SecurityGroupProtocolUDP represents the UDP protocol.
        SecurityGroupProtocolUDP = SecurityGroupProtocol("Udp")
        // SecurityGroupProtocolICMP represents the ICMP protocol.
        SecurityGroupProtocolICMP = SecurityGroupProtocol("Icmp")
)

// SecurityRuleDirection defines the direction type for a security group rule.
type SecurityRuleDirection string

const (
        // SecurityRuleDirectionInbound defines an ingress security rule.
        SecurityRuleDirectionInbound = SecurityRuleDirection("Inbound")

        // SecurityRuleDirectionOutbound defines an egress security rule.
        SecurityRuleDirectionOutbound = SecurityRuleDirection("Outbound")
)

// SecurityRule defines an Azure security rule for security groups.
type SecurityRule struct {
        // Name is a unique name within the network security group.
        Name string `json:"name"`
        // A description for this rule. Restricted to 140 chars.
        Description string `json:"description"`
        // Protocol specifies the protocol type. "Tcp", "Udp", "Icmp", or "*".
        // +kubebuilder:validation:Enum=Tcp;Udp;Icmp;*
        Protocol SecurityGroupProtocol `json:"protocol"`
        // Direction indicates whether the rule applies to inbound, or outbound traffic. "Inbound" or "Outbound".
        // +kubebuilder:validation:Enum=Inbound;Outbound
        Direction SecurityRuleDirection `json:"direction"`
        // Priority is a number between 100 and 4096. Each rule should have a unique value for priority. Rules are processed in priority order, with lower numbers processed before higher numbers. Once traffic matches a rule, processing stops.
        // +optional
        Priority int32 `json:"priority,omitempty"`
        // SourcePorts specifies source port or range. Integer or range between 0 and 65535. Asterix '*' can also be used to match all ports.
        // +optional
        SourcePorts *string `json:"sourcePorts,omitempty"`
        // DestinationPorts specifies the destination port or range. Integer or range between 0 and 65535. Asterix '*' can also be used to match all ports.
        // +optional
        DestinationPorts *string `json:"destinationPorts,omitempty"`
        // Source specifies the CIDR or source IP range. Asterix '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used. If this is an ingress rule, specifies where network traffic originates from.
        // +optional
        Source *string `json:"source,omitempty"`
        // Destination is the destination address prefix. CIDR or destination IP range. Asterix '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used.
        // +optional
        Destination *string `json:"destination,omitempty"`
}

// SecurityRules is a slice of Azure security rules for security groups.
type SecurityRules []SecurityRule

// LoadBalancerSpec defines an Azure load balancer.
type LoadBalancerSpec struct {
        // ID is the Azure resource ID of the load balancer.
        // READ-ONLY
        // +optional
        ID string `json:"id,omitempty"`
        // +optional
        Name string `json:"name,omitempty"`
        // +optional
        FrontendIPs []FrontendIP `json:"frontendIPs,omitempty"`
        // FrontendIPsCount specifies the number of frontend IP addresses for the load balancer.
        // +optional
        FrontendIPsCount *int32 `json:"frontendIPsCount,omitempty"`

        LoadBalancerClassSpec `json:",inline"`
}

// SKU defines an Azure load balancer SKU.
type SKU string

const (
        // SKUStandard is the value for the Azure load balancer Standard SKU.
        SKUStandard = SKU("Standard")
)

// LBType defines an Azure load balancer Type.
type LBType string

const (
        // Internal is the value for the Azure load balancer internal type.
        Internal = LBType("Internal")
        // Public is the value for the Azure load balancer public type.
        Public = LBType("Public")
)

// FrontendIP defines a load balancer frontend IP configuration.
type FrontendIP struct {
        // +kubebuilder:validation:MinLength=1
        Name string `json:"name"`
        // +optional
        PublicIP *PublicIPSpec `json:"publicIP,omitempty"`

        FrontendIPClass `json:",inline"`
}

// PublicIPSpec defines the inputs to create an Azure public IP address.
type PublicIPSpec struct {
        Name string `json:"name"`
        // +optional
        DNSName string `json:"dnsName,omitempty"`
        // +optional
        IPTags []IPTag `json:"ipTags,omitempty"`
}

// IPTag contains the IpTag associated with the object.
type IPTag struct {
        // Type specifies the IP tag type. Example: FirstPartyUsage.
        Type string `json:"type"`
        // Tag specifies the value of the IP tag associated with the public IP. Example: SQL.
        Tag string `json:"tag"`
}

// VMState describes the state of an Azure virtual machine.
// Deprecated: use ProvisioningState.
type VMState string

// ProvisioningState describes the provisioning state of an Azure resource.
type ProvisioningState string

const (
        // Creating ...
        Creating ProvisioningState = "Creating"
        // Deleting ...
        Deleting ProvisioningState = "Deleting"
        // Failed ...
        Failed ProvisioningState = "Failed"
        // Migrating ...
        Migrating ProvisioningState = "Migrating"
        // Succeeded ...
        Succeeded ProvisioningState = "Succeeded"
        // Updating ...
        Updating ProvisioningState = "Updating"
        // Canceled represents an action which was initiated but terminated by the user before completion.
        Canceled ProvisioningState = "Canceled"
        // Deleted represents a deleted VM
        // NOTE: This state is specific to capz, and does not have corresponding mapping in Azure API (https://docs.microsoft.com/en-us/azure/virtual-machines/states-billing#provisioning-states)
        Deleted ProvisioningState = "Deleted"
)

// Image defines information about the image to use for VM creation.
// There are three ways to specify an image: by ID, Marketplace Image or SharedImageGallery
// One of ID, SharedImage or Marketplace should be set.
type Image struct {
        // ID specifies an image to use by ID
        // +optional
        ID *string `json:"id,omitempty"`

        // SharedGallery specifies an image to use from an Azure Shared Image Gallery
        // Deprecated: use ComputeGallery instead.
        // +optional
        SharedGallery *AzureSharedGalleryImage `json:"sharedGallery,omitempty"`

        // Marketplace specifies an image to use from the Azure Marketplace
        // +optional
        Marketplace *AzureMarketplaceImage `json:"marketplace,omitempty"`

        // ComputeGallery specifies an image to use from the Azure Compute Gallery
        // +optional
        ComputeGallery *AzureComputeGalleryImage `json:"computeGallery,omitempty"`
}

// AzureComputeGalleryImage defines an image in the Azure Compute Gallery to use for VM creation.
type AzureComputeGalleryImage struct {
        // Gallery specifies the name of the compute image gallery that contains the image
        // +kubebuilder:validation:MinLength=1
        Gallery string `json:"gallery"`
        // Name is the name of the image
        // +kubebuilder:validation:MinLength=1
        Name string `json:"name"`
        // Version specifies the version of the marketplace image. The allowed formats
        // are Major.Minor.Build or 'latest'. Major, Minor, and Build are decimal numbers.
        // Specify 'latest' to use the latest version of an image available at deploy time.
        // Even if you use 'latest', the VM image will not automatically update after deploy
        // time even if a new version becomes available.
        // +kubebuilder:validation:MinLength=1
        Version string `json:"version"`
        // SubscriptionID is the identifier of the subscription that contains the private compute gallery.
        // +optional
        SubscriptionID *string `json:"subscriptionID,omitempty"`
        // ResourceGroup specifies the resource group containing the private compute gallery.
        // +optional
        ResourceGroup *string `json:"resourceGroup,omitempty"`
        // Plan contains plan information.
        // +optional
        Plan *ImagePlan `json:"plan,omitempty"`
}

// ImagePlan contains plan information for marketplace images.
type ImagePlan struct {
        // Publisher is the name of the organization that created the image
        // +kubebuilder:validation:MinLength=1
        Publisher string `json:"publisher"`
        // Offer specifies the name of a group of related images created by the publisher.
        // For example, UbuntuServer, WindowsServer
        // +kubebuilder:validation:MinLength=1
        Offer string `json:"offer"`
        // SKU specifies an instance of an offer, such as a major release of a distribution.
        // For example, 18.04-LTS, 2019-Datacenter
        // +kubebuilder:validation:MinLength=1
        SKU string `json:"sku"`
}

// AzureMarketplaceImage defines an image in the Azure Marketplace to use for VM creation.
type AzureMarketplaceImage struct {
        ImagePlan `json:",inline"`

        // Version specifies the version of an image sku. The allowed formats
        // are Major.Minor.Build or 'latest'. Major, Minor, and Build are decimal numbers.
        // Specify 'latest' to use the latest version of an image available at deploy time.
        // Even if you use 'latest', the VM image will not automatically update after deploy
        // time even if a new version becomes available.
        // +kubebuilder:validation:MinLength=1
        Version string `json:"version"`
        // ThirdPartyImage indicates the image is published by a third party publisher and a Plan
        // will be generated for it.
        // +kubebuilder:default=false
        // +optional
        ThirdPartyImage bool `json:"thirdPartyImage"`
}

// AzureSharedGalleryImage defines an image in a Shared Image Gallery to use for VM creation.
type AzureSharedGalleryImage struct {
        // SubscriptionID is the identifier of the subscription that contains the shared image gallery
        // +kubebuilder:validation:MinLength=1
        SubscriptionID string `json:"subscriptionID"`
        // ResourceGroup specifies the resource group containing the shared image gallery
        // +kubebuilder:validation:MinLength=1
        ResourceGroup string `json:"resourceGroup"`
        // Gallery specifies the name of the shared image gallery that contains the image
        // +kubebuilder:validation:MinLength=1
        Gallery string `json:"gallery"`
        // Name is the name of the image
        // +kubebuilder:validation:MinLength=1
        Name string `json:"name"`
        // Version specifies the version of the marketplace image. The allowed formats
        // are Major.Minor.Build or 'latest'. Major, Minor, and Build are decimal numbers.
        // Specify 'latest' to use the latest version of an image available at deploy time.
        // Even if you use 'latest', the VM image will not automatically update after deploy
        // time even if a new version becomes available.
        // +kubebuilder:validation:MinLength=1
        Version string `json:"version"`
        // Publisher is the name of the organization that created the image.
        // This value will be used to add a `Plan` in the API request when creating the VM/VMSS resource.
        // This is needed when the source image from which this SIG image was built requires the `Plan` to be used.
        // +optional
        Publisher *string `json:"publisher,omitempty"`
        // Offer specifies the name of a group of related images created by the publisher.
        // For example, UbuntuServer, WindowsServer
        // This value will be used to add a `Plan` in the API request when creating the VM/VMSS resource.
        // This is needed when the source image from which this SIG image was built requires the `Plan` to be used.
        // +optional
        Offer *string `json:"offer,omitempty"`
        // SKU specifies an instance of an offer, such as a major release of a distribution.
        // For example, 18.04-LTS, 2019-Datacenter
        // This value will be used to add a `Plan` in the API request when creating the VM/VMSS resource.
        // This is needed when the source image from which this SIG image was built requires the `Plan` to be used.
        // +optional
        SKU *string `json:"sku,omitempty"`
}

// VMIdentity defines the identity of the virtual machine, if configured.
// +kubebuilder:validation:Enum=None;SystemAssigned;UserAssigned
type VMIdentity string

const (
        // VMIdentityNone ...
        VMIdentityNone VMIdentity = "None"
        // VMIdentitySystemAssigned ...
        VMIdentitySystemAssigned VMIdentity = "SystemAssigned"
        // VMIdentityUserAssigned ...
        VMIdentityUserAssigned VMIdentity = "UserAssigned"
)

// UserAssignedIdentity defines the user-assigned identities provided
// by the user to be assigned to Azure resources.
type UserAssignedIdentity struct {
        // ProviderID is the identification ID of the user-assigned Identity, the format of an identity is:
        // 'azure:///subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'
        ProviderID string `json:"providerID"`
}

const (
        // AzureIdentityBindingSelector is the label used to match with the AzureIdentityBinding
        // For the controller to match an identity binding, it needs a [label] with the key `aadpodidbinding`
        // whose value is that of the `selector:` field in the `AzureIdentityBinding`.
        AzureIdentityBindingSelector = "capz-controller-aadpodidentity-selector"
)

// IdentityType represents different types of identities.
// +kubebuilder:validation:Enum=ServicePrincipal;UserAssignedMSI;ManualServicePrincipal;ServicePrincipalCertificate
type IdentityType string

const (
        // UserAssignedMSI represents a user-assigned managed identity.
        UserAssignedMSI IdentityType = "UserAssignedMSI"

        // ServicePrincipal represents a service principal using a client password as secret.
        ServicePrincipal IdentityType = "ServicePrincipal"

        // ManualServicePrincipal represents a manual service principal.
        ManualServicePrincipal IdentityType = "ManualServicePrincipal"

        // ServicePrincipalCertificate represents a service principal using a certificate as secret.
        ServicePrincipalCertificate IdentityType = "ServicePrincipalCertificate"
)

// OSDisk defines the operating system disk for a VM.
//
// WARNING: this requires any updates to ManagedDisk to be manually converted. This is due to the odd issue with
// conversion-gen where the warning message generated uses a relative directory import rather than the fully
// qualified import when generating outside of the GOPATH.
type OSDisk struct {
        OSType string `json:"osType"`
        // DiskSizeGB is the size in GB to assign to the OS disk.
        // Will have a default of 30GB if not provided
        // +optional
        DiskSizeGB *int32 `json:"diskSizeGB,omitempty"`
        // ManagedDisk specifies the Managed Disk parameters for the OS disk.
        // +optional
        ManagedDisk *ManagedDiskParameters `json:"managedDisk,omitempty"`
        // +optional
        DiffDiskSettings *DiffDiskSettings `json:"diffDiskSettings,omitempty"`
        // CachingType specifies the caching requirements.
        // +optional
        // +kubebuilder:validation:Enum=None;ReadOnly;ReadWrite
        CachingType string `json:"cachingType,omitempty"`
}

// DataDisk specifies the parameters that are used to add one or more data disks to the machine.
type DataDisk struct {
        // NameSuffix is the suffix to be appended to the machine name to generate the disk name.
        // Each disk name will be in format &lt;machineName&gt;_&lt;nameSuffix&gt;.
        NameSuffix string `json:"nameSuffix"`
        // DiskSizeGB is the size in GB to assign to the data disk.
        DiskSizeGB int32 `json:"diskSizeGB"`
        // ManagedDisk specifies the Managed Disk parameters for the data disk.
        // +optional
        ManagedDisk *ManagedDiskParameters `json:"managedDisk,omitempty"`
        // Lun Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and therefore must be unique for each data disk attached to a VM.
        // The value must be between 0 and 63.
        // +optional
        Lun *int32 `json:"lun,omitempty"`
        // CachingType specifies the caching requirements.
        // +optional
        // +kubebuilder:validation:Enum=None;ReadOnly;ReadWrite
        CachingType string `json:"cachingType,omitempty"`
}

// ManagedDiskParameters defines the parameters of a managed disk.
type ManagedDiskParameters struct {
        // +optional
        StorageAccountType string `json:"storageAccountType,omitempty"`
        // +optional
        DiskEncryptionSet *DiskEncryptionSetParameters `json:"diskEncryptionSet,omitempty"`
}

// DiskEncryptionSetParameters defines disk encryption options.
type DiskEncryptionSetParameters struct {
        // ID defines resourceID for diskEncryptionSet resource. It must be in the same subscription
        // +optional
        ID string `json:"id,omitempty"`
}

// DiffDiskSettings describe ephemeral disk settings for the os disk.
type DiffDiskSettings struct {
        // Option enables ephemeral OS when set to "Local"
        // See https://docs.microsoft.com/en-us/azure/virtual-machines/ephemeral-os-disks for full details
        // +kubebuilder:validation:Enum=Local
        Option string `json:"option"`
}

// SubnetRole defines the unique role of a subnet.
type SubnetRole string

const (
        // SubnetNode defines a Kubernetes workload node role.
        SubnetNode = SubnetRole(Node)

        // SubnetControlPlane defines a Kubernetes control plane node role.
        SubnetControlPlane = SubnetRole(ControlPlane)

        // SubnetBastion defines a Bastion subnet role.
        SubnetBastion = SubnetRole(Bastion)
)

// SubnetSpec configures an Azure subnet.
type SubnetSpec struct {
        // ID is the Azure resource ID of the subnet.
        // READ-ONLY
        // +optional
        ID string `json:"id,omitempty"`

        // Name defines a name for the subnet resource.
        Name string `json:"name"`

        // SecurityGroup defines the NSG (network security group) that should be attached to this subnet.
        // +optional
        SecurityGroup SecurityGroup `json:"securityGroup,omitempty"`

        // RouteTable defines the route table that should be attached to this subnet.
        // +optional
        RouteTable RouteTable `json:"routeTable,omitempty"`

        // NatGateway associated with this subnet.
        // +optional
        NatGateway NatGateway `json:"natGateway,omitempty"`

        SubnetClassSpec `json:",inline"`
}

// GetControlPlaneSubnet returns the cluster control plane subnet.
func (n *NetworkSpec) GetControlPlaneSubnet() (SubnetSpec, error) <span class="cov8" title="1">{
        for _, sn := range n.Subnets </span><span class="cov8" title="1">{
                if sn.Role == SubnetControlPlane </span><span class="cov8" title="1">{
                        return sn, nil
                }</span>
        }
        <span class="cov8" title="1">return SubnetSpec{}, errors.Errorf("no subnet found with role %s", SubnetControlPlane)</span>
}

// UpdateControlPlaneSubnet updates the cluster control plane subnet.
func (n *NetworkSpec) UpdateControlPlaneSubnet(subnet SubnetSpec) <span class="cov8" title="1">{
        for i, sn := range n.Subnets </span><span class="cov8" title="1">{
                if sn.Role == SubnetControlPlane </span><span class="cov8" title="1">{
                        n.Subnets[i] = subnet
                }</span>
        }
}

// UpdateNodeSubnet updates the cluster node subnet.
func (n *NetworkSpec) UpdateNodeSubnet(subnet SubnetSpec) <span class="cov0" title="0">{
        for i, sn := range n.Subnets </span><span class="cov0" title="0">{
                if sn.Role == SubnetNode </span><span class="cov0" title="0">{
                        n.Subnets[i] = subnet
                }</span>
        }
}

// IsNatGatewayEnabled returns whether or not a NAT gateway is enabled on the subnet.
func (s SubnetSpec) IsNatGatewayEnabled() bool <span class="cov8" title="1">{
        return s.NatGateway.Name != ""
}</span>

// SecurityProfile specifies the Security profile settings for a
// virtual machine or virtual machine scale set.
type SecurityProfile struct {
        // This field indicates whether Host Encryption should be enabled
        // or disabled for a virtual machine or virtual machine scale
        // set. Default is disabled.
        // +optional
        EncryptionAtHost *bool `json:"encryptionAtHost,omitempty"`
}

// AddressRecord specifies a DNS record mapping a hostname to an IPV4 or IPv6 address.
type AddressRecord struct {
        Hostname string
        IP       string
}

// CloudProviderConfigOverrides represents the fields that can be overridden in azure cloud provider config.
type CloudProviderConfigOverrides struct {
        // +optional
        RateLimits []RateLimitSpec `json:"rateLimits,omitempty"`
        // +optional
        BackOffs BackOffConfig `json:"backOffs,omitempty"`
}

// BackOffConfig indicates the back-off config options.
type BackOffConfig struct {
        // +optional
        CloudProviderBackoff bool `json:"cloudProviderBackoff,omitempty"`
        // +optional
        CloudProviderBackoffRetries int `json:"cloudProviderBackoffRetries,omitempty"`
        // +optional
        CloudProviderBackoffExponent *resource.Quantity `json:"cloudProviderBackoffExponent,omitempty"`
        // +optional
        CloudProviderBackoffDuration int `json:"cloudProviderBackoffDuration,omitempty"`
        // +optional
        CloudProviderBackoffJitter *resource.Quantity `json:"cloudProviderBackoffJitter,omitempty"`
}

// RateLimitSpec represents the rate limit configuration for a particular kind of resource.
// Eg. loadBalancerRateLimit is used to configure rate limits for load balancers.
// This eventually gets converted to CloudProviderRateLimitConfig that cloud-provider-azure expects.
// See: https://github.com/kubernetes-sigs/cloud-provider-azure/blob/d585c2031925b39c925624302f22f8856e29e352/pkg/provider/azure_ratelimit.go#L25
// We cannot use CloudProviderRateLimitConfig directly because floating point values are not supported in controller-tools.
// See: https://github.com/kubernetes-sigs/controller-tools/issues/245
type RateLimitSpec struct {
        // Name is the name of the rate limit spec.
        // +kubebuilder:validation:Enum=defaultRateLimit;routeRateLimit;subnetsRateLimit;interfaceRateLimit;routeTableRateLimit;loadBalancerRateLimit;publicIPAddressRateLimit;securityGroupRateLimit;virtualMachineRateLimit;storageAccountRateLimit;diskRateLimit;snapshotRateLimit;virtualMachineScaleSetRateLimit;virtualMachineSizesRateLimit;availabilitySetRateLimit
        Name string `json:"name"`
        // +optional
        Config RateLimitConfig `json:"config,omitempty"`
}

// RateLimitConfig indicates the rate limit config options.
type RateLimitConfig struct {
        // +optional
        CloudProviderRateLimit bool `json:"cloudProviderRateLimit,omitempty"`
        // +optional
        CloudProviderRateLimitQPS *resource.Quantity `json:"cloudProviderRateLimitQPS,omitempty"`
        // +optional
        CloudProviderRateLimitBucket int `json:"cloudProviderRateLimitBucket,omitempty"`
        // +optional
        CloudProviderRateLimitQPSWrite *resource.Quantity `json:"cloudProviderRateLimitQPSWrite,omitempty"`
        // +optional
        CloudProviderRateLimitBucketWrite int `json:"cloudProviderRateLimitBucketWrite,omitempty"`
}

const (
        // DefaultRateLimit ...
        DefaultRateLimit = "defaultRateLimit"
        // RouteRateLimit ...
        RouteRateLimit = "routeRateLimit"
        // SubnetsRateLimit ...
        SubnetsRateLimit = "subnetsRateLimit"
        // InterfaceRateLimit ...
        InterfaceRateLimit = "interfaceRateLimit"
        // RouteTableRateLimit ...
        RouteTableRateLimit = "routeTableRateLimit"
        // LoadBalancerRateLimit ...
        LoadBalancerRateLimit = "loadBalancerRateLimit"
        // PublicIPAddressRateLimit ...
        PublicIPAddressRateLimit = "publicIPAddressRateLimit"
        // SecurityGroupRateLimit ...
        SecurityGroupRateLimit = "securityGroupRateLimit"
        // VirtualMachineRateLimit ...
        VirtualMachineRateLimit = "virtualMachineRateLimit"
        // StorageAccountRateLimit ...
        StorageAccountRateLimit = "storageAccountRateLimit"
        // DiskRateLimit ...
        DiskRateLimit = "diskRateLimit"
        // SnapshotRateLimit ...
        SnapshotRateLimit = "snapshotRateLimit"
        // VirtualMachineScaleSetRateLimit ...
        VirtualMachineScaleSetRateLimit = "virtualMachineScaleSetRateLimit"
        // VirtualMachineSizesRateLimit ...
        VirtualMachineSizesRateLimit = "virtualMachineSizesRateLimit"
        // AvailabilitySetRateLimit ...
        AvailabilitySetRateLimit = "availabilitySetRateLimit"
)

// BastionSpec specifies how the Bastion feature should be set up for the cluster.
type BastionSpec struct {
        // +optional
        AzureBastion *AzureBastion `json:"azureBastion,omitempty"`
}

// AzureBastion specifies how the Azure Bastion cloud component should be configured.
type AzureBastion struct {
        // +optional
        Name string `json:"name,omitempty"`
        // +optional
        Subnet SubnetSpec `json:"subnet,omitempty"`
        // +optional
        PublicIP PublicIPSpec `json:"publicIP,omitempty"`
}

// IsTerminalProvisioningState returns true if the ProvisioningState is a terminal state for an Azure resource.
func IsTerminalProvisioningState(state ProvisioningState) bool <span class="cov0" title="0">{
        return state == Failed || state == Succeeded
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import corev1 "k8s.io/api/core/v1"

// AzureClusterClassSpec defines the AzureCluster properties that may be shared across several Azure clusters.
type AzureClusterClassSpec struct {
        // +optional
        SubscriptionID string `json:"subscriptionID,omitempty"`

        Location string `json:"location"`

        // AdditionalTags is an optional set of tags to add to Azure resources managed by the Azure provider, in addition to the
        // ones added by default.
        // +optional
        AdditionalTags Tags `json:"additionalTags,omitempty"`

        // IdentityRef is a reference to an AzureIdentity to be used when reconciling this cluster
        // +optional
        IdentityRef *corev1.ObjectReference `json:"identityRef,omitempty"`

        // AzureEnvironment is the name of the AzureCloud to be used.
        // The default value that would be used by most users is "AzurePublicCloud", other values are:
        // - ChinaCloud: "AzureChinaCloud"
        // - GermanCloud: "AzureGermanCloud"
        // - PublicCloud: "AzurePublicCloud"
        // - USGovernmentCloud: "AzureUSGovernmentCloud"
        // +optional
        AzureEnvironment string `json:"azureEnvironment,omitempty"`

        // CloudProviderConfigOverrides is an optional set of configuration values that can be overridden in azure cloud provider config.
        // This is only a subset of options that are available in azure cloud provider config.
        // Some values for the cloud provider config are inferred from other parts of cluster api provider azure spec, and may not be available for overrides.
        // See: https://kubernetes-sigs.github.io/cloud-provider-azure/install/configs
        // Note: All cloud provider config values can be customized by creating the secret beforehand. CloudProviderConfigOverrides is only used when the secret is managed by the Azure Provider.
        // +optional
        CloudProviderConfigOverrides *CloudProviderConfigOverrides `json:"cloudProviderConfigOverrides,omitempty"`
}

// NetworkClassSpec defines the NetworkSpec properties that may be shared across several Azure clusters.
type NetworkClassSpec struct {
        // PrivateDNSZoneName defines the zone name for the Azure Private DNS.
        // +optional
        PrivateDNSZoneName string `json:"privateDNSZoneName,omitempty"`
}

// VnetClassSpec defines the VnetSpec properties that may be shared across several Azure clusters.
type VnetClassSpec struct {
        // CIDRBlocks defines the virtual network's address space, specified as one or more address prefixes in CIDR notation.
        // +optional
        CIDRBlocks []string `json:"cidrBlocks,omitempty"`

        // Tags is a collection of tags describing the resource.
        // +optional
        Tags Tags `json:"tags,omitempty"`
}

// SubnetClassSpec defines the SubnetSpec properties that may be shared across several Azure clusters.
type SubnetClassSpec struct {
        // Role defines the subnet role (eg. Node, ControlPlane)
        // +kubebuilder:validation:Enum=node;control-plane;bastion
        Role SubnetRole `json:"role"`

        // CIDRBlocks defines the subnet's address space, specified as one or more address prefixes in CIDR notation.
        // +optional
        CIDRBlocks []string `json:"cidrBlocks,omitempty"`
}

// LoadBalancerClassSpec defines the LoadBalancerSpec properties that may be shared across several Azure clusters.
type LoadBalancerClassSpec struct {
        // +optional
        SKU SKU `json:"sku,omitempty"`
        // +optional
        Type LBType `json:"type,omitempty"`
        // IdleTimeoutInMinutes specifies the timeout for the TCP idle connection.
        // +optional
        IdleTimeoutInMinutes *int32 `json:"idleTimeoutInMinutes,omitempty"`
}

// SecurityGroupClass defines the SecurityGroup properties that may be shared across several Azure clusters.
type SecurityGroupClass struct {
        // +optional
        SecurityRules SecurityRules `json:"securityRules,omitempty"`
        // +optional
        Tags Tags `json:"tags,omitempty"`
}

// FrontendIPClass defines the FrontendIP properties that may be shared across several Azure clusters.
type FrontendIPClass struct {
        // +optional
        PrivateIPAddress string `json:"privateIP,omitempty"`
}

// setDefaults sets default values for AzureClusterClassSpec.
func (acc *AzureClusterClassSpec) setDefaults() <span class="cov0" title="0">{
        if acc.AzureEnvironment == "" </span><span class="cov0" title="0">{
                acc.AzureEnvironment = DefaultAzureCloud
        }</span>
}

// setDefaults sets default values for VnetClassSpec.
func (vc *VnetClassSpec) setDefaults() <span class="cov8" title="1">{
        if len(vc.CIDRBlocks) == 0 </span><span class="cov8" title="1">{
                vc.CIDRBlocks = []string{DefaultVnetCIDR}
        }</span>
}

// setDefaults sets default values for SubnetClassSpec.
func (sc *SubnetClassSpec) setDefaults(cidr string) <span class="cov8" title="1">{
        if len(sc.CIDRBlocks) == 0 </span><span class="cov8" title="1">{
                sc.CIDRBlocks = []string{cidr}
        }</span>
}

// setDefaults sets default values for SecurityGroupClass.
func (sgc *SecurityGroupClass) setDefaults() <span class="cov8" title="1">{
        for i := range sgc.SecurityRules </span><span class="cov8" title="1">{
                if sgc.SecurityRules[i].Direction == "" </span><span class="cov8" title="1">{
                        sgc.SecurityRules[i].Direction = SecurityRuleDirectionInbound
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file49" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import "github.com/pkg/errors"

// AzureClusterTemplateResourceSpec specifies an Azure cluster template resource.
type AzureClusterTemplateResourceSpec struct {
        AzureClusterClassSpec `json:",inline"`

        // NetworkSpec encapsulates all things related to Azure network.
        // +optional
        NetworkSpec NetworkTemplateSpec `json:"networkSpec,omitempty"`

        // BastionSpec encapsulates all things related to the Bastions in the cluster.
        // +optional
        BastionSpec BastionTemplateSpec `json:"bastionSpec,omitempty"`
}

// NetworkTemplateSpec specifies a network template.
type NetworkTemplateSpec struct {
        NetworkClassSpec `json:",inline"`

        // Vnet is the configuration for the Azure virtual network.
        // +optional
        Vnet VnetTemplateSpec `json:"vnet,omitempty"`

        // Subnets is the configuration for the control-plane subnet and the node subnet.
        // +optional
        Subnets SubnetTemplatesSpec `json:"subnets,omitempty"`

        // APIServerLB is the configuration for the control-plane load balancer.
        // +optional
        APIServerLB LoadBalancerClassSpec `json:"apiServerLB,omitempty"`

        // NodeOutboundLB is the configuration for the node outbound load balancer.
        // +optional
        NodeOutboundLB *LoadBalancerClassSpec `json:"nodeOutboundLB,omitempty"`

        // ControlPlaneOutboundLB is the configuration for the control-plane outbound load balancer.
        // This is different from APIServerLB, and is used only in private clusters (optionally) for enabling outbound traffic.
        // +optional
        ControlPlaneOutboundLB *LoadBalancerClassSpec `json:"controlPlaneOutboundLB,omitempty"`
}

// GetControlPlaneSubnetTemplate returns the cluster control plane subnet template.
func (n *NetworkTemplateSpec) GetControlPlaneSubnetTemplate() (SubnetTemplateSpec, error) <span class="cov8" title="1">{
        for _, sn := range n.Subnets </span><span class="cov8" title="1">{
                if sn.Role == SubnetControlPlane </span><span class="cov8" title="1">{
                        return sn, nil
                }</span>
        }
        <span class="cov8" title="1">return SubnetTemplateSpec{}, errors.Errorf("no subnet template found with role %s", SubnetControlPlane)</span>
}

// UpdateControlPlaneSubnetTemplate updates the cluster control plane subnet template.
func (n *NetworkTemplateSpec) UpdateControlPlaneSubnetTemplate(subnet SubnetTemplateSpec) <span class="cov8" title="1">{
        for i, sn := range n.Subnets </span><span class="cov8" title="1">{
                if sn.Role == SubnetControlPlane </span><span class="cov8" title="1">{
                        n.Subnets[i] = subnet
                }</span>
        }
}

// VnetTemplateSpec defines the desired state of a virtual network.
type VnetTemplateSpec struct {
        VnetClassSpec `json:",inline"`

        // Peerings defines a list of peerings of the newly created virtual network with existing virtual networks.
        // +optional
        Peerings VnetPeeringsTemplateSpec `json:"peerings,omitempty"`
}

// VnetPeeringsTemplateSpec defines a list of peerings of the newly created virtual network with existing virtual networks.
type VnetPeeringsTemplateSpec []VnetPeeringClassSpec

// SubnetTemplateSpec specifies a template for a subnet.
type SubnetTemplateSpec struct {
        SubnetClassSpec `json:",inline"`

        // SecurityGroup defines the NSG (network security group) that should be attached to this subnet.
        // +optional
        SecurityGroup SecurityGroupClass `json:"securityGroup,omitempty"`

        // NatGateway associated with this subnet.
        // +optional
        NatGateway NatGatewayClassSpec `json:"natGateway,omitempty"`
}

// IsNatGatewayEnabled returns true if the NAT gateway is enabled.
func (s SubnetTemplateSpec) IsNatGatewayEnabled() bool <span class="cov8" title="1">{
        return s.NatGateway.Name != ""
}</span>

// SubnetTemplatesSpec specifies a list of subnet templates.
type SubnetTemplatesSpec []SubnetTemplateSpec

// BastionTemplateSpec specifies a template for a bastion host.
type BastionTemplateSpec struct {
        // +optional
        AzureBastion *AzureBastionTemplateSpec `json:"azureBastion,omitempty"`
}

// AzureBastionTemplateSpec specifies a template for an Azure Bastion host.
type AzureBastionTemplateSpec struct {
        // +optional
        Subnet SubnetTemplateSpec `json:"subnet,omitempty"`
}
</pre>
		
		<pre class="file" id="file50" style="display: none">//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by controller-gen. DO NOT EDIT.

package v1beta1

import (
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        apiv1beta1 "sigs.k8s.io/cluster-api/api/v1beta1"
        "sigs.k8s.io/cluster-api/errors"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AdditionalCapabilities) DeepCopyInto(out *AdditionalCapabilities) <span class="cov0" title="0">{
        *out = *in
        if in.UltraSSDEnabled != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.UltraSSDEnabled, &amp;out.UltraSSDEnabled
                *out = new(bool)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AdditionalCapabilities.
func (in *AdditionalCapabilities) DeepCopy() *AdditionalCapabilities <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AdditionalCapabilities)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AddressRecord) DeepCopyInto(out *AddressRecord) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AddressRecord.
func (in *AddressRecord) DeepCopy() *AddressRecord <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AddressRecord)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AllowedNamespaces) DeepCopyInto(out *AllowedNamespaces) <span class="cov0" title="0">{
        *out = *in
        if in.NamespaceList != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.NamespaceList, &amp;out.NamespaceList
                *out = make([]string, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov0" title="0">if in.Selector != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Selector, &amp;out.Selector
                *out = new(v1.LabelSelector)
                (*in).DeepCopyInto(*out)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AllowedNamespaces.
func (in *AllowedNamespaces) DeepCopy() *AllowedNamespaces <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AllowedNamespaces)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureBastion) DeepCopyInto(out *AzureBastion) <span class="cov0" title="0">{
        *out = *in
        in.Subnet.DeepCopyInto(&amp;out.Subnet)
        in.PublicIP.DeepCopyInto(&amp;out.PublicIP)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureBastion.
func (in *AzureBastion) DeepCopy() *AzureBastion <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureBastion)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureBastionTemplateSpec) DeepCopyInto(out *AzureBastionTemplateSpec) <span class="cov0" title="0">{
        *out = *in
        in.Subnet.DeepCopyInto(&amp;out.Subnet)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureBastionTemplateSpec.
func (in *AzureBastionTemplateSpec) DeepCopy() *AzureBastionTemplateSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureBastionTemplateSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureCluster) DeepCopyInto(out *AzureCluster) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
        in.Status.DeepCopyInto(&amp;out.Status)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureCluster.
func (in *AzureCluster) DeepCopy() *AzureCluster <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureCluster)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureCluster) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureClusterClassSpec) DeepCopyInto(out *AzureClusterClassSpec) <span class="cov0" title="0">{
        *out = *in
        if in.AdditionalTags != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AdditionalTags, &amp;out.AdditionalTags
                *out = make(Tags, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
        <span class="cov0" title="0">if in.IdentityRef != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.IdentityRef, &amp;out.IdentityRef
                *out = new(corev1.ObjectReference)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.CloudProviderConfigOverrides != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.CloudProviderConfigOverrides, &amp;out.CloudProviderConfigOverrides
                *out = new(CloudProviderConfigOverrides)
                (*in).DeepCopyInto(*out)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureClusterClassSpec.
func (in *AzureClusterClassSpec) DeepCopy() *AzureClusterClassSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureClusterClassSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureClusterIdentity) DeepCopyInto(out *AzureClusterIdentity) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
        in.Status.DeepCopyInto(&amp;out.Status)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureClusterIdentity.
func (in *AzureClusterIdentity) DeepCopy() *AzureClusterIdentity <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureClusterIdentity)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureClusterIdentity) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureClusterIdentityList) DeepCopyInto(out *AzureClusterIdentityList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureClusterIdentity, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureClusterIdentityList.
func (in *AzureClusterIdentityList) DeepCopy() *AzureClusterIdentityList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureClusterIdentityList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureClusterIdentityList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureClusterIdentitySpec) DeepCopyInto(out *AzureClusterIdentitySpec) <span class="cov0" title="0">{
        *out = *in
        out.ClientSecret = in.ClientSecret
        if in.AllowedNamespaces != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AllowedNamespaces, &amp;out.AllowedNamespaces
                *out = new(AllowedNamespaces)
                (*in).DeepCopyInto(*out)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureClusterIdentitySpec.
func (in *AzureClusterIdentitySpec) DeepCopy() *AzureClusterIdentitySpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureClusterIdentitySpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureClusterIdentityStatus) DeepCopyInto(out *AzureClusterIdentityStatus) <span class="cov0" title="0">{
        *out = *in
        if in.Conditions != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make(apiv1beta1.Conditions, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureClusterIdentityStatus.
func (in *AzureClusterIdentityStatus) DeepCopy() *AzureClusterIdentityStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureClusterIdentityStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureClusterList) DeepCopyInto(out *AzureClusterList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureCluster, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureClusterList.
func (in *AzureClusterList) DeepCopy() *AzureClusterList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureClusterList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureClusterList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureClusterSpec) DeepCopyInto(out *AzureClusterSpec) <span class="cov0" title="0">{
        *out = *in
        in.AzureClusterClassSpec.DeepCopyInto(&amp;out.AzureClusterClassSpec)
        in.NetworkSpec.DeepCopyInto(&amp;out.NetworkSpec)
        in.BastionSpec.DeepCopyInto(&amp;out.BastionSpec)
        out.ControlPlaneEndpoint = in.ControlPlaneEndpoint
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureClusterSpec.
func (in *AzureClusterSpec) DeepCopy() *AzureClusterSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureClusterSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureClusterStatus) DeepCopyInto(out *AzureClusterStatus) <span class="cov0" title="0">{
        *out = *in
        if in.FailureDomains != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.FailureDomains, &amp;out.FailureDomains
                *out = make(apiv1beta1.FailureDomains, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = *val.DeepCopy()
                }</span>
        }
        <span class="cov0" title="0">if in.Conditions != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make(apiv1beta1.Conditions, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov0" title="0">if in.LongRunningOperationStates != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.LongRunningOperationStates, &amp;out.LongRunningOperationStates
                *out = make(Futures, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureClusterStatus.
func (in *AzureClusterStatus) DeepCopy() *AzureClusterStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureClusterStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureClusterTemplate) DeepCopyInto(out *AzureClusterTemplate) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureClusterTemplate.
func (in *AzureClusterTemplate) DeepCopy() *AzureClusterTemplate <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureClusterTemplate)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureClusterTemplate) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureClusterTemplateList) DeepCopyInto(out *AzureClusterTemplateList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureClusterTemplate, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureClusterTemplateList.
func (in *AzureClusterTemplateList) DeepCopy() *AzureClusterTemplateList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureClusterTemplateList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureClusterTemplateList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureClusterTemplateResource) DeepCopyInto(out *AzureClusterTemplateResource) <span class="cov0" title="0">{
        *out = *in
        in.Spec.DeepCopyInto(&amp;out.Spec)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureClusterTemplateResource.
func (in *AzureClusterTemplateResource) DeepCopy() *AzureClusterTemplateResource <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureClusterTemplateResource)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureClusterTemplateResourceSpec) DeepCopyInto(out *AzureClusterTemplateResourceSpec) <span class="cov0" title="0">{
        *out = *in
        in.AzureClusterClassSpec.DeepCopyInto(&amp;out.AzureClusterClassSpec)
        in.NetworkSpec.DeepCopyInto(&amp;out.NetworkSpec)
        in.BastionSpec.DeepCopyInto(&amp;out.BastionSpec)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureClusterTemplateResourceSpec.
func (in *AzureClusterTemplateResourceSpec) DeepCopy() *AzureClusterTemplateResourceSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureClusterTemplateResourceSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureClusterTemplateSpec) DeepCopyInto(out *AzureClusterTemplateSpec) <span class="cov0" title="0">{
        *out = *in
        in.Template.DeepCopyInto(&amp;out.Template)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureClusterTemplateSpec.
func (in *AzureClusterTemplateSpec) DeepCopy() *AzureClusterTemplateSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureClusterTemplateSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureComputeGalleryImage) DeepCopyInto(out *AzureComputeGalleryImage) <span class="cov0" title="0">{
        *out = *in
        if in.SubscriptionID != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.SubscriptionID, &amp;out.SubscriptionID
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.ResourceGroup != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ResourceGroup, &amp;out.ResourceGroup
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.Plan != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Plan, &amp;out.Plan
                *out = new(ImagePlan)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureComputeGalleryImage.
func (in *AzureComputeGalleryImage) DeepCopy() *AzureComputeGalleryImage <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureComputeGalleryImage)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachine) DeepCopyInto(out *AzureMachine) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
        in.Status.DeepCopyInto(&amp;out.Status)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachine.
func (in *AzureMachine) DeepCopy() *AzureMachine <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachine)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureMachine) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachineList) DeepCopyInto(out *AzureMachineList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureMachine, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachineList.
func (in *AzureMachineList) DeepCopy() *AzureMachineList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachineList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureMachineList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachineSpec) DeepCopyInto(out *AzureMachineSpec) <span class="cov0" title="0">{
        *out = *in
        if in.ProviderID != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ProviderID, &amp;out.ProviderID
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.FailureDomain != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.FailureDomain, &amp;out.FailureDomain
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.Image != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Image, &amp;out.Image
                *out = new(Image)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov0" title="0">if in.UserAssignedIdentities != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.UserAssignedIdentities, &amp;out.UserAssignedIdentities
                *out = make([]UserAssignedIdentity, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov0" title="0">in.OSDisk.DeepCopyInto(&amp;out.OSDisk)
        if in.DataDisks != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.DataDisks, &amp;out.DataDisks
                *out = make([]DataDisk, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov0" title="0">if in.AdditionalTags != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AdditionalTags, &amp;out.AdditionalTags
                *out = make(Tags, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
        <span class="cov0" title="0">if in.AdditionalCapabilities != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AdditionalCapabilities, &amp;out.AdditionalCapabilities
                *out = new(AdditionalCapabilities)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov0" title="0">if in.AcceleratedNetworking != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AcceleratedNetworking, &amp;out.AcceleratedNetworking
                *out = new(bool)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.SpotVMOptions != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.SpotVMOptions, &amp;out.SpotVMOptions
                *out = new(SpotVMOptions)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov0" title="0">if in.SecurityProfile != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.SecurityProfile, &amp;out.SecurityProfile
                *out = new(SecurityProfile)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov0" title="0">if in.DNSServers != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.DNSServers, &amp;out.DNSServers
                *out = make([]string, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachineSpec.
func (in *AzureMachineSpec) DeepCopy() *AzureMachineSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachineSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachineStatus) DeepCopyInto(out *AzureMachineStatus) <span class="cov0" title="0">{
        *out = *in
        if in.Addresses != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Addresses, &amp;out.Addresses
                *out = make([]corev1.NodeAddress, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov0" title="0">if in.VMState != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.VMState, &amp;out.VMState
                *out = new(ProvisioningState)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.FailureReason != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.FailureReason, &amp;out.FailureReason
                *out = new(errors.MachineStatusError)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.FailureMessage != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.FailureMessage, &amp;out.FailureMessage
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.Conditions != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make(apiv1beta1.Conditions, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov0" title="0">if in.LongRunningOperationStates != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.LongRunningOperationStates, &amp;out.LongRunningOperationStates
                *out = make(Futures, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachineStatus.
func (in *AzureMachineStatus) DeepCopy() *AzureMachineStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachineStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachineTemplate) DeepCopyInto(out *AzureMachineTemplate) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachineTemplate.
func (in *AzureMachineTemplate) DeepCopy() *AzureMachineTemplate <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachineTemplate)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureMachineTemplate) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachineTemplateList) DeepCopyInto(out *AzureMachineTemplateList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureMachineTemplate, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachineTemplateList.
func (in *AzureMachineTemplateList) DeepCopy() *AzureMachineTemplateList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachineTemplateList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureMachineTemplateList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachineTemplateResource) DeepCopyInto(out *AzureMachineTemplateResource) <span class="cov0" title="0">{
        *out = *in
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachineTemplateResource.
func (in *AzureMachineTemplateResource) DeepCopy() *AzureMachineTemplateResource <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachineTemplateResource)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachineTemplateSpec) DeepCopyInto(out *AzureMachineTemplateSpec) <span class="cov0" title="0">{
        *out = *in
        in.Template.DeepCopyInto(&amp;out.Template)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachineTemplateSpec.
func (in *AzureMachineTemplateSpec) DeepCopy() *AzureMachineTemplateSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachineTemplateSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMarketplaceImage) DeepCopyInto(out *AzureMarketplaceImage) <span class="cov0" title="0">{
        *out = *in
        out.ImagePlan = in.ImagePlan
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMarketplaceImage.
func (in *AzureMarketplaceImage) DeepCopy() *AzureMarketplaceImage <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMarketplaceImage)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureSharedGalleryImage) DeepCopyInto(out *AzureSharedGalleryImage) <span class="cov0" title="0">{
        *out = *in
        if in.Publisher != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Publisher, &amp;out.Publisher
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.Offer != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Offer, &amp;out.Offer
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.SKU != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.SKU, &amp;out.SKU
                *out = new(string)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureSharedGalleryImage.
func (in *AzureSharedGalleryImage) DeepCopy() *AzureSharedGalleryImage <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureSharedGalleryImage)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BackOffConfig) DeepCopyInto(out *BackOffConfig) <span class="cov0" title="0">{
        *out = *in
        if in.CloudProviderBackoffExponent != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.CloudProviderBackoffExponent, &amp;out.CloudProviderBackoffExponent
                x := (*in).DeepCopy()
                *out = &amp;x
        }</span>
        <span class="cov0" title="0">if in.CloudProviderBackoffJitter != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.CloudProviderBackoffJitter, &amp;out.CloudProviderBackoffJitter
                x := (*in).DeepCopy()
                *out = &amp;x
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BackOffConfig.
func (in *BackOffConfig) DeepCopy() *BackOffConfig <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(BackOffConfig)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BastionSpec) DeepCopyInto(out *BastionSpec) <span class="cov0" title="0">{
        *out = *in
        if in.AzureBastion != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AzureBastion, &amp;out.AzureBastion
                *out = new(AzureBastion)
                (*in).DeepCopyInto(*out)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BastionSpec.
func (in *BastionSpec) DeepCopy() *BastionSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(BastionSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BastionTemplateSpec) DeepCopyInto(out *BastionTemplateSpec) <span class="cov0" title="0">{
        *out = *in
        if in.AzureBastion != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AzureBastion, &amp;out.AzureBastion
                *out = new(AzureBastionTemplateSpec)
                (*in).DeepCopyInto(*out)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BastionTemplateSpec.
func (in *BastionTemplateSpec) DeepCopy() *BastionTemplateSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(BastionTemplateSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BuildParams) DeepCopyInto(out *BuildParams) <span class="cov0" title="0">{
        *out = *in
        if in.Name != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Name, &amp;out.Name
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.Role != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Role, &amp;out.Role
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.Additional != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Additional, &amp;out.Additional
                *out = make(Tags, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BuildParams.
func (in *BuildParams) DeepCopy() *BuildParams <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(BuildParams)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CloudProviderConfigOverrides) DeepCopyInto(out *CloudProviderConfigOverrides) <span class="cov0" title="0">{
        *out = *in
        if in.RateLimits != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.RateLimits, &amp;out.RateLimits
                *out = make([]RateLimitSpec, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov0" title="0">in.BackOffs.DeepCopyInto(&amp;out.BackOffs)</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CloudProviderConfigOverrides.
func (in *CloudProviderConfigOverrides) DeepCopy() *CloudProviderConfigOverrides <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(CloudProviderConfigOverrides)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DataDisk) DeepCopyInto(out *DataDisk) <span class="cov0" title="0">{
        *out = *in
        if in.ManagedDisk != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ManagedDisk, &amp;out.ManagedDisk
                *out = new(ManagedDiskParameters)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov0" title="0">if in.Lun != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Lun, &amp;out.Lun
                *out = new(int32)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DataDisk.
func (in *DataDisk) DeepCopy() *DataDisk <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(DataDisk)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DiffDiskSettings) DeepCopyInto(out *DiffDiskSettings) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DiffDiskSettings.
func (in *DiffDiskSettings) DeepCopy() *DiffDiskSettings <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(DiffDiskSettings)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DiskEncryptionSetParameters) DeepCopyInto(out *DiskEncryptionSetParameters) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DiskEncryptionSetParameters.
func (in *DiskEncryptionSetParameters) DeepCopy() *DiskEncryptionSetParameters <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(DiskEncryptionSetParameters)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FrontendIP) DeepCopyInto(out *FrontendIP) <span class="cov0" title="0">{
        *out = *in
        if in.PublicIP != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.PublicIP, &amp;out.PublicIP
                *out = new(PublicIPSpec)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov0" title="0">out.FrontendIPClass = in.FrontendIPClass</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FrontendIP.
func (in *FrontendIP) DeepCopy() *FrontendIP <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(FrontendIP)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FrontendIPClass) DeepCopyInto(out *FrontendIPClass) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FrontendIPClass.
func (in *FrontendIPClass) DeepCopy() *FrontendIPClass <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(FrontendIPClass)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Future) DeepCopyInto(out *Future) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Future.
func (in *Future) DeepCopy() *Future <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(Future)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in Futures) DeepCopyInto(out *Futures) <span class="cov0" title="0">{
        </span><span class="cov0" title="0">{
                in := &amp;in
                *out = make(Futures, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Futures.
func (in Futures) DeepCopy() Futures <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(Futures)
        in.DeepCopyInto(out)
        return *out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *IPTag) DeepCopyInto(out *IPTag) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new IPTag.
func (in *IPTag) DeepCopy() *IPTag <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(IPTag)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Image) DeepCopyInto(out *Image) <span class="cov0" title="0">{
        *out = *in
        if in.ID != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ID, &amp;out.ID
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.SharedGallery != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.SharedGallery, &amp;out.SharedGallery
                *out = new(AzureSharedGalleryImage)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov0" title="0">if in.Marketplace != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Marketplace, &amp;out.Marketplace
                *out = new(AzureMarketplaceImage)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.ComputeGallery != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ComputeGallery, &amp;out.ComputeGallery
                *out = new(AzureComputeGalleryImage)
                (*in).DeepCopyInto(*out)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Image.
func (in *Image) DeepCopy() *Image <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(Image)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ImagePlan) DeepCopyInto(out *ImagePlan) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ImagePlan.
func (in *ImagePlan) DeepCopy() *ImagePlan <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(ImagePlan)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LoadBalancerClassSpec) DeepCopyInto(out *LoadBalancerClassSpec) <span class="cov0" title="0">{
        *out = *in
        if in.IdleTimeoutInMinutes != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.IdleTimeoutInMinutes, &amp;out.IdleTimeoutInMinutes
                *out = new(int32)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LoadBalancerClassSpec.
func (in *LoadBalancerClassSpec) DeepCopy() *LoadBalancerClassSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(LoadBalancerClassSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LoadBalancerSpec) DeepCopyInto(out *LoadBalancerSpec) <span class="cov0" title="0">{
        *out = *in
        if in.FrontendIPs != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.FrontendIPs, &amp;out.FrontendIPs
                *out = make([]FrontendIP, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov0" title="0">if in.FrontendIPsCount != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.FrontendIPsCount, &amp;out.FrontendIPsCount
                *out = new(int32)
                **out = **in
        }</span>
        <span class="cov0" title="0">in.LoadBalancerClassSpec.DeepCopyInto(&amp;out.LoadBalancerClassSpec)</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LoadBalancerSpec.
func (in *LoadBalancerSpec) DeepCopy() *LoadBalancerSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(LoadBalancerSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ManagedDiskParameters) DeepCopyInto(out *ManagedDiskParameters) <span class="cov0" title="0">{
        *out = *in
        if in.DiskEncryptionSet != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.DiskEncryptionSet, &amp;out.DiskEncryptionSet
                *out = new(DiskEncryptionSetParameters)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ManagedDiskParameters.
func (in *ManagedDiskParameters) DeepCopy() *ManagedDiskParameters <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(ManagedDiskParameters)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NatGateway) DeepCopyInto(out *NatGateway) <span class="cov0" title="0">{
        *out = *in
        in.NatGatewayIP.DeepCopyInto(&amp;out.NatGatewayIP)
        out.NatGatewayClassSpec = in.NatGatewayClassSpec
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NatGateway.
func (in *NatGateway) DeepCopy() *NatGateway <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(NatGateway)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NatGatewayClassSpec) DeepCopyInto(out *NatGatewayClassSpec) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NatGatewayClassSpec.
func (in *NatGatewayClassSpec) DeepCopy() *NatGatewayClassSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(NatGatewayClassSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NetworkClassSpec) DeepCopyInto(out *NetworkClassSpec) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NetworkClassSpec.
func (in *NetworkClassSpec) DeepCopy() *NetworkClassSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(NetworkClassSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NetworkSpec) DeepCopyInto(out *NetworkSpec) <span class="cov0" title="0">{
        *out = *in
        in.Vnet.DeepCopyInto(&amp;out.Vnet)
        if in.Subnets != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Subnets, &amp;out.Subnets
                *out = make(Subnets, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov0" title="0">in.APIServerLB.DeepCopyInto(&amp;out.APIServerLB)
        if in.NodeOutboundLB != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.NodeOutboundLB, &amp;out.NodeOutboundLB
                *out = new(LoadBalancerSpec)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov0" title="0">if in.ControlPlaneOutboundLB != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ControlPlaneOutboundLB, &amp;out.ControlPlaneOutboundLB
                *out = new(LoadBalancerSpec)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov0" title="0">out.NetworkClassSpec = in.NetworkClassSpec</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NetworkSpec.
func (in *NetworkSpec) DeepCopy() *NetworkSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(NetworkSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NetworkTemplateSpec) DeepCopyInto(out *NetworkTemplateSpec) <span class="cov0" title="0">{
        *out = *in
        out.NetworkClassSpec = in.NetworkClassSpec
        in.Vnet.DeepCopyInto(&amp;out.Vnet)
        if in.Subnets != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Subnets, &amp;out.Subnets
                *out = make(SubnetTemplatesSpec, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov0" title="0">in.APIServerLB.DeepCopyInto(&amp;out.APIServerLB)
        if in.NodeOutboundLB != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.NodeOutboundLB, &amp;out.NodeOutboundLB
                *out = new(LoadBalancerClassSpec)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov0" title="0">if in.ControlPlaneOutboundLB != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ControlPlaneOutboundLB, &amp;out.ControlPlaneOutboundLB
                *out = new(LoadBalancerClassSpec)
                (*in).DeepCopyInto(*out)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NetworkTemplateSpec.
func (in *NetworkTemplateSpec) DeepCopy() *NetworkTemplateSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(NetworkTemplateSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OSDisk) DeepCopyInto(out *OSDisk) <span class="cov0" title="0">{
        *out = *in
        if in.DiskSizeGB != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.DiskSizeGB, &amp;out.DiskSizeGB
                *out = new(int32)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.ManagedDisk != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ManagedDisk, &amp;out.ManagedDisk
                *out = new(ManagedDiskParameters)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov0" title="0">if in.DiffDiskSettings != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.DiffDiskSettings, &amp;out.DiffDiskSettings
                *out = new(DiffDiskSettings)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OSDisk.
func (in *OSDisk) DeepCopy() *OSDisk <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(OSDisk)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PublicIPSpec) DeepCopyInto(out *PublicIPSpec) <span class="cov0" title="0">{
        *out = *in
        if in.IPTags != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.IPTags, &amp;out.IPTags
                *out = make([]IPTag, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PublicIPSpec.
func (in *PublicIPSpec) DeepCopy() *PublicIPSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(PublicIPSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RateLimitConfig) DeepCopyInto(out *RateLimitConfig) <span class="cov0" title="0">{
        *out = *in
        if in.CloudProviderRateLimitQPS != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.CloudProviderRateLimitQPS, &amp;out.CloudProviderRateLimitQPS
                x := (*in).DeepCopy()
                *out = &amp;x
        }</span>
        <span class="cov0" title="0">if in.CloudProviderRateLimitQPSWrite != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.CloudProviderRateLimitQPSWrite, &amp;out.CloudProviderRateLimitQPSWrite
                x := (*in).DeepCopy()
                *out = &amp;x
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RateLimitConfig.
func (in *RateLimitConfig) DeepCopy() *RateLimitConfig <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(RateLimitConfig)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RateLimitSpec) DeepCopyInto(out *RateLimitSpec) <span class="cov0" title="0">{
        *out = *in
        in.Config.DeepCopyInto(&amp;out.Config)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RateLimitSpec.
func (in *RateLimitSpec) DeepCopy() *RateLimitSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(RateLimitSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RouteTable) DeepCopyInto(out *RouteTable) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RouteTable.
func (in *RouteTable) DeepCopy() *RouteTable <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(RouteTable)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecurityGroup) DeepCopyInto(out *SecurityGroup) <span class="cov0" title="0">{
        *out = *in
        in.SecurityGroupClass.DeepCopyInto(&amp;out.SecurityGroupClass)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecurityGroup.
func (in *SecurityGroup) DeepCopy() *SecurityGroup <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(SecurityGroup)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecurityGroupClass) DeepCopyInto(out *SecurityGroupClass) <span class="cov0" title="0">{
        *out = *in
        if in.SecurityRules != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.SecurityRules, &amp;out.SecurityRules
                *out = make(SecurityRules, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov0" title="0">if in.Tags != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Tags, &amp;out.Tags
                *out = make(Tags, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecurityGroupClass.
func (in *SecurityGroupClass) DeepCopy() *SecurityGroupClass <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(SecurityGroupClass)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecurityProfile) DeepCopyInto(out *SecurityProfile) <span class="cov0" title="0">{
        *out = *in
        if in.EncryptionAtHost != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.EncryptionAtHost, &amp;out.EncryptionAtHost
                *out = new(bool)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecurityProfile.
func (in *SecurityProfile) DeepCopy() *SecurityProfile <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(SecurityProfile)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecurityRule) DeepCopyInto(out *SecurityRule) <span class="cov0" title="0">{
        *out = *in
        if in.SourcePorts != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.SourcePorts, &amp;out.SourcePorts
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.DestinationPorts != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.DestinationPorts, &amp;out.DestinationPorts
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.Source != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Source, &amp;out.Source
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.Destination != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Destination, &amp;out.Destination
                *out = new(string)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecurityRule.
func (in *SecurityRule) DeepCopy() *SecurityRule <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(SecurityRule)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in SecurityRules) DeepCopyInto(out *SecurityRules) <span class="cov0" title="0">{
        </span><span class="cov0" title="0">{
                in := &amp;in
                *out = make(SecurityRules, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecurityRules.
func (in SecurityRules) DeepCopy() SecurityRules <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(SecurityRules)
        in.DeepCopyInto(out)
        return *out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SpotVMOptions) DeepCopyInto(out *SpotVMOptions) <span class="cov0" title="0">{
        *out = *in
        if in.MaxPrice != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.MaxPrice, &amp;out.MaxPrice
                x := (*in).DeepCopy()
                *out = &amp;x
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SpotVMOptions.
func (in *SpotVMOptions) DeepCopy() *SpotVMOptions <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(SpotVMOptions)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SubnetClassSpec) DeepCopyInto(out *SubnetClassSpec) <span class="cov0" title="0">{
        *out = *in
        if in.CIDRBlocks != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.CIDRBlocks, &amp;out.CIDRBlocks
                *out = make([]string, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SubnetClassSpec.
func (in *SubnetClassSpec) DeepCopy() *SubnetClassSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(SubnetClassSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SubnetSpec) DeepCopyInto(out *SubnetSpec) <span class="cov0" title="0">{
        *out = *in
        in.SecurityGroup.DeepCopyInto(&amp;out.SecurityGroup)
        out.RouteTable = in.RouteTable
        in.NatGateway.DeepCopyInto(&amp;out.NatGateway)
        in.SubnetClassSpec.DeepCopyInto(&amp;out.SubnetClassSpec)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SubnetSpec.
func (in *SubnetSpec) DeepCopy() *SubnetSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(SubnetSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SubnetTemplateSpec) DeepCopyInto(out *SubnetTemplateSpec) <span class="cov0" title="0">{
        *out = *in
        in.SubnetClassSpec.DeepCopyInto(&amp;out.SubnetClassSpec)
        in.SecurityGroup.DeepCopyInto(&amp;out.SecurityGroup)
        out.NatGateway = in.NatGateway
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SubnetTemplateSpec.
func (in *SubnetTemplateSpec) DeepCopy() *SubnetTemplateSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(SubnetTemplateSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in SubnetTemplatesSpec) DeepCopyInto(out *SubnetTemplatesSpec) <span class="cov0" title="0">{
        </span><span class="cov0" title="0">{
                in := &amp;in
                *out = make(SubnetTemplatesSpec, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SubnetTemplatesSpec.
func (in SubnetTemplatesSpec) DeepCopy() SubnetTemplatesSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(SubnetTemplatesSpec)
        in.DeepCopyInto(out)
        return *out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in Subnets) DeepCopyInto(out *Subnets) <span class="cov0" title="0">{
        </span><span class="cov0" title="0">{
                in := &amp;in
                *out = make(Subnets, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Subnets.
func (in Subnets) DeepCopy() Subnets <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(Subnets)
        in.DeepCopyInto(out)
        return *out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in Tags) DeepCopyInto(out *Tags) <span class="cov0" title="0">{
        </span><span class="cov0" title="0">{
                in := &amp;in
                *out = make(Tags, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Tags.
func (in Tags) DeepCopy() Tags <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(Tags)
        in.DeepCopyInto(out)
        return *out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *UserAssignedIdentity) DeepCopyInto(out *UserAssignedIdentity) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new UserAssignedIdentity.
func (in *UserAssignedIdentity) DeepCopy() *UserAssignedIdentity <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(UserAssignedIdentity)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *VnetClassSpec) DeepCopyInto(out *VnetClassSpec) <span class="cov0" title="0">{
        *out = *in
        if in.CIDRBlocks != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.CIDRBlocks, &amp;out.CIDRBlocks
                *out = make([]string, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov0" title="0">if in.Tags != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Tags, &amp;out.Tags
                *out = make(Tags, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VnetClassSpec.
func (in *VnetClassSpec) DeepCopy() *VnetClassSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(VnetClassSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *VnetPeeringClassSpec) DeepCopyInto(out *VnetPeeringClassSpec) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VnetPeeringClassSpec.
func (in *VnetPeeringClassSpec) DeepCopy() *VnetPeeringClassSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(VnetPeeringClassSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *VnetPeeringSpec) DeepCopyInto(out *VnetPeeringSpec) <span class="cov0" title="0">{
        *out = *in
        out.VnetPeeringClassSpec = in.VnetPeeringClassSpec
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VnetPeeringSpec.
func (in *VnetPeeringSpec) DeepCopy() *VnetPeeringSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(VnetPeeringSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in VnetPeerings) DeepCopyInto(out *VnetPeerings) <span class="cov0" title="0">{
        </span><span class="cov0" title="0">{
                in := &amp;in
                *out = make(VnetPeerings, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VnetPeerings.
func (in VnetPeerings) DeepCopy() VnetPeerings <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(VnetPeerings)
        in.DeepCopyInto(out)
        return *out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in VnetPeeringsTemplateSpec) DeepCopyInto(out *VnetPeeringsTemplateSpec) <span class="cov0" title="0">{
        </span><span class="cov0" title="0">{
                in := &amp;in
                *out = make(VnetPeeringsTemplateSpec, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VnetPeeringsTemplateSpec.
func (in VnetPeeringsTemplateSpec) DeepCopy() VnetPeeringsTemplateSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(VnetPeeringsTemplateSpec)
        in.DeepCopyInto(out)
        return *out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *VnetSpec) DeepCopyInto(out *VnetSpec) <span class="cov0" title="0">{
        *out = *in
        if in.Peerings != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Peerings, &amp;out.Peerings
                *out = make(VnetPeerings, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov0" title="0">in.VnetClassSpec.DeepCopyInto(&amp;out.VnetClassSpec)</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VnetSpec.
func (in *VnetSpec) DeepCopy() *VnetSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(VnetSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *VnetTemplateSpec) DeepCopyInto(out *VnetTemplateSpec) <span class="cov0" title="0">{
        *out = *in
        in.VnetClassSpec.DeepCopyInto(&amp;out.VnetClassSpec)
        if in.Peerings != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Peerings, &amp;out.Peerings
                *out = make(VnetPeeringsTemplateSpec, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VnetTemplateSpec.
func (in *VnetTemplateSpec) DeepCopy() *VnetTemplateSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(VnetTemplateSpec)
        in.DeepCopyInto(out)
        return out</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package converters

import (
        "github.com/Azure/azure-sdk-for-go/services/privatedns/mgmt/2018-09-01/privatedns"
        "k8s.io/utils/net"
)

// GetRecordType returns the SDK record type to use based on the type of IP to map.
// Currently only allows type A (IPv4) and AAAA (IPv6) records.
func GetRecordType(ip string) privatedns.RecordType <span class="cov8" title="1">{
        switch </span>{
        case net.IsIPv6String(ip):<span class="cov8" title="1">
                return privatedns.AAAA</span>
        default:<span class="cov8" title="1">
                return privatedns.A</span>
        }
}
</pre>
		
		<pre class="file" id="file52" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package converters

import (
        "encoding/base64"

        azureautorest "github.com/Azure/go-autorest/autorest/azure"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
)

// SDKToFuture converts an SDK future to an infrav1.Future.
func SDKToFuture(future azureautorest.FutureAPI, futureType, service, resourceName, rgName string) (*infrav1.Future, error) <span class="cov8" title="1">{
        jsonData, err := future.MarshalJSON()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to marshal async future")
        }</span>

        <span class="cov8" title="1">return &amp;infrav1.Future{
                Type:          futureType,
                ResourceGroup: rgName,
                ServiceName:   service,
                Name:          resourceName,
                Data:          base64.URLEncoding.EncodeToString(jsonData),
        }, nil</span>
}

// FutureToSDK converts an infrav1.Future to an SDK future.
func FutureToSDK(future infrav1.Future) (azureautorest.FutureAPI, error) <span class="cov8" title="1">{
        futureData, err := base64.URLEncoding.DecodeString(future.Data)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, "failed to base64 decode future data")
        }</span>
        <span class="cov8" title="1">var genericFuture azureautorest.Future
        if err := genericFuture.UnmarshalJSON(futureData); err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, "failed to unmarshal future data")
        }</span>
        <span class="cov8" title="1">return &amp;genericFuture, nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package converters

import (
        "strings"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-11-01/compute"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
)

// ErrUserAssignedIdentitiesNotFound is the error thrown when user assigned identities is not passed with the identity type being UserAssigned.
var ErrUserAssignedIdentitiesNotFound = errors.New("the user-assigned identity provider ids must not be null or empty for 'UserAssigned' identity type")

// VMIdentityToVMSDK converts CAPZ VM identity to Azure SDK identity.
func VMIdentityToVMSDK(identity infrav1.VMIdentity, uami []infrav1.UserAssignedIdentity) (*compute.VirtualMachineIdentity, error) <span class="cov8" title="1">{
        if identity == infrav1.VMIdentitySystemAssigned </span><span class="cov8" title="1">{
                return &amp;compute.VirtualMachineIdentity{
                        Type: compute.ResourceIdentityTypeSystemAssigned,
                }, nil
        }</span>

        <span class="cov8" title="1">if identity == infrav1.VMIdentityUserAssigned </span><span class="cov8" title="1">{
                userIdentitiesMap, err := UserAssignedIdentitiesToVMSDK(uami)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, errors.Wrap(err, "failed to assign VM identity")
                }</span>

                <span class="cov8" title="1">return &amp;compute.VirtualMachineIdentity{
                        Type:                   compute.ResourceIdentityTypeUserAssigned,
                        UserAssignedIdentities: userIdentitiesMap,
                }, nil</span>
        }

        <span class="cov8" title="1">return nil, nil</span>
}

// UserAssignedIdentitiesToVMSDK converts CAPZ user assigned identities associated with the Virtual Machine to Azure SDK identities
// The user identity dictionary key references will be ARM resource ids in the form:
// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
func UserAssignedIdentitiesToVMSDK(identities []infrav1.UserAssignedIdentity) (map[string]*compute.VirtualMachineIdentityUserAssignedIdentitiesValue, error) <span class="cov8" title="1">{
        if len(identities) == 0 </span><span class="cov8" title="1">{
                return nil, ErrUserAssignedIdentitiesNotFound
        }</span>
        <span class="cov8" title="1">userIdentitiesMap := make(map[string]*compute.VirtualMachineIdentityUserAssignedIdentitiesValue, len(identities))
        for _, id := range identities </span><span class="cov8" title="1">{
                key := sanitized(id.ProviderID)
                userIdentitiesMap[key] = &amp;compute.VirtualMachineIdentityUserAssignedIdentitiesValue{}
        }</span>

        <span class="cov8" title="1">return userIdentitiesMap, nil</span>
}

// UserAssignedIdentitiesToVMSSSDK converts CAPZ user assigned identities associated with the Virtual Machine Scale Set to Azure SDK identities
// Similar to UserAssignedIdentitiesToVMSDK.
func UserAssignedIdentitiesToVMSSSDK(identities []infrav1.UserAssignedIdentity) (map[string]*compute.VirtualMachineScaleSetIdentityUserAssignedIdentitiesValue, error) <span class="cov8" title="1">{
        if len(identities) == 0 </span><span class="cov8" title="1">{
                return nil, ErrUserAssignedIdentitiesNotFound
        }</span>
        <span class="cov8" title="1">userIdentitiesMap := make(map[string]*compute.VirtualMachineScaleSetIdentityUserAssignedIdentitiesValue, len(identities))
        for _, id := range identities </span><span class="cov8" title="1">{
                key := sanitized(id.ProviderID)
                userIdentitiesMap[key] = &amp;compute.VirtualMachineScaleSetIdentityUserAssignedIdentitiesValue{}
        }</span>

        <span class="cov8" title="1">return userIdentitiesMap, nil</span>
}

// sanitized removes "azure://" prefix from the given id.
func sanitized(id string) string <span class="cov8" title="1">{
        return strings.TrimPrefix(id, azure.ProviderIDPrefix)
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package converters

import (
        "fmt"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-11-01/compute"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
)

// ImageToSDK converts a CAPZ Image (as RawExtension) to a Azure SDK Image Reference.
func ImageToSDK(image *infrav1.Image) (*compute.ImageReference, error) <span class="cov0" title="0">{
        if image.ID != nil </span><span class="cov0" title="0">{
                return specificImageToSDK(image)
        }</span>
        <span class="cov0" title="0">if image.Marketplace != nil </span><span class="cov0" title="0">{
                return mpImageToSDK(image)
        }</span>
        <span class="cov0" title="0">if image.ComputeGallery != nil || image.SharedGallery != nil </span><span class="cov0" title="0">{
                return computeImageToSDK(image)
        }</span>

        <span class="cov0" title="0">return nil, errors.New("unable to convert image as no options set")</span>
}

func mpImageToSDK(image *infrav1.Image) (*compute.ImageReference, error) <span class="cov0" title="0">{
        return &amp;compute.ImageReference{
                Publisher: &amp;image.Marketplace.Publisher,
                Offer:     &amp;image.Marketplace.Offer,
                Sku:       &amp;image.Marketplace.SKU,
                Version:   &amp;image.Marketplace.Version,
        }, nil
}</span>

func computeImageToSDK(image *infrav1.Image) (*compute.ImageReference, error) <span class="cov0" title="0">{
        idTemplate := "/subscriptions/%s/resourceGroups/%s/providers/Microsoft.Compute/galleries/%s/images/%s/versions/%s"

        if image.SharedGallery != nil </span><span class="cov0" title="0">{
                return &amp;compute.ImageReference{
                        ID: to.StringPtr(fmt.Sprintf(idTemplate,
                                image.SharedGallery.SubscriptionID,
                                image.SharedGallery.ResourceGroup,
                                image.SharedGallery.Gallery,
                                image.SharedGallery.Name,
                                image.SharedGallery.Version,
                        )),
                }, nil
        }</span>

        // For private Azure Compute Gallery consumption both resource group and subscription ID must be provided.
        // If they are not, we assume use of community gallery.
        <span class="cov0" title="0">if image.ComputeGallery.ResourceGroup != nil &amp;&amp; image.ComputeGallery.SubscriptionID != nil </span><span class="cov0" title="0">{
                return &amp;compute.ImageReference{
                        ID: to.StringPtr(fmt.Sprintf(idTemplate,
                                image.ComputeGallery.SubscriptionID,
                                image.ComputeGallery.ResourceGroup,
                                image.ComputeGallery.Gallery,
                                image.ComputeGallery.Name,
                                image.ComputeGallery.Version,
                        )),
                }, nil
        }</span>

        <span class="cov0" title="0">return &amp;compute.ImageReference{
                CommunityGalleryImageID: to.StringPtr(fmt.Sprintf("/CommunityGalleries/%s/Images/%s/Versions/%s",
                        image.ComputeGallery.Gallery,
                        image.ComputeGallery.Name,
                        image.ComputeGallery.Version)),
        }, nil</span>
}

func specificImageToSDK(image *infrav1.Image) (*compute.ImageReference, error) <span class="cov0" title="0">{
        return &amp;compute.ImageReference{
                ID: image.ID,
        }, nil
}</span>

// ImageToPlan converts a CAPZ Image to an Azure Compute Plan.
func ImageToPlan(image *infrav1.Image) *compute.Plan <span class="cov8" title="1">{
        // Plan is needed when using a Shared Gallery image with Plan details.
        if image.SharedGallery != nil &amp;&amp; image.SharedGallery.Publisher != nil &amp;&amp; image.SharedGallery.SKU != nil &amp;&amp; image.SharedGallery.Offer != nil </span><span class="cov8" title="1">{
                return &amp;compute.Plan{
                        Publisher: image.SharedGallery.Publisher,
                        Name:      image.SharedGallery.SKU,
                        Product:   image.SharedGallery.Offer,
                }
        }</span>

        // Plan is needed for third party Marketplace images.
        <span class="cov8" title="1">if image.Marketplace != nil &amp;&amp; image.Marketplace.ThirdPartyImage </span><span class="cov8" title="1">{
                return &amp;compute.Plan{
                        Publisher: to.StringPtr(image.Marketplace.Publisher),
                        Name:      to.StringPtr(image.Marketplace.SKU),
                        Product:   to.StringPtr(image.Marketplace.Offer),
                }
        }</span>

        // Plan is needed when using a Azure Compute Gallery image with Plan details.
        <span class="cov8" title="1">if image.ComputeGallery != nil &amp;&amp; image.ComputeGallery.Plan != nil </span><span class="cov8" title="1">{
                return &amp;compute.Plan{
                        Publisher: to.StringPtr(image.ComputeGallery.Plan.Publisher),
                        Name:      to.StringPtr(image.ComputeGallery.Plan.SKU),
                        Product:   to.StringPtr(image.ComputeGallery.Plan.Offer),
                }
        }</span>

        // Otherwise return nil.
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package converters

import (
        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-08-01/network"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
)

// SKUtoSDK converts infrav1.SKU into a network.LoadBalancerSkuName.
func SKUtoSDK(src infrav1.SKU) network.LoadBalancerSkuName <span class="cov8" title="1">{
        if src == infrav1.SKUStandard </span><span class="cov8" title="1">{
                return network.LoadBalancerSkuNameStandard
        }</span>
        <span class="cov8" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package converters

import (
        "github.com/Azure/azure-sdk-for-go/services/containerservice/mgmt/2021-05-01/containerservice"
)

// AgentPoolToManagedClusterAgentPoolProfile converts a AgentPoolSpec to an Azure SDK ManagedClusterAgentPoolProfile used in managedcluster reconcile.
func AgentPoolToManagedClusterAgentPoolProfile(pool containerservice.AgentPool) containerservice.ManagedClusterAgentPoolProfile <span class="cov8" title="1">{
        properties := pool.ManagedClusterAgentPoolProfileProperties
        return containerservice.ManagedClusterAgentPoolProfile{
                Name:                pool.Name, // Note: if converting from agentPoolSpec.Parameters(), this field will not be set
                VMSize:              properties.VMSize,
                OsType:              properties.OsType,
                OsDiskSizeGB:        properties.OsDiskSizeGB,
                Count:               properties.Count,
                Type:                properties.Type,
                OrchestratorVersion: properties.OrchestratorVersion,
                VnetSubnetID:        properties.VnetSubnetID,
                Mode:                properties.Mode,
                EnableAutoScaling:   properties.EnableAutoScaling,
                MaxCount:            properties.MaxCount,
                MinCount:            properties.MinCount,
                NodeTaints:          properties.NodeTaints,
                AvailabilityZones:   properties.AvailabilityZones,
                MaxPods:             properties.MaxPods,
                OsDiskType:          properties.OsDiskType,
                NodeLabels:          properties.NodeLabels,
                EnableUltraSSD:      properties.EnableUltraSSD,
                EnableNodePublicIP:  properties.EnableNodePublicIP,
        }
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package converters

import (
        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-08-01/network"
        "github.com/Azure/go-autorest/autorest/to"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
)

// IPTagsToSDK converts a CAPZ IP tag to an Azure SDK IP tag.
func IPTagsToSDK(ipTags []infrav1.IPTag) *[]network.IPTag <span class="cov8" title="1">{
        if len(ipTags) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">skdIPTags := make([]network.IPTag, len(ipTags))
        for i, ipTag := range ipTags </span><span class="cov8" title="1">{
                skdIPTags[i] = network.IPTag{
                        IPTagType: to.StringPtr(ipTag.Type),
                        Tag:       to.StringPtr(ipTag.Tag),
                }
        }</span>
        <span class="cov8" title="1">return &amp;skdIPTags</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package converters

import (
        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-08-01/network"
        "github.com/Azure/go-autorest/autorest/to"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
)

// SecurityRuleToSDK converts a CAPZ security rule to an Azure network security rule.
func SecurityRuleToSDK(rule infrav1.SecurityRule) network.SecurityRule <span class="cov0" title="0">{
        secRule := network.SecurityRule{
                Name: to.StringPtr(rule.Name),
                SecurityRulePropertiesFormat: &amp;network.SecurityRulePropertiesFormat{
                        Description:              to.StringPtr(rule.Description),
                        SourceAddressPrefix:      rule.Source,
                        SourcePortRange:          rule.SourcePorts,
                        DestinationAddressPrefix: rule.Destination,
                        DestinationPortRange:     rule.DestinationPorts,
                        Access:                   network.SecurityRuleAccessAllow,
                        Priority:                 to.Int32Ptr(rule.Priority),
                },
        }

        switch rule.Protocol </span>{
        case infrav1.SecurityGroupProtocolAll:<span class="cov0" title="0">
                secRule.Protocol = network.SecurityRuleProtocolAsterisk</span>
        case infrav1.SecurityGroupProtocolTCP:<span class="cov0" title="0">
                secRule.Protocol = network.SecurityRuleProtocolTCP</span>
        case infrav1.SecurityGroupProtocolUDP:<span class="cov0" title="0">
                secRule.Protocol = network.SecurityRuleProtocolUDP</span>
        case infrav1.SecurityGroupProtocolICMP:<span class="cov0" title="0">
                secRule.Protocol = network.SecurityRuleProtocolIcmp</span>
        }

        <span class="cov0" title="0">switch rule.Direction </span>{
        case infrav1.SecurityRuleDirectionOutbound:<span class="cov0" title="0">
                secRule.Direction = network.SecurityRuleDirectionOutbound</span>
        case infrav1.SecurityRuleDirectionInbound:<span class="cov0" title="0">
                secRule.Direction = network.SecurityRuleDirectionInbound</span>
        }

        <span class="cov0" title="0">return secRule</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package converters

import (
        "strconv"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-11-01/compute"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
)

// GetSpotVMOptions takes the spot vm options
// and returns the individual vm priority, eviction policy and billing profile.
func GetSpotVMOptions(spotVMOptions *infrav1.SpotVMOptions, diffDiskSettings *infrav1.DiffDiskSettings) (compute.VirtualMachinePriorityTypes, compute.VirtualMachineEvictionPolicyTypes, *compute.BillingProfile, error) <span class="cov8" title="1">{
        // Spot VM not requested, return zero values to apply defaults
        if spotVMOptions == nil </span><span class="cov8" title="1">{
                return "", "", nil, nil
        }</span>
        <span class="cov8" title="1">var billingProfile *compute.BillingProfile
        if spotVMOptions.MaxPrice != nil </span><span class="cov8" title="1">{
                maxPrice, err := strconv.ParseFloat(spotVMOptions.MaxPrice.AsDec().String(), 64)
                if err != nil </span><span class="cov0" title="0">{
                        return "", "", nil, err
                }</span>
                <span class="cov8" title="1">billingProfile = &amp;compute.BillingProfile{
                        MaxPrice: &amp;maxPrice,
                }</span>
        }
        <span class="cov8" title="1">evictionPolicy := compute.VirtualMachineEvictionPolicyTypesDeallocate
        if diffDiskSettings != nil &amp;&amp; diffDiskSettings.Option == "Local" </span><span class="cov8" title="1">{
                evictionPolicy = compute.VirtualMachineEvictionPolicyTypesDelete
        }</span>
        <span class="cov8" title="1">return compute.VirtualMachinePriorityTypesSpot, evictionPolicy, billingProfile, nil</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package converters

import (
        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-08-01/network"
        "github.com/Azure/go-autorest/autorest/to"
)

// GetSubnetAddresses returns the address prefixes contained in a subnet.
func GetSubnetAddresses(subnet network.Subnet) []string <span class="cov8" title="1">{
        var addresses []string
        if subnet.SubnetPropertiesFormat != nil &amp;&amp; subnet.SubnetPropertiesFormat.AddressPrefix != nil </span><span class="cov8" title="1">{
                addresses = []string{to.String(subnet.SubnetPropertiesFormat.AddressPrefix)}
        }</span> else<span class="cov8" title="1"> if subnet.SubnetPropertiesFormat != nil &amp;&amp; subnet.SubnetPropertiesFormat.AddressPrefixes != nil </span><span class="cov8" title="1">{
                addresses = to.StringSlice(subnet.SubnetPropertiesFormat.AddressPrefixes)
        }</span>
        <span class="cov8" title="1">return addresses</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package converters

import (
        "github.com/Azure/go-autorest/autorest/to"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
)

// MapToTags converts a map[string]*string into a infrav1.Tags.
func MapToTags(src map[string]*string) infrav1.Tags <span class="cov8" title="1">{
        tags := make(infrav1.Tags, len(src))

        for k, v := range src </span><span class="cov8" title="1">{
                tags[k] = to.String(v)
        }</span>

        <span class="cov8" title="1">return tags</span>
}

// TagsToMap converts infrav1.Tags into a map[string]*string.
func TagsToMap(src infrav1.Tags) map[string]*string <span class="cov0" title="0">{
        tags := make(map[string]*string, len(src))

        for k, v := range src </span><span class="cov0" title="0">{
                tags[k] = to.StringPtr(v)
        }</span>

        <span class="cov0" title="0">return tags</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package converters

import (
        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-11-01/compute"
        "github.com/Azure/go-autorest/autorest/to"
        corev1 "k8s.io/api/core/v1"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
)

// VM describes an Azure virtual machine.
type VM struct {
        ID               string `json:"id,omitempty"`
        Name             string `json:"name,omitempty"`
        AvailabilityZone string `json:"availabilityZone,omitempty"`
        // Hardware profile
        VMSize string `json:"vmSize,omitempty"`
        // Storage profile
        Image         infrav1.Image  `json:"image,omitempty"`
        OSDisk        infrav1.OSDisk `json:"osDisk,omitempty"`
        StartupScript string         `json:"startupScript,omitempty"`
        // State - The provisioning state, which only appears in the response.
        State    infrav1.ProvisioningState `json:"vmState,omitempty"`
        Identity infrav1.VMIdentity        `json:"identity,omitempty"`
        Tags     infrav1.Tags              `json:"tags,omitempty"`

        // Addresses contains the addresses associated with the Azure VM.
        Addresses []corev1.NodeAddress `json:"addresses,omitempty"`
}

// SDKToVM converts an Azure SDK VirtualMachine to the CAPZ VM type.
func SDKToVM(v compute.VirtualMachine) *VM <span class="cov8" title="1">{
        vm := &amp;VM{
                ID:    to.String(v.ID),
                Name:  to.String(v.Name),
                State: infrav1.ProvisioningState(to.String(v.ProvisioningState)),
        }

        if v.VirtualMachineProperties != nil &amp;&amp; v.VirtualMachineProperties.HardwareProfile != nil </span><span class="cov8" title="1">{
                vm.VMSize = string(v.VirtualMachineProperties.HardwareProfile.VMSize)
        }</span>

        <span class="cov8" title="1">if v.Zones != nil &amp;&amp; len(*v.Zones) &gt; 0 </span><span class="cov8" title="1">{
                vm.AvailabilityZone = to.StringSlice(v.Zones)[0]
        }</span>

        <span class="cov8" title="1">if len(v.Tags) &gt; 0 </span><span class="cov8" title="1">{
                vm.Tags = MapToTags(v.Tags)
        }</span>

        <span class="cov8" title="1">return vm</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package converters

import (
        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-11-01/compute"
        "github.com/Azure/go-autorest/autorest/to"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
)

// SDKToVMSS converts an Azure SDK VirtualMachineScaleSet to the AzureMachinePool type.
func SDKToVMSS(sdkvmss compute.VirtualMachineScaleSet, sdkinstances []compute.VirtualMachineScaleSetVM) *azure.VMSS <span class="cov8" title="1">{
        vmss := &amp;azure.VMSS{
                ID:    to.String(sdkvmss.ID),
                Name:  to.String(sdkvmss.Name),
                State: infrav1.ProvisioningState(to.String(sdkvmss.ProvisioningState)),
        }

        if sdkvmss.Sku != nil </span><span class="cov8" title="1">{
                vmss.Sku = to.String(sdkvmss.Sku.Name)
                vmss.Capacity = to.Int64(sdkvmss.Sku.Capacity)
        }</span>

        <span class="cov8" title="1">if sdkvmss.Zones != nil &amp;&amp; len(*sdkvmss.Zones) &gt; 0 </span><span class="cov8" title="1">{
                vmss.Zones = to.StringSlice(sdkvmss.Zones)
        }</span>

        <span class="cov8" title="1">if len(sdkvmss.Tags) &gt; 0 </span><span class="cov8" title="1">{
                vmss.Tags = MapToTags(sdkvmss.Tags)
        }</span>

        <span class="cov8" title="1">if len(sdkinstances) &gt; 0 </span><span class="cov8" title="1">{
                vmss.Instances = make([]azure.VMSSVM, len(sdkinstances))
                for i, vm := range sdkinstances </span><span class="cov8" title="1">{
                        vmss.Instances[i] = *SDKToVMSSVM(vm)
                }</span>
        }

        <span class="cov8" title="1">if sdkvmss.VirtualMachineProfile != nil &amp;&amp;
                sdkvmss.VirtualMachineProfile.StorageProfile != nil &amp;&amp;
                sdkvmss.VirtualMachineProfile.StorageProfile.ImageReference != nil </span><span class="cov0" title="0">{
                imageRef := sdkvmss.VirtualMachineProfile.StorageProfile.ImageReference
                vmss.Image = SDKImageToImage(imageRef, sdkvmss.Plan != nil)
        }</span>

        <span class="cov8" title="1">return vmss</span>
}

// SDKToVMSSVM converts an Azure SDK VirtualMachineScaleSetVM into an infrav1exp.VMSSVM.
func SDKToVMSSVM(sdkInstance compute.VirtualMachineScaleSetVM) *azure.VMSSVM <span class="cov8" title="1">{
        instance := azure.VMSSVM{
                ID:         to.String(sdkInstance.ID),
                InstanceID: to.String(sdkInstance.InstanceID),
        }

        if sdkInstance.VirtualMachineScaleSetVMProperties == nil </span><span class="cov0" title="0">{
                return &amp;instance
        }</span>

        <span class="cov8" title="1">instance.State = infrav1.Creating
        if sdkInstance.ProvisioningState != nil </span><span class="cov8" title="1">{
                instance.State = infrav1.ProvisioningState(to.String(sdkInstance.ProvisioningState))
        }</span>

        <span class="cov8" title="1">if sdkInstance.OsProfile != nil &amp;&amp; sdkInstance.OsProfile.ComputerName != nil </span><span class="cov8" title="1">{
                instance.Name = *sdkInstance.OsProfile.ComputerName
        }</span>

        <span class="cov8" title="1">if sdkInstance.StorageProfile != nil &amp;&amp; sdkInstance.StorageProfile.ImageReference != nil </span><span class="cov0" title="0">{
                imageRef := sdkInstance.StorageProfile.ImageReference
                instance.Image = SDKImageToImage(imageRef, sdkInstance.Plan != nil)
        }</span>

        <span class="cov8" title="1">if sdkInstance.Zones != nil &amp;&amp; len(*sdkInstance.Zones) &gt; 0 </span><span class="cov8" title="1">{
                // an instance should only have 1 zone, so we select the first item of the slice
                instance.AvailabilityZone = to.StringSlice(sdkInstance.Zones)[0]
        }</span>

        <span class="cov8" title="1">return &amp;instance</span>
}

// SDKImageToImage converts a SDK image reference to infrav1.Image.
func SDKImageToImage(sdkImageRef *compute.ImageReference, isThirdPartyImage bool) infrav1.Image <span class="cov0" title="0">{
        return infrav1.Image{
                ID: sdkImageRef.ID,
                Marketplace: &amp;infrav1.AzureMarketplaceImage{
                        ImagePlan: infrav1.ImagePlan{
                                Publisher: to.String(sdkImageRef.Publisher),
                                Offer:     to.String(sdkImageRef.Offer),
                                SKU:       to.String(sdkImageRef.Sku),
                        },
                        Version:         to.String(sdkImageRef.Version),
                        ThirdPartyImage: isThirdPartyImage,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package azure

import (
        "fmt"
        "net/http"

        "github.com/Azure/go-autorest/autorest"
        "github.com/Azure/go-autorest/autorest/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
        "sigs.k8s.io/cluster-api-provider-azure/version"
)

const (
        // DefaultUserName is the default username for a created VM.
        DefaultUserName = "capi"
        // DefaultAKSUserName is the default username for a created AKS VM.
        DefaultAKSUserName = "azureuser"
)

const (
        // DefaultImageOfferID is the default Azure Marketplace offer ID.
        DefaultImageOfferID = "capi"
        // DefaultWindowsImageOfferID is the default Azure Marketplace offer ID for Windows.
        DefaultWindowsImageOfferID = "capi-windows"
        // DefaultImagePublisherID is the default Azure Marketplace publisher ID.
        DefaultImagePublisherID = "cncf-upstream"
        // LatestVersion is the image version latest.
        LatestVersion = "latest"
)

const (
        // LinuxOS is Linux OS value for OSDisk.OSType.
        LinuxOS = "Linux"
        // WindowsOS is Windows OS value for OSDisk.OSType.
        WindowsOS = "Windows"
)

const (
        // DefaultWindowsOsAndVersion is the default Windows Server version to use when
        // genearating default images for Windows nodes.
        DefaultWindowsOsAndVersion = "windows-2019"
)

const (
        // Global is the Azure global location value.
        Global = "global"
)

const (
        // PrivateAPIServerHostname will be used as the api server hostname for private clusters.
        PrivateAPIServerHostname = "apiserver"
)

const (
        // ControlPlaneNodeGroup will be used to create availability set for control plane machines.
        ControlPlaneNodeGroup = "control-plane"
)

const (
        // bootstrapExtensionRetries is the number of retries in the BootstrapExtensionCommand.
        // NOTE: the overall timeout will be number of retries * retry sleep, in this case 60 * 5s = 300s.
        bootstrapExtensionRetries = 60
        // bootstrapExtensionSleep is the duration in seconds to sleep before each retry in the BootstrapExtensionCommand.
        bootstrapExtensionSleep = 5
        // bootstrapSentinelFile is the file written by bootstrap provider on machines to indicate successful bootstrapping,
        // as defined by the Cluster API Bootstrap Provider contract (https://cluster-api.sigs.k8s.io/developer/providers/bootstrap.html).
        bootstrapSentinelFile = "/run/cluster-api/bootstrap-success.complete"
)

const (
        // ProviderIDPrefix will be appended to the beginning of Azure resource IDs to form the Kubernetes Provider ID.
        // NOTE: this format matches the 2 slashes format used in cloud-provider and cluster-autoscaler.
        ProviderIDPrefix = "azure://"
        // azureBuiltInContributorID the ID of the Contributor role in Azure
        // Ref: https://docs.microsoft.com/en-us/azure/role-based-access-control/built-in-roles
        azureBuiltInContributorID = "b24988ac-6180-42a0-ab88-20f7382dd24c"
)

const (
        // CustomHeaderPrefix is the prefix of annotations that enable additional cluster / node pool features.
        // Whatever follows the prefix will be passed as a header to cluster/node pool creation/update requests.
        // E.g. add `"infrastructure.cluster.x-k8s.io/custom-header-UseGPUDedicatedVHD": "true"` annotation to
        // AzureManagedMachinePool CR to enable creating GPU nodes by the node pool.
        CustomHeaderPrefix = "infrastructure.cluster.x-k8s.io/custom-header-"
)

var (
        // LinuxBootstrapExtensionCommand is the command the VM bootstrap extension will execute to verify Linux nodes bootstrap completes successfully.
        LinuxBootstrapExtensionCommand = fmt.Sprintf("for i in $(seq 1 %d); do test -f %s &amp;&amp; break; if [ $i -eq %d ]; then exit 1; else sleep %d; fi; done", bootstrapExtensionRetries, bootstrapSentinelFile, bootstrapExtensionRetries, bootstrapExtensionSleep)
        // WindowsBootstrapExtensionCommand is the command the VM bootstrap extension will execute to verify Windows nodes bootstrap completes successfully.
        WindowsBootstrapExtensionCommand = fmt.Sprintf("powershell.exe -Command \"for ($i = 0; $i -lt %d; $i++) {if (Test-Path '%s') {exit 0} else {Start-Sleep -Seconds %d}} exit -2\"",
                bootstrapExtensionRetries, bootstrapSentinelFile, bootstrapExtensionSleep)
)

// GenerateBackendAddressPoolName generates a load balancer backend address pool name.
func GenerateBackendAddressPoolName(lbName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s-%s", lbName, "backendPool")
}</span>

// GenerateSubscriptionScope generates a role assignment scope that applies to all resources in the subscription.
func GenerateSubscriptionScope(subscriptionID string) string <span class="cov0" title="0">{
        return fmt.Sprintf("/subscriptions/%s/", subscriptionID)
}</span>

// GenerateContributorRoleDefinitionID generates the contributor role definition ID.
func GenerateContributorRoleDefinitionID(subscriptionID string) string <span class="cov0" title="0">{
        return fmt.Sprintf("/subscriptions/%s/providers/Microsoft.Authorization/roleDefinitions/%s", subscriptionID, azureBuiltInContributorID)
}</span>

// GenerateOutboundBackendAddressPoolName generates a load balancer outbound backend address pool name.
func GenerateOutboundBackendAddressPoolName(lbName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s-%s", lbName, "outboundBackendPool")
}</span>

// GenerateFrontendIPConfigName generates a load balancer frontend IP config name.
func GenerateFrontendIPConfigName(lbName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s-%s", lbName, "frontEnd")
}</span>

// GenerateNatGatewayIPName generates a NAT gateway IP name.
func GenerateNatGatewayIPName(clusterName, subnetName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("pip-%s-%s-natgw", clusterName, subnetName)
}</span>

// GenerateNodeOutboundIPName generates a public IP name, based on the cluster name.
func GenerateNodeOutboundIPName(clusterName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("pip-%s-node-outbound", clusterName)
}</span>

// GenerateNodePublicIPName generates a node public IP name, based on the machine name.
func GenerateNodePublicIPName(machineName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("pip-%s", machineName)
}</span>

// GenerateControlPlaneOutboundLBName generates the name of the control plane outbound LB.
func GenerateControlPlaneOutboundLBName(clusterName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s-outbound-lb", clusterName)
}</span>

// GenerateControlPlaneOutboundIPName generates a public IP name, based on the cluster name.
func GenerateControlPlaneOutboundIPName(clusterName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("pip-%s-controlplane-outbound", clusterName)
}</span>

// GeneratePrivateDNSZoneName generates the name of a private DNS zone based on the cluster name.
func GeneratePrivateDNSZoneName(clusterName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s.capz.io", clusterName)
}</span>

// GeneratePrivateFQDN generates the FQDN for a private API Server based on the private DNS zone name.
func GeneratePrivateFQDN(zoneName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s.%s", PrivateAPIServerHostname, zoneName)
}</span>

// GenerateVNetLinkName generates the name of a virtual network link name based on the vnet name.
func GenerateVNetLinkName(vnetName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s-link", vnetName)
}</span>

// GenerateNICName generates the name of a network interface based on the name of a VM.
func GenerateNICName(machineName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s-nic", machineName)
}</span>

// GeneratePublicNICName generates the name of a public network interface based on the name of a VM.
func GeneratePublicNICName(machineName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s-public-nic", machineName)
}</span>

// GenerateOSDiskName generates the name of an OS disk based on the name of a VM.
func GenerateOSDiskName(machineName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s_OSDisk", machineName)
}</span>

// GenerateDataDiskName generates the name of a data disk based on the name of a VM.
func GenerateDataDiskName(machineName, nameSuffix string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s_%s", machineName, nameSuffix)
}</span>

// GenerateVnetPeeringName generates the name for a peering between two vnets.
func GenerateVnetPeeringName(sourceVnetName string, remoteVnetName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s-To-%s", sourceVnetName, remoteVnetName)
}</span>

// GenerateAvailabilitySetName generates the name of a availability set based on the cluster name and the node group.
// node group identifies the set of nodes that belong to this availability set:
// For control plane nodes, this will be `control-plane`.
// For worker nodes, this will be the machine deployment name.
func GenerateAvailabilitySetName(clusterName, nodeGroup string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s_%s-as", clusterName, nodeGroup)
}</span>

// WithIndex appends the index as suffix to a generated name.
func WithIndex(name string, n int) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s-%d", name, n)
}</span>

// ResourceGroupID returns the azure resource ID for a given resource group.
func ResourceGroupID(subscriptionID, resourceGroup string) string <span class="cov0" title="0">{
        return fmt.Sprintf("/subscriptions/%s/resourceGroups/%s", subscriptionID, resourceGroup)
}</span>

// VMID returns the azure resource ID for a given VM.
func VMID(subscriptionID, resourceGroup, vmName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("/subscriptions/%s/resourceGroups/%s/providers/Microsoft.Compute/virtualMachines/%s", subscriptionID, resourceGroup, vmName)
}</span>

// VNetID returns the azure resource ID for a given VNet.
func VNetID(subscriptionID, resourceGroup, vnetName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("/subscriptions/%s/resourceGroups/%s/providers/Microsoft.Network/virtualNetworks/%s", subscriptionID, resourceGroup, vnetName)
}</span>

// SubnetID returns the azure resource ID for a given subnet.
func SubnetID(subscriptionID, resourceGroup, vnetName, subnetName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("/subscriptions/%s/resourceGroups/%s/providers/Microsoft.Network/virtualNetworks/%s/subnets/%s", subscriptionID, resourceGroup, vnetName, subnetName)
}</span>

// PublicIPID returns the azure resource ID for a given public IP.
func PublicIPID(subscriptionID, resourceGroup, ipName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("/subscriptions/%s/resourceGroups/%s/providers/Microsoft.Network/publicIPAddresses/%s", subscriptionID, resourceGroup, ipName)
}</span>

// RouteTableID returns the azure resource ID for a given route table.
func RouteTableID(subscriptionID, resourceGroup, routeTableName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("/subscriptions/%s/resourceGroups/%s/providers/Microsoft.Network/routeTables/%s", subscriptionID, resourceGroup, routeTableName)
}</span>

// SecurityGroupID returns the azure resource ID for a given security group.
func SecurityGroupID(subscriptionID, resourceGroup, nsgName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("/subscriptions/%s/resourceGroups/%s/providers/Microsoft.Network/networkSecurityGroups/%s", subscriptionID, resourceGroup, nsgName)
}</span>

// NatGatewayID returns the azure resource ID for a given NAT gateway.
func NatGatewayID(subscriptionID, resourceGroup, natgatewayName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("/subscriptions/%s/resourceGroups/%s/providers/Microsoft.Network/natGateways/%s", subscriptionID, resourceGroup, natgatewayName)
}</span>

// NetworkInterfaceID returns the azure resource ID for a given network interface.
func NetworkInterfaceID(subscriptionID, resourceGroup, nicName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("/subscriptions/%s/resourceGroups/%s/providers/Microsoft.Network/networkInterfaces/%s", subscriptionID, resourceGroup, nicName)
}</span>

// FrontendIPConfigID returns the azure resource ID for a given frontend IP config.
func FrontendIPConfigID(subscriptionID, resourceGroup, loadBalancerName, configName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("/subscriptions/%s/resourceGroups/%s/providers/Microsoft.Network/loadBalancers/%s/frontendIPConfigurations/%s", subscriptionID, resourceGroup, loadBalancerName, configName)
}</span>

// AddressPoolID returns the azure resource ID for a given backend address pool.
func AddressPoolID(subscriptionID, resourceGroup, loadBalancerName, backendPoolName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("/subscriptions/%s/resourceGroups/%s/providers/Microsoft.Network/loadBalancers/%s/backendAddressPools/%s", subscriptionID, resourceGroup, loadBalancerName, backendPoolName)
}</span>

// ProbeID returns the azure resource ID for a given probe.
func ProbeID(subscriptionID, resourceGroup, loadBalancerName, probeName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("/subscriptions/%s/resourceGroups/%s/providers/Microsoft.Network/loadBalancers/%s/probes/%s", subscriptionID, resourceGroup, loadBalancerName, probeName)
}</span>

// NATRuleID returns the azure resource ID for a inbound NAT rule.
func NATRuleID(subscriptionID, resourceGroup, loadBalancerName, natRuleName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("/subscriptions/%s/resourceGroups/%s/providers/Microsoft.Network/loadBalancers/%s/inboundNatRules/%s", subscriptionID, resourceGroup, loadBalancerName, natRuleName)
}</span>

// AvailabilitySetID returns the azure resource ID for a given availability set.
func AvailabilitySetID(subscriptionID, resourceGroup, availabilitySetName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("/subscriptions/%s/resourceGroups/%s/providers/Microsoft.Compute/availabilitySets/%s", subscriptionID, resourceGroup, availabilitySetName)
}</span>

// GetBootstrappingVMExtension returns the CAPZ Bootstrapping VM extension.
// The CAPZ Bootstrapping extension is a simple clone of https://github.com/Azure/custom-script-extension-linux for Linux or
// https://docs.microsoft.com/en-us/azure/virtual-machines/extensions/custom-script-windows for Windows.
// This extension allows running arbitrary scripts on the VM.
// Its role is to detect and report Kubernetes bootstrap failure or success.
func GetBootstrappingVMExtension(osType string, cloud string, vmName string) *ExtensionSpec <span class="cov0" title="0">{
        // currently, the bootstrap extension is only available in AzurePublicCloud.
        if osType == LinuxOS &amp;&amp; cloud == azure.PublicCloud.Name </span><span class="cov0" title="0">{
                // The command checks for the existence of the bootstrapSentinelFile on the machine, with retries and sleep between retries.
                return &amp;ExtensionSpec{
                        Name:      "CAPZ.Linux.Bootstrapping",
                        VMName:    vmName,
                        Publisher: "Microsoft.Azure.ContainerUpstream",
                        Version:   "1.0",
                        ProtectedSettings: map[string]string{
                                "commandToExecute": LinuxBootstrapExtensionCommand,
                        },
                }
        }</span> else<span class="cov0" title="0"> if osType == WindowsOS &amp;&amp; cloud == azure.PublicCloud.Name </span><span class="cov0" title="0">{
                // This command for the existence of the bootstrapSentinelFile on the machine, with retries and sleep between reties.
                // If the file is not present after the retries are exhausted the extension fails with return code '-2' - ERROR_FILE_NOT_FOUND.
                return &amp;ExtensionSpec{
                        Name:      "CAPZ.Windows.Bootstrapping",
                        VMName:    vmName,
                        Publisher: "Microsoft.Azure.ContainerUpstream",
                        Version:   "1.0",
                        ProtectedSettings: map[string]string{
                                "commandToExecute": WindowsBootstrapExtensionCommand,
                        },
                }
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UserAgent specifies a string to append to the agent identifier.
func UserAgent() string <span class="cov0" title="0">{
        return fmt.Sprintf("cluster-api-provider-azure/%s", version.Get().String())
}</span>

// SetAutoRestClientDefaults set authorizer and user agent for autorest client.
func SetAutoRestClientDefaults(c *autorest.Client, auth autorest.Authorizer) <span class="cov0" title="0">{
        c.Authorizer = auth
        // Wrap the original Sender on the autorest.Client c.
        // The wrapped Sender should set the x-ms-correlation-request-id on the given
        // request, then pass the new request to the underlying Sender.
        c.Sender = autorest.DecorateSender(c.Sender, msCorrelationIDSendDecorator)
        // The default number of retries is 3. This means the client will attempt to retry operation results like resource
        // conflicts (HTTP 409). For a reconciling controller, this is undesirable behavior since if the controller runs
        // into an error reconciling, the controller would be better off to end with an error and try again later.
        //
        // Unfortunately, the naming of this field is a bit misleading. This is not actually "retry attempts", it actually
        // is attempts. Setting this to a value of 0 will cause a panic in Go AutoRest.
        c.RetryAttempts = 1
        AutoRestClientAppendUserAgent(c, UserAgent())
}</span>

// AutoRestClientAppendUserAgent autorest client calls "AddToUserAgent" but ignores errors.
func AutoRestClientAppendUserAgent(c *autorest.Client, extension string) <span class="cov8" title="1">{
        _ = c.AddToUserAgent(extension) // intentionally ignore error as it doesn't matter
}</span>

func msCorrelationIDSendDecorator(snd autorest.Sender) autorest.Sender <span class="cov8" title="1">{
        return autorest.SenderFunc(func(r *http.Request) (*http.Response, error) </span><span class="cov8" title="1">{
                // if the correlation ID was found in the request context, set
                // it in the header
                if corrID, ok := tele.CorrIDFromCtx(r.Context()); ok </span><span class="cov8" title="1">{
                        r.Header.Set(string(tele.CorrIDKeyVal), string(corrID))
                }</span>
                <span class="cov8" title="1">return snd.Do(r)</span>
        })
}
</pre>
		
		<pre class="file" id="file65" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package azure

import (
        "errors"
        "fmt"
        "time"

        "github.com/Azure/go-autorest/autorest"
        "github.com/Azure/go-autorest/autorest/azure"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
)

const codeResourceGroupNotFound = "ResourceGroupNotFound"

// ResourceGroupNotFound parses the error to check if it's a resource group not found error.
func ResourceGroupNotFound(err error) bool <span class="cov0" title="0">{
        derr := autorest.DetailedError{}
        serr := &amp;azure.ServiceError{}
        return errors.As(err, &amp;derr) &amp;&amp; errors.As(derr.Original, &amp;serr) &amp;&amp; serr.Code == codeResourceGroupNotFound
}</span>

// ResourceNotFound parses the error to check if it's a resource not found error.
func ResourceNotFound(err error) bool <span class="cov0" title="0">{
        derr := autorest.DetailedError{}
        return errors.As(err, &amp;derr) &amp;&amp; derr.StatusCode == 404
}</span>

// ResourceConflict parses the error to check if it's a resource conflict error (409).
func ResourceConflict(err error) bool <span class="cov0" title="0">{
        derr := autorest.DetailedError{}
        return errors.As(err, &amp;derr) &amp;&amp; derr.StatusCode == 409
}</span>

// VMDeletedError is returned when a virtual machine is deleted outside of capz.
type VMDeletedError struct {
        ProviderID string
}

// Error returns the error string.
func (vde VMDeletedError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("VM with provider id %q has been deleted", vde.ProviderID)
}</span>

// ReconcileError represents an error that is not automatically recoverable
// errorType indicates what type of action is required to recover. It can take two values:
// 1. `Transient` - Can be recovered through manual intervention, will be requeued after.
// 2. `Terminal` - Cannot be recovered, will not be requeued.
type ReconcileError struct {
        error
        errorType    ReconcileErrorType
        requestAfter time.Duration
}

// ReconcileErrorType represents the type of a ReconcileError.
type ReconcileErrorType string

const (
        // TransientErrorType can be recovered, will be requeued after a configured time interval.
        TransientErrorType ReconcileErrorType = "Transient"
        // TerminalErrorType cannot be recovered, will not be requeued.
        TerminalErrorType ReconcileErrorType = "Terminal"
)

// Error returns the error message for a ReconcileError.
func (t ReconcileError) Error() string <span class="cov0" title="0">{
        var errStr string
        if t.error != nil </span><span class="cov0" title="0">{
                errStr = t.error.Error()
        }</span>
        <span class="cov0" title="0">switch t.errorType </span>{
        case TransientErrorType:<span class="cov0" title="0">
                return fmt.Sprintf("%s. Object will be requeued after %s", errStr, t.requestAfter.String())</span>
        case TerminalErrorType:<span class="cov0" title="0">
                return fmt.Sprintf("reconcile error that cannot be recovered occurred: %s. Object will not be requeued", errStr)</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("reconcile error occurred with unknown recovery type. The actual error is: %s", errStr)</span>
        }
}

// IsTransient returns if the ReconcileError is recoverable.
func (t ReconcileError) IsTransient() bool <span class="cov0" title="0">{
        return t.errorType == TransientErrorType
}</span>

// IsTerminal returns if the ReconcileError is recoverable.
func (t ReconcileError) IsTerminal() bool <span class="cov0" title="0">{
        return t.errorType == TerminalErrorType
}</span>

// Is returns true if the target is a ReconcileError.
func (t ReconcileError) Is(target error) bool <span class="cov0" title="0">{
        return errors.As(target, &amp;ReconcileError{})
}</span>

// RequeueAfter returns requestAfter value.
func (t ReconcileError) RequeueAfter() time.Duration <span class="cov0" title="0">{
        return t.requestAfter
}</span>

// WithTransientError wraps the error in a ReconcileError with errorType as `Transient`.
func WithTransientError(err error, requeueAfter time.Duration) ReconcileError <span class="cov0" title="0">{
        return ReconcileError{error: err, errorType: TransientErrorType, requestAfter: requeueAfter}
}</span>

// WithTerminalError wraps the error in a ReconcileError with errorType as `Terminal`.
func WithTerminalError(err error) ReconcileError <span class="cov0" title="0">{
        return ReconcileError{error: err, errorType: TerminalErrorType}
}</span>

// OperationNotDoneError is used to represent a long-running operation that is not yet complete.
type OperationNotDoneError struct {
        Future *infrav1.Future
}

// NewOperationNotDoneError returns a new OperationNotDoneError wrapping a Future.
func NewOperationNotDoneError(future *infrav1.Future) OperationNotDoneError <span class="cov0" title="0">{
        return OperationNotDoneError{
                Future: future,
        }
}</span>

// Error returns the error represented as a string.
func (onde OperationNotDoneError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("operation type %s on Azure resource %s/%s is not done", onde.Future.Type, onde.Future.ResourceGroup, onde.Future.Name)
}</span>

// Is returns true if the target is an OperationNotDoneError.
func (onde OperationNotDoneError) Is(target error) bool <span class="cov0" title="0">{
        return IsOperationNotDoneError(target)
}</span>

// IsOperationNotDoneError returns true if the target is an OperationNotDoneError.
func IsOperationNotDoneError(target error) bool <span class="cov0" title="0">{
        reconcileErr := &amp;ReconcileError{}
        if errors.As(target, reconcileErr) </span><span class="cov0" title="0">{
                return IsOperationNotDoneError(reconcileErr.error)
        }</span>
        <span class="cov0" title="0">return errors.As(target, &amp;OperationNotDoneError{})</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package azure

import (
        "fmt"
        "net/url"
        "path"

        "github.com/pkg/errors"
)

type aliasAuth = Authorizer

// baseURIAdapter wraps an azure.Authorizer and adds a region to the BaseURI. This is useful if you need to make direct
// calls to a specific Azure region. One possible case is to avoid replication delay when listing resources within a
// resource group. For example, listing the VMSSes within a resource group.
type baseURIAdapter struct {
        aliasAuth
        Region    string
        parsedURL *url.URL
}

// WithRegionalBaseURI returns an authorizer that has a regional base URI, like `https://{region}.management.azure.com`.
func WithRegionalBaseURI(authorizer Authorizer, region string) (Authorizer, error) <span class="cov8" title="1">{
        parsedURI, err := url.Parse(authorizer.BaseURI())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to parse the base URI of client")
        }</span>

        <span class="cov8" title="1">return &amp;baseURIAdapter{
                aliasAuth: authorizer,
                Region:    region,
                parsedURL: parsedURI,
        }, nil</span>
}

// BaseURI return a regional base URI, like `https://{region}.management.azure.com`.
func (a *baseURIAdapter) BaseURI() string <span class="cov8" title="1">{
        if a == nil || a.parsedURL == nil || a.Region == "" </span><span class="cov8" title="1">{
                return a.aliasAuth.BaseURI()
        }</span>

        <span class="cov8" title="1">sansScheme := path.Join(fmt.Sprintf("%s.%s", a.Region, a.parsedURL.Host), a.parsedURL.Path)
        return fmt.Sprintf("%s://%s", a.parsedURL.Scheme, sansScheme)</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">/*
Copyright 2018 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package scope

import (
        "context"
        "crypto/sha256"
        "encoding/base64"
        "fmt"
        "os"
        "strings"

        "github.com/Azure/go-autorest/autorest"
        "github.com/Azure/go-autorest/autorest/azure"
        "github.com/Azure/go-autorest/autorest/azure/auth"
)

// AzureClients contains all the Azure clients used by the scopes.
type AzureClients struct {
        auth.EnvironmentSettings

        Authorizer                 autorest.Authorizer
        ResourceManagerEndpoint    string
        ResourceManagerVMDNSSuffix string
}

// CloudEnvironment returns the Azure environment the controller runs in.
func (c *AzureClients) CloudEnvironment() string <span class="cov8" title="1">{
        return c.Environment.Name
}</span>

// TenantID returns the Azure tenant id the controller runs in.
func (c *AzureClients) TenantID() string <span class="cov0" title="0">{
        return c.Values[auth.TenantID]
}</span>

// ClientID returns the Azure client id from the controller environment.
func (c *AzureClients) ClientID() string <span class="cov0" title="0">{
        return c.Values[auth.ClientID]
}</span>

// ClientSecret returns the Azure client secret from the controller environment.
func (c *AzureClients) ClientSecret() string <span class="cov0" title="0">{
        return c.Values[auth.ClientSecret]
}</span>

// SubscriptionID returns the Azure subscription id of the cluster,
// either specified or from the environment.
func (c *AzureClients) SubscriptionID() string <span class="cov8" title="1">{
        return c.Values[auth.SubscriptionID]
}</span>

// HashKey returns a base64 url encoded sha256 hash for the Auth scope (Azure TenantID + CloudEnv + SubscriptionID +
// ClientID).
func (c *AzureClients) HashKey() string <span class="cov0" title="0">{
        hasher := sha256.New()
        _, _ = hasher.Write([]byte(c.TenantID() + c.CloudEnvironment() + c.SubscriptionID() + c.ClientID()))
        return base64.URLEncoding.EncodeToString(hasher.Sum(nil))
}</span>

func (c *AzureClients) setCredentials(subscriptionID, environmentName string) error <span class="cov8" title="1">{
        settings, err := c.getSettingsFromEnvironment(environmentName)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if subscriptionID == "" </span><span class="cov0" title="0">{
                subscriptionID = settings.GetSubscriptionID()
                if subscriptionID == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("error creating azure services. subscriptionID is not set in cluster or AZURE_SUBSCRIPTION_ID env var")
                }</span>
        }

        <span class="cov8" title="1">c.EnvironmentSettings = settings
        c.ResourceManagerEndpoint = settings.Environment.ResourceManagerEndpoint
        c.ResourceManagerVMDNSSuffix = settings.Environment.ResourceManagerVMDNSSuffix
        c.Values[auth.ClientID] = strings.TrimSuffix(c.Values[auth.ClientID], "\n")
        c.Values[auth.ClientSecret] = strings.TrimSuffix(c.Values[auth.ClientSecret], "\n")
        c.Values[auth.SubscriptionID] = strings.TrimSuffix(subscriptionID, "\n")
        c.Values[auth.TenantID] = strings.TrimSuffix(c.Values[auth.TenantID], "\n")

        if c.Authorizer == nil </span><span class="cov0" title="0">{
                c.Authorizer, err = c.GetAuthorizer()
        }</span>
        <span class="cov8" title="1">return err</span>
}

func (c *AzureClients) setCredentialsWithProvider(ctx context.Context, subscriptionID, environmentName string, credentialsProvider CredentialsProvider) error <span class="cov0" title="0">{
        if credentialsProvider == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("credentials provider cannot have an empty value")
        }</span>

        <span class="cov0" title="0">settings, err := c.getSettingsFromEnvironment(environmentName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if subscriptionID == "" </span><span class="cov0" title="0">{
                subscriptionID = settings.GetSubscriptionID()
                if subscriptionID == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("error creating azure services. subscriptionID is not set in cluster or AZURE_SUBSCRIPTION_ID env var")
                }</span>
        }

        <span class="cov0" title="0">c.EnvironmentSettings = settings
        c.ResourceManagerEndpoint = settings.Environment.ResourceManagerEndpoint
        c.ResourceManagerVMDNSSuffix = settings.Environment.ResourceManagerVMDNSSuffix
        c.Values[auth.SubscriptionID] = strings.TrimSuffix(subscriptionID, "\n")
        c.Values[auth.TenantID] = strings.TrimSuffix(credentialsProvider.GetTenantID(), "\n")
        c.Values[auth.ClientID] = strings.TrimSuffix(credentialsProvider.GetClientID(), "\n")

        clientSecret, err := credentialsProvider.GetClientSecret(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">c.Values[auth.ClientSecret] = strings.TrimSuffix(clientSecret, "\n")

        c.Authorizer, err = credentialsProvider.GetAuthorizer(ctx, c.ResourceManagerEndpoint, c.Environment.ActiveDirectoryEndpoint)
        return err</span>
}

func (c *AzureClients) getSettingsFromEnvironment(environmentName string) (s auth.EnvironmentSettings, err error) <span class="cov8" title="1">{
        s = auth.EnvironmentSettings{
                Values: map[string]string{},
        }
        s.Values[auth.EnvironmentName] = environmentName
        setValue(s, auth.SubscriptionID)
        setValue(s, auth.TenantID)
        setValue(s, auth.AuxiliaryTenantIDs)
        setValue(s, auth.ClientID)
        setValue(s, auth.ClientSecret)
        setValue(s, auth.CertificatePath)
        setValue(s, auth.CertificatePassword)
        setValue(s, auth.Username)
        setValue(s, auth.Password)
        setValue(s, auth.Resource)
        if v := s.Values[auth.EnvironmentName]; v == "" </span><span class="cov8" title="1">{
                s.Environment = azure.PublicCloud
        }</span> else<span class="cov8" title="1"> {
                s.Environment, err = azure.EnvironmentFromName(v)
        }</span>
        <span class="cov8" title="1">if s.Values[auth.Resource] == "" </span><span class="cov8" title="1">{
                s.Values[auth.Resource] = s.Environment.ResourceManagerEndpoint
        }</span>
        <span class="cov8" title="1">return</span>
}

// setValue adds the specified environment variable value to the Values map if it exists.
func setValue(settings auth.EnvironmentSettings, key string) <span class="cov8" title="1">{
        if v := os.Getenv(key); v != "" </span><span class="cov0" title="0">{
                settings.Values[key] = v
        }</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">/*
Copyright 2018 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package scope

import (
        "context"
        "encoding/json"
        "fmt"
        "hash/fnv"
        "sort"
        "strconv"
        "strings"

        "github.com/Azure/go-autorest/autorest"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        "k8s.io/utils/net"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/bastionhosts"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/groups"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/loadbalancers"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/natgateways"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/privatedns"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/publicips"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/routetables"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/securitygroups"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/subnets"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/virtualnetworks"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/vnetpeerings"
        "sigs.k8s.io/cluster-api-provider-azure/util/futures"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        "sigs.k8s.io/cluster-api/util/conditions"
        "sigs.k8s.io/cluster-api/util/patch"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// ClusterScopeParams defines the input parameters used to create a new Scope.
type ClusterScopeParams struct {
        AzureClients
        Client       client.Client
        Cluster      *clusterv1.Cluster
        AzureCluster *infrav1.AzureCluster
        Cache        *ClusterCache
}

// NewClusterScope creates a new Scope from the supplied parameters.
// This is meant to be called for each reconcile iteration.
func NewClusterScope(ctx context.Context, params ClusterScopeParams) (*ClusterScope, error) <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "azure.clusterScope.NewClusterScope")
        defer done()

        if params.Cluster == nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to generate new scope from nil Cluster")
        }</span>
        <span class="cov8" title="1">if params.AzureCluster == nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to generate new scope from nil AzureCluster")
        }</span>

        <span class="cov8" title="1">if params.AzureCluster.Spec.IdentityRef == nil </span><span class="cov8" title="1">{
                err := params.AzureClients.setCredentials(params.AzureCluster.Spec.SubscriptionID, params.AzureCluster.Spec.AzureEnvironment)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to configure azure settings and credentials from environment")
                }</span>
        } else<span class="cov0" title="0"> {
                credentialsProvider, err := NewAzureClusterCredentialsProvider(ctx, params.Client, params.AzureCluster)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to init credentials provider")
                }</span>
                <span class="cov0" title="0">err = params.AzureClients.setCredentialsWithProvider(ctx, params.AzureCluster.Spec.SubscriptionID, params.AzureCluster.Spec.AzureEnvironment, credentialsProvider)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to configure azure settings and credentials for Identity")
                }</span>
        }

        <span class="cov8" title="1">if params.Cache == nil </span><span class="cov8" title="1">{
                params.Cache = &amp;ClusterCache{}
        }</span>

        <span class="cov8" title="1">helper, err := patch.NewHelper(params.AzureCluster, params.Client)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Errorf("failed to init patch helper: %v", err)
        }</span>

        <span class="cov8" title="1">return &amp;ClusterScope{
                Client:       params.Client,
                AzureClients: params.AzureClients,
                Cluster:      params.Cluster,
                AzureCluster: params.AzureCluster,
                patchHelper:  helper,
                cache:        params.Cache,
        }, nil</span>
}

// ClusterScope defines the basic context for an actuator to operate upon.
type ClusterScope struct {
        Client      client.Client
        patchHelper *patch.Helper
        cache       *ClusterCache

        AzureClients
        Cluster      *clusterv1.Cluster
        AzureCluster *infrav1.AzureCluster
}

// ClusterCache stores ClusterCache data locally so we don't have to hit the API multiple times within the same reconcile loop.
type ClusterCache struct {
        isVnetManaged *bool
}

// BaseURI returns the Azure ResourceManagerEndpoint.
func (s *ClusterScope) BaseURI() string <span class="cov0" title="0">{
        return s.ResourceManagerEndpoint
}</span>

// Authorizer returns the Azure client Authorizer.
func (s *ClusterScope) Authorizer() autorest.Authorizer <span class="cov0" title="0">{
        return s.AzureClients.Authorizer
}</span>

// PublicIPSpecs returns the public IP specs.
func (s *ClusterScope) PublicIPSpecs() []azure.ResourceSpecGetter <span class="cov8" title="1">{
        var publicIPSpecs []azure.ResourceSpecGetter

        // Public IP specs for control plane lb
        var controlPlaneOutboundIPSpecs []azure.ResourceSpecGetter
        if s.IsAPIServerPrivate() </span><span class="cov8" title="1">{
                // Public IP specs for control plane outbound lb
                if s.ControlPlaneOutboundLB() != nil </span><span class="cov8" title="1">{
                        for _, ip := range s.ControlPlaneOutboundLB().FrontendIPs </span><span class="cov8" title="1">{
                                controlPlaneOutboundIPSpecs = append(controlPlaneOutboundIPSpecs, &amp;publicips.PublicIPSpec{
                                        Name:           ip.PublicIP.Name,
                                        ResourceGroup:  s.ResourceGroup(),
                                        ClusterName:    s.ClusterName(),
                                        DNSName:        "",    // Set to default value
                                        IsIPv6:         false, // Set to default value
                                        Location:       s.Location(),
                                        FailureDomains: s.FailureDomains(),
                                        AdditionalTags: s.AdditionalTags(),
                                })
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                controlPlaneOutboundIPSpecs = []azure.ResourceSpecGetter{
                        &amp;publicips.PublicIPSpec{
                                Name:           s.APIServerPublicIP().Name,
                                ResourceGroup:  s.ResourceGroup(),
                                DNSName:        s.APIServerPublicIP().DNSName,
                                IsIPv6:         false, // Currently azure requires an IPv4 lb rule to enable IPv6
                                ClusterName:    s.ClusterName(),
                                Location:       s.Location(),
                                FailureDomains: s.FailureDomains(),
                                AdditionalTags: s.AdditionalTags(),
                                IPTags:         s.APIServerPublicIP().IPTags,
                        },
                }
        }</span>
        <span class="cov8" title="1">publicIPSpecs = append(publicIPSpecs, controlPlaneOutboundIPSpecs...)

        // Public IP specs for node outbound lb
        if s.NodeOutboundLB() != nil </span><span class="cov8" title="1">{
                for _, ip := range s.NodeOutboundLB().FrontendIPs </span><span class="cov0" title="0">{
                        publicIPSpecs = append(publicIPSpecs, &amp;publicips.PublicIPSpec{
                                Name:           ip.PublicIP.Name,
                                ResourceGroup:  s.ResourceGroup(),
                                ClusterName:    s.ClusterName(),
                                DNSName:        "",    // Set to default value
                                IsIPv6:         false, // Set to default value
                                Location:       s.Location(),
                                FailureDomains: s.FailureDomains(),
                                AdditionalTags: s.AdditionalTags(),
                        })
                }</span>
        }

        // Public IP specs for node NAT gateways
        <span class="cov8" title="1">var nodeNatGatewayIPSpecs []azure.ResourceSpecGetter
        for _, subnet := range s.NodeSubnets() </span><span class="cov8" title="1">{
                if subnet.IsNatGatewayEnabled() </span><span class="cov0" title="0">{
                        nodeNatGatewayIPSpecs = append(nodeNatGatewayIPSpecs, &amp;publicips.PublicIPSpec{
                                Name:           subnet.NatGateway.NatGatewayIP.Name,
                                ResourceGroup:  s.ResourceGroup(),
                                DNSName:        subnet.NatGateway.NatGatewayIP.DNSName,
                                IsIPv6:         false, // Public IP is IPv4 by default
                                ClusterName:    s.ClusterName(),
                                Location:       s.Location(),
                                FailureDomains: s.FailureDomains(),
                                AdditionalTags: s.AdditionalTags(),
                                IPTags:         subnet.NatGateway.NatGatewayIP.IPTags,
                        })
                }</span>
                <span class="cov8" title="1">publicIPSpecs = append(publicIPSpecs, nodeNatGatewayIPSpecs...)</span>
        }

        <span class="cov8" title="1">if azureBastion := s.AzureBastion(); azureBastion != nil </span><span class="cov8" title="1">{
                // public IP for Azure Bastion.
                azureBastionPublicIP := &amp;publicips.PublicIPSpec{
                        Name:           azureBastion.PublicIP.Name,
                        ResourceGroup:  s.ResourceGroup(),
                        DNSName:        azureBastion.PublicIP.DNSName,
                        IsIPv6:         false, // Public IP is IPv4 by default
                        ClusterName:    s.ClusterName(),
                        Location:       s.Location(),
                        FailureDomains: s.FailureDomains(),
                        AdditionalTags: s.AdditionalTags(),
                        IPTags:         azureBastion.PublicIP.IPTags,
                }
                publicIPSpecs = append(publicIPSpecs, azureBastionPublicIP)
        }</span>

        <span class="cov8" title="1">return publicIPSpecs</span>
}

// LBSpecs returns the load balancer specs.
func (s *ClusterScope) LBSpecs() []azure.ResourceSpecGetter <span class="cov0" title="0">{
        specs := []azure.ResourceSpecGetter{
                &amp;loadbalancers.LBSpec{
                        // API Server LB
                        Name:                 s.APIServerLB().Name,
                        ResourceGroup:        s.ResourceGroup(),
                        SubscriptionID:       s.SubscriptionID(),
                        ClusterName:          s.ClusterName(),
                        Location:             s.Location(),
                        VNetName:             s.Vnet().Name,
                        VNetResourceGroup:    s.Vnet().ResourceGroup,
                        SubnetName:           s.ControlPlaneSubnet().Name,
                        FrontendIPConfigs:    s.APIServerLB().FrontendIPs,
                        APIServerPort:        s.APIServerPort(),
                        Type:                 s.APIServerLB().Type,
                        SKU:                  infrav1.SKUStandard,
                        Role:                 infrav1.APIServerRole,
                        BackendPoolName:      s.APIServerLBPoolName(s.APIServerLB().Name),
                        IdleTimeoutInMinutes: s.APIServerLB().IdleTimeoutInMinutes,
                        AdditionalTags:       s.AdditionalTags(),
                },
        }

        // Node outbound LB
        if s.NodeOutboundLB() != nil </span><span class="cov0" title="0">{
                specs = append(specs, &amp;loadbalancers.LBSpec{
                        Name:                 s.NodeOutboundLB().Name,
                        ResourceGroup:        s.ResourceGroup(),
                        SubscriptionID:       s.SubscriptionID(),
                        ClusterName:          s.ClusterName(),
                        Location:             s.Location(),
                        VNetName:             s.Vnet().Name,
                        VNetResourceGroup:    s.Vnet().ResourceGroup,
                        FrontendIPConfigs:    s.NodeOutboundLB().FrontendIPs,
                        Type:                 s.NodeOutboundLB().Type,
                        SKU:                  s.NodeOutboundLB().SKU,
                        BackendPoolName:      s.OutboundPoolName(s.NodeOutboundLB().Name),
                        IdleTimeoutInMinutes: s.NodeOutboundLB().IdleTimeoutInMinutes,
                        Role:                 infrav1.NodeOutboundRole,
                        AdditionalTags:       s.AdditionalTags(),
                })
        }</span>

        // Control Plane Outbound LB
        <span class="cov0" title="0">if s.ControlPlaneOutboundLB() != nil </span><span class="cov0" title="0">{
                specs = append(specs, &amp;loadbalancers.LBSpec{
                        Name:                 s.ControlPlaneOutboundLB().Name,
                        ResourceGroup:        s.ResourceGroup(),
                        SubscriptionID:       s.SubscriptionID(),
                        ClusterName:          s.ClusterName(),
                        Location:             s.Location(),
                        VNetName:             s.Vnet().Name,
                        VNetResourceGroup:    s.Vnet().ResourceGroup,
                        FrontendIPConfigs:    s.ControlPlaneOutboundLB().FrontendIPs,
                        Type:                 s.ControlPlaneOutboundLB().Type,
                        SKU:                  s.ControlPlaneOutboundLB().SKU,
                        BackendPoolName:      s.OutboundPoolName(azure.GenerateControlPlaneOutboundLBName(s.ClusterName())),
                        IdleTimeoutInMinutes: s.NodeOutboundLB().IdleTimeoutInMinutes,
                        Role:                 infrav1.ControlPlaneOutboundRole,
                        AdditionalTags:       s.AdditionalTags(),
                })
        }</span>

        <span class="cov0" title="0">return specs</span>
}

// RouteTableSpecs returns the subnet route tables.
func (s *ClusterScope) RouteTableSpecs() []azure.ResourceSpecGetter <span class="cov8" title="1">{
        var specs []azure.ResourceSpecGetter
        for _, subnet := range s.AzureCluster.Spec.NetworkSpec.Subnets </span><span class="cov8" title="1">{
                if subnet.RouteTable.Name != "" </span><span class="cov8" title="1">{
                        specs = append(specs, &amp;routetables.RouteTableSpec{
                                Name:           subnet.RouteTable.Name,
                                Location:       s.Location(),
                                ResourceGroup:  s.ResourceGroup(),
                                ClusterName:    s.ClusterName(),
                                AdditionalTags: s.AdditionalTags(),
                        })
                }</span>
        }

        <span class="cov8" title="1">return specs</span>
}

// NatGatewaySpecs returns the node NAT gateway.
func (s *ClusterScope) NatGatewaySpecs() []azure.ResourceSpecGetter <span class="cov8" title="1">{
        natGatewaySet := make(map[string]struct{})
        var natGateways []azure.ResourceSpecGetter

        // We ignore the control plane NAT gateway, as we will always use a LB to enable egress on the control plane.
        for _, subnet := range s.NodeSubnets() </span><span class="cov8" title="1">{
                if subnet.IsNatGatewayEnabled() </span><span class="cov8" title="1">{
                        if _, ok := natGatewaySet[subnet.NatGateway.Name]; !ok </span><span class="cov8" title="1">{
                                natGatewaySet[subnet.NatGateway.Name] = struct{}{} // empty struct to represent hash set
                                natGateways = append(natGateways, &amp;natgateways.NatGatewaySpec{
                                        Name:           subnet.NatGateway.Name,
                                        ResourceGroup:  s.ResourceGroup(),
                                        SubscriptionID: s.SubscriptionID(),
                                        Location:       s.Location(),
                                        ClusterName:    s.ClusterName(),
                                        NatGatewayIP: infrav1.PublicIPSpec{
                                                Name: subnet.NatGateway.NatGatewayIP.Name,
                                        },
                                        AdditionalTags: s.AdditionalTags(),
                                })
                        }</span>
                }
        }

        <span class="cov8" title="1">return natGateways</span>
}

// NSGSpecs returns the security group specs.
func (s *ClusterScope) NSGSpecs() []azure.ResourceSpecGetter <span class="cov8" title="1">{
        nsgspecs := make([]azure.ResourceSpecGetter, len(s.AzureCluster.Spec.NetworkSpec.Subnets))
        for i, subnet := range s.AzureCluster.Spec.NetworkSpec.Subnets </span><span class="cov8" title="1">{
                nsgspecs[i] = &amp;securitygroups.NSGSpec{
                        Name:           subnet.SecurityGroup.Name,
                        SecurityRules:  subnet.SecurityGroup.SecurityRules,
                        ResourceGroup:  s.ResourceGroup(),
                        Location:       s.Location(),
                        ClusterName:    s.ClusterName(),
                        AdditionalTags: s.AdditionalTags(),
                }
        }</span>

        <span class="cov8" title="1">return nsgspecs</span>
}

// SubnetSpecs returns the subnets specs.
func (s *ClusterScope) SubnetSpecs() []azure.ResourceSpecGetter <span class="cov8" title="1">{
        numberOfSubnets := len(s.AzureCluster.Spec.NetworkSpec.Subnets)
        if s.IsAzureBastionEnabled() </span><span class="cov8" title="1">{
                numberOfSubnets++
        }</span>

        <span class="cov8" title="1">subnetSpecs := make([]azure.ResourceSpecGetter, 0, numberOfSubnets)

        for _, subnet := range s.AzureCluster.Spec.NetworkSpec.Subnets </span><span class="cov8" title="1">{
                subnetSpec := &amp;subnets.SubnetSpec{
                        Name:              subnet.Name,
                        ResourceGroup:     s.ResourceGroup(),
                        SubscriptionID:    s.SubscriptionID(),
                        CIDRs:             subnet.CIDRBlocks,
                        VNetName:          s.Vnet().Name,
                        VNetResourceGroup: s.Vnet().ResourceGroup,
                        IsVNetManaged:     s.IsVnetManaged(),
                        RouteTableName:    subnet.RouteTable.Name,
                        SecurityGroupName: subnet.SecurityGroup.Name,
                        Role:              subnet.Role,
                        NatGatewayName:    subnet.NatGateway.Name,
                }
                subnetSpecs = append(subnetSpecs, subnetSpec)
        }</span>

        <span class="cov8" title="1">if s.IsAzureBastionEnabled() </span><span class="cov8" title="1">{
                azureBastionSubnet := s.AzureCluster.Spec.BastionSpec.AzureBastion.Subnet
                subnetSpecs = append(subnetSpecs, &amp;subnets.SubnetSpec{
                        Name:              azureBastionSubnet.Name,
                        ResourceGroup:     s.ResourceGroup(),
                        SubscriptionID:    s.SubscriptionID(),
                        CIDRs:             azureBastionSubnet.CIDRBlocks,
                        VNetName:          s.Vnet().Name,
                        VNetResourceGroup: s.Vnet().ResourceGroup,
                        IsVNetManaged:     s.IsVnetManaged(),
                        SecurityGroupName: azureBastionSubnet.SecurityGroup.Name,
                        RouteTableName:    azureBastionSubnet.RouteTable.Name,
                        Role:              azureBastionSubnet.Role,
                })
        }</span>

        <span class="cov8" title="1">return subnetSpecs</span>
}

// GroupSpec returns the resource group spec.
func (s *ClusterScope) GroupSpec() azure.ResourceSpecGetter <span class="cov0" title="0">{
        return &amp;groups.GroupSpec{
                Name:           s.ResourceGroup(),
                Location:       s.Location(),
                ClusterName:    s.ClusterName(),
                AdditionalTags: s.AdditionalTags(),
        }
}</span>

// VnetPeeringSpecs returns the virtual network peering specs.
func (s *ClusterScope) VnetPeeringSpecs() []azure.ResourceSpecGetter <span class="cov0" title="0">{
        peeringSpecs := make([]azure.ResourceSpecGetter, 2*len(s.Vnet().Peerings))
        for i, peering := range s.Vnet().Peerings </span><span class="cov0" title="0">{
                forwardPeering := &amp;vnetpeerings.VnetPeeringSpec{
                        PeeringName:         azure.GenerateVnetPeeringName(s.Vnet().Name, peering.RemoteVnetName),
                        SourceVnetName:      s.Vnet().Name,
                        SourceResourceGroup: s.Vnet().ResourceGroup,
                        RemoteVnetName:      peering.RemoteVnetName,
                        RemoteResourceGroup: peering.ResourceGroup,
                        SubscriptionID:      s.SubscriptionID(),
                }
                reversePeering := &amp;vnetpeerings.VnetPeeringSpec{
                        PeeringName:         azure.GenerateVnetPeeringName(peering.RemoteVnetName, s.Vnet().Name),
                        SourceVnetName:      peering.RemoteVnetName,
                        SourceResourceGroup: peering.ResourceGroup,
                        RemoteVnetName:      s.Vnet().Name,
                        RemoteResourceGroup: s.Vnet().ResourceGroup,
                        SubscriptionID:      s.SubscriptionID(),
                }
                peeringSpecs[i*2] = forwardPeering
                peeringSpecs[i*2+1] = reversePeering
        }</span>

        <span class="cov0" title="0">return peeringSpecs</span>
}

// VNetSpec returns the virtual network spec.
func (s *ClusterScope) VNetSpec() azure.ResourceSpecGetter <span class="cov0" title="0">{
        return &amp;virtualnetworks.VNetSpec{
                ResourceGroup:  s.Vnet().ResourceGroup,
                Name:           s.Vnet().Name,
                CIDRs:          s.Vnet().CIDRBlocks,
                Location:       s.Location(),
                ClusterName:    s.ClusterName(),
                AdditionalTags: s.AdditionalTags(),
        }
}</span>

// PrivateDNSSpec returns the private dns zone spec.
func (s *ClusterScope) PrivateDNSSpec() (zoneSpec azure.ResourceSpecGetter, linkSpec, recordSpec []azure.ResourceSpecGetter) <span class="cov0" title="0">{
        if s.IsAPIServerPrivate() </span><span class="cov0" title="0">{
                zone := privatedns.ZoneSpec{
                        Name:           s.GetPrivateDNSZoneName(),
                        ResourceGroup:  s.ResourceGroup(),
                        ClusterName:    s.ClusterName(),
                        AdditionalTags: s.AdditionalTags(),
                }

                links := make([]azure.ResourceSpecGetter, 1+len(s.Vnet().Peerings))
                links[0] = privatedns.LinkSpec{
                        Name:              azure.GenerateVNetLinkName(s.Vnet().Name),
                        ZoneName:          s.GetPrivateDNSZoneName(),
                        SubscriptionID:    s.SubscriptionID(),
                        VNetResourceGroup: s.Vnet().ResourceGroup,
                        VNetName:          s.Vnet().Name,
                        ResourceGroup:     s.ResourceGroup(),
                        ClusterName:       s.ClusterName(),
                        AdditionalTags:    s.AdditionalTags(),
                }
                for i, peering := range s.Vnet().Peerings </span><span class="cov0" title="0">{
                        links[i+1] = privatedns.LinkSpec{
                                Name:              azure.GenerateVNetLinkName(peering.RemoteVnetName),
                                ZoneName:          s.GetPrivateDNSZoneName(),
                                SubscriptionID:    s.SubscriptionID(),
                                VNetResourceGroup: peering.ResourceGroup,
                                VNetName:          peering.RemoteVnetName,
                                ResourceGroup:     s.ResourceGroup(),
                                ClusterName:       s.ClusterName(),
                                AdditionalTags:    s.AdditionalTags(),
                        }
                }</span>

                <span class="cov0" title="0">records := make([]azure.ResourceSpecGetter, 1)
                records[0] = privatedns.RecordSpec{
                        Record: infrav1.AddressRecord{
                                Hostname: azure.PrivateAPIServerHostname,
                                IP:       s.APIServerPrivateIP(),
                        },
                        ZoneName:      s.GetPrivateDNSZoneName(),
                        ResourceGroup: s.ResourceGroup(),
                }

                return zone, links, records</span>
        }

        <span class="cov0" title="0">return nil, nil, nil</span>
}

// IsAzureBastionEnabled returns true if the azure bastion is enabled.
func (s *ClusterScope) IsAzureBastionEnabled() bool <span class="cov8" title="1">{
        return s.AzureCluster.Spec.BastionSpec.AzureBastion != nil
}</span>

// AzureBastion returns the cluster AzureBastion.
func (s *ClusterScope) AzureBastion() *infrav1.AzureBastion <span class="cov8" title="1">{
        return s.AzureCluster.Spec.BastionSpec.AzureBastion
}</span>

// AzureBastionSpec returns the bastion spec.
func (s *ClusterScope) AzureBastionSpec() azure.ResourceSpecGetter <span class="cov8" title="1">{
        if s.IsAzureBastionEnabled() </span><span class="cov8" title="1">{
                subnetID := azure.SubnetID(s.SubscriptionID(), s.ResourceGroup(), s.Vnet().Name, s.AzureBastion().Subnet.Name)
                publicIPID := azure.PublicIPID(s.SubscriptionID(), s.ResourceGroup(), s.AzureBastion().PublicIP.Name)

                return &amp;bastionhosts.AzureBastionSpec{
                        Name:          s.AzureBastion().Name,
                        ResourceGroup: s.ResourceGroup(),
                        Location:      s.Location(),
                        ClusterName:   s.ClusterName(),
                        SubnetID:      subnetID,
                        PublicIPID:    publicIPID,
                }
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Vnet returns the cluster Vnet.
func (s *ClusterScope) Vnet() *infrav1.VnetSpec <span class="cov8" title="1">{
        return &amp;s.AzureCluster.Spec.NetworkSpec.Vnet
}</span>

// IsVnetManaged returns true if the vnet is managed.
func (s *ClusterScope) IsVnetManaged() bool <span class="cov8" title="1">{
        if s.cache.isVnetManaged != nil </span><span class="cov8" title="1">{
                return to.Bool(s.cache.isVnetManaged)
        }</span>
        <span class="cov8" title="1">isVnetManaged := s.Vnet().ID == "" || s.Vnet().Tags.HasOwned(s.ClusterName())
        s.cache.isVnetManaged = to.BoolPtr(isVnetManaged)
        return isVnetManaged</span>
}

// IsIPv6Enabled returns true if IPv6 is enabled.
func (s *ClusterScope) IsIPv6Enabled() bool <span class="cov8" title="1">{
        for _, cidr := range s.AzureCluster.Spec.NetworkSpec.Vnet.CIDRBlocks </span><span class="cov0" title="0">{
                if net.IsIPv6CIDRString(cidr) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Subnets returns the cluster subnets.
func (s *ClusterScope) Subnets() infrav1.Subnets <span class="cov8" title="1">{
        return s.AzureCluster.Spec.NetworkSpec.Subnets
}</span>

// ControlPlaneSubnet returns the cluster control plane subnet.
func (s *ClusterScope) ControlPlaneSubnet() infrav1.SubnetSpec <span class="cov8" title="1">{
        subnet, _ := s.AzureCluster.Spec.NetworkSpec.GetControlPlaneSubnet()
        return subnet
}</span>

// NodeSubnets returns the subnets with the node role.
func (s *ClusterScope) NodeSubnets() []infrav1.SubnetSpec <span class="cov8" title="1">{
        subnets := []infrav1.SubnetSpec{}
        for _, subnet := range s.AzureCluster.Spec.NetworkSpec.Subnets </span><span class="cov8" title="1">{
                if subnet.Role == infrav1.SubnetNode </span><span class="cov8" title="1">{
                        subnets = append(subnets, subnet)
                }</span>
        }

        <span class="cov8" title="1">return subnets</span>
}

// Subnet returns the subnet with the provided name.
func (s *ClusterScope) Subnet(name string) infrav1.SubnetSpec <span class="cov8" title="1">{
        for _, sn := range s.AzureCluster.Spec.NetworkSpec.Subnets </span><span class="cov8" title="1">{
                if sn.Name == name </span><span class="cov8" title="1">{
                        return sn
                }</span>
        }

        <span class="cov8" title="1">return infrav1.SubnetSpec{}</span>
}

// SetSubnet sets the subnet spec for the subnet with the same name.
func (s *ClusterScope) SetSubnet(subnetSpec infrav1.SubnetSpec) <span class="cov0" title="0">{
        for i, sn := range s.AzureCluster.Spec.NetworkSpec.Subnets </span><span class="cov0" title="0">{
                if sn.Name == subnetSpec.Name </span><span class="cov0" title="0">{
                        s.AzureCluster.Spec.NetworkSpec.Subnets[i] = subnetSpec
                        return
                }</span>
        }
}

// SetNatGatewayIDInSubnets sets the NAT Gateway ID in the subnets with the same name.
func (s *ClusterScope) SetNatGatewayIDInSubnets(name string, id string) <span class="cov0" title="0">{
        for _, subnet := range s.Subnets() </span><span class="cov0" title="0">{
                if subnet.NatGateway.Name == name </span><span class="cov0" title="0">{
                        subnet.NatGateway.ID = id
                        s.SetSubnet(subnet)
                }</span>
        }
}

// UpdateSubnetCIDRs updates the subnet CIDRs for the subnet with the same name.
func (s *ClusterScope) UpdateSubnetCIDRs(name string, cidrBlocks []string) <span class="cov0" title="0">{
        subnetSpecInfra := s.Subnet(name)
        subnetSpecInfra.CIDRBlocks = cidrBlocks
        s.SetSubnet(subnetSpecInfra)
}</span>

// UpdateSubnetID updates the subnet ID for the subnet with the same name.
func (s *ClusterScope) UpdateSubnetID(name string, id string) <span class="cov0" title="0">{
        subnetSpecInfra := s.Subnet(name)
        subnetSpecInfra.ID = id
        s.SetSubnet(subnetSpecInfra)
}</span>

// ControlPlaneRouteTable returns the cluster controlplane routetable.
func (s *ClusterScope) ControlPlaneRouteTable() infrav1.RouteTable <span class="cov8" title="1">{
        subnet, _ := s.AzureCluster.Spec.NetworkSpec.GetControlPlaneSubnet()
        return subnet.RouteTable
}</span>

// APIServerLB returns the cluster API Server load balancer.
func (s *ClusterScope) APIServerLB() *infrav1.LoadBalancerSpec <span class="cov8" title="1">{
        return &amp;s.AzureCluster.Spec.NetworkSpec.APIServerLB
}</span>

// NodeOutboundLB returns the cluster node outbound load balancer.
func (s *ClusterScope) NodeOutboundLB() *infrav1.LoadBalancerSpec <span class="cov8" title="1">{
        return s.AzureCluster.Spec.NetworkSpec.NodeOutboundLB
}</span>

// ControlPlaneOutboundLB returns the cluster control plane outbound load balancer.
func (s *ClusterScope) ControlPlaneOutboundLB() *infrav1.LoadBalancerSpec <span class="cov8" title="1">{
        return s.AzureCluster.Spec.NetworkSpec.ControlPlaneOutboundLB
}</span>

// APIServerLBName returns the API Server LB name.
func (s *ClusterScope) APIServerLBName() string <span class="cov8" title="1">{
        return s.APIServerLB().Name
}</span>

// IsAPIServerPrivate returns true if the API Server LB is of type Internal.
func (s *ClusterScope) IsAPIServerPrivate() bool <span class="cov8" title="1">{
        return s.APIServerLB().Type == infrav1.Internal
}</span>

// APIServerPublicIP returns the API Server public IP.
func (s *ClusterScope) APIServerPublicIP() *infrav1.PublicIPSpec <span class="cov8" title="1">{
        return s.APIServerLB().FrontendIPs[0].PublicIP
}</span>

// APIServerPrivateIP returns the API Server private IP.
func (s *ClusterScope) APIServerPrivateIP() string <span class="cov0" title="0">{
        return s.APIServerLB().FrontendIPs[0].PrivateIPAddress
}</span>

// GetPrivateDNSZoneName returns the Private DNS Zone from the spec or generate it from cluster name.
func (s *ClusterScope) GetPrivateDNSZoneName() string <span class="cov8" title="1">{
        if len(s.AzureCluster.Spec.NetworkSpec.PrivateDNSZoneName) &gt; 0 </span><span class="cov8" title="1">{
                return s.AzureCluster.Spec.NetworkSpec.PrivateDNSZoneName
        }</span>
        <span class="cov8" title="1">return azure.GeneratePrivateDNSZoneName(s.ClusterName())</span>
}

// APIServerLBPoolName returns the API Server LB backend pool name.
func (s *ClusterScope) APIServerLBPoolName(loadBalancerName string) string <span class="cov8" title="1">{
        return azure.GenerateBackendAddressPoolName(loadBalancerName)
}</span>

// OutboundLBName returns the name of the outbound LB.
func (s *ClusterScope) OutboundLBName(role string) string <span class="cov8" title="1">{
        if role == infrav1.Node </span><span class="cov8" title="1">{
                if s.NodeOutboundLB() == nil </span><span class="cov8" title="1">{
                        return ""
                }</span>
                <span class="cov8" title="1">return s.NodeOutboundLB().Name</span>
        }
        <span class="cov8" title="1">if s.IsAPIServerPrivate() </span><span class="cov8" title="1">{
                if s.ControlPlaneOutboundLB() == nil </span><span class="cov8" title="1">{
                        return ""
                }</span>
                <span class="cov8" title="1">return s.ControlPlaneOutboundLB().Name</span>
        }
        <span class="cov8" title="1">return s.APIServerLBName()</span>
}

// OutboundPoolName returns the outbound LB backend pool name.
func (s *ClusterScope) OutboundPoolName(loadBalancerName string) string <span class="cov8" title="1">{
        if loadBalancerName == "" </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return azure.GenerateOutboundBackendAddressPoolName(loadBalancerName)</span>
}

// ResourceGroup returns the cluster resource group.
func (s *ClusterScope) ResourceGroup() string <span class="cov8" title="1">{
        return s.AzureCluster.Spec.ResourceGroup
}</span>

// ClusterName returns the cluster name.
func (s *ClusterScope) ClusterName() string <span class="cov8" title="1">{
        return s.Cluster.Name
}</span>

// Namespace returns the cluster namespace.
func (s *ClusterScope) Namespace() string <span class="cov0" title="0">{
        return s.Cluster.Namespace
}</span>

// Location returns the cluster location.
func (s *ClusterScope) Location() string <span class="cov8" title="1">{
        return s.AzureCluster.Spec.Location
}</span>

// AvailabilitySetEnabled informs machines that they should be part of an Availability Set.
func (s *ClusterScope) AvailabilitySetEnabled() bool <span class="cov8" title="1">{
        return len(s.AzureCluster.Status.FailureDomains) == 0
}</span>

// CloudProviderConfigOverrides returns the cloud provider config overrides for the cluster.
func (s *ClusterScope) CloudProviderConfigOverrides() *infrav1.CloudProviderConfigOverrides <span class="cov0" title="0">{
        return s.AzureCluster.Spec.CloudProviderConfigOverrides
}</span>

// GenerateFQDN generates a fully qualified domain name, based on a hash, cluster name and cluster location.
func (s *ClusterScope) GenerateFQDN(ipName string) string <span class="cov8" title="1">{
        h := fnv.New32a()
        if _, err := fmt.Fprintf(h, "%s/%s/%s", s.SubscriptionID(), s.ResourceGroup(), ipName); err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">hash := fmt.Sprintf("%x", h.Sum32())
        return strings.ToLower(fmt.Sprintf("%s-%s.%s.%s", s.ClusterName(), hash, s.Location(), s.AzureClients.ResourceManagerVMDNSSuffix))</span>
}

// GenerateLegacyFQDN generates an IP name and a fully qualified domain name, based on a hash, cluster name and cluster location.
// Deprecated: use GenerateFQDN instead.
func (s *ClusterScope) GenerateLegacyFQDN() (ip string, domain string) <span class="cov0" title="0">{
        h := fnv.New32a()
        if _, err := fmt.Fprintf(h, "%s/%s/%s", s.SubscriptionID(), s.ResourceGroup(), s.ClusterName()); err != nil </span><span class="cov0" title="0">{
                return "", ""
        }</span>
        <span class="cov0" title="0">ipName := fmt.Sprintf("%s-%x", s.ClusterName(), h.Sum32())
        fqdn := fmt.Sprintf("%s.%s.%s", ipName, s.Location(), s.AzureClients.ResourceManagerVMDNSSuffix)
        return ipName, fqdn</span>
}

// ListOptionsLabelSelector returns a ListOptions with a label selector for clusterName.
func (s *ClusterScope) ListOptionsLabelSelector() client.ListOption <span class="cov0" title="0">{
        return client.MatchingLabels(map[string]string{
                clusterv1.ClusterLabelName: s.Cluster.Name,
        })
}</span>

// PatchObject persists the cluster configuration and status.
func (s *ClusterScope) PatchObject(ctx context.Context) error <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "scope.ClusterScope.PatchObject")
        defer done()

        conditions.SetSummary(s.AzureCluster)

        return s.patchHelper.Patch(
                ctx,
                s.AzureCluster,
                patch.WithOwnedConditions{Conditions: []clusterv1.ConditionType{
                        clusterv1.ReadyCondition,
                        infrav1.ResourceGroupReadyCondition,
                        infrav1.RouteTablesReadyCondition,
                        infrav1.NetworkInfrastructureReadyCondition,
                        infrav1.VnetPeeringReadyCondition,
                        infrav1.DisksReadyCondition,
                        infrav1.NATGatewaysReadyCondition,
                        infrav1.LoadBalancersReadyCondition,
                        infrav1.BastionHostReadyCondition,
                        infrav1.VNetReadyCondition,
                        infrav1.SubnetsReadyCondition,
                        infrav1.SecurityGroupsReadyCondition,
                        infrav1.PrivateDNSZoneReadyCondition,
                        infrav1.PrivateDNSLinkReadyCondition,
                        infrav1.PrivateDNSRecordReadyCondition,
                }})
}</span>

// Close closes the current scope persisting the cluster configuration and status.
func (s *ClusterScope) Close(ctx context.Context) error <span class="cov0" title="0">{
        return s.PatchObject(ctx)
}</span>

// AdditionalTags returns AdditionalTags from the scope's AzureCluster.
func (s *ClusterScope) AdditionalTags() infrav1.Tags <span class="cov8" title="1">{
        tags := make(infrav1.Tags)
        if s.AzureCluster.Spec.AdditionalTags != nil </span><span class="cov8" title="1">{
                tags = s.AzureCluster.Spec.AdditionalTags.DeepCopy()
        }</span>
        <span class="cov8" title="1">return tags</span>
}

// APIServerPort returns the APIServerPort to use when creating the load balancer.
func (s *ClusterScope) APIServerPort() int32 <span class="cov8" title="1">{
        if s.Cluster.Spec.ClusterNetwork != nil &amp;&amp; s.Cluster.Spec.ClusterNetwork.APIServerPort != nil </span><span class="cov8" title="1">{
                return *s.Cluster.Spec.ClusterNetwork.APIServerPort
        }</span>
        <span class="cov8" title="1">return 6443</span>
}

// APIServerHost returns the hostname used to reach the API server.
func (s *ClusterScope) APIServerHost() string <span class="cov8" title="1">{
        if s.IsAPIServerPrivate() </span><span class="cov8" title="1">{
                return azure.GeneratePrivateFQDN(s.GetPrivateDNSZoneName())
        }</span>
        <span class="cov8" title="1">return s.APIServerPublicIP().DNSName</span>
}

// SetFailureDomain will set the spec for a for a given key.
func (s *ClusterScope) SetFailureDomain(id string, spec clusterv1.FailureDomainSpec) <span class="cov0" title="0">{
        if s.AzureCluster.Status.FailureDomains == nil </span><span class="cov0" title="0">{
                s.AzureCluster.Status.FailureDomains = make(clusterv1.FailureDomains)
        }</span>
        <span class="cov0" title="0">s.AzureCluster.Status.FailureDomains[id] = spec</span>
}

// FailureDomains returns the failure domains for the cluster.
func (s *ClusterScope) FailureDomains() []string <span class="cov8" title="1">{
        fds := make([]string, len(s.AzureCluster.Status.FailureDomains))
        i := 0
        for id := range s.AzureCluster.Status.FailureDomains </span><span class="cov8" title="1">{
                fds[i] = id
                i++
        }</span>

        <span class="cov8" title="1">sort.Strings(fds)

        return fds</span>
}

// SetControlPlaneSecurityRules sets the default security rules of the control plane subnet.
// Note that this is not done in a webhook as it requires a valid Cluster object to exist to get the API Server port.
func (s *ClusterScope) SetControlPlaneSecurityRules() <span class="cov8" title="1">{
        if s.ControlPlaneSubnet().SecurityGroup.SecurityRules == nil </span><span class="cov8" title="1">{
                subnet := s.ControlPlaneSubnet()
                subnet.SecurityGroup.SecurityRules = infrav1.SecurityRules{
                        infrav1.SecurityRule{
                                Name:             "allow_ssh",
                                Description:      "Allow SSH",
                                Priority:         2200,
                                Protocol:         infrav1.SecurityGroupProtocolTCP,
                                Direction:        infrav1.SecurityRuleDirectionInbound,
                                Source:           to.StringPtr("*"),
                                SourcePorts:      to.StringPtr("*"),
                                Destination:      to.StringPtr("*"),
                                DestinationPorts: to.StringPtr("22"),
                        },
                        infrav1.SecurityRule{
                                Name:             "allow_apiserver",
                                Description:      "Allow K8s API Server",
                                Priority:         2201,
                                Protocol:         infrav1.SecurityGroupProtocolTCP,
                                Direction:        infrav1.SecurityRuleDirectionInbound,
                                Source:           to.StringPtr("*"),
                                SourcePorts:      to.StringPtr("*"),
                                Destination:      to.StringPtr("*"),
                                DestinationPorts: to.StringPtr(strconv.Itoa(int(s.APIServerPort()))),
                        },
                }
                s.AzureCluster.Spec.NetworkSpec.UpdateControlPlaneSubnet(subnet)
        }</span>
}

// SetDNSName sets the API Server public IP DNS name.
// Note: this logic exists only for purposes of ensuring backwards compatibility for old clusters created without an APIServerLB, and should be removed in the future.
func (s *ClusterScope) SetDNSName() <span class="cov0" title="0">{
        // for back compat, set the old API Server defaults if no API Server Spec has been set by new webhooks.
        lb := s.APIServerLB()
        if lb == nil || lb.Name == "" </span><span class="cov0" title="0">{
                lbName := fmt.Sprintf("%s-%s", s.ClusterName(), "public-lb")
                ip, dns := s.GenerateLegacyFQDN()
                lb = &amp;infrav1.LoadBalancerSpec{
                        Name: lbName,
                        FrontendIPs: []infrav1.FrontendIP{
                                {
                                        Name: azure.GenerateFrontendIPConfigName(lbName),
                                        PublicIP: &amp;infrav1.PublicIPSpec{
                                                Name:    ip,
                                                DNSName: dns,
                                        },
                                },
                        },
                        LoadBalancerClassSpec: infrav1.LoadBalancerClassSpec{
                                SKU:  infrav1.SKUStandard,
                                Type: infrav1.Public,
                        },
                }
                lb.DeepCopyInto(s.APIServerLB())
        }</span>
        // Generate valid FQDN if not set.
        // Note: this function uses the AzureCluster subscription ID.
        <span class="cov0" title="0">if !s.IsAPIServerPrivate() &amp;&amp; s.APIServerPublicIP().DNSName == "" </span><span class="cov0" title="0">{
                s.APIServerPublicIP().DNSName = s.GenerateFQDN(s.APIServerPublicIP().Name)
        }</span>
}

// SetLongRunningOperationState will set the future on the AzureCluster status to allow the resource to continue
// in the next reconciliation.
func (s *ClusterScope) SetLongRunningOperationState(future *infrav1.Future) <span class="cov0" title="0">{
        futures.Set(s.AzureCluster, future)
}</span>

// GetLongRunningOperationState will get the future on the AzureCluster status.
func (s *ClusterScope) GetLongRunningOperationState(name, service string) *infrav1.Future <span class="cov0" title="0">{
        return futures.Get(s.AzureCluster, name, service)
}</span>

// DeleteLongRunningOperationState will delete the future from the AzureCluster status.
func (s *ClusterScope) DeleteLongRunningOperationState(name, service string) <span class="cov0" title="0">{
        futures.Delete(s.AzureCluster, name, service)
}</span>

// UpdateDeleteStatus updates a condition on the AzureCluster status after a DELETE operation.
func (s *ClusterScope) UpdateDeleteStatus(condition clusterv1.ConditionType, service string, err error) <span class="cov0" title="0">{
        switch </span>{
        case err == nil:<span class="cov0" title="0">
                conditions.MarkFalse(s.AzureCluster, condition, infrav1.DeletedReason, clusterv1.ConditionSeverityInfo, "%s successfully deleted", service)</span>
        case azure.IsOperationNotDoneError(err):<span class="cov0" title="0">
                conditions.MarkFalse(s.AzureCluster, condition, infrav1.DeletingReason, clusterv1.ConditionSeverityInfo, "%s deleting", service)</span>
        default:<span class="cov0" title="0">
                conditions.MarkFalse(s.AzureCluster, condition, infrav1.DeletionFailedReason, clusterv1.ConditionSeverityError, "%s failed to delete. err: %s", service, err.Error())</span>
        }
}

// UpdatePutStatus updates a condition on the AzureCluster status after a PUT operation.
func (s *ClusterScope) UpdatePutStatus(condition clusterv1.ConditionType, service string, err error) <span class="cov0" title="0">{
        switch </span>{
        case err == nil:<span class="cov0" title="0">
                conditions.MarkTrue(s.AzureCluster, condition)</span>
        case azure.IsOperationNotDoneError(err):<span class="cov0" title="0">
                conditions.MarkFalse(s.AzureCluster, condition, infrav1.CreatingReason, clusterv1.ConditionSeverityInfo, "%s creating or updating", service)</span>
        default:<span class="cov0" title="0">
                conditions.MarkFalse(s.AzureCluster, condition, infrav1.FailedReason, clusterv1.ConditionSeverityError, "%s failed to create or update. err: %s", service, err.Error())</span>
        }
}

// UpdatePatchStatus updates a condition on the AzureCluster status after a PATCH operation.
func (s *ClusterScope) UpdatePatchStatus(condition clusterv1.ConditionType, service string, err error) <span class="cov0" title="0">{
        switch </span>{
        case err == nil:<span class="cov0" title="0">
                conditions.MarkTrue(s.AzureCluster, condition)</span>
        case azure.IsOperationNotDoneError(err):<span class="cov0" title="0">
                conditions.MarkFalse(s.AzureCluster, condition, infrav1.UpdatingReason, clusterv1.ConditionSeverityInfo, "%s updating", service)</span>
        default:<span class="cov0" title="0">
                conditions.MarkFalse(s.AzureCluster, condition, infrav1.FailedReason, clusterv1.ConditionSeverityError, "%s failed to update. err: %s", service, err.Error())</span>
        }
}

// AnnotationJSON returns a map[string]interface from a JSON annotation.
func (s *ClusterScope) AnnotationJSON(annotation string) (map[string]interface{}, error) <span class="cov0" title="0">{
        out := map[string]interface{}{}
        jsonAnnotation := s.AzureCluster.GetAnnotations()[annotation]
        if jsonAnnotation == "" </span><span class="cov0" title="0">{
                return out, nil
        }</span>
        <span class="cov0" title="0">err := json.Unmarshal([]byte(jsonAnnotation), &amp;out)
        if err != nil </span><span class="cov0" title="0">{
                return out, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// UpdateAnnotationJSON updates the `annotation` with
// `content`. `content` in this case should be a `map[string]interface{}`
// suitable for turning into JSON. This `content` map will be marshalled into a
// JSON string before being set as the given `annotation`.
func (s *ClusterScope) UpdateAnnotationJSON(annotation string, content map[string]interface{}) error <span class="cov0" title="0">{
        b, err := json.Marshal(content)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">s.SetAnnotation(annotation, string(b))
        return nil</span>
}

// SetAnnotation sets a key value annotation on the AzureCluster.
func (s *ClusterScope) SetAnnotation(key, value string) <span class="cov0" title="0">{
        if s.AzureCluster.Annotations == nil </span><span class="cov0" title="0">{
                s.AzureCluster.Annotations = map[string]string{}
        }</span>
        <span class="cov0" title="0">s.AzureCluster.Annotations[key] = value</span>
}

// TagsSpecs returns the tag specs for the AzureCluster.
func (s *ClusterScope) TagsSpecs() []azure.TagsSpec <span class="cov0" title="0">{
        return []azure.TagsSpec{
                {
                        Scope:      azure.ResourceGroupID(s.SubscriptionID(), s.ResourceGroup()),
                        Tags:       s.AdditionalTags(),
                        Annotation: azure.RGTagsLastAppliedAnnotation,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package scope

import (
        "context"
        "fmt"
        "reflect"

        aadpodid "github.com/Azure/aad-pod-identity/pkg/apis/aadpodidentity"
        aadpodv1 "github.com/Azure/aad-pod-identity/pkg/apis/aadpodidentity/v1"
        "github.com/Azure/go-autorest/autorest"
        "github.com/Azure/go-autorest/autorest/adal"
        "github.com/pkg/errors"
        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        infrav1exp "sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/util/identity"
        "sigs.k8s.io/cluster-api-provider-azure/util/system"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        clusterctl "sigs.k8s.io/cluster-api/cmd/clusterctl/api/v1alpha3"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

const azureSecretKey = "clientSecret"

// CredentialsProvider defines the behavior for azure identity based credential providers.
type CredentialsProvider interface {
        GetAuthorizer(ctx context.Context, resourceManagerEndpoint, activeDirectoryEndpoint string) (autorest.Authorizer, error)
        GetClientID() string
        GetClientSecret(ctx context.Context) (string, error)
        GetTenantID() string
}

// AzureCredentialsProvider represents a credential provider with azure cluster identity.
type AzureCredentialsProvider struct {
        Client   client.Client
        Identity *infrav1.AzureClusterIdentity
}

// AzureClusterCredentialsProvider wraps AzureCredentialsProvider with AzureCluster.
type AzureClusterCredentialsProvider struct {
        AzureCredentialsProvider
        AzureCluster *infrav1.AzureCluster
}

// ManagedControlPlaneCredentialsProvider wraps AzureCredentialsProvider with AzureManagedControlPlane.
type ManagedControlPlaneCredentialsProvider struct {
        AzureCredentialsProvider
        AzureManagedControlPlane *infrav1exp.AzureManagedControlPlane
}

var _ CredentialsProvider = (*AzureClusterCredentialsProvider)(nil)
var _ CredentialsProvider = (*ManagedControlPlaneCredentialsProvider)(nil)

// NewAzureClusterCredentialsProvider creates a new AzureClusterCredentialsProvider from the supplied inputs.
func NewAzureClusterCredentialsProvider(ctx context.Context, kubeClient client.Client, azureCluster *infrav1.AzureCluster) (*AzureClusterCredentialsProvider, error) <span class="cov0" title="0">{
        if azureCluster.Spec.IdentityRef == nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to generate new AzureClusterCredentialsProvider from empty identityName")
        }</span>

        <span class="cov0" title="0">ref := azureCluster.Spec.IdentityRef
        // if the namespace isn't specified then assume it's in the same namespace as the AzureCluster
        namespace := ref.Namespace
        if namespace == "" </span><span class="cov0" title="0">{
                namespace = azureCluster.Namespace
        }</span>
        <span class="cov0" title="0">identity := &amp;infrav1.AzureClusterIdentity{}
        key := client.ObjectKey{Name: ref.Name, Namespace: namespace}
        if err := kubeClient.Get(ctx, key, identity); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Errorf("failed to retrieve AzureClusterIdentity external object %q/%q: %v", key.Namespace, key.Name, err)
        }</span>

        <span class="cov0" title="0">return &amp;AzureClusterCredentialsProvider{
                AzureCredentialsProvider{
                        Client:   kubeClient,
                        Identity: identity,
                },
                azureCluster,
        }, nil</span>
}

// GetAuthorizer returns an Azure authorizer based on the provided azure identity. It delegates to AzureCredentialsProvider with AzureCluster metadata.
func (p *AzureClusterCredentialsProvider) GetAuthorizer(ctx context.Context, resourceManagerEndpoint, activeDirectoryEndpoint string) (autorest.Authorizer, error) <span class="cov0" title="0">{
        return p.AzureCredentialsProvider.GetAuthorizer(ctx, resourceManagerEndpoint, activeDirectoryEndpoint, p.AzureCluster.ObjectMeta)
}</span>

// NewManagedControlPlaneCredentialsProvider creates a new ManagedControlPlaneCredentialsProvider from the supplied inputs.
func NewManagedControlPlaneCredentialsProvider(ctx context.Context, kubeClient client.Client, managedControlPlane *infrav1exp.AzureManagedControlPlane) (*ManagedControlPlaneCredentialsProvider, error) <span class="cov0" title="0">{
        if managedControlPlane.Spec.IdentityRef == nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to generate new ManagedControlPlaneCredentialsProvider from empty identityName")
        }</span>

        <span class="cov0" title="0">ref := managedControlPlane.Spec.IdentityRef
        // if the namespace isn't specified then assume it's in the same namespace as the AzureManagedControlPlane
        namespace := ref.Namespace
        if namespace == "" </span><span class="cov0" title="0">{
                namespace = managedControlPlane.Namespace
        }</span>
        <span class="cov0" title="0">identity := &amp;infrav1.AzureClusterIdentity{}
        key := client.ObjectKey{Name: ref.Name, Namespace: namespace}
        if err := kubeClient.Get(ctx, key, identity); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Errorf("failed to retrieve AzureClusterIdentity external object %q/%q: %v", key.Namespace, key.Name, err)
        }</span>

        <span class="cov0" title="0">return &amp;ManagedControlPlaneCredentialsProvider{
                AzureCredentialsProvider{
                        Client:   kubeClient,
                        Identity: identity,
                },
                managedControlPlane,
        }, nil</span>
}

// GetAuthorizer returns an Azure authorizer based on the provided azure identity. It delegates to AzureCredentialsProvider with AzureManagedControlPlane metadata.
func (p *ManagedControlPlaneCredentialsProvider) GetAuthorizer(ctx context.Context, resourceManagerEndpoint, activeDirectoryEndpoint string) (autorest.Authorizer, error) <span class="cov0" title="0">{
        return p.AzureCredentialsProvider.GetAuthorizer(ctx, resourceManagerEndpoint, activeDirectoryEndpoint, p.AzureManagedControlPlane.ObjectMeta)
}</span>

// GetAuthorizer returns an Azure authorizer based on the provided azure identity and cluster metadata.
func (p *AzureCredentialsProvider) GetAuthorizer(ctx context.Context, resourceManagerEndpoint, activeDirectoryEndpoint string, clusterMeta metav1.ObjectMeta) (autorest.Authorizer, error) <span class="cov0" title="0">{
        var spt *adal.ServicePrincipalToken
        switch p.Identity.Spec.Type </span>{
        case infrav1.ServicePrincipal, infrav1.ServicePrincipalCertificate, infrav1.UserAssignedMSI:<span class="cov0" title="0">
                if err := createAzureIdentityWithBindings(ctx, p.Identity, resourceManagerEndpoint, activeDirectoryEndpoint, clusterMeta, p.Client); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">msiEndpoint, err := adal.GetMSIVMEndpoint()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("failed to get MSI endpoint: %v", err)
                }</span>

                <span class="cov0" title="0">spt, err = adal.NewServicePrincipalTokenFromMSIWithUserAssignedID(msiEndpoint, resourceManagerEndpoint, p.Identity.Spec.ClientID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("failed to get token from service principal identity: %v", err)
                }</span>

        case infrav1.ManualServicePrincipal:<span class="cov0" title="0">
                oauthConfig, err := adal.NewOAuthConfig(activeDirectoryEndpoint, p.GetTenantID())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">clientSecret, err := p.GetClientSecret(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to get client secret")
                }</span>

                <span class="cov0" title="0">spt, err = adal.NewServicePrincipalToken(*oauthConfig, p.Identity.Spec.ClientID, clientSecret, resourceManagerEndpoint)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("failed to get token from service principal identity: %v", err)
                }</span>

        default:<span class="cov0" title="0">
                return nil, errors.Errorf("identity type %s not supported", p.Identity.Spec.Type)</span>
        }

        <span class="cov0" title="0">return autorest.NewBearerAuthorizer(spt), nil</span>
}

// GetClientID returns the Client ID associated with the AzureCredentialsProvider's Identity.
func (p *AzureCredentialsProvider) GetClientID() string <span class="cov0" title="0">{
        return p.Identity.Spec.ClientID
}</span>

// GetClientSecret returns the Client Secret associated with the AzureCredentialsProvider's Identity.
// NOTE: this only works if the Identity references a Service Principal Client Secret.
// If using another type of credentials, such a Certificate, we return an empty string.
func (p *AzureCredentialsProvider) GetClientSecret(ctx context.Context) (string, error) <span class="cov0" title="0">{
        if p.hasClientSecret() </span><span class="cov0" title="0">{
                secretRef := p.Identity.Spec.ClientSecret
                key := types.NamespacedName{
                        Namespace: secretRef.Namespace,
                        Name:      secretRef.Name,
                }
                secret := &amp;corev1.Secret{}

                if err := p.Client.Get(ctx, key, secret); err != nil </span><span class="cov0" title="0">{
                        return "", errors.Wrap(err, "Unable to fetch ClientSecret")
                }</span>
                <span class="cov0" title="0">return string(secret.Data[azureSecretKey]), nil</span>
        }
        <span class="cov0" title="0">return "", nil</span>
}

// GetTenantID returns the Tenant ID associated with the AzureCredentialsProvider's Identity.
func (p *AzureCredentialsProvider) GetTenantID() string <span class="cov0" title="0">{
        return p.Identity.Spec.TenantID
}</span>

// hasClientSecret returns true if the identity has a Service Principal Client Secret.
// This does not include service principals with certificates or managed identities.
func (p *AzureCredentialsProvider) hasClientSecret() bool <span class="cov8" title="1">{
        return p.Identity.Spec.Type == infrav1.ServicePrincipal || p.Identity.Spec.Type == infrav1.ManualServicePrincipal
}</span>

func createAzureIdentityWithBindings(ctx context.Context, azureIdentity *infrav1.AzureClusterIdentity, resourceManagerEndpoint, activeDirectoryEndpoint string, clusterMeta metav1.ObjectMeta,
        kubeClient client.Client) error <span class="cov8" title="1">{
        azureIdentityType, err := getAzureIdentityType(azureIdentity)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // AzureIdentity and AzureIdentityBinding will no longer have an OwnerRef starting from capz release v0.5.0 because of the following:
        // In Kubernetes v1.20+, if the garbage collector detects an invalid cross-namespace ownerReference, or a cluster-scoped dependent with
        // an ownerReference referencing a namespaced kind, a warning Event with a reason of OwnerRefInvalidNamespace and an involvedObject
        // of the invalid dependent is reported. You can check for that kind of Event by running kubectl get events -A --field-selector=reason=OwnerRefInvalidNamespace.

        <span class="cov8" title="1">copiedIdentity := &amp;aadpodv1.AzureIdentity{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "AzureIdentity",
                        APIVersion: "aadpodidentity.k8s.io/v1",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      identity.GetAzureIdentityName(clusterMeta.Name, clusterMeta.Namespace, azureIdentity.Name),
                        Namespace: system.GetManagerNamespace(),
                        Annotations: map[string]string{
                                aadpodv1.BehaviorKey: "namespaced",
                        },
                        Labels: map[string]string{
                                clusterv1.ClusterLabelName:                  clusterMeta.Name,
                                infrav1.ClusterLabelNamespace:               clusterMeta.Namespace,
                                clusterctl.ClusterctlMoveHierarchyLabelName: "true",
                        },
                },
                Spec: aadpodv1.AzureIdentitySpec{
                        Type:           azureIdentityType,
                        TenantID:       azureIdentity.Spec.TenantID,
                        ClientID:       azureIdentity.Spec.ClientID,
                        ClientPassword: azureIdentity.Spec.ClientSecret,
                        ResourceID:     azureIdentity.Spec.ResourceID,
                        ADResourceID:   resourceManagerEndpoint,
                        ADEndpoint:     activeDirectoryEndpoint,
                },
        }
        err = kubeClient.Create(ctx, copiedIdentity)
        if err != nil &amp;&amp; !apierrors.IsAlreadyExists(err) </span><span class="cov0" title="0">{
                return errors.Errorf("failed to create copied AzureIdentity %s in %s: %v", copiedIdentity.Name, system.GetManagerNamespace(), err)
        }</span>

        <span class="cov8" title="1">azureIdentityBinding := &amp;aadpodv1.AzureIdentityBinding{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "AzureIdentityBinding",
                        APIVersion: "aadpodidentity.k8s.io/v1",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      fmt.Sprintf("%s-binding", copiedIdentity.Name),
                        Namespace: copiedIdentity.Namespace,
                        Labels: map[string]string{
                                clusterv1.ClusterLabelName:                  clusterMeta.Name,
                                infrav1.ClusterLabelNamespace:               clusterMeta.Namespace,
                                clusterctl.ClusterctlMoveHierarchyLabelName: "true",
                        },
                },
                Spec: aadpodv1.AzureIdentityBindingSpec{
                        AzureIdentity: copiedIdentity.Name,
                        Selector:      infrav1.AzureIdentityBindingSelector, // should be same as selector added on controller
                },
        }
        err = kubeClient.Create(ctx, azureIdentityBinding)
        if err != nil &amp;&amp; !apierrors.IsAlreadyExists(err) </span><span class="cov0" title="0">{
                return errors.Errorf("failed to create AzureIdentityBinding %s in %s: %v", copiedIdentity.Name, system.GetManagerNamespace(), err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func getAzureIdentityType(identity *infrav1.AzureClusterIdentity) (aadpodv1.IdentityType, error) <span class="cov8" title="1">{
        switch identity.Spec.Type </span>{
        case infrav1.UserAssignedMSI:<span class="cov8" title="1">
                return aadpodv1.UserAssignedMSI, nil</span>
        case infrav1.ServicePrincipal:<span class="cov8" title="1">
                return aadpodv1.ServicePrincipal, nil</span>
        case infrav1.ServicePrincipalCertificate:<span class="cov8" title="1">
                return aadpodv1.IdentityType(aadpodid.ServicePrincipalCertificate), nil</span>
        }

        <span class="cov8" title="1">return -1, errors.New("AzureIdentity does not have a valid type")</span>
}

// IsClusterNamespaceAllowed indicates if the cluster namespace is allowed.
func IsClusterNamespaceAllowed(ctx context.Context, k8sClient client.Client, allowedNamespaces *infrav1.AllowedNamespaces, namespace string) bool <span class="cov8" title="1">{
        if allowedNamespaces == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // empty value matches with all namespaces
        <span class="cov8" title="1">if reflect.DeepEqual(*allowedNamespaces, infrav1.AllowedNamespaces{}) </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">for _, v := range allowedNamespaces.NamespaceList </span><span class="cov8" title="1">{
                if v == namespace </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        // Check if clusterNamespace is in the namespaces selected by the identity's allowedNamespaces selector.
        <span class="cov8" title="1">namespaces := &amp;corev1.NamespaceList{}
        selector, err := metav1.LabelSelectorAsSelector(allowedNamespaces.Selector)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // If a Selector has a nil or empty selector, it should match nothing.
        <span class="cov8" title="1">if selector.Empty() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if err := k8sClient.List(ctx, namespaces, client.MatchingLabelsSelector{Selector: selector}); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">for _, n := range namespaces.Items </span><span class="cov8" title="1">{
                if n.Name == namespace </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">/*
Copyright 2018 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package scope

import (
        "context"
        "encoding/base64"
        "encoding/json"
        "strings"
        "time"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-11-01/compute"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/types"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/availabilitysets"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/disks"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/inboundnatrules"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/networkinterfaces"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/publicips"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/resourceskus"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/roleassignments"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/virtualmachineimages"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/virtualmachines"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/vmextensions"
        "sigs.k8s.io/cluster-api-provider-azure/util/futures"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        "sigs.k8s.io/cluster-api/controllers/noderefutil"
        capierrors "sigs.k8s.io/cluster-api/errors"
        "sigs.k8s.io/cluster-api/util"
        "sigs.k8s.io/cluster-api/util/conditions"
        "sigs.k8s.io/cluster-api/util/patch"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// MachineScopeParams defines the input parameters used to create a new MachineScope.
type MachineScopeParams struct {
        Client       client.Client
        ClusterScope azure.ClusterScoper
        Machine      *clusterv1.Machine
        AzureMachine *infrav1.AzureMachine
        Cache        *MachineCache
}

// NewMachineScope creates a new MachineScope from the supplied parameters.
// This is meant to be called for each reconcile iteration.
func NewMachineScope(params MachineScopeParams) (*MachineScope, error) <span class="cov0" title="0">{
        if params.Client == nil </span><span class="cov0" title="0">{
                return nil, errors.New("client is required when creating a MachineScope")
        }</span>
        <span class="cov0" title="0">if params.Machine == nil </span><span class="cov0" title="0">{
                return nil, errors.New("machine is required when creating a MachineScope")
        }</span>
        <span class="cov0" title="0">if params.AzureMachine == nil </span><span class="cov0" title="0">{
                return nil, errors.New("azure machine is required when creating a MachineScope")
        }</span>

        <span class="cov0" title="0">helper, err := patch.NewHelper(params.AzureMachine, params.Client)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to init patch helper")
        }</span>

        <span class="cov0" title="0">return &amp;MachineScope{
                client:        params.Client,
                Machine:       params.Machine,
                AzureMachine:  params.AzureMachine,
                patchHelper:   helper,
                ClusterScoper: params.ClusterScope,
                cache:         params.Cache,
        }, nil</span>
}

// MachineScope defines a scope defined around a machine and its cluster.
type MachineScope struct {
        client      client.Client
        patchHelper *patch.Helper

        azure.ClusterScoper
        Machine      *clusterv1.Machine
        AzureMachine *infrav1.AzureMachine
        cache        *MachineCache
}

// MachineCache stores common machine information so we don't have to hit the API multiple times within the same reconcile loop.
type MachineCache struct {
        BootstrapData      string
        VMImage            *infrav1.Image
        VMSKU              resourceskus.SKU
        availabilitySetSKU resourceskus.SKU
}

// InitMachineCache sets cached information about the machine to be used in the scope.
func (m *MachineScope) InitMachineCache(ctx context.Context) error <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "azure.MachineScope.InitMachineCache")
        defer done()

        if m.cache == nil </span><span class="cov0" title="0">{
                var err error
                m.cache = &amp;MachineCache{}

                m.cache.BootstrapData, err = m.GetBootstrapData(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">m.cache.VMImage, err = m.GetVMImage(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">skuCache, err := resourceskus.GetCache(m, m.Location())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">m.cache.VMSKU, err = skuCache.Get(ctx, m.AzureMachine.Spec.VMSize, resourceskus.VirtualMachines)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrapf(err, "failed to get VM SKU %s in compute api", m.AzureMachine.Spec.VMSize)
                }</span>

                <span class="cov0" title="0">m.cache.availabilitySetSKU, err = skuCache.Get(ctx, string(compute.AvailabilitySetSkuTypesAligned), resourceskus.AvailabilitySets)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrapf(err, "failed to get availability set SKU %s in compute api", string(compute.AvailabilitySetSkuTypesAligned))
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// VMSpec returns the VM spec.
func (m *MachineScope) VMSpec() azure.ResourceSpecGetter <span class="cov0" title="0">{
        spec := &amp;virtualmachines.VMSpec{
                Name:                   m.Name(),
                Location:               m.Location(),
                ResourceGroup:          m.ResourceGroup(),
                ClusterName:            m.ClusterName(),
                Role:                   m.Role(),
                NICIDs:                 m.NICIDs(),
                SSHKeyData:             m.AzureMachine.Spec.SSHPublicKey,
                Size:                   m.AzureMachine.Spec.VMSize,
                OSDisk:                 m.AzureMachine.Spec.OSDisk,
                DataDisks:              m.AzureMachine.Spec.DataDisks,
                AvailabilitySetID:      m.AvailabilitySetID(),
                Zone:                   m.AvailabilityZone(),
                Identity:               m.AzureMachine.Spec.Identity,
                UserAssignedIdentities: m.AzureMachine.Spec.UserAssignedIdentities,
                SpotVMOptions:          m.AzureMachine.Spec.SpotVMOptions,
                SecurityProfile:        m.AzureMachine.Spec.SecurityProfile,
                AdditionalTags:         m.AdditionalTags(),
                AdditionalCapabilities: m.AzureMachine.Spec.AdditionalCapabilities,
                ProviderID:             m.ProviderID(),
        }
        if m.cache != nil </span><span class="cov0" title="0">{
                spec.SKU = m.cache.VMSKU
                spec.Image = m.cache.VMImage
                spec.BootstrapData = m.cache.BootstrapData
        }</span>
        <span class="cov0" title="0">return spec</span>
}

// TagsSpecs returns the tags for the AzureMachine.
func (m *MachineScope) TagsSpecs() []azure.TagsSpec <span class="cov0" title="0">{
        return []azure.TagsSpec{
                {
                        Scope:      azure.VMID(m.SubscriptionID(), m.ResourceGroup(), m.Name()),
                        Tags:       m.AdditionalTags(),
                        Annotation: azure.VMTagsLastAppliedAnnotation,
                },
        }
}</span>

// PublicIPSpecs returns the public IP specs.
func (m *MachineScope) PublicIPSpecs() []azure.ResourceSpecGetter <span class="cov8" title="1">{
        var specs []azure.ResourceSpecGetter
        if m.AzureMachine.Spec.AllocatePublicIP </span><span class="cov8" title="1">{
                specs = append(specs, &amp;publicips.PublicIPSpec{
                        Name:           azure.GenerateNodePublicIPName(m.Name()),
                        ResourceGroup:  m.ResourceGroup(),
                        ClusterName:    m.ClusterName(),
                        DNSName:        "",    // Set to default value
                        IsIPv6:         false, // Set to default value
                        Location:       m.Location(),
                        FailureDomains: m.FailureDomains(),
                        AdditionalTags: m.ClusterScoper.AdditionalTags(),
                })
        }</span>
        <span class="cov8" title="1">return specs</span>
}

// InboundNatSpecs returns the inbound NAT specs.
func (m *MachineScope) InboundNatSpecs() []azure.ResourceSpecGetter <span class="cov8" title="1">{
        // The existing inbound NAT rules are needed in order to find an available SSH port for each new inbound NAT rule.
        if m.Role() == infrav1.ControlPlane </span><span class="cov8" title="1">{
                spec := &amp;inboundnatrules.InboundNatSpec{
                        Name:                      m.Name(),
                        ResourceGroup:             m.ResourceGroup(),
                        LoadBalancerName:          m.APIServerLBName(),
                        FrontendIPConfigurationID: nil,
                }
                if frontEndIPs := m.APIServerLB().FrontendIPs; len(frontEndIPs) &gt; 0 </span><span class="cov8" title="1">{
                        ipConfig := frontEndIPs[0].Name
                        id := azure.FrontendIPConfigID(m.SubscriptionID(), m.ResourceGroup(), m.APIServerLBName(), ipConfig)
                        spec.FrontendIPConfigurationID = to.StringPtr(id)
                }</span>

                <span class="cov8" title="1">return []azure.ResourceSpecGetter{spec}</span>
        }
        <span class="cov8" title="1">return []azure.ResourceSpecGetter{}</span>
}

// NICSpecs returns the network interface specs.
func (m *MachineScope) NICSpecs() []azure.ResourceSpecGetter <span class="cov8" title="1">{
        spec := &amp;networkinterfaces.NICSpec{
                Name:                  azure.GenerateNICName(m.Name()),
                ResourceGroup:         m.ResourceGroup(),
                Location:              m.Location(),
                SubscriptionID:        m.SubscriptionID(),
                MachineName:           m.Name(),
                VNetName:              m.Vnet().Name,
                VNetResourceGroup:     m.Vnet().ResourceGroup,
                SubnetName:            m.AzureMachine.Spec.SubnetName,
                AcceleratedNetworking: m.AzureMachine.Spec.AcceleratedNetworking,
                DNSServers:            m.AzureMachine.Spec.DNSServers,
                IPv6Enabled:           m.IsIPv6Enabled(),
                EnableIPForwarding:    m.AzureMachine.Spec.EnableIPForwarding,
                AdditionalTags:        m.AdditionalTags(),
                ClusterName:           m.ClusterName(),
        }

        if m.Role() == infrav1.ControlPlane </span><span class="cov8" title="1">{
                spec.PublicLBName = m.OutboundLBName(m.Role())
                spec.PublicLBAddressPoolName = m.OutboundPoolName(m.OutboundLBName(m.Role()))
                if m.IsAPIServerPrivate() </span><span class="cov8" title="1">{
                        spec.InternalLBName = m.APIServerLBName()
                        spec.InternalLBAddressPoolName = m.APIServerLBPoolName(m.APIServerLBName())
                }</span> else<span class="cov8" title="1"> {
                        spec.PublicLBNATRuleName = m.Name()
                        spec.PublicLBAddressPoolName = m.APIServerLBPoolName(m.APIServerLBName())
                }</span>
        }

        // If NAT gateway is not enabled and node has no public IP, then the NIC needs to reference the LB to get outbound traffic.
        <span class="cov8" title="1">if m.Role() == infrav1.Node &amp;&amp; !m.Subnet().IsNatGatewayEnabled() &amp;&amp; !m.AzureMachine.Spec.AllocatePublicIP </span><span class="cov8" title="1">{
                spec.PublicLBName = m.OutboundLBName(m.Role())
                spec.PublicLBAddressPoolName = m.OutboundPoolName(m.OutboundLBName(m.Role()))
        }</span>

        <span class="cov8" title="1">if m.Role() == infrav1.Node &amp;&amp; m.AzureMachine.Spec.AllocatePublicIP </span><span class="cov8" title="1">{
                spec.PublicIPName = azure.GenerateNodePublicIPName(m.Name())
        }</span>

        <span class="cov8" title="1">if m.cache != nil </span><span class="cov8" title="1">{
                spec.SKU = &amp;m.cache.VMSKU
        }</span>

        <span class="cov8" title="1">return []azure.ResourceSpecGetter{spec}</span>
}

// NICIDs returns the NIC resource IDs.
func (m *MachineScope) NICIDs() []string <span class="cov0" title="0">{
        nicspecs := m.NICSpecs()
        nicIDs := make([]string, len(nicspecs))
        for i, nic := range nicspecs </span><span class="cov0" title="0">{
                nicIDs[i] = azure.NetworkInterfaceID(m.SubscriptionID(), nic.ResourceGroupName(), nic.ResourceName())
        }</span>
        <span class="cov0" title="0">return nicIDs</span>
}

// DiskSpecs returns the disk specs.
func (m *MachineScope) DiskSpecs() []azure.ResourceSpecGetter <span class="cov8" title="1">{
        diskSpecs := make([]azure.ResourceSpecGetter, 1+len(m.AzureMachine.Spec.DataDisks))
        diskSpecs[0] = &amp;disks.DiskSpec{
                Name:          azure.GenerateOSDiskName(m.Name()),
                ResourceGroup: m.ResourceGroup(),
        }

        for i, dd := range m.AzureMachine.Spec.DataDisks </span><span class="cov8" title="1">{
                diskSpecs[i+1] = &amp;disks.DiskSpec{
                        Name:          azure.GenerateDataDiskName(m.Name(), dd.NameSuffix),
                        ResourceGroup: m.ResourceGroup(),
                }
        }</span>
        <span class="cov8" title="1">return diskSpecs</span>
}

// RoleAssignmentSpecs returns the role assignment specs.
func (m *MachineScope) RoleAssignmentSpecs(principalID *string) []azure.ResourceSpecGetter <span class="cov8" title="1">{
        roles := make([]azure.ResourceSpecGetter, 1)
        if m.HasSystemAssignedIdentity() </span><span class="cov8" title="1">{
                roles[0] = &amp;roleassignments.RoleAssignmentSpec{
                        Name:             m.AzureMachine.Spec.RoleAssignmentName,
                        MachineName:      m.Name(),
                        ResourceType:     azure.VirtualMachine,
                        ResourceGroup:    m.ResourceGroup(),
                        Scope:            azure.GenerateSubscriptionScope(m.SubscriptionID()),
                        RoleDefinitionID: azure.GenerateContributorRoleDefinitionID(m.SubscriptionID()),
                        PrincipalID:      principalID,
                }
                return roles
        }</span>
        <span class="cov8" title="1">return []azure.ResourceSpecGetter{}</span>
}

// RoleAssignmentResourceType returns the role assignment resource type.
func (m *MachineScope) RoleAssignmentResourceType() string <span class="cov0" title="0">{
        return azure.VirtualMachine
}</span>

// HasSystemAssignedIdentity returns true if the azure machine has
// system assigned identity.
func (m *MachineScope) HasSystemAssignedIdentity() bool <span class="cov8" title="1">{
        return m.AzureMachine.Spec.Identity == infrav1.VMIdentitySystemAssigned
}</span>

// VMExtensionSpecs returns the VM extension specs.
func (m *MachineScope) VMExtensionSpecs() []azure.ResourceSpecGetter <span class="cov8" title="1">{
        var extensionSpecs = []azure.ResourceSpecGetter{}
        bootstrapExtensionSpec := azure.GetBootstrappingVMExtension(m.AzureMachine.Spec.OSDisk.OSType, m.CloudEnvironment(), m.Name())

        if bootstrapExtensionSpec != nil </span><span class="cov8" title="1">{
                extensionSpecs = append(extensionSpecs, &amp;vmextensions.VMExtensionSpec{
                        ExtensionSpec: *bootstrapExtensionSpec,
                        ResourceGroup: m.ResourceGroup(),
                        Location:      m.Location(),
                })
        }</span>

        <span class="cov8" title="1">return extensionSpecs</span>
}

// Subnet returns the machine's subnet.
func (m *MachineScope) Subnet() infrav1.SubnetSpec <span class="cov8" title="1">{
        for _, subnet := range m.Subnets() </span><span class="cov8" title="1">{
                if subnet.Name == m.AzureMachine.Spec.SubnetName </span><span class="cov8" title="1">{
                        return subnet
                }</span>
        }

        <span class="cov8" title="1">return infrav1.SubnetSpec{}</span>
}

// AvailabilityZone returns the AzureMachine Availability Zone.
// Priority for selecting the AZ is
//   1) Machine.Spec.FailureDomain
//   2) AzureMachine.Spec.FailureDomain (This is to support deprecated AZ)
//   3) No AZ
func (m *MachineScope) AvailabilityZone() string <span class="cov8" title="1">{
        if m.Machine.Spec.FailureDomain != nil </span><span class="cov8" title="1">{
                return *m.Machine.Spec.FailureDomain
        }</span>
        // Deprecated: to support old clients
        <span class="cov8" title="1">if m.AzureMachine.Spec.FailureDomain != nil </span><span class="cov8" title="1">{
                return *m.AzureMachine.Spec.FailureDomain
        }</span>

        <span class="cov8" title="1">return ""</span>
}

// Name returns the AzureMachine name.
func (m *MachineScope) Name() string <span class="cov8" title="1">{
        if id := m.GetVMID(); id != "" </span><span class="cov8" title="1">{
                return id
        }</span>
        // Windows Machine names cannot be longer than 15 chars
        <span class="cov8" title="1">if m.AzureMachine.Spec.OSDisk.OSType == azure.WindowsOS &amp;&amp; len(m.AzureMachine.Name) &gt; 15 </span><span class="cov8" title="1">{
                return strings.TrimSuffix(m.AzureMachine.Name[0:9], "-") + "-" + m.AzureMachine.Name[len(m.AzureMachine.Name)-5:]
        }</span>
        <span class="cov8" title="1">return m.AzureMachine.Name</span>
}

// Namespace returns the namespace name.
func (m *MachineScope) Namespace() string <span class="cov8" title="1">{
        return m.AzureMachine.Namespace
}</span>

// IsControlPlane returns true if the machine is a control plane.
func (m *MachineScope) IsControlPlane() bool <span class="cov8" title="1">{
        return util.IsControlPlaneMachine(m.Machine)
}</span>

// Role returns the machine role from the labels.
func (m *MachineScope) Role() string <span class="cov8" title="1">{
        if util.IsControlPlaneMachine(m.Machine) </span><span class="cov8" title="1">{
                return infrav1.ControlPlane
        }</span>
        <span class="cov8" title="1">return infrav1.Node</span>
}

// GetVMID returns the AzureMachine instance id by parsing Spec.FakeProviderID.
func (m *MachineScope) GetVMID() string <span class="cov8" title="1">{
        parsed, err := noderefutil.NewProviderID(m.ProviderID())
        if err != nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return parsed.ID()</span>
}

// ProviderID returns the AzureMachine providerID from the spec.
func (m *MachineScope) ProviderID() string <span class="cov8" title="1">{
        parsed, err := noderefutil.NewProviderID(to.String(m.AzureMachine.Spec.ProviderID))
        if err != nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return parsed.String()</span>
}

// AvailabilitySetSpec returns the availability set spec for this machine if available.
func (m *MachineScope) AvailabilitySetSpec() azure.ResourceSpecGetter <span class="cov0" title="0">{
        availabilitySetName, ok := m.AvailabilitySet()
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">spec := &amp;availabilitysets.AvailabilitySetSpec{
                Name:           availabilitySetName,
                ResourceGroup:  m.ResourceGroup(),
                ClusterName:    m.ClusterName(),
                Location:       m.Location(),
                SKU:            nil,
                AdditionalTags: m.AdditionalTags(),
        }

        if m.cache != nil </span><span class="cov0" title="0">{
                spec.SKU = &amp;m.cache.availabilitySetSKU
        }</span>

        <span class="cov0" title="0">return spec</span>
}

// AvailabilitySet returns the availability set for this machine if available.
func (m *MachineScope) AvailabilitySet() (string, bool) <span class="cov8" title="1">{
        if !m.AvailabilitySetEnabled() </span><span class="cov8" title="1">{
                return "", false
        }</span>

        <span class="cov8" title="1">if m.IsControlPlane() </span><span class="cov8" title="1">{
                return azure.GenerateAvailabilitySetName(m.ClusterName(), azure.ControlPlaneNodeGroup), true
        }</span>

        // get machine deployment name from labels for machines that maybe part of a machine deployment.
        <span class="cov8" title="1">if mdName, ok := m.Machine.Labels[clusterv1.MachineDeploymentLabelName]; ok </span><span class="cov8" title="1">{
                return azure.GenerateAvailabilitySetName(m.ClusterName(), mdName), true
        }</span>

        // if machine deployment name label is not available, use machine set name.
        <span class="cov8" title="1">if msName, ok := m.Machine.Labels[clusterv1.MachineSetLabelName]; ok </span><span class="cov8" title="1">{
                return azure.GenerateAvailabilitySetName(m.ClusterName(), msName), true
        }</span>

        <span class="cov8" title="1">return "", false</span>
}

// AvailabilitySetID returns the availability set for this machine, or "" if there is no availability set.
func (m *MachineScope) AvailabilitySetID() string <span class="cov0" title="0">{
        var asID string
        if asName, ok := m.AvailabilitySet(); ok </span><span class="cov0" title="0">{
                asID = azure.AvailabilitySetID(m.SubscriptionID(), m.ResourceGroup(), asName)
        }</span>
        <span class="cov0" title="0">return asID</span>
}

// SetProviderID sets the AzureMachine providerID in spec.
func (m *MachineScope) SetProviderID(v string) <span class="cov0" title="0">{
        m.AzureMachine.Spec.ProviderID = to.StringPtr(v)
}</span>

// VMState returns the AzureMachine VM state.
func (m *MachineScope) VMState() infrav1.ProvisioningState <span class="cov8" title="1">{
        if m.AzureMachine.Status.VMState != nil </span><span class="cov8" title="1">{
                return *m.AzureMachine.Status.VMState
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// SetVMState sets the AzureMachine VM state.
func (m *MachineScope) SetVMState(v infrav1.ProvisioningState) <span class="cov0" title="0">{
        m.AzureMachine.Status.VMState = &amp;v
}</span>

// SetReady sets the AzureMachine Ready Status to true.
func (m *MachineScope) SetReady() <span class="cov0" title="0">{
        m.AzureMachine.Status.Ready = true
}</span>

// SetNotReady sets the AzureMachine Ready Status to false.
func (m *MachineScope) SetNotReady() <span class="cov0" title="0">{
        m.AzureMachine.Status.Ready = false
}</span>

// SetFailureMessage sets the AzureMachine status failure message.
func (m *MachineScope) SetFailureMessage(v error) <span class="cov0" title="0">{
        m.AzureMachine.Status.FailureMessage = to.StringPtr(v.Error())
}</span>

// SetFailureReason sets the AzureMachine status failure reason.
func (m *MachineScope) SetFailureReason(v capierrors.MachineStatusError) <span class="cov0" title="0">{
        m.AzureMachine.Status.FailureReason = &amp;v
}</span>

// SetBootstrapConditions sets the AzureMachine BootstrapSucceeded condition based on the extension provisioning states.
func (m *MachineScope) SetBootstrapConditions(ctx context.Context, provisioningState string, extensionName string) error <span class="cov0" title="0">{
        _, log, done := tele.StartSpanWithLogger(ctx, "scope.MachineScope.SetBootstrapConditions")
        defer done()

        switch infrav1.ProvisioningState(provisioningState) </span>{
        case infrav1.Succeeded:<span class="cov0" title="0">
                log.V(4).Info("extension provisioning state is succeeded", "vm extension", extensionName, "virtual machine", m.Name())
                conditions.MarkTrue(m.AzureMachine, infrav1.BootstrapSucceededCondition)
                return nil</span>
        case infrav1.Creating:<span class="cov0" title="0">
                log.V(4).Info("extension provisioning state is creating", "vm extension", extensionName, "virtual machine", m.Name())
                conditions.MarkFalse(m.AzureMachine, infrav1.BootstrapSucceededCondition, infrav1.BootstrapInProgressReason, clusterv1.ConditionSeverityInfo, "")
                return azure.WithTransientError(errors.New("extension is still in provisioning state. This likely means that bootstrapping has not yet completed on the VM"), 30*time.Second)</span>
        case infrav1.Failed:<span class="cov0" title="0">
                log.V(4).Info("extension provisioning state is failed", "vm extension", extensionName, "virtual machine", m.Name())
                conditions.MarkFalse(m.AzureMachine, infrav1.BootstrapSucceededCondition, infrav1.BootstrapFailedReason, clusterv1.ConditionSeverityError, "")
                return azure.WithTerminalError(errors.New("extension state failed. This likely means the Kubernetes node bootstrapping process failed or timed out. Check VM boot diagnostics logs to learn more"))</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// SetAnnotation sets a key value annotation on the AzureMachine.
func (m *MachineScope) SetAnnotation(key, value string) <span class="cov0" title="0">{
        if m.AzureMachine.Annotations == nil </span><span class="cov0" title="0">{
                m.AzureMachine.Annotations = map[string]string{}
        }</span>
        <span class="cov0" title="0">m.AzureMachine.Annotations[key] = value</span>
}

// AnnotationJSON returns a map[string]interface from a JSON annotation.
func (m *MachineScope) AnnotationJSON(annotation string) (map[string]interface{}, error) <span class="cov0" title="0">{
        out := map[string]interface{}{}
        jsonAnnotation := m.AzureMachine.GetAnnotations()[annotation]
        if jsonAnnotation == "" </span><span class="cov0" title="0">{
                return out, nil
        }</span>
        <span class="cov0" title="0">err := json.Unmarshal([]byte(jsonAnnotation), &amp;out)
        if err != nil </span><span class="cov0" title="0">{
                return out, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// UpdateAnnotationJSON updates the `annotation` with
// `content`. `content` in this case should be a `map[string]interface{}`
// suitable for turning into JSON. This `content` map will be marshalled into a
// JSON string before being set as the given `annotation`.
func (m *MachineScope) UpdateAnnotationJSON(annotation string, content map[string]interface{}) error <span class="cov0" title="0">{
        b, err := json.Marshal(content)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">m.SetAnnotation(annotation, string(b))
        return nil</span>
}

// SetAddresses sets the Azure address status.
func (m *MachineScope) SetAddresses(addrs []corev1.NodeAddress) <span class="cov0" title="0">{
        m.AzureMachine.Status.Addresses = addrs
}</span>

// PatchObject persists the machine spec and status.
func (m *MachineScope) PatchObject(ctx context.Context) error <span class="cov0" title="0">{
        conditions.SetSummary(m.AzureMachine)

        return m.patchHelper.Patch(
                ctx,
                m.AzureMachine,
                patch.WithOwnedConditions{Conditions: []clusterv1.ConditionType{
                        clusterv1.ReadyCondition,
                        infrav1.VMRunningCondition,
                        infrav1.AvailabilitySetReadyCondition,
                        infrav1.NetworkInterfaceReadyCondition,
                }})
}</span>

// Close the MachineScope by updating the machine spec, machine status.
func (m *MachineScope) Close(ctx context.Context) error <span class="cov0" title="0">{
        return m.PatchObject(ctx)
}</span>

// AdditionalTags merges AdditionalTags from the scope's AzureCluster and AzureMachine. If the same key is present in both,
// the value from AzureMachine takes precedence.
func (m *MachineScope) AdditionalTags() infrav1.Tags <span class="cov8" title="1">{
        tags := make(infrav1.Tags)
        // Start with the cluster-wide tags...
        tags.Merge(m.ClusterScoper.AdditionalTags())
        // ... and merge in the Machine's
        tags.Merge(m.AzureMachine.Spec.AdditionalTags)
        // Set the cloud provider tag
        tags[infrav1.ClusterAzureCloudProviderTagKey(m.ClusterName())] = string(infrav1.ResourceLifecycleOwned)

        return tags
}</span>

// GetBootstrapData returns the bootstrap data from the secret in the Machine's bootstrap.dataSecretName.
func (m *MachineScope) GetBootstrapData(ctx context.Context) (string, error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "scope.MachineScope.GetBootstrapData")
        defer done()

        if m.Machine.Spec.Bootstrap.DataSecretName == nil </span><span class="cov0" title="0">{
                return "", errors.New("error retrieving bootstrap data: linked Machine's bootstrap.dataSecretName is nil")
        }</span>
        <span class="cov0" title="0">secret := &amp;corev1.Secret{}
        key := types.NamespacedName{Namespace: m.Namespace(), Name: *m.Machine.Spec.Bootstrap.DataSecretName}
        if err := m.client.Get(ctx, key, secret); err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrapf(err, "failed to retrieve bootstrap data secret for AzureMachine %s/%s", m.Namespace(), m.Name())
        }</span>

        <span class="cov0" title="0">value, ok := secret.Data["value"]
        if !ok </span><span class="cov0" title="0">{
                return "", errors.New("error retrieving bootstrap data: secret value key is missing")
        }</span>
        <span class="cov0" title="0">return base64.StdEncoding.EncodeToString(value), nil</span>
}

// GetVMImage returns the image from the machine configuration, or a default one.
func (m *MachineScope) GetVMImage(ctx context.Context) (*infrav1.Image, error) <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "scope.MachineScope.GetVMImage")
        defer done()

        // Use custom Marketplace image, Image ID or a Shared Image Gallery image if provided
        if m.AzureMachine.Spec.Image != nil </span><span class="cov8" title="1">{
                return m.AzureMachine.Spec.Image, nil
        }</span>

        <span class="cov8" title="1">svc := virtualmachineimages.New(m)

        if m.AzureMachine.Spec.OSDisk.OSType == azure.WindowsOS </span><span class="cov8" title="1">{
                runtime := m.AzureMachine.Annotations["runtime"]
                windowsServerVersion := m.AzureMachine.Annotations["windowsServerVersion"]
                log.Info("No image specified for machine, using default Windows Image", "machine", m.AzureMachine.GetName(), "runtime", runtime, "windowsServerVersion", windowsServerVersion)
                return svc.GetDefaultWindowsImage(ctx, m.Location(), to.String(m.Machine.Spec.Version), runtime, windowsServerVersion)
        }</span>

        <span class="cov8" title="1">log.Info("No image specified for machine, using default Linux Image", "machine", m.AzureMachine.GetName())
        return svc.GetDefaultUbuntuImage(ctx, m.Location(), to.String(m.Machine.Spec.Version))</span>
}

// SetSubnetName defaults the AzureMachine subnet name to the name of one the subnets with the machine role when there is only one of them.
// Note: this logic exists only for purposes of ensuring backwards compatibility for old clusters created without the `subnetName` field being
// set, and should be removed in the future when this field is no longer optional.
func (m *MachineScope) SetSubnetName() error <span class="cov0" title="0">{
        if m.AzureMachine.Spec.SubnetName == "" </span><span class="cov0" title="0">{
                subnetName := ""
                subnets := m.Subnets()
                var subnetCount int
                for _, subnet := range subnets </span><span class="cov0" title="0">{
                        if string(subnet.Role) == m.Role() </span><span class="cov0" title="0">{
                                subnetCount++
                                subnetName = subnet.Name
                        }</span>
                }
                <span class="cov0" title="0">if subnetCount == 0 || subnetCount &gt; 1 || subnetName == "" </span><span class="cov0" title="0">{
                        return errors.New("a subnet name must be specified when no subnets are specified or more than 1 subnet of the same role exist")
                }</span>

                <span class="cov0" title="0">m.AzureMachine.Spec.SubnetName = subnetName</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// SetLongRunningOperationState will set the future on the AzureMachine status to allow the resource to continue
// in the next reconciliation.
func (m *MachineScope) SetLongRunningOperationState(future *infrav1.Future) <span class="cov0" title="0">{
        futures.Set(m.AzureMachine, future)
}</span>

// GetLongRunningOperationState will get the future on the AzureMachine status.
func (m *MachineScope) GetLongRunningOperationState(name, service string) *infrav1.Future <span class="cov0" title="0">{
        return futures.Get(m.AzureMachine, name, service)
}</span>

// DeleteLongRunningOperationState will delete the future from the AzureMachine status.
func (m *MachineScope) DeleteLongRunningOperationState(name, service string) <span class="cov0" title="0">{
        futures.Delete(m.AzureMachine, name, service)
}</span>

// UpdateDeleteStatus updates a condition on the AzureMachine status after a DELETE operation.
func (m *MachineScope) UpdateDeleteStatus(condition clusterv1.ConditionType, service string, err error) <span class="cov0" title="0">{
        switch </span>{
        case err == nil:<span class="cov0" title="0">
                conditions.MarkFalse(m.AzureMachine, condition, infrav1.DeletedReason, clusterv1.ConditionSeverityInfo, "%s successfully deleted", service)</span>
        case azure.IsOperationNotDoneError(err):<span class="cov0" title="0">
                conditions.MarkFalse(m.AzureMachine, condition, infrav1.DeletingReason, clusterv1.ConditionSeverityInfo, "%s deleting", service)</span>
        default:<span class="cov0" title="0">
                conditions.MarkFalse(m.AzureMachine, condition, infrav1.DeletionFailedReason, clusterv1.ConditionSeverityError, "%s failed to delete. err: %s", service, err.Error())</span>
        }
}

// UpdatePutStatus updates a condition on the AzureMachine status after a PUT operation.
func (m *MachineScope) UpdatePutStatus(condition clusterv1.ConditionType, service string, err error) <span class="cov0" title="0">{
        switch </span>{
        case err == nil:<span class="cov0" title="0">
                conditions.MarkTrue(m.AzureMachine, condition)</span>
        case azure.IsOperationNotDoneError(err):<span class="cov0" title="0">
                conditions.MarkFalse(m.AzureMachine, condition, infrav1.CreatingReason, clusterv1.ConditionSeverityInfo, "%s creating or updating", service)</span>
        default:<span class="cov0" title="0">
                conditions.MarkFalse(m.AzureMachine, condition, infrav1.FailedReason, clusterv1.ConditionSeverityError, "%s failed to create or update. err: %s", service, err.Error())</span>
        }
}

// UpdatePatchStatus updates a condition on the AzureMachine status after a PATCH operation.
func (m *MachineScope) UpdatePatchStatus(condition clusterv1.ConditionType, service string, err error) <span class="cov0" title="0">{
        switch </span>{
        case err == nil:<span class="cov0" title="0">
                conditions.MarkTrue(m.AzureMachine, condition)</span>
        case azure.IsOperationNotDoneError(err):<span class="cov0" title="0">
                conditions.MarkFalse(m.AzureMachine, condition, infrav1.UpdatingReason, clusterv1.ConditionSeverityInfo, "%s updating", service)</span>
        default:<span class="cov0" title="0">
                conditions.MarkFalse(m.AzureMachine, condition, infrav1.FailedReason, clusterv1.ConditionSeverityError, "%s failed to update. err: %s", service, err.Error())</span>
        }
}
</pre>
		
		<pre class="file" id="file71" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package scope

import (
        "context"
        "encoding/base64"
        "time"

        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/utils/pointer"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        machinepool "sigs.k8s.io/cluster-api-provider-azure/azure/scope/strategies/machinepool_deployments"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/roleassignments"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/scalesets"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/virtualmachineimages"
        infrav1exp "sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/util/futures"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        "sigs.k8s.io/cluster-api/controllers/noderefutil"
        capierrors "sigs.k8s.io/cluster-api/errors"
        expv1 "sigs.k8s.io/cluster-api/exp/api/v1beta1"
        "sigs.k8s.io/cluster-api/util/conditions"
        "sigs.k8s.io/cluster-api/util/patch"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
)

// ScalesetsServiceName is the name of the scalesets service.
// TODO: move this to scalesets.go once we remove the usage in this package,
// added here to avoid a circular dependency.
const ScalesetsServiceName = "scalesets"

type (
        // MachinePoolScopeParams defines the input parameters used to create a new MachinePoolScope.
        MachinePoolScopeParams struct {
                Client           client.Client
                MachinePool      *expv1.MachinePool
                AzureMachinePool *infrav1exp.AzureMachinePool
                ClusterScope     azure.ClusterScoper
        }

        // MachinePoolScope defines a scope defined around a machine pool and its cluster.
        MachinePoolScope struct {
                azure.ClusterScoper
                AzureMachinePool *infrav1exp.AzureMachinePool
                MachinePool      *expv1.MachinePool
                client           client.Client
                patchHelper      *patch.Helper
                vmssState        *azure.VMSS
        }

        // NodeStatus represents the status of a Kubernetes node.
        NodeStatus struct {
                Ready   bool
                Version string
        }
)

// NewMachinePoolScope creates a new MachinePoolScope from the supplied parameters.
// This is meant to be called for each reconcile iteration.
func NewMachinePoolScope(params MachinePoolScopeParams) (*MachinePoolScope, error) <span class="cov8" title="1">{
        if params.Client == nil </span><span class="cov0" title="0">{
                return nil, errors.New("client is required when creating a MachinePoolScope")
        }</span>

        <span class="cov8" title="1">if params.MachinePool == nil </span><span class="cov0" title="0">{
                return nil, errors.New("machine pool is required when creating a MachinePoolScope")
        }</span>

        <span class="cov8" title="1">if params.AzureMachinePool == nil </span><span class="cov0" title="0">{
                return nil, errors.New("azure machine pool is required when creating a MachinePoolScope")
        }</span>

        <span class="cov8" title="1">helper, err := patch.NewHelper(params.AzureMachinePool, params.Client)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to init patch helper")
        }</span>

        <span class="cov8" title="1">return &amp;MachinePoolScope{
                client:           params.Client,
                MachinePool:      params.MachinePool,
                AzureMachinePool: params.AzureMachinePool,
                patchHelper:      helper,
                ClusterScoper:    params.ClusterScope,
        }, nil</span>
}

// ScaleSetSpec returns the scale set spec.
func (m *MachinePoolScope) ScaleSetSpec() azure.ScaleSetSpec <span class="cov0" title="0">{
        return azure.ScaleSetSpec{
                Name:                         m.Name(),
                Size:                         m.AzureMachinePool.Spec.Template.VMSize,
                Capacity:                     int64(to.Int32(m.MachinePool.Spec.Replicas)),
                SSHKeyData:                   m.AzureMachinePool.Spec.Template.SSHPublicKey,
                OSDisk:                       m.AzureMachinePool.Spec.Template.OSDisk,
                DataDisks:                    m.AzureMachinePool.Spec.Template.DataDisks,
                SubnetName:                   m.AzureMachinePool.Spec.Template.SubnetName,
                VNetName:                     m.Vnet().Name,
                VNetResourceGroup:            m.Vnet().ResourceGroup,
                PublicLBName:                 m.OutboundLBName(infrav1.Node),
                PublicLBAddressPoolName:      azure.GenerateOutboundBackendAddressPoolName(m.OutboundLBName(infrav1.Node)),
                AcceleratedNetworking:        m.AzureMachinePool.Spec.Template.AcceleratedNetworking,
                Identity:                     m.AzureMachinePool.Spec.Identity,
                UserAssignedIdentities:       m.AzureMachinePool.Spec.UserAssignedIdentities,
                SecurityProfile:              m.AzureMachinePool.Spec.Template.SecurityProfile,
                SpotVMOptions:                m.AzureMachinePool.Spec.Template.SpotVMOptions,
                FailureDomains:               m.MachinePool.Spec.FailureDomains,
                TerminateNotificationTimeout: m.AzureMachinePool.Spec.Template.TerminateNotificationTimeout,
        }
}</span>

// Name returns the Azure Machine Pool Name.
func (m *MachinePoolScope) Name() string <span class="cov8" title="1">{
        // Windows Machine pools names cannot be longer than 9 chars
        if m.AzureMachinePool.Spec.Template.OSDisk.OSType == azure.WindowsOS &amp;&amp; len(m.AzureMachinePool.Name) &gt; 9 </span><span class="cov8" title="1">{
                return "win-" + m.AzureMachinePool.Name[len(m.AzureMachinePool.Name)-5:]
        }</span>
        <span class="cov8" title="1">return m.AzureMachinePool.Name</span>
}

// ProviderID returns the AzureMachinePool ID by parsing Spec.FakeProviderID.
func (m *MachinePoolScope) ProviderID() string <span class="cov0" title="0">{
        parsed, err := noderefutil.NewProviderID(m.AzureMachinePool.Spec.ProviderID)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return parsed.ID()</span>
}

// SetProviderID sets the AzureMachinePool providerID in spec.
func (m *MachinePoolScope) SetProviderID(v string) <span class="cov0" title="0">{
        m.AzureMachinePool.Spec.ProviderID = v
}</span>

// ProvisioningState returns the AzureMachinePool provisioning state.
func (m *MachinePoolScope) ProvisioningState() infrav1.ProvisioningState <span class="cov0" title="0">{
        if m.AzureMachinePool.Status.ProvisioningState != nil </span><span class="cov0" title="0">{
                return *m.AzureMachinePool.Status.ProvisioningState
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// SetVMSSState updates the machine pool scope with the current state of the VMSS.
func (m *MachinePoolScope) SetVMSSState(vmssState *azure.VMSS) <span class="cov0" title="0">{
        m.vmssState = vmssState
}</span>

// NeedsRequeue return true if any machines are not on the latest model or the VMSS is not in a terminal provisioning
// state.
func (m *MachinePoolScope) NeedsRequeue() bool <span class="cov8" title="1">{
        state := m.AzureMachinePool.Status.ProvisioningState
        if m.vmssState == nil </span><span class="cov0" title="0">{
                return state != nil &amp;&amp; infrav1.IsTerminalProvisioningState(*state)
        }</span>

        <span class="cov8" title="1">if !m.vmssState.HasLatestModelAppliedToAll() </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">desiredMatchesActual := len(m.vmssState.Instances) == int(m.DesiredReplicas())
        return !(state != nil &amp;&amp; infrav1.IsTerminalProvisioningState(*state) &amp;&amp; desiredMatchesActual)</span>
}

// DesiredReplicas returns the replica count on machine pool or 0 if machine pool replicas is nil.
func (m MachinePoolScope) DesiredReplicas() int32 <span class="cov8" title="1">{
        return to.Int32(m.MachinePool.Spec.Replicas)
}</span>

// MaxSurge returns the number of machines to surge, or 0 if the deployment strategy does not support surge.
func (m MachinePoolScope) MaxSurge() (int, error) <span class="cov8" title="1">{
        if surger, ok := m.getDeploymentStrategy().(machinepool.Surger); ok </span><span class="cov8" title="1">{
                surgeCount, err := surger.Surge(int(m.DesiredReplicas()))
                if err != nil </span><span class="cov0" title="0">{
                        return 0, errors.Wrap(err, "failed to calculate surge for the machine pool")
                }</span>

                <span class="cov8" title="1">return surgeCount, nil</span>
        }

        <span class="cov0" title="0">return 0, nil</span>
}

// updateReplicasAndProviderIDs ties the Azure VMSS instance data and the Node status data together to build and update
// the AzureMachinePool replica count and providerIDList.
func (m *MachinePoolScope) updateReplicasAndProviderIDs(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "scope.MachinePoolScope.UpdateInstanceStatuses")
        defer done()

        machines, err := m.getMachinePoolMachines(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to get machine pool machines")
        }</span>

        <span class="cov8" title="1">var readyReplicas int32
        providerIDs := make([]string, len(machines))
        for i, machine := range machines </span><span class="cov8" title="1">{
                if machine.Status.Ready </span><span class="cov8" title="1">{
                        readyReplicas++
                }</span>
                <span class="cov8" title="1">providerIDs[i] = machine.Spec.ProviderID</span>
        }

        <span class="cov8" title="1">m.AzureMachinePool.Status.Replicas = readyReplicas
        m.AzureMachinePool.Spec.ProviderIDList = providerIDs
        return nil</span>
}

func (m *MachinePoolScope) getMachinePoolMachines(ctx context.Context) ([]infrav1exp.AzureMachinePoolMachine, error) <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "scope.MachinePoolScope.getMachinePoolMachines")
        defer done()

        labels := map[string]string{
                clusterv1.ClusterLabelName:      m.ClusterName(),
                infrav1exp.MachinePoolNameLabel: m.AzureMachinePool.Name,
        }
        ampml := &amp;infrav1exp.AzureMachinePoolMachineList{}
        if err := m.client.List(ctx, ampml, client.InNamespace(m.AzureMachinePool.Namespace), client.MatchingLabels(labels)); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to list AzureMachinePoolMachines")
        }</span>

        <span class="cov8" title="1">return ampml.Items, nil</span>
}

func (m *MachinePoolScope) applyAzureMachinePoolMachines(ctx context.Context) error <span class="cov0" title="0">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "scope.MachinePoolScope.applyAzureMachinePoolMachines")
        defer done()

        if m.vmssState == nil </span><span class="cov0" title="0">{
                log.Info("vmssState is nil")
                return nil
        }</span>

        <span class="cov0" title="0">labels := map[string]string{
                clusterv1.ClusterLabelName:      m.ClusterName(),
                infrav1exp.MachinePoolNameLabel: m.AzureMachinePool.Name,
        }
        ampml := &amp;infrav1exp.AzureMachinePoolMachineList{}
        if err := m.client.List(ctx, ampml, client.InNamespace(m.AzureMachinePool.Namespace), client.MatchingLabels(labels)); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to list AzureMachinePoolMachines")
        }</span>

        <span class="cov0" title="0">existingMachinesByProviderID := make(map[string]infrav1exp.AzureMachinePoolMachine, len(ampml.Items))
        for _, machine := range ampml.Items </span><span class="cov0" title="0">{
                existingMachinesByProviderID[machine.Spec.ProviderID] = machine
        }</span>

        // determine which machines need to be created to reflect the current state in Azure
        <span class="cov0" title="0">azureMachinesByProviderID := m.vmssState.InstancesByProviderID()
        for key, val := range azureMachinesByProviderID </span><span class="cov0" title="0">{
                if _, ok := existingMachinesByProviderID[key]; !ok </span><span class="cov0" title="0">{
                        log.V(4).Info("creating AzureMachinePoolMachine", "providerID", key)
                        if err := m.createMachine(ctx, val); err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "failed creating AzureMachinePoolMachine")
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
        }

        <span class="cov0" title="0">deleted := false
        // delete machines that no longer exist in Azure
        for key, machine := range existingMachinesByProviderID </span><span class="cov0" title="0">{
                machine := machine
                if _, ok := azureMachinesByProviderID[key]; !ok </span><span class="cov0" title="0">{
                        deleted = true
                        log.V(4).Info("deleting AzureMachinePoolMachine because it no longer exists in the VMSS", "providerID", key)
                        delete(existingMachinesByProviderID, key)
                        if err := m.client.Delete(ctx, &amp;machine); err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "failed deleting AzureMachinePoolMachine to reduce replica count")
                        }</span>
                }
        }

        <span class="cov0" title="0">if deleted </span><span class="cov0" title="0">{
                log.V(4).Info("exiting early due to finding AzureMachinePoolMachine(s) that were deleted because they no longer exist in the VMSS")
                // exit early to be less greedy about delete
                return nil
        }</span>

        <span class="cov0" title="0">if futures.Has(m.AzureMachinePool, m.Name(), ScalesetsServiceName) </span><span class="cov0" title="0">{
                log.V(4).Info("exiting early due an in-progress long running operation on the ScaleSet")
                // exit early to be less greedy about delete
                return nil
        }</span>

        <span class="cov0" title="0">deleteSelector := m.getDeploymentStrategy()
        if deleteSelector == nil </span><span class="cov0" title="0">{
                log.V(4).Info("can not select AzureMachinePoolMachines to delete because no deployment strategy is specified")
                return nil
        }</span>

        // select machines to delete to lower the replica count
        <span class="cov0" title="0">toDelete, err := deleteSelector.SelectMachinesToDelete(ctx, m.DesiredReplicas(), existingMachinesByProviderID)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed selecting AzureMachinePoolMachine(s) to delete")
        }</span>

        <span class="cov0" title="0">for _, machine := range toDelete </span><span class="cov0" title="0">{
                machine := machine
                log.Info("deleting selected AzureMachinePoolMachine", "providerID", machine.Spec.ProviderID)
                if err := m.client.Delete(ctx, &amp;machine); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed deleting AzureMachinePoolMachine to reduce replica count")
                }</span>
        }

        <span class="cov0" title="0">log.V(4).Info("done reconciling AzureMachinePoolMachine(s)")
        return nil</span>
}

func (m *MachinePoolScope) createMachine(ctx context.Context, machine azure.VMSSVM) error <span class="cov0" title="0">{
        if machine.InstanceID == "" </span><span class="cov0" title="0">{
                return errors.New("machine.InstanceID must not be empty")
        }</span>

        <span class="cov0" title="0">if machine.Name == "" </span><span class="cov0" title="0">{
                return errors.New("machine.Name must not be empty")
        }</span>

        <span class="cov0" title="0">ampm := infrav1exp.AzureMachinePoolMachine{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      m.AzureMachinePool.Name + "-" + machine.InstanceID,
                        Namespace: m.AzureMachinePool.Namespace,
                        OwnerReferences: []metav1.OwnerReference{
                                {
                                        APIVersion:         infrav1exp.GroupVersion.String(),
                                        Kind:               "AzureMachinePool",
                                        Name:               m.AzureMachinePool.Name,
                                        BlockOwnerDeletion: to.BoolPtr(true),
                                        UID:                m.AzureMachinePool.UID,
                                },
                        },
                        Labels: map[string]string{
                                m.ClusterName():                 string(infrav1.ResourceLifecycleOwned),
                                clusterv1.ClusterLabelName:      m.ClusterName(),
                                infrav1exp.MachinePoolNameLabel: m.AzureMachinePool.Name,
                        },
                },
                Spec: infrav1exp.AzureMachinePoolMachineSpec{
                        ProviderID: machine.ProviderID(),
                        InstanceID: machine.InstanceID,
                },
        }

        controllerutil.AddFinalizer(&amp;ampm, infrav1exp.AzureMachinePoolMachineFinalizer)
        conditions.MarkFalse(&amp;ampm, infrav1.VMRunningCondition, string(infrav1.Creating), clusterv1.ConditionSeverityInfo, "")
        if err := m.client.Create(ctx, &amp;ampm); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed creating AzureMachinePoolMachine %s in AzureMachinePool %s", machine.ID, m.AzureMachinePool.Name)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SetLongRunningOperationState will set the future on the AzureMachinePool status to allow the resource to continue
// in the next reconciliation.
func (m *MachinePoolScope) SetLongRunningOperationState(future *infrav1.Future) <span class="cov0" title="0">{
        futures.Set(m.AzureMachinePool, future)
}</span>

// GetLongRunningOperationState will get the future on the AzureMachinePool status.
func (m *MachinePoolScope) GetLongRunningOperationState(name, service string) *infrav1.Future <span class="cov0" title="0">{
        return futures.Get(m.AzureMachinePool, name, service)
}</span>

// DeleteLongRunningOperationState will delete the future from the AzureMachinePool status.
func (m *MachinePoolScope) DeleteLongRunningOperationState(name, service string) <span class="cov0" title="0">{
        futures.Delete(m.AzureMachinePool, name, service)
}</span>

// setProvisioningStateAndConditions sets the AzureMachinePool provisioning state and conditions.
func (m *MachinePoolScope) setProvisioningStateAndConditions(v infrav1.ProvisioningState) <span class="cov0" title="0">{
        m.AzureMachinePool.Status.ProvisioningState = &amp;v
        switch </span>{
        case v == infrav1.Succeeded &amp;&amp; *m.MachinePool.Spec.Replicas == m.AzureMachinePool.Status.Replicas:<span class="cov0" title="0">
                // vmss is provisioned with enough ready replicas
                conditions.MarkTrue(m.AzureMachinePool, infrav1.ScaleSetRunningCondition)
                conditions.MarkTrue(m.AzureMachinePool, infrav1.ScaleSetModelUpdatedCondition)
                conditions.MarkTrue(m.AzureMachinePool, infrav1.ScaleSetDesiredReplicasCondition)
                m.SetReady()</span>
        case v == infrav1.Succeeded &amp;&amp; *m.MachinePool.Spec.Replicas != m.AzureMachinePool.Status.Replicas:<span class="cov0" title="0">
                // not enough ready or too many ready replicas we must still be scaling up or down
                updatingState := infrav1.Updating
                m.AzureMachinePool.Status.ProvisioningState = &amp;updatingState
                if *m.MachinePool.Spec.Replicas &gt; m.AzureMachinePool.Status.Replicas </span><span class="cov0" title="0">{
                        conditions.MarkFalse(m.AzureMachinePool, infrav1.ScaleSetDesiredReplicasCondition, infrav1.ScaleSetScaleUpReason, clusterv1.ConditionSeverityInfo, "")
                }</span> else<span class="cov0" title="0"> {
                        conditions.MarkFalse(m.AzureMachinePool, infrav1.ScaleSetDesiredReplicasCondition, infrav1.ScaleSetScaleDownReason, clusterv1.ConditionSeverityInfo, "")
                }</span>
                <span class="cov0" title="0">m.SetNotReady()</span>
        case v == infrav1.Updating:<span class="cov0" title="0">
                conditions.MarkFalse(m.AzureMachinePool, infrav1.ScaleSetModelUpdatedCondition, infrav1.ScaleSetModelOutOfDateReason, clusterv1.ConditionSeverityInfo, "")
                m.SetNotReady()</span>
        case v == infrav1.Creating:<span class="cov0" title="0">
                conditions.MarkFalse(m.AzureMachinePool, infrav1.ScaleSetRunningCondition, infrav1.ScaleSetCreatingReason, clusterv1.ConditionSeverityInfo, "")
                m.SetNotReady()</span>
        case v == infrav1.Deleting:<span class="cov0" title="0">
                conditions.MarkFalse(m.AzureMachinePool, infrav1.ScaleSetRunningCondition, infrav1.ScaleSetDeletingReason, clusterv1.ConditionSeverityInfo, "")
                m.SetNotReady()</span>
        default:<span class="cov0" title="0">
                conditions.MarkFalse(m.AzureMachinePool, infrav1.ScaleSetRunningCondition, string(v), clusterv1.ConditionSeverityInfo, "")
                m.SetNotReady()</span>
        }
}

// SetReady sets the AzureMachinePool Ready Status to true.
func (m *MachinePoolScope) SetReady() <span class="cov0" title="0">{
        m.AzureMachinePool.Status.Ready = true
}</span>

// SetNotReady sets the AzureMachinePool Ready Status to false.
func (m *MachinePoolScope) SetNotReady() <span class="cov0" title="0">{
        m.AzureMachinePool.Status.Ready = false
}</span>

// SetFailureMessage sets the AzureMachinePool status failure message.
func (m *MachinePoolScope) SetFailureMessage(v error) <span class="cov0" title="0">{
        m.AzureMachinePool.Status.FailureMessage = pointer.StringPtr(v.Error())
}</span>

// SetFailureReason sets the AzureMachinePool status failure reason.
func (m *MachinePoolScope) SetFailureReason(v capierrors.MachineStatusError) <span class="cov0" title="0">{
        m.AzureMachinePool.Status.FailureReason = &amp;v
}</span>

// SetBootstrapConditions sets the AzureMachinePool BootstrapSucceeded condition based on the extension provisioning states.
func (m *MachinePoolScope) SetBootstrapConditions(ctx context.Context, provisioningState string, extensionName string) error <span class="cov8" title="1">{
        _, log, done := tele.StartSpanWithLogger(ctx, "scope.MachinePoolScope.SetBootstrapConditions")
        defer done()

        switch infrav1.ProvisioningState(provisioningState) </span>{
        case infrav1.Succeeded:<span class="cov8" title="1">
                log.V(4).Info("extension provisioning state is succeeded", "vm extension", extensionName, "scale set", m.Name())
                conditions.MarkTrue(m.AzureMachinePool, infrav1.BootstrapSucceededCondition)
                return nil</span>
        case infrav1.Creating:<span class="cov8" title="1">
                log.V(4).Info("extension provisioning state is creating", "vm extension", extensionName, "scale set", m.Name())
                conditions.MarkFalse(m.AzureMachinePool, infrav1.BootstrapSucceededCondition, infrav1.BootstrapInProgressReason, clusterv1.ConditionSeverityInfo, "")
                return azure.WithTransientError(errors.New("extension is still in provisioning state. This likely means that bootstrapping has not yet completed on the VM"), 30*time.Second)</span>
        case infrav1.Failed:<span class="cov8" title="1">
                log.V(4).Info("extension provisioning state is failed", "vm extension", extensionName, "scale set", m.Name())
                conditions.MarkFalse(m.AzureMachinePool, infrav1.BootstrapSucceededCondition, infrav1.BootstrapFailedReason, clusterv1.ConditionSeverityError, "")
                return azure.WithTerminalError(errors.New("extension state failed. This likely means the Kubernetes node bootstrapping process failed or timed out. Check VM boot diagnostics logs to learn more"))</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// AdditionalTags merges AdditionalTags from the scope's AzureCluster and AzureMachinePool. If the same key is present in both,
// the value from AzureMachinePool takes precedence.
func (m *MachinePoolScope) AdditionalTags() infrav1.Tags <span class="cov0" title="0">{
        tags := make(infrav1.Tags)
        // Start with the cluster-wide tags...
        tags.Merge(m.ClusterScoper.AdditionalTags())
        // ... and merge in the Machine Pool's
        tags.Merge(m.AzureMachinePool.Spec.AdditionalTags)
        // Set the cloud provider tag
        tags[infrav1.ClusterAzureCloudProviderTagKey(m.ClusterName())] = string(infrav1.ResourceLifecycleOwned)

        return tags
}</span>

// SetAnnotation sets a key value annotation on the AzureMachinePool.
func (m *MachinePoolScope) SetAnnotation(key, value string) <span class="cov0" title="0">{
        if m.AzureMachinePool.Annotations == nil </span><span class="cov0" title="0">{
                m.AzureMachinePool.Annotations = map[string]string{}
        }</span>
        <span class="cov0" title="0">m.AzureMachinePool.Annotations[key] = value</span>
}

// PatchObject persists the AzureMachinePool spec and status.
func (m *MachinePoolScope) PatchObject(ctx context.Context) error <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "scope.MachinePoolScope.PatchObject")
        defer done()

        conditions.SetSummary(m.AzureMachinePool)
        return m.patchHelper.Patch(
                ctx,
                m.AzureMachinePool,
                patch.WithOwnedConditions{Conditions: []clusterv1.ConditionType{
                        clusterv1.ReadyCondition,
                        infrav1.BootstrapSucceededCondition,
                        infrav1.ScaleSetDesiredReplicasCondition,
                        infrav1.ScaleSetModelUpdatedCondition,
                        infrav1.ScaleSetRunningCondition,
                }})
}</span>

// Close the MachinePoolScope by updating the AzureMachinePool spec and AzureMachinePool status.
func (m *MachinePoolScope) Close(ctx context.Context) error <span class="cov0" title="0">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "scope.MachinePoolScope.Close")
        defer done()

        if m.vmssState != nil </span><span class="cov0" title="0">{
                if err := m.applyAzureMachinePoolMachines(ctx); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to apply changes to the AzureMachinePoolMachines")
                        return errors.Wrap(err, "failed to apply changes to AzureMachinePoolMachines")
                }</span>

                <span class="cov0" title="0">m.setProvisioningStateAndConditions(m.vmssState.State)
                if err := m.updateReplicasAndProviderIDs(ctx); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to update replicas and providerIDs")
                }</span>
        }

        <span class="cov0" title="0">return m.PatchObject(ctx)</span>
}

// GetBootstrapData returns the bootstrap data from the secret in the MachinePool's bootstrap.dataSecretName.
func (m *MachinePoolScope) GetBootstrapData(ctx context.Context) (string, error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "scope.MachinePoolScope.GetBootstrapData")
        defer done()

        dataSecretName := m.MachinePool.Spec.Template.Spec.Bootstrap.DataSecretName
        if dataSecretName == nil </span><span class="cov0" title="0">{
                return "", errors.New("error retrieving bootstrap data: linked MachinePool Spec's bootstrap.dataSecretName is nil")
        }</span>
        <span class="cov0" title="0">secret := &amp;corev1.Secret{}
        key := types.NamespacedName{Namespace: m.AzureMachinePool.Namespace, Name: *dataSecretName}
        if err := m.client.Get(ctx, key, secret); err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrapf(err, "failed to retrieve bootstrap data secret for AzureMachinePool %s/%s", m.AzureMachinePool.Namespace, m.Name())
        }</span>

        <span class="cov0" title="0">value, ok := secret.Data["value"]
        if !ok </span><span class="cov0" title="0">{
                return "", errors.New("error retrieving bootstrap data: secret value key is missing")
        }</span>
        <span class="cov0" title="0">return base64.StdEncoding.EncodeToString(value), nil</span>
}

// GetVMImage picks an image from the AzureMachinePool configuration, or uses a default one.
func (m *MachinePoolScope) GetVMImage(ctx context.Context) (*infrav1.Image, error) <span class="cov8" title="1">{
        _, log, done := tele.StartSpanWithLogger(ctx, "scope.MachinePoolScope.GetVMImage")
        defer done()

        // Use custom Marketplace image, Image ID or a Shared Image Gallery image if provided
        if m.AzureMachinePool.Spec.Template.Image != nil </span><span class="cov8" title="1">{
                return m.AzureMachinePool.Spec.Template.Image, nil
        }</span>

        <span class="cov8" title="1">svc := virtualmachineimages.New(m)

        var (
                err          error
                defaultImage *infrav1.Image
        )
        if m.AzureMachinePool.Spec.Template.OSDisk.OSType == azure.WindowsOS </span><span class="cov0" title="0">{
                runtime := m.AzureMachinePool.Annotations["runtime"]
                windowsServerVersion := m.AzureMachinePool.Annotations["windowsServerVersion"]
                log.V(4).Info("No image specified for machine, using default Windows Image", "machine", m.MachinePool.GetName(), "runtime", runtime, "windowsServerVersion", windowsServerVersion)
                defaultImage, err = svc.GetDefaultWindowsImage(ctx, m.Location(), to.String(m.MachinePool.Spec.Template.Spec.Version), runtime, windowsServerVersion)
        }</span> else<span class="cov8" title="1"> {
                defaultImage, err = svc.GetDefaultUbuntuImage(ctx, m.Location(), to.String(m.MachinePool.Spec.Template.Spec.Version))
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return defaultImage, errors.Wrap(err, "failed to get default OS image")
        }</span>

        <span class="cov8" title="1">return defaultImage, nil</span>
}

// SaveVMImageToStatus persists the AzureMachinePool image to the status.
func (m *MachinePoolScope) SaveVMImageToStatus(image *infrav1.Image) <span class="cov8" title="1">{
        m.AzureMachinePool.Status.Image = image
}</span>

// RoleAssignmentSpecs returns the role assignment specs.
func (m *MachinePoolScope) RoleAssignmentSpecs(principalID *string) []azure.ResourceSpecGetter <span class="cov0" title="0">{
        roles := make([]azure.ResourceSpecGetter, 1)
        if m.HasSystemAssignedIdentity() </span><span class="cov0" title="0">{
                roles[0] = &amp;roleassignments.RoleAssignmentSpec{
                        Name:          m.AzureMachinePool.Spec.RoleAssignmentName,
                        MachineName:   m.Name(),
                        ResourceGroup: m.ResourceGroup(),
                        ResourceType:  azure.VirtualMachineScaleSet,
                        PrincipalID:   principalID,
                }
                return roles
        }</span>
        <span class="cov0" title="0">return []azure.ResourceSpecGetter{}</span>
}

// RoleAssignmentResourceType returns the role assignment resource type.
func (m *MachinePoolScope) RoleAssignmentResourceType() string <span class="cov0" title="0">{
        return azure.VirtualMachineScaleSet
}</span>

// HasSystemAssignedIdentity returns true if the azure machine pool has system
// assigned identity.
func (m *MachinePoolScope) HasSystemAssignedIdentity() bool <span class="cov0" title="0">{
        return m.AzureMachinePool.Spec.Identity == infrav1.VMIdentitySystemAssigned
}</span>

// VMSSExtensionSpecs returns the VMSS extension specs.
func (m *MachinePoolScope) VMSSExtensionSpecs() []azure.ResourceSpecGetter <span class="cov8" title="1">{
        var extensionSpecs = []azure.ResourceSpecGetter{}
        bootstrapExtensionSpec := azure.GetBootstrappingVMExtension(m.AzureMachinePool.Spec.Template.OSDisk.OSType, m.CloudEnvironment(), m.Name())

        if bootstrapExtensionSpec != nil </span><span class="cov8" title="1">{
                extensionSpecs = append(extensionSpecs, &amp;scalesets.VMSSExtensionSpec{
                        ExtensionSpec: *bootstrapExtensionSpec,
                        ResourceGroup: m.ResourceGroup(),
                })
        }</span>

        <span class="cov8" title="1">return extensionSpecs</span>
}

func (m *MachinePoolScope) getDeploymentStrategy() machinepool.TypedDeleteSelector <span class="cov8" title="1">{
        if m.AzureMachinePool == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return machinepool.NewMachinePoolDeploymentStrategy(m.AzureMachinePool.Spec.Strategy)</span>
}

// SetSubnetName defaults the AzureMachinePool subnet name to the name of the subnet with role 'node' when there is only one of them.
// Note: this logic exists only for purposes of ensuring backwards compatibility for old clusters created without the `subnetName` field being
// set, and should be removed in the future when this field is no longer optional.
func (m *MachinePoolScope) SetSubnetName() error <span class="cov0" title="0">{
        if m.AzureMachinePool.Spec.Template.SubnetName == "" </span><span class="cov0" title="0">{
                subnetName := ""
                for _, subnet := range m.NodeSubnets() </span><span class="cov0" title="0">{
                        subnetName = subnet.Name
                }</span>
                <span class="cov0" title="0">if len(m.NodeSubnets()) == 0 || len(m.NodeSubnets()) &gt; 1 || subnetName == "" </span><span class="cov0" title="0">{
                        return errors.New("a subnet name must be specified when no subnets are specified or more than 1 subnet of role 'node' exist")
                }</span>

                <span class="cov0" title="0">m.AzureMachinePool.Spec.Template.SubnetName = subnetName</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// UpdateDeleteStatus updates a condition on the AzureMachinePool status after a DELETE operation.
func (m *MachinePoolScope) UpdateDeleteStatus(condition clusterv1.ConditionType, service string, err error) <span class="cov0" title="0">{
        switch </span>{
        case err == nil:<span class="cov0" title="0">
                conditions.MarkFalse(m.AzureMachinePool, condition, infrav1.DeletedReason, clusterv1.ConditionSeverityInfo, "%s successfully deleted", service)</span>
        case azure.IsOperationNotDoneError(err):<span class="cov0" title="0">
                conditions.MarkFalse(m.AzureMachinePool, condition, infrav1.DeletingReason, clusterv1.ConditionSeverityInfo, "%s deleting", service)</span>
        default:<span class="cov0" title="0">
                conditions.MarkFalse(m.AzureMachinePool, condition, infrav1.DeletionFailedReason, clusterv1.ConditionSeverityError, "%s failed to delete. err: %s", service, err.Error())</span>
        }
}

// UpdatePutStatus updates a condition on the AzureMachinePool status after a PUT operation.
func (m *MachinePoolScope) UpdatePutStatus(condition clusterv1.ConditionType, service string, err error) <span class="cov0" title="0">{
        switch </span>{
        case err == nil:<span class="cov0" title="0">
                conditions.MarkTrue(m.AzureMachinePool, condition)</span>
        case azure.IsOperationNotDoneError(err):<span class="cov0" title="0">
                conditions.MarkFalse(m.AzureMachinePool, condition, infrav1.CreatingReason, clusterv1.ConditionSeverityInfo, "%s creating or updating", service)</span>
        default:<span class="cov0" title="0">
                conditions.MarkFalse(m.AzureMachinePool, condition, infrav1.FailedReason, clusterv1.ConditionSeverityError, "%s failed to create or update. err: %s", service, err.Error())</span>
        }
}

// UpdatePatchStatus updates a condition on the AzureMachinePool status after a PATCH operation.
func (m *MachinePoolScope) UpdatePatchStatus(condition clusterv1.ConditionType, service string, err error) <span class="cov0" title="0">{
        switch </span>{
        case err == nil:<span class="cov0" title="0">
                conditions.MarkTrue(m.AzureMachinePool, condition)</span>
        case azure.IsOperationNotDoneError(err):<span class="cov0" title="0">
                conditions.MarkFalse(m.AzureMachinePool, condition, infrav1.UpdatingReason, clusterv1.ConditionSeverityInfo, "%s updating", service)</span>
        default:<span class="cov0" title="0">
                conditions.MarkFalse(m.AzureMachinePool, condition, infrav1.FailedReason, clusterv1.ConditionSeverityError, "%s failed to update. err: %s", service, err.Error())</span>
        }
}
</pre>
		
		<pre class="file" id="file72" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package scope

import (
        "context"
        "fmt"
        "reflect"
        "time"

        "github.com/pkg/errors"
        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/client-go/kubernetes"
        "k8s.io/klog/v2"
        kubedrain "k8s.io/kubectl/pkg/drain"
        "k8s.io/utils/pointer"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        infrav1exp "sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/util/futures"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        "sigs.k8s.io/cluster-api/controllers/noderefutil"
        "sigs.k8s.io/cluster-api/controllers/remote"
        capierrors "sigs.k8s.io/cluster-api/errors"
        expv1 "sigs.k8s.io/cluster-api/exp/api/v1beta1"
        "sigs.k8s.io/cluster-api/util/conditions"
        "sigs.k8s.io/cluster-api/util/patch"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

const (
        // MachinePoolMachineScopeName is the sourceName, or more specifically the UserAgent, of client used in cordon and drain.
        MachinePoolMachineScopeName = "azuremachinepoolmachine-scope"
)

type (
        nodeGetter interface {
                GetNodeByProviderID(ctx context.Context, providerID string) (*corev1.Node, error)
                GetNodeByObjectReference(ctx context.Context, nodeRef corev1.ObjectReference) (*corev1.Node, error)
        }

        workloadClusterProxy struct {
                Client  client.Client
                Cluster client.ObjectKey
        }

        // MachinePoolMachineScopeParams defines the input parameters used to create a new MachinePoolScope.
        MachinePoolMachineScopeParams struct {
                AzureMachinePool        *infrav1exp.AzureMachinePool
                AzureMachinePoolMachine *infrav1exp.AzureMachinePoolMachine
                Client                  client.Client
                ClusterScope            azure.ClusterScoper
                MachinePool             *expv1.MachinePool

                // workloadNodeGetter is only used for testing purposes and provides a way for mocking requests to the workload cluster
                workloadNodeGetter nodeGetter
        }

        // MachinePoolMachineScope defines a scope defined around a machine pool machine.
        MachinePoolMachineScope struct {
                azure.ClusterScoper
                AzureMachinePoolMachine *infrav1exp.AzureMachinePoolMachine
                AzureMachinePool        *infrav1exp.AzureMachinePool
                MachinePool             *expv1.MachinePool
                MachinePoolScope        *MachinePoolScope
                client                  client.Client
                patchHelper             *patch.Helper
                instance                *azure.VMSSVM

                // workloadNodeGetter is only used for testing purposes and provides a way for mocking requests to the workload cluster
                workloadNodeGetter nodeGetter
        }
)

// NewMachinePoolMachineScope creates a new MachinePoolMachineScope from the supplied parameters.
// This is meant to be called for each reconcile iteration.
func NewMachinePoolMachineScope(params MachinePoolMachineScopeParams) (*MachinePoolMachineScope, error) <span class="cov8" title="1">{
        if params.Client == nil </span><span class="cov8" title="1">{
                return nil, errors.New("client is required when creating a MachinePoolScope")
        }</span>

        <span class="cov8" title="1">if params.ClusterScope == nil </span><span class="cov8" title="1">{
                return nil, errors.New("cluster scope is required when creating a MachinePoolScope")
        }</span>

        <span class="cov8" title="1">if params.MachinePool == nil </span><span class="cov8" title="1">{
                return nil, errors.New("machine pool is required when creating a MachinePoolScope")
        }</span>

        <span class="cov8" title="1">if params.AzureMachinePool == nil </span><span class="cov8" title="1">{
                return nil, errors.New("azure machine pool is required when creating a MachinePoolScope")
        }</span>

        <span class="cov8" title="1">if params.AzureMachinePoolMachine == nil </span><span class="cov8" title="1">{
                return nil, errors.New("azure machine pool machine is required when creating a MachinePoolScope")
        }</span>

        <span class="cov8" title="1">if params.workloadNodeGetter == nil </span><span class="cov8" title="1">{
                params.workloadNodeGetter = newWorkloadClusterProxy(
                        params.Client,
                        client.ObjectKey{
                                Namespace: params.MachinePool.Namespace,
                                Name:      params.ClusterScope.ClusterName(),
                        },
                )
        }</span>

        <span class="cov8" title="1">mpScope, err := NewMachinePoolScope(MachinePoolScopeParams{
                Client:           params.Client,
                MachinePool:      params.MachinePool,
                AzureMachinePool: params.AzureMachinePool,
                ClusterScope:     params.ClusterScope,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to build machine pool scope")
        }</span>

        <span class="cov8" title="1">helper, err := patch.NewHelper(params.AzureMachinePoolMachine, params.Client)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to init patch helper")
        }</span>

        <span class="cov8" title="1">return &amp;MachinePoolMachineScope{
                AzureMachinePool:        params.AzureMachinePool,
                AzureMachinePoolMachine: params.AzureMachinePoolMachine,
                ClusterScoper:           params.ClusterScope,
                MachinePool:             params.MachinePool,
                MachinePoolScope:        mpScope,
                client:                  params.Client,
                patchHelper:             helper,
                workloadNodeGetter:      params.workloadNodeGetter,
        }, nil</span>
}

// Name is the name of the Machine Pool Machine.
func (s *MachinePoolMachineScope) Name() string <span class="cov0" title="0">{
        return s.AzureMachinePoolMachine.Name
}</span>

// InstanceID is the unique ID of the machine within the Machine Pool.
func (s *MachinePoolMachineScope) InstanceID() string <span class="cov0" title="0">{
        return s.AzureMachinePoolMachine.Spec.InstanceID
}</span>

// ScaleSetName is the name of the VMSS.
func (s *MachinePoolMachineScope) ScaleSetName() string <span class="cov0" title="0">{
        return s.MachinePoolScope.Name()
}</span>

// SetLongRunningOperationState will set the future on the AzureMachinePoolMachine status to allow the resource to continue
// in the next reconciliation.
func (s *MachinePoolMachineScope) SetLongRunningOperationState(future *infrav1.Future) <span class="cov0" title="0">{
        futures.Set(s.AzureMachinePoolMachine, future)
}</span>

// GetLongRunningOperationState will get the future on the AzureMachinePoolMachine status.
func (s *MachinePoolMachineScope) GetLongRunningOperationState(name, service string) *infrav1.Future <span class="cov0" title="0">{
        return futures.Get(s.AzureMachinePoolMachine, name, service)
}</span>

// DeleteLongRunningOperationState will delete the future from the AzureMachinePoolMachine status.
func (s *MachinePoolMachineScope) DeleteLongRunningOperationState(name, service string) <span class="cov0" title="0">{
        futures.Delete(s.AzureMachinePoolMachine, name, service)
}</span>

// UpdateDeleteStatus updates a condition on the AzureMachinePoolMachine status after a DELETE operation.
func (s *MachinePoolMachineScope) UpdateDeleteStatus(condition clusterv1.ConditionType, service string, err error) <span class="cov0" title="0">{
        switch </span>{
        case err == nil:<span class="cov0" title="0">
                conditions.MarkFalse(s.AzureMachinePoolMachine, condition, infrav1.DeletedReason, clusterv1.ConditionSeverityInfo, "%s successfully deleted", service)</span>
        case azure.IsOperationNotDoneError(err):<span class="cov0" title="0">
                conditions.MarkFalse(s.AzureMachinePoolMachine, condition, infrav1.DeletingReason, clusterv1.ConditionSeverityInfo, "%s deleting", service)</span>
        default:<span class="cov0" title="0">
                conditions.MarkFalse(s.AzureMachinePoolMachine, condition, infrav1.DeletionFailedReason, clusterv1.ConditionSeverityError, "%s failed to delete. err: %s", service, err.Error())</span>
        }
}

// UpdatePutStatus updates a condition on the AzureMachinePoolMachine status after a PUT operation.
func (s *MachinePoolMachineScope) UpdatePutStatus(condition clusterv1.ConditionType, service string, err error) <span class="cov0" title="0">{
        switch </span>{
        case err == nil:<span class="cov0" title="0">
                conditions.MarkTrue(s.AzureMachinePoolMachine, condition)</span>
        case azure.IsOperationNotDoneError(err):<span class="cov0" title="0">
                conditions.MarkFalse(s.AzureMachinePoolMachine, condition, infrav1.CreatingReason, clusterv1.ConditionSeverityInfo, "%s creating or updating", service)</span>
        default:<span class="cov0" title="0">
                conditions.MarkFalse(s.AzureMachinePoolMachine, condition, infrav1.FailedReason, clusterv1.ConditionSeverityError, "%s failed to create or update. err: %s", service, err.Error())</span>
        }
}

// UpdatePatchStatus updates a condition on the AzureMachinePoolMachine status after a PATCH operation.
func (s *MachinePoolMachineScope) UpdatePatchStatus(condition clusterv1.ConditionType, service string, err error) <span class="cov0" title="0">{
        switch </span>{
        case err == nil:<span class="cov0" title="0">
                conditions.MarkTrue(s.AzureMachinePoolMachine, condition)</span>
        case azure.IsOperationNotDoneError(err):<span class="cov0" title="0">
                conditions.MarkFalse(s.AzureMachinePoolMachine, condition, infrav1.UpdatingReason, clusterv1.ConditionSeverityInfo, "%s updating", service)</span>
        default:<span class="cov0" title="0">
                conditions.MarkFalse(s.AzureMachinePoolMachine, condition, infrav1.FailedReason, clusterv1.ConditionSeverityError, "%s failed to update. err: %s", service, err.Error())</span>
        }
}

// SetVMSSVM update the scope with the current state of the VMSS VM.
func (s *MachinePoolMachineScope) SetVMSSVM(instance *azure.VMSSVM) <span class="cov0" title="0">{
        s.instance = instance
}</span>

// ProvisioningState returns the AzureMachinePoolMachine provisioning state.
func (s *MachinePoolMachineScope) ProvisioningState() infrav1.ProvisioningState <span class="cov0" title="0">{
        if s.AzureMachinePoolMachine.Status.ProvisioningState != nil </span><span class="cov0" title="0">{
                return *s.AzureMachinePoolMachine.Status.ProvisioningState
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// IsReady indicates the machine has successfully provisioned and has a node ref associated.
func (s *MachinePoolMachineScope) IsReady() bool <span class="cov0" title="0">{
        state := s.AzureMachinePoolMachine.Status.ProvisioningState
        return s.AzureMachinePoolMachine.Status.Ready &amp;&amp; state != nil &amp;&amp; *state == infrav1.Succeeded
}</span>

// SetFailureMessage sets the AzureMachinePoolMachine status failure message.
func (s *MachinePoolMachineScope) SetFailureMessage(v error) <span class="cov0" title="0">{
        s.AzureMachinePoolMachine.Status.FailureMessage = pointer.StringPtr(v.Error())
}</span>

// SetFailureReason sets the AzureMachinePoolMachine status failure reason.
func (s *MachinePoolMachineScope) SetFailureReason(v capierrors.MachineStatusError) <span class="cov0" title="0">{
        s.AzureMachinePoolMachine.Status.FailureReason = &amp;v
}</span>

// ProviderID returns the AzureMachinePool ID by parsing Spec.FakeProviderID.
func (s *MachinePoolMachineScope) ProviderID() string <span class="cov8" title="1">{
        return s.AzureMachinePoolMachine.Spec.ProviderID
}</span>

// PatchObject persists the MachinePoolMachine spec and status.
func (s *MachinePoolMachineScope) PatchObject(ctx context.Context) error <span class="cov0" title="0">{
        conditions.SetSummary(s.AzureMachinePoolMachine)

        return s.patchHelper.Patch(
                ctx,
                s.AzureMachinePoolMachine,
                patch.WithOwnedConditions{Conditions: []clusterv1.ConditionType{
                        clusterv1.ReadyCondition,
                        clusterv1.MachineNodeHealthyCondition,
                }})
}</span>

// Close updates the state of MachinePoolMachine.
func (s *MachinePoolMachineScope) Close(ctx context.Context) error <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(
                ctx,
                "scope.MachinePoolMachineScope.Close",
        )
        defer done()

        return s.PatchObject(ctx)
}</span>

// UpdateNodeStatus AzureMachinePoolMachine conditions and ready status. It will also update the node ref and the Kubernetes
// version of the VM instance if the node is found.
// Note: This func should be called at the end of a reconcile request and after updating the scope with the most recent Azure data.
func (s *MachinePoolMachineScope) UpdateNodeStatus(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(
                ctx,
                "scope.MachinePoolMachineScope.UpdateNodeStatus",
        )
        defer done()

        var node *corev1.Node
        nodeRef := s.AzureMachinePoolMachine.Status.NodeRef

        // See if we can fetch a node using either the providerID or the nodeRef
        node, found, err := s.GetNode(ctx)
        switch </span>{
        case err != nil &amp;&amp; apierrors.IsNotFound(err) &amp;&amp; nodeRef != nil &amp;&amp; nodeRef.Name != "":<span class="cov0" title="0">
                // Node was not found due to 404 when finding by ObjectReference.
                conditions.MarkFalse(s.AzureMachinePoolMachine, clusterv1.MachineNodeHealthyCondition, clusterv1.NodeNotFoundReason, clusterv1.ConditionSeverityError, "")</span>
        case err != nil:<span class="cov8" title="1">
                // Failed due to an unexpected error
                return err</span>
        case !found &amp;&amp; s.ProviderID() == "":<span class="cov0" title="0">
                // Node was not found due to not having a providerID set
                conditions.MarkFalse(s.AzureMachinePoolMachine, clusterv1.MachineNodeHealthyCondition, clusterv1.WaitingForNodeRefReason, clusterv1.ConditionSeverityInfo, "")</span>
        case !found &amp;&amp; s.ProviderID() != "":<span class="cov8" title="1">
                // Node was not found due to not finding a matching node by providerID
                conditions.MarkFalse(s.AzureMachinePoolMachine, clusterv1.MachineNodeHealthyCondition, clusterv1.NodeProvisioningReason, clusterv1.ConditionSeverityInfo, "")</span>
        default:<span class="cov8" title="1">
                // Node was found. Check if it is ready.
                nodeReady := noderefutil.IsNodeReady(node)
                s.AzureMachinePoolMachine.Status.Ready = nodeReady
                if nodeReady </span><span class="cov8" title="1">{
                        conditions.MarkTrue(s.AzureMachinePoolMachine, clusterv1.MachineNodeHealthyCondition)
                }</span> else<span class="cov8" title="1"> {
                        conditions.MarkFalse(s.AzureMachinePoolMachine, clusterv1.MachineNodeHealthyCondition, clusterv1.NodeConditionsFailedReason, clusterv1.ConditionSeverityWarning, "")
                }</span>

                <span class="cov8" title="1">s.AzureMachinePoolMachine.Status.NodeRef = &amp;corev1.ObjectReference{
                        Kind:       node.Kind,
                        Namespace:  node.Namespace,
                        Name:       node.Name,
                        UID:        node.UID,
                        APIVersion: node.APIVersion,
                }

                s.AzureMachinePoolMachine.Status.Version = node.Status.NodeInfo.KubeletVersion</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// UpdateInstanceStatus updates the provisioning state of the AzureMachinePoolMachine and if it has the latest model applied
// using the VMSS VM instance.
// Note: This func should be called at the end of a reconcile request and after updating the scope with the most recent Azure data.
func (s *MachinePoolMachineScope) UpdateInstanceStatus(ctx context.Context) error <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(
                ctx,
                "scope.MachinePoolMachineScope.UpdateInstanceStatus",
        )
        defer done()

        if s.instance != nil </span><span class="cov0" title="0">{
                s.AzureMachinePoolMachine.Status.ProvisioningState = &amp;s.instance.State
                hasLatestModel, err := s.hasLatestModelApplied(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to determine if the VMSS instance has the latest model")
                }</span>

                <span class="cov0" title="0">s.AzureMachinePoolMachine.Status.LatestModelApplied = hasLatestModel</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// CordonAndDrain will cordon and drain the Kubernetes node associated with this AzureMachinePoolMachine.
func (s *MachinePoolMachineScope) CordonAndDrain(ctx context.Context) error <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(
                ctx,
                "scope.MachinePoolMachineScope.CordonAndDrain",
        )
        defer done()

        // See if we can fetch a node using either the providerID or the nodeRef
        node, found, err := s.GetNode(ctx)
        if err != nil </span><span class="cov8" title="1">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                // failed due to an unexpected error
                <span class="cov8" title="1">return errors.Wrap(err, "failed to get node")</span>
        } else<span class="cov8" title="1"> if !found </span><span class="cov8" title="1">{
                // node was not found due to not finding a nodes with the ProviderID
                return nil
        }</span>

        // Drain node before deletion and issue a patch in order to make this operation visible to the users.
        <span class="cov0" title="0">if s.isNodeDrainAllowed() </span><span class="cov0" title="0">{
                patchHelper, err := patch.NewHelper(s.AzureMachinePoolMachine, s.client)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to build a patchHelper when draining node")
                }</span>

                <span class="cov0" title="0">log.V(4).Info("Draining node", "node", node.Name)
                // The DrainingSucceededCondition never exists before the node is drained for the first time,
                // so its transition time can be used to record the first time draining.
                // This `if` condition prevents the transition time to be changed more than once.
                if conditions.Get(s.AzureMachinePoolMachine, clusterv1.DrainingSucceededCondition) == nil </span><span class="cov0" title="0">{
                        conditions.MarkFalse(s.AzureMachinePoolMachine, clusterv1.DrainingSucceededCondition, clusterv1.DrainingReason, clusterv1.ConditionSeverityInfo, "Draining the node before deletion")
                }</span>

                <span class="cov0" title="0">if err := patchHelper.Patch(ctx, s.AzureMachinePoolMachine); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to patch AzureMachinePoolMachine")
                }</span>

                <span class="cov0" title="0">if err := s.drainNode(ctx, node); err != nil </span><span class="cov0" title="0">{
                        // Check for condition existence. If the condition exists, it may have a different severity or message, which
                        // would cause the last transition time to be updated. The last transition time is used to determine how
                        // long to wait to timeout the node drain operation. If we were to keep updating the last transition time,
                        // a drain operation may never timeout.
                        if conditions.Get(s.AzureMachinePoolMachine, clusterv1.DrainingSucceededCondition) == nil </span><span class="cov0" title="0">{
                                conditions.MarkFalse(s.AzureMachinePoolMachine, clusterv1.DrainingSucceededCondition, clusterv1.DrainingFailedReason, clusterv1.ConditionSeverityWarning, err.Error())
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov0" title="0">conditions.MarkTrue(s.AzureMachinePoolMachine, clusterv1.DrainingSucceededCondition)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *MachinePoolMachineScope) drainNode(ctx context.Context, node *corev1.Node) error <span class="cov0" title="0">{
        ctx, log, done := tele.StartSpanWithLogger(
                ctx,
                "scope.MachinePoolMachineScope.drainNode",
        )
        defer done()

        restConfig, err := remote.RESTConfig(ctx, MachinePoolMachineScopeName, s.client, client.ObjectKey{
                Name:      s.ClusterName(),
                Namespace: s.AzureMachinePoolMachine.Namespace,
        })

        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "Error creating a remote client while deleting Machine, won't retry")
                return nil
        }</span>

        <span class="cov0" title="0">kubeClient, err := kubernetes.NewForConfig(restConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "Error creating a remote client while deleting Machine, won't retry")
                return nil
        }</span>

        <span class="cov0" title="0">drainer := &amp;kubedrain.Helper{
                Client:              kubeClient,
                Ctx:                 ctx,
                Force:               true,
                IgnoreAllDaemonSets: true,
                DeleteEmptyDirData:  true,
                GracePeriodSeconds:  -1,
                // If a pod is not evicted in 20 seconds, retry the eviction next time the
                // machine gets reconciled again (to allow other machines to be reconciled).
                Timeout: 20 * time.Second,
                OnPodDeletedOrEvicted: func(pod *corev1.Pod, usingEviction bool) </span><span class="cov0" title="0">{
                        verbStr := "Deleted"
                        if usingEviction </span><span class="cov0" title="0">{
                                verbStr = "Evicted"
                        }</span>
                        <span class="cov0" title="0">log.V(4).Info(fmt.Sprintf("%s pod from Node", verbStr),
                                "pod", fmt.Sprintf("%s/%s", pod.Name, pod.Namespace))</span>
                },
                Out:    writer{klog.Info},
                ErrOut: writer{klog.Error},
        }

        <span class="cov0" title="0">if noderefutil.IsNodeUnreachable(node) </span><span class="cov0" title="0">{
                // When the node is unreachable and some pods are not evicted for as long as this timeout, we ignore them.
                drainer.SkipWaitForDeleteTimeoutSeconds = 60 * 5 // 5 minutes
        }</span>

        <span class="cov0" title="0">if err := kubedrain.RunCordonOrUncordon(drainer, node, true); err != nil </span><span class="cov0" title="0">{
                // Machine will be re-reconciled after a cordon failure.
                return azure.WithTransientError(errors.Errorf("unable to cordon node %s: %v", node.Name, err), 20*time.Second)
        }</span>

        <span class="cov0" title="0">if err := kubedrain.RunNodeDrain(drainer, node.Name); err != nil </span><span class="cov0" title="0">{
                // Machine will be re-reconciled after a drain failure.
                return azure.WithTransientError(errors.Wrap(err, "Drain failed, retry in 20s"), 20*time.Second)
        }</span>

        <span class="cov0" title="0">log.V(4).Info("Drain successful")
        return nil</span>
}

// isNodeDrainAllowed checks to see the node is excluded from draining or if the NodeDrainTimeout has expired.
func (s *MachinePoolMachineScope) isNodeDrainAllowed() bool <span class="cov0" title="0">{
        if _, exists := s.AzureMachinePoolMachine.ObjectMeta.Annotations[clusterv1.ExcludeNodeDrainingAnnotation]; exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if s.nodeDrainTimeoutExceeded() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// nodeDrainTimeoutExceeded will check to see if the AzureMachinePool's NodeDrainTimeout is exceeded for the
// AzureMachinePoolMachine.
func (s *MachinePoolMachineScope) nodeDrainTimeoutExceeded() bool <span class="cov0" title="0">{
        // if the NodeDrainTineout type is not set by user
        pool := s.AzureMachinePool
        if pool == nil || pool.Spec.NodeDrainTimeout == nil || pool.Spec.NodeDrainTimeout.Seconds() &lt;= 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        // if the draining succeeded condition does not exist
        <span class="cov0" title="0">if conditions.Get(s.AzureMachinePoolMachine, clusterv1.DrainingSucceededCondition) == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">now := time.Now()
        firstTimeDrain := conditions.GetLastTransitionTime(s.AzureMachinePoolMachine, clusterv1.DrainingSucceededCondition)
        diff := now.Sub(firstTimeDrain.Time)
        return diff.Seconds() &gt;= s.AzureMachinePool.Spec.NodeDrainTimeout.Seconds()</span>
}

func (s *MachinePoolMachineScope) hasLatestModelApplied(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(
                ctx,
                "scope.MachinePoolMachineScope.hasLatestModelApplied",
        )
        defer done()

        if s.instance == nil </span><span class="cov0" title="0">{
                return false, errors.New("instance must not be nil")
        }</span>

        <span class="cov0" title="0">image, err := s.MachinePoolScope.GetVMImage(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "unable to build vm image information from MachinePoolScope")
        }</span>

        // this should never happen as GetVMImage should only return nil when err != nil. Just in case.
        <span class="cov0" title="0">if image == nil </span><span class="cov0" title="0">{
                return false, errors.New("machinepoolscope image must not be nil")
        }</span>

        // if the images match, then the VM is of the same model
        <span class="cov0" title="0">return reflect.DeepEqual(s.instance.Image, *image), nil</span>
}

func newWorkloadClusterProxy(c client.Client, cluster client.ObjectKey) *workloadClusterProxy <span class="cov8" title="1">{
        return &amp;workloadClusterProxy{
                Client:  c,
                Cluster: cluster,
        }
}</span>

// GetNode returns the node associated with the AzureMachinePoolMachine. Returns an error if one occurred, and a boolean
// indicating if the node was found if there was no error.
func (s *MachinePoolMachineScope) GetNode(ctx context.Context) (*corev1.Node, bool, error) <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(
                ctx,
                "scope.MachinePoolMachineScope.GetNode",
        )
        defer done()

        var (
                nodeRef = s.AzureMachinePoolMachine.Status.NodeRef
                node    *corev1.Node
                err     error
        )

        if nodeRef == nil || nodeRef.Name == "" </span><span class="cov8" title="1">{
                node, err = s.workloadNodeGetter.GetNodeByProviderID(ctx, s.ProviderID())
                if err != nil </span><span class="cov8" title="1">{
                        return nil, false, errors.Wrap(err, "failed to get node by providerID")
                }</span>
        } else<span class="cov8" title="1"> {
                node, err = s.workloadNodeGetter.GetNodeByObjectReference(ctx, *nodeRef)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, false, errors.Wrap(err, "failed to get node by object reference")
                }</span>
        }

        <span class="cov8" title="1">if node == nil </span><span class="cov8" title="1">{
                return nil, false, nil
        }</span>

        <span class="cov8" title="1">return node, true, nil</span>
}

// GetNodeByObjectReference will fetch a *corev1.Node via a node object reference.
func (np *workloadClusterProxy) GetNodeByObjectReference(ctx context.Context, nodeRef corev1.ObjectReference) (*corev1.Node, error) <span class="cov0" title="0">{
        workloadClient, err := getWorkloadClient(ctx, np.Client, np.Cluster)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to create the workload cluster client")
        }</span>

        <span class="cov0" title="0">var node corev1.Node
        err = workloadClient.Get(ctx, client.ObjectKey{
                Namespace: nodeRef.Namespace,
                Name:      nodeRef.Name,
        }, &amp;node)

        return &amp;node, err</span>
}

// GetNodeByProviderID will fetch a node from the workload cluster by it's providerID.
func (np *workloadClusterProxy) GetNodeByProviderID(ctx context.Context, providerID string) (*corev1.Node, error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(
                ctx,
                "scope.MachinePoolMachineScope.getNode",
        )
        defer done()

        workloadClient, err := getWorkloadClient(ctx, np.Client, np.Cluster)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to create the workload cluster client")
        }</span>

        <span class="cov0" title="0">return getNodeByProviderID(ctx, workloadClient, providerID)</span>
}

func getNodeByProviderID(ctx context.Context, workloadClient client.Client, providerID string) (*corev1.Node, error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(
                ctx,
                "scope.MachinePoolMachineScope.getNodeRefForProviderID",
        )
        defer done()

        nodeList := corev1.NodeList{}
        for </span><span class="cov0" title="0">{
                if err := workloadClient.List(ctx, &amp;nodeList, client.Continue(nodeList.Continue)); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrapf(err, "failed to List nodes")
                }</span>

                <span class="cov0" title="0">for _, node := range nodeList.Items </span><span class="cov0" title="0">{
                        if node.Spec.ProviderID == providerID </span><span class="cov0" title="0">{
                                return &amp;node, nil
                        }</span>
                }

                <span class="cov0" title="0">if nodeList.Continue == "" </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return nil, nil</span>
}

func getWorkloadClient(ctx context.Context, c client.Client, cluster client.ObjectKey) (client.Client, error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(
                ctx,
                "scope.MachinePoolMachineScope.getWorkloadClient",
        )
        defer done()

        return remote.NewClusterClient(ctx, MachinePoolMachineScopeName, c, cluster)
}</span>

// writer implements io.Writer interface as a pass-through for klog.
type writer struct {
        logFunc func(args ...interface{})
}

// Write passes string(p) into writer's logFunc and always returns len(p).
func (w writer) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        w.logFunc(string(p))
        return len(p), nil
}</span>
</pre>
		
		<pre class="file" id="file73" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package scope

import (
        "context"
        "encoding/json"
        "strings"

        "github.com/Azure/go-autorest/autorest"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        "golang.org/x/mod/semver"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/groups"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/managedclusters"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/subnets"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/virtualnetworks"
        infrav1exp "sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/util/futures"
        "sigs.k8s.io/cluster-api-provider-azure/util/maps"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        "sigs.k8s.io/cluster-api/util/conditions"
        "sigs.k8s.io/cluster-api/util/patch"
        "sigs.k8s.io/cluster-api/util/secret"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// ManagedControlPlaneScopeParams defines the input parameters used to create a new managed
// control plane.
type ManagedControlPlaneScopeParams struct {
        AzureClients
        Client              client.Client
        Cluster             *clusterv1.Cluster
        ControlPlane        *infrav1exp.AzureManagedControlPlane
        ManagedMachinePools []ManagedMachinePool
        Cache               *ManagedControlPlaneCache
}

// NewManagedControlPlaneScope creates a new Scope from the supplied parameters.
// This is meant to be called for each reconcile iteration.
func NewManagedControlPlaneScope(ctx context.Context, params ManagedControlPlaneScopeParams) (*ManagedControlPlaneScope, error) <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "scope.NewManagedControlPlaneScope")
        defer done()

        if params.Cluster == nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to generate new scope from nil Cluster")
        }</span>

        <span class="cov8" title="1">if params.ControlPlane == nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to generate new scope from nil ControlPlane")
        }</span>

        <span class="cov8" title="1">if params.ControlPlane.Spec.IdentityRef == nil </span><span class="cov8" title="1">{
                if err := params.AzureClients.setCredentials(params.ControlPlane.Spec.SubscriptionID, ""); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to create Azure session")
                }</span>
        } else<span class="cov0" title="0"> {
                credentialsProvider, err := NewManagedControlPlaneCredentialsProvider(ctx, params.Client, params.ControlPlane)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to init credentials provider")
                }</span>

                <span class="cov0" title="0">if err := params.AzureClients.setCredentialsWithProvider(ctx, params.ControlPlane.Spec.SubscriptionID, "", credentialsProvider); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to configure azure settings and credentials for Identity")
                }</span>
        }

        <span class="cov8" title="1">if params.Cache == nil </span><span class="cov8" title="1">{
                params.Cache = &amp;ManagedControlPlaneCache{}
        }</span>

        <span class="cov8" title="1">helper, err := patch.NewHelper(params.ControlPlane, params.Client)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to init patch helper")
        }</span>

        <span class="cov8" title="1">return &amp;ManagedControlPlaneScope{
                Client:              params.Client,
                AzureClients:        params.AzureClients,
                Cluster:             params.Cluster,
                ControlPlane:        params.ControlPlane,
                ManagedMachinePools: params.ManagedMachinePools,
                patchHelper:         helper,
                cache:               params.Cache,
        }, nil</span>
}

// ManagedControlPlaneScope defines the basic context for an actuator to operate upon.
type ManagedControlPlaneScope struct {
        Client         client.Client
        patchHelper    *patch.Helper
        kubeConfigData []byte
        cache          *ManagedControlPlaneCache

        AzureClients
        Cluster             *clusterv1.Cluster
        ControlPlane        *infrav1exp.AzureManagedControlPlane
        ManagedMachinePools []ManagedMachinePool
}

// ManagedControlPlaneCache stores ManagedControlPlane data locally so we don't have to hit the API multiple times within the same reconcile loop.
type ManagedControlPlaneCache struct {
        isVnetManaged *bool
}

// ResourceGroup returns the managed control plane's resource group.
func (s *ManagedControlPlaneScope) ResourceGroup() string <span class="cov0" title="0">{
        if s.ControlPlane == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return s.ControlPlane.Spec.ResourceGroupName</span>
}

// NodeResourceGroup returns the managed control plane's node resource group.
func (s *ManagedControlPlaneScope) NodeResourceGroup() string <span class="cov0" title="0">{
        if s.ControlPlane == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return s.ControlPlane.Spec.NodeResourceGroupName</span>
}

// ClusterName returns the managed control plane's name.
func (s *ManagedControlPlaneScope) ClusterName() string <span class="cov8" title="1">{
        return s.Cluster.Name
}</span>

// Location returns the managed control plane's Azure location, or an empty string.
func (s *ManagedControlPlaneScope) Location() string <span class="cov8" title="1">{
        if s.ControlPlane == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return s.ControlPlane.Spec.Location</span>
}

// AvailabilitySetEnabled is always false for a managed control plane.
func (s *ManagedControlPlaneScope) AvailabilitySetEnabled() bool <span class="cov0" title="0">{
        return false // not applicable for a managed control plane
}</span>

// AdditionalTags returns AdditionalTags from the ControlPlane spec.
func (s *ManagedControlPlaneScope) AdditionalTags() infrav1.Tags <span class="cov8" title="1">{
        tags := make(infrav1.Tags)
        if s.ControlPlane.Spec.AdditionalTags != nil </span><span class="cov0" title="0">{
                tags = s.ControlPlane.Spec.AdditionalTags.DeepCopy()
        }</span>
        <span class="cov8" title="1">return tags</span>
}

// SubscriptionID returns the Azure client Subscription ID.
func (s *ManagedControlPlaneScope) SubscriptionID() string <span class="cov8" title="1">{
        return s.AzureClients.SubscriptionID()
}</span>

// BaseURI returns the Azure ResourceManagerEndpoint.
func (s *ManagedControlPlaneScope) BaseURI() string <span class="cov8" title="1">{
        return s.AzureClients.ResourceManagerEndpoint
}</span>

// Authorizer returns the Azure client Authorizer.
func (s *ManagedControlPlaneScope) Authorizer() autorest.Authorizer <span class="cov8" title="1">{
        return s.AzureClients.Authorizer
}</span>

// PatchObject persists the cluster configuration and status.
func (s *ManagedControlPlaneScope) PatchObject(ctx context.Context) error <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "scope.ManagedControlPlaneScope.PatchObject")
        defer done()

        conditions.SetSummary(s.ControlPlane)

        return s.patchHelper.Patch(
                ctx,
                s.ControlPlane,
                patch.WithOwnedConditions{Conditions: []clusterv1.ConditionType{
                        clusterv1.ReadyCondition,
                        infrav1.ResourceGroupReadyCondition,
                        infrav1.VNetReadyCondition,
                        infrav1.SubnetsReadyCondition,
                        infrav1.ManagedClusterRunningCondition,
                        infrav1.AgentPoolsReadyCondition,
                }})
}</span>

// Close closes the current scope persisting the cluster configuration and status.
func (s *ManagedControlPlaneScope) Close(ctx context.Context) error <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "scope.ManagedControlPlaneScope.Close")
        defer done()

        return s.PatchObject(ctx)
}</span>

// Vnet returns the cluster Vnet.
func (s *ManagedControlPlaneScope) Vnet() *infrav1.VnetSpec <span class="cov8" title="1">{
        return &amp;infrav1.VnetSpec{
                ResourceGroup: s.ControlPlane.Spec.ResourceGroupName,
                Name:          s.ControlPlane.Spec.VirtualNetwork.Name,
                VnetClassSpec: infrav1.VnetClassSpec{
                        CIDRBlocks: []string{s.ControlPlane.Spec.VirtualNetwork.CIDRBlock},
                },
        }
}</span>

// GroupSpec returns the resource group spec.
func (s *ManagedControlPlaneScope) GroupSpec() azure.ResourceSpecGetter <span class="cov0" title="0">{
        return &amp;groups.GroupSpec{
                Name:           s.ResourceGroup(),
                Location:       s.Location(),
                ClusterName:    s.ClusterName(),
                AdditionalTags: s.AdditionalTags(),
        }
}</span>

// VNetSpec returns the virtual network spec.
func (s *ManagedControlPlaneScope) VNetSpec() azure.ResourceSpecGetter <span class="cov8" title="1">{
        return &amp;virtualnetworks.VNetSpec{
                ResourceGroup:  s.Vnet().ResourceGroup,
                Name:           s.Vnet().Name,
                CIDRs:          s.Vnet().CIDRBlocks,
                Location:       s.Location(),
                ClusterName:    s.ClusterName(),
                AdditionalTags: s.AdditionalTags(),
        }
}</span>

// ControlPlaneRouteTable returns the cluster controlplane routetable.
func (s *ManagedControlPlaneScope) ControlPlaneRouteTable() infrav1.RouteTable <span class="cov0" title="0">{
        return infrav1.RouteTable{}
}</span>

// NodeRouteTable returns the cluster node routetable.
func (s *ManagedControlPlaneScope) NodeRouteTable() infrav1.RouteTable <span class="cov0" title="0">{
        return infrav1.RouteTable{}
}</span>

// NodeNatGateway returns the cluster node NAT gateway.
func (s *ManagedControlPlaneScope) NodeNatGateway() infrav1.NatGateway <span class="cov0" title="0">{
        return infrav1.NatGateway{}
}</span>

// SubnetSpecs returns the subnets specs.
func (s *ManagedControlPlaneScope) SubnetSpecs() []azure.ResourceSpecGetter <span class="cov0" title="0">{
        return []azure.ResourceSpecGetter{
                &amp;subnets.SubnetSpec{
                        Name:              s.NodeSubnet().Name,
                        ResourceGroup:     s.ResourceGroup(),
                        SubscriptionID:    s.SubscriptionID(),
                        CIDRs:             s.NodeSubnet().CIDRBlocks,
                        VNetName:          s.Vnet().Name,
                        VNetResourceGroup: s.Vnet().ResourceGroup,
                        IsVNetManaged:     s.IsVnetManaged(),
                        Role:              infrav1.SubnetNode,
                },
        }
}</span>

// Subnets returns the subnets specs.
func (s *ManagedControlPlaneScope) Subnets() infrav1.Subnets <span class="cov0" title="0">{
        return infrav1.Subnets{}
}</span>

// NodeSubnet returns the cluster node subnet.
func (s *ManagedControlPlaneScope) NodeSubnet() infrav1.SubnetSpec <span class="cov0" title="0">{
        return infrav1.SubnetSpec{
                Name: s.ControlPlane.Spec.VirtualNetwork.Subnet.Name,
                SubnetClassSpec: infrav1.SubnetClassSpec{
                        CIDRBlocks: []string{s.ControlPlane.Spec.VirtualNetwork.Subnet.CIDRBlock},
                },
        }
}</span>

// SetSubnet sets the passed subnet spec into the scope.
// This is not used when using a managed control plane.
func (s *ManagedControlPlaneScope) SetSubnet(_ infrav1.SubnetSpec) {<span class="cov0" title="0">
        // no-op
}</span>

// UpdateSubnetCIDRs updates the subnet CIDRs for the subnet with the same name.
// This is not used when using a managed control plane.
func (s *ManagedControlPlaneScope) UpdateSubnetCIDRs(_ string, _ []string) {<span class="cov0" title="0">
        // no-op
}</span>

// UpdateSubnetID updates the subnet ID for the subnet with the same name.
// This is not used when using a managed control plane.
func (s *ManagedControlPlaneScope) UpdateSubnetID(_ string, _ string) {<span class="cov0" title="0">
        // no-op
}</span>

// ControlPlaneSubnet returns the cluster control plane subnet.
func (s *ManagedControlPlaneScope) ControlPlaneSubnet() infrav1.SubnetSpec <span class="cov0" title="0">{
        return infrav1.SubnetSpec{}
}</span>

// NodeSubnets returns the subnets with the node role.
func (s *ManagedControlPlaneScope) NodeSubnets() []infrav1.SubnetSpec <span class="cov0" title="0">{
        return []infrav1.SubnetSpec{
                {
                        Name: s.ControlPlane.Spec.VirtualNetwork.Subnet.Name,
                        SubnetClassSpec: infrav1.SubnetClassSpec{
                                CIDRBlocks: []string{s.ControlPlane.Spec.VirtualNetwork.Subnet.CIDRBlock},
                        },
                },
        }
}</span>

// Subnet returns the subnet with the provided name.
func (s *ManagedControlPlaneScope) Subnet(name string) infrav1.SubnetSpec <span class="cov0" title="0">{
        subnet := infrav1.SubnetSpec{}
        if name == s.ControlPlane.Spec.VirtualNetwork.Subnet.Name </span><span class="cov0" title="0">{
                subnet.Name = s.ControlPlane.Spec.VirtualNetwork.Subnet.Name
                subnet.CIDRBlocks = []string{s.ControlPlane.Spec.VirtualNetwork.Subnet.CIDRBlock}
        }</span>

        <span class="cov0" title="0">return subnet</span>
}

// IsIPv6Enabled returns true if a cluster is ipv6 enabled.
// Currently always false as managed control planes do not currently implement ipv6.
func (s *ManagedControlPlaneScope) IsIPv6Enabled() bool <span class="cov0" title="0">{
        return false
}</span>

// IsVnetManaged returns true if the vnet is managed.
func (s *ManagedControlPlaneScope) IsVnetManaged() bool <span class="cov8" title="1">{
        if s.cache.isVnetManaged != nil </span><span class="cov8" title="1">{
                return to.Bool(s.cache.isVnetManaged)
        }</span>
        // TODO refactor `IsVnetManaged` so that it is able to use an upstream context
        // see https://github.com/kubernetes-sigs/cluster-api-provider-azure/issues/2581
        <span class="cov8" title="1">ctx := context.Background()
        ctx, log, done := tele.StartSpanWithLogger(ctx, "scope.ManagedControlPlaneScope.IsVnetManaged")
        defer done()
        isManaged, err := virtualnetworks.New(s).IsManaged(ctx)
        if err != nil </span><span class="cov8" title="1">{
                log.Error(err, "Unable to determine if ManagedControlPlaneScope VNET is managed by capz", "AzureManagedCluster", s.ClusterName())
        }</span>
        <span class="cov8" title="1">s.cache.isVnetManaged = to.BoolPtr(isManaged)
        return isManaged</span>
}

// APIServerLB returns the API Server LB spec.
func (s *ManagedControlPlaneScope) APIServerLB() *infrav1.LoadBalancerSpec <span class="cov0" title="0">{
        return nil // does not apply for AKS
}</span>

// APIServerLBName returns the API Server LB name.
func (s *ManagedControlPlaneScope) APIServerLBName() string <span class="cov0" title="0">{
        return "" // does not apply for AKS
}</span>

// APIServerLBPoolName returns the API Server LB backend pool name.
func (s *ManagedControlPlaneScope) APIServerLBPoolName(_ string) string <span class="cov0" title="0">{
        return "" // does not apply for AKS
}</span>

// IsAPIServerPrivate returns true if the API Server LB is of type Internal.
// Currently always false as managed control planes do not currently implement private clusters.
func (s *ManagedControlPlaneScope) IsAPIServerPrivate() bool <span class="cov0" title="0">{
        return false
}</span>

// OutboundLBName returns the name of the outbound LB.
// Note: for managed clusters, the outbound LB lifecycle is not managed.
func (s *ManagedControlPlaneScope) OutboundLBName(_ string) string <span class="cov0" title="0">{
        return "kubernetes"
}</span>

// OutboundPoolName returns the outbound LB backend pool name.
func (s *ManagedControlPlaneScope) OutboundPoolName(_ string) string <span class="cov0" title="0">{
        return "aksOutboundBackendPool" // hard-coded in aks
}</span>

// GetPrivateDNSZoneName returns the Private DNS Zone from the spec or generate it from cluster name.
// Currently always empty as managed control planes do not currently implement private clusters.
func (s *ManagedControlPlaneScope) GetPrivateDNSZoneName() string <span class="cov0" title="0">{
        return ""
}</span>

// CloudProviderConfigOverrides returns the cloud provider config overrides for the cluster.
func (s *ManagedControlPlaneScope) CloudProviderConfigOverrides() *infrav1.CloudProviderConfigOverrides <span class="cov0" title="0">{
        return nil
}</span>

// FailureDomains returns the failure domains for the cluster.
func (s *ManagedControlPlaneScope) FailureDomains() []string <span class="cov0" title="0">{
        return []string{}
}</span>

// ManagedClusterAnnotations returns the annotations for the managed cluster.
func (s *ManagedControlPlaneScope) ManagedClusterAnnotations() map[string]string <span class="cov8" title="1">{
        return s.ControlPlane.Annotations
}</span>

// ManagedClusterSpec returns the managed cluster spec.
func (s *ManagedControlPlaneScope) ManagedClusterSpec(ctx context.Context) azure.ResourceSpecGetter <span class="cov8" title="1">{
        managedClusterSpec := managedclusters.ManagedClusterSpec{
                Name:              s.ControlPlane.Name,
                ResourceGroup:     s.ControlPlane.Spec.ResourceGroupName,
                NodeResourceGroup: s.ControlPlane.Spec.NodeResourceGroupName,
                Location:          s.ControlPlane.Spec.Location,
                Tags:              s.ControlPlane.Spec.AdditionalTags,
                Headers:           maps.FilterByKeyPrefix(s.ManagedClusterAnnotations(), azure.CustomHeaderPrefix),
                Version:           strings.TrimPrefix(s.ControlPlane.Spec.Version, "v"),
                SSHPublicKey:      s.ControlPlane.Spec.SSHPublicKey,
                DNSServiceIP:      s.ControlPlane.Spec.DNSServiceIP,
                VnetSubnetID: azure.SubnetID(
                        s.ControlPlane.Spec.SubscriptionID,
                        s.ControlPlane.Spec.ResourceGroupName,
                        s.ControlPlane.Spec.VirtualNetwork.Name,
                        s.ControlPlane.Spec.VirtualNetwork.Subnet.Name,
                ),
                GetAllAgentPools: s.GetAllAgentPoolSpecs,
        }

        if s.ControlPlane.Spec.NetworkPlugin != nil </span><span class="cov0" title="0">{
                managedClusterSpec.NetworkPlugin = *s.ControlPlane.Spec.NetworkPlugin
        }</span>
        <span class="cov8" title="1">if s.ControlPlane.Spec.NetworkPolicy != nil </span><span class="cov0" title="0">{
                managedClusterSpec.NetworkPolicy = *s.ControlPlane.Spec.NetworkPolicy
        }</span>
        <span class="cov8" title="1">if s.ControlPlane.Spec.LoadBalancerSKU != nil </span><span class="cov0" title="0">{
                managedClusterSpec.LoadBalancerSKU = *s.ControlPlane.Spec.LoadBalancerSKU
        }</span>

        <span class="cov8" title="1">if clusterNetwork := s.Cluster.Spec.ClusterNetwork; clusterNetwork != nil </span><span class="cov0" title="0">{
                if clusterNetwork.Services != nil &amp;&amp; len(clusterNetwork.Services.CIDRBlocks) == 1 </span><span class="cov0" title="0">{
                        managedClusterSpec.ServiceCIDR = clusterNetwork.Services.CIDRBlocks[0]
                }</span>
                <span class="cov0" title="0">if clusterNetwork.Pods != nil &amp;&amp; len(clusterNetwork.Pods.CIDRBlocks) == 1 </span><span class="cov0" title="0">{
                        managedClusterSpec.PodCIDR = clusterNetwork.Pods.CIDRBlocks[0]
                }</span>
        }

        <span class="cov8" title="1">if s.ControlPlane.Spec.AADProfile != nil </span><span class="cov0" title="0">{
                managedClusterSpec.AADProfile = &amp;managedclusters.AADProfile{
                        Managed:             s.ControlPlane.Spec.AADProfile.Managed,
                        EnableAzureRBAC:     s.ControlPlane.Spec.AADProfile.Managed,
                        AdminGroupObjectIDs: s.ControlPlane.Spec.AADProfile.AdminGroupObjectIDs,
                }
        }</span>

        <span class="cov8" title="1">if s.ControlPlane.Spec.AddonProfiles != nil </span><span class="cov8" title="1">{
                for _, profile := range s.ControlPlane.Spec.AddonProfiles </span><span class="cov8" title="1">{
                        managedClusterSpec.AddonProfiles = append(managedClusterSpec.AddonProfiles, managedclusters.AddonProfile{
                                Name:    profile.Name,
                                Enabled: profile.Enabled,
                                Config:  profile.Config,
                        })
                }</span>
        }

        <span class="cov8" title="1">if s.ControlPlane.Spec.SKU != nil </span><span class="cov0" title="0">{
                managedClusterSpec.SKU = &amp;managedclusters.SKU{
                        Tier: string(s.ControlPlane.Spec.SKU.Tier),
                }
        }</span>

        <span class="cov8" title="1">if s.ControlPlane.Spec.LoadBalancerProfile != nil </span><span class="cov0" title="0">{
                managedClusterSpec.LoadBalancerProfile = &amp;managedclusters.LoadBalancerProfile{
                        ManagedOutboundIPs:     s.ControlPlane.Spec.LoadBalancerProfile.ManagedOutboundIPs,
                        OutboundIPPrefixes:     s.ControlPlane.Spec.LoadBalancerProfile.OutboundIPPrefixes,
                        OutboundIPs:            s.ControlPlane.Spec.LoadBalancerProfile.OutboundIPs,
                        AllocatedOutboundPorts: s.ControlPlane.Spec.LoadBalancerProfile.AllocatedOutboundPorts,
                        IdleTimeoutInMinutes:   s.ControlPlane.Spec.LoadBalancerProfile.IdleTimeoutInMinutes,
                }
        }</span>

        <span class="cov8" title="1">if s.ControlPlane.Spec.APIServerAccessProfile != nil </span><span class="cov0" title="0">{
                managedClusterSpec.APIServerAccessProfile = &amp;managedclusters.APIServerAccessProfile{
                        AuthorizedIPRanges:             s.ControlPlane.Spec.APIServerAccessProfile.AuthorizedIPRanges,
                        EnablePrivateCluster:           s.ControlPlane.Spec.APIServerAccessProfile.EnablePrivateCluster,
                        PrivateDNSZone:                 s.ControlPlane.Spec.APIServerAccessProfile.PrivateDNSZone,
                        EnablePrivateClusterPublicFQDN: s.ControlPlane.Spec.APIServerAccessProfile.EnablePrivateClusterPublicFQDN,
                }
        }</span>

        <span class="cov8" title="1">return &amp;managedClusterSpec</span>
}

// GetAllAgentPoolSpecs gets a slice of azure.AgentPoolSpec for the list of agent pools.
func (s *ManagedControlPlaneScope) GetAllAgentPoolSpecs() ([]azure.ResourceSpecGetter, error) <span class="cov8" title="1">{
        var (
                ammps           = make([]azure.ResourceSpecGetter, 0, len(s.ManagedMachinePools))
                foundSystemPool = false
        )
        for _, pool := range s.ManagedMachinePools </span><span class="cov8" title="1">{
                // TODO: this should be in a webhook: https://github.com/kubernetes-sigs/cluster-api/issues/6040
                if pool.MachinePool != nil &amp;&amp; pool.MachinePool.Spec.Template.Spec.Version != nil </span><span class="cov8" title="1">{
                        version := *pool.MachinePool.Spec.Template.Spec.Version
                        if semver.Compare(version, s.ControlPlane.Spec.Version) &gt; 0 </span><span class="cov8" title="1">{
                                return nil, errors.New("MachinePool version cannot be greater than the AzureManagedControlPlane version")
                        }</span>
                }

                <span class="cov8" title="1">if pool.InfraMachinePool != nil &amp;&amp; pool.InfraMachinePool.Spec.Mode == string(infrav1exp.NodePoolModeSystem) </span><span class="cov8" title="1">{
                        foundSystemPool = true
                }</span>

                <span class="cov8" title="1">ammp := buildAgentPoolSpec(s.ControlPlane, pool.MachinePool, pool.InfraMachinePool, pool.InfraMachinePool.Annotations)
                ammps = append(ammps, ammp)</span>
        }

        <span class="cov8" title="1">if !foundSystemPool </span><span class="cov8" title="1">{
                return nil, errors.New("failed to fetch azuremanagedMachine pool with mode:System, require at least 1 system node pool")
        }</span>

        <span class="cov8" title="1">return ammps, nil</span>
}

// SetControlPlaneEndpoint sets a control plane endpoint.
func (s *ManagedControlPlaneScope) SetControlPlaneEndpoint(endpoint clusterv1.APIEndpoint) <span class="cov0" title="0">{
        s.ControlPlane.Spec.ControlPlaneEndpoint = endpoint
}</span>

// MakeEmptyKubeConfigSecret creates an empty secret object that is used for storing kubeconfig secret data.
func (s *ManagedControlPlaneScope) MakeEmptyKubeConfigSecret() corev1.Secret <span class="cov0" title="0">{
        return corev1.Secret{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      secret.Name(s.Cluster.Name, secret.Kubeconfig),
                        Namespace: s.Cluster.Namespace,
                        OwnerReferences: []metav1.OwnerReference{
                                *metav1.NewControllerRef(s.ControlPlane, infrav1exp.GroupVersion.WithKind("AzureManagedControlPlane")),
                        },
                },
        }
}</span>

// GetKubeConfigData returns a []byte that contains kubeconfig.
func (s *ManagedControlPlaneScope) GetKubeConfigData() []byte <span class="cov0" title="0">{
        return s.kubeConfigData
}</span>

// SetKubeConfigData sets kubeconfig data.
func (s *ManagedControlPlaneScope) SetKubeConfigData(kubeConfigData []byte) <span class="cov0" title="0">{
        s.kubeConfigData = kubeConfigData
}</span>

// SetLongRunningOperationState will set the future on the AzureManagedControlPlane status to allow the resource to continue
// in the next reconciliation.
func (s *ManagedControlPlaneScope) SetLongRunningOperationState(future *infrav1.Future) <span class="cov0" title="0">{
        futures.Set(s.ControlPlane, future)
}</span>

// GetLongRunningOperationState will get the future on the AzureManagedControlPlane status.
func (s *ManagedControlPlaneScope) GetLongRunningOperationState(name, service string) *infrav1.Future <span class="cov0" title="0">{
        return futures.Get(s.ControlPlane, name, service)
}</span>

// DeleteLongRunningOperationState will delete the future from the AzureManagedControlPlane status.
func (s *ManagedControlPlaneScope) DeleteLongRunningOperationState(name, service string) <span class="cov0" title="0">{
        futures.Delete(s.ControlPlane, name, service)
}</span>

// UpdateDeleteStatus updates a condition on the AzureManagedControlPlane status after a DELETE operation.
func (s *ManagedControlPlaneScope) UpdateDeleteStatus(condition clusterv1.ConditionType, service string, err error) <span class="cov0" title="0">{
        switch </span>{
        case err == nil:<span class="cov0" title="0">
                conditions.MarkFalse(s.ControlPlane, condition, infrav1.DeletedReason, clusterv1.ConditionSeverityInfo, "%s successfully deleted", service)</span>
        case azure.IsOperationNotDoneError(err):<span class="cov0" title="0">
                conditions.MarkFalse(s.ControlPlane, condition, infrav1.DeletingReason, clusterv1.ConditionSeverityInfo, "%s deleting", service)</span>
        default:<span class="cov0" title="0">
                conditions.MarkFalse(s.ControlPlane, condition, infrav1.DeletionFailedReason, clusterv1.ConditionSeverityError, "%s failed to delete. err: %s", service, err.Error())</span>
        }
}

// UpdatePutStatus updates a condition on the AzureManagedControlPlane status after a PUT operation.
func (s *ManagedControlPlaneScope) UpdatePutStatus(condition clusterv1.ConditionType, service string, err error) <span class="cov0" title="0">{
        switch </span>{
        case err == nil:<span class="cov0" title="0">
                conditions.MarkTrue(s.ControlPlane, condition)</span>
        case azure.IsOperationNotDoneError(err):<span class="cov0" title="0">
                conditions.MarkFalse(s.ControlPlane, condition, infrav1.CreatingReason, clusterv1.ConditionSeverityInfo, "%s creating or updating", service)</span>
        default:<span class="cov0" title="0">
                conditions.MarkFalse(s.ControlPlane, condition, infrav1.FailedReason, clusterv1.ConditionSeverityError, "%s failed to create or update. err: %s", service, err.Error())</span>
        }
}

// UpdatePatchStatus updates a condition on the AzureManagedControlPlane status after a PATCH operation.
func (s *ManagedControlPlaneScope) UpdatePatchStatus(condition clusterv1.ConditionType, service string, err error) <span class="cov0" title="0">{
        switch </span>{
        case err == nil:<span class="cov0" title="0">
                conditions.MarkTrue(s.ControlPlane, condition)</span>
        case azure.IsOperationNotDoneError(err):<span class="cov0" title="0">
                conditions.MarkFalse(s.ControlPlane, condition, infrav1.UpdatingReason, clusterv1.ConditionSeverityInfo, "%s updating", service)</span>
        default:<span class="cov0" title="0">
                conditions.MarkFalse(s.ControlPlane, condition, infrav1.FailedReason, clusterv1.ConditionSeverityError, "%s failed to update. err: %s", service, err.Error())</span>
        }
}

// AnnotationJSON returns a map[string]interface from a JSON annotation.
func (s *ManagedControlPlaneScope) AnnotationJSON(annotation string) (map[string]interface{}, error) <span class="cov0" title="0">{
        out := map[string]interface{}{}
        jsonAnnotation := s.ControlPlane.GetAnnotations()[annotation]
        if jsonAnnotation == "" </span><span class="cov0" title="0">{
                return out, nil
        }</span>
        <span class="cov0" title="0">err := json.Unmarshal([]byte(jsonAnnotation), &amp;out)
        if err != nil </span><span class="cov0" title="0">{
                return out, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// UpdateAnnotationJSON updates the `annotation` with
// `content`. `content` in this case should be a `map[string]interface{}`
// suitable for turning into JSON. This `content` map will be marshalled into a
// JSON string before being set as the given `annotation`.
func (s *ManagedControlPlaneScope) UpdateAnnotationJSON(annotation string, content map[string]interface{}) error <span class="cov0" title="0">{
        b, err := json.Marshal(content)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">s.SetAnnotation(annotation, string(b))
        return nil</span>
}

// SetAnnotation sets a key value annotation on the ControlPlane.
func (s *ManagedControlPlaneScope) SetAnnotation(key, value string) <span class="cov0" title="0">{
        if s.ControlPlane.Annotations == nil </span><span class="cov0" title="0">{
                s.ControlPlane.Annotations = map[string]string{}
        }</span>
        <span class="cov0" title="0">s.ControlPlane.Annotations[key] = value</span>
}

// TagsSpecs returns the tag specs for the ManagedControlPlane.
func (s *ManagedControlPlaneScope) TagsSpecs() []azure.TagsSpec <span class="cov0" title="0">{
        return []azure.TagsSpec{
                {
                        Scope:      azure.ResourceGroupID(s.SubscriptionID(), s.ResourceGroup()),
                        Tags:       s.AdditionalTags(),
                        Annotation: azure.RGTagsLastAppliedAnnotation,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file74" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package scope

import (
        "context"
        "fmt"
        "strings"

        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/agentpools"
        infrav1exp "sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/util/futures"
        "sigs.k8s.io/cluster-api-provider-azure/util/maps"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        expv1 "sigs.k8s.io/cluster-api/exp/api/v1beta1"
        "sigs.k8s.io/cluster-api/util/conditions"
        "sigs.k8s.io/cluster-api/util/patch"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// ManagedMachinePoolScopeParams defines the input parameters used to create a new managed
// control plane.
type ManagedMachinePoolScopeParams struct {
        ManagedMachinePool
        Client                   client.Client
        Cluster                  *clusterv1.Cluster
        ControlPlane             *infrav1exp.AzureManagedControlPlane
        ManagedControlPlaneScope azure.ManagedClusterScoper
}

// ManagedMachinePool defines the scope interface for a managed machine pool.
type ManagedMachinePool struct {
        InfraMachinePool *infrav1exp.AzureManagedMachinePool
        MachinePool      *expv1.MachinePool
}

// NewManagedMachinePoolScope creates a new Scope from the supplied parameters.
// This is meant to be called for each reconcile iteration.
func NewManagedMachinePoolScope(ctx context.Context, params ManagedMachinePoolScopeParams) (*ManagedMachinePoolScope, error) <span class="cov8" title="1">{
        _, _, done := tele.StartSpanWithLogger(ctx, "scope.NewManagedMachinePoolScope")
        defer done()

        if params.Cluster == nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to generate new scope from nil Cluster")
        }</span>

        <span class="cov8" title="1">if params.ControlPlane == nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to generate new scope from nil ControlPlane")
        }</span>

        <span class="cov8" title="1">helper, err := patch.NewHelper(params.InfraMachinePool, params.Client)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to init patch helper")
        }</span>

        <span class="cov8" title="1">capiMachinePoolPatchHelper, err := patch.NewHelper(params.MachinePool, params.Client)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to init patch helper")
        }</span>

        <span class="cov8" title="1">return &amp;ManagedMachinePoolScope{
                Client:                     params.Client,
                Cluster:                    params.Cluster,
                ControlPlane:               params.ControlPlane,
                MachinePool:                params.MachinePool,
                InfraMachinePool:           params.InfraMachinePool,
                patchHelper:                helper,
                capiMachinePoolPatchHelper: capiMachinePoolPatchHelper,
                ManagedClusterScoper:       params.ManagedControlPlaneScope,
        }, nil</span>
}

// ManagedMachinePoolScope defines the basic context for an actuator to operate upon.
type ManagedMachinePoolScope struct {
        Client                     client.Client
        patchHelper                *patch.Helper
        capiMachinePoolPatchHelper *patch.Helper

        azure.ManagedClusterScoper
        Cluster          *clusterv1.Cluster
        MachinePool      *expv1.MachinePool
        ControlPlane     *infrav1exp.AzureManagedControlPlane
        InfraMachinePool *infrav1exp.AzureManagedMachinePool
}

// PatchObject persists the cluster configuration and status.
func (s *ManagedMachinePoolScope) PatchObject(ctx context.Context) error <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "scope.ManagedMachinePoolScope.PatchObject")
        defer done()

        conditions.SetSummary(s.InfraMachinePool)

        return s.patchHelper.Patch(
                ctx,
                s.InfraMachinePool,
                patch.WithOwnedConditions{Conditions: []clusterv1.ConditionType{
                        clusterv1.ReadyCondition,
                }})
}</span>

// Close closes the current scope persisting the cluster configuration and status.
func (s *ManagedMachinePoolScope) Close(ctx context.Context) error <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "scope.ManagedMachinePoolScope.Close")
        defer done()

        return s.PatchObject(ctx)
}</span>

// AgentPoolAnnotations returns a map of annotations for the infra machine pool.
func (s *ManagedMachinePoolScope) AgentPoolAnnotations() map[string]string <span class="cov8" title="1">{
        return s.InfraMachinePool.Annotations
}</span>

// Name returns the name of the infra machine pool.
func (s *ManagedMachinePoolScope) Name() string <span class="cov0" title="0">{
        return s.InfraMachinePool.Name
}</span>

// AgentPoolSpec returns an azure.ResourceSpecGetter for currently reconciled AzureManagedMachinePool.
func (s *ManagedMachinePoolScope) AgentPoolSpec() azure.ResourceSpecGetter <span class="cov8" title="1">{
        return buildAgentPoolSpec(s.ControlPlane, s.MachinePool, s.InfraMachinePool, s.AgentPoolAnnotations())
}</span>

func buildAgentPoolSpec(managedControlPlane *infrav1exp.AzureManagedControlPlane,
        machinePool *expv1.MachinePool,
        managedMachinePool *infrav1exp.AzureManagedMachinePool,
        agentPoolAnnotations map[string]string) azure.ResourceSpecGetter <span class="cov8" title="1">{
        var normalizedVersion *string
        if machinePool.Spec.Template.Spec.Version != nil </span><span class="cov8" title="1">{
                v := strings.TrimPrefix(*machinePool.Spec.Template.Spec.Version, "v")
                normalizedVersion = &amp;v
        }</span>

        <span class="cov8" title="1">replicas := int32(1)
        if machinePool.Spec.Replicas != nil </span><span class="cov0" title="0">{
                replicas = *machinePool.Spec.Replicas
        }</span>

        <span class="cov8" title="1">agentPoolSpec := &amp;agentpools.AgentPoolSpec{
                Name:          to.String(managedMachinePool.Spec.Name),
                ResourceGroup: managedControlPlane.Spec.ResourceGroupName,
                Cluster:       managedControlPlane.Name,
                SKU:           managedMachinePool.Spec.SKU,
                Replicas:      replicas,
                Version:       normalizedVersion,
                OSType:        managedMachinePool.Spec.OSType,
                VnetSubnetID: azure.SubnetID(
                        managedControlPlane.Spec.SubscriptionID,
                        managedControlPlane.Spec.ResourceGroupName,
                        managedControlPlane.Spec.VirtualNetwork.Name,
                        managedControlPlane.Spec.VirtualNetwork.Subnet.Name,
                ),
                Mode:               managedMachinePool.Spec.Mode,
                MaxPods:            managedMachinePool.Spec.MaxPods,
                AvailabilityZones:  managedMachinePool.Spec.AvailabilityZones,
                OsDiskType:         managedMachinePool.Spec.OsDiskType,
                EnableUltraSSD:     managedMachinePool.Spec.EnableUltraSSD,
                Headers:            maps.FilterByKeyPrefix(agentPoolAnnotations, azure.CustomHeaderPrefix),
                EnableNodePublicIP: managedMachinePool.Spec.EnableNodePublicIP,
        }

        if managedMachinePool.Spec.OSDiskSizeGB != nil </span><span class="cov0" title="0">{
                agentPoolSpec.OSDiskSizeGB = *managedMachinePool.Spec.OSDiskSizeGB
        }</span>

        <span class="cov8" title="1">if len(managedMachinePool.Spec.Taints) &gt; 0 </span><span class="cov8" title="1">{
                nodeTaints := make([]string, 0, len(managedMachinePool.Spec.Taints))
                for _, t := range managedMachinePool.Spec.Taints </span><span class="cov8" title="1">{
                        nodeTaints = append(nodeTaints, fmt.Sprintf("%s=%s:%s", t.Key, t.Value, t.Effect))
                }</span>
                <span class="cov8" title="1">agentPoolSpec.NodeTaints = nodeTaints</span>
        }

        <span class="cov8" title="1">if managedMachinePool.Spec.Scaling != nil </span><span class="cov8" title="1">{
                agentPoolSpec.EnableAutoScaling = to.BoolPtr(true)
                agentPoolSpec.MaxCount = managedMachinePool.Spec.Scaling.MaxSize
                agentPoolSpec.MinCount = managedMachinePool.Spec.Scaling.MinSize
        }</span>

        <span class="cov8" title="1">if len(managedMachinePool.Spec.NodeLabels) &gt; 0 </span><span class="cov8" title="1">{
                agentPoolSpec.NodeLabels = make(map[string]*string, len(managedMachinePool.Spec.NodeLabels))
                for k, v := range managedMachinePool.Spec.NodeLabels </span><span class="cov8" title="1">{
                        agentPoolSpec.NodeLabels[k] = to.StringPtr(v)
                }</span>
        }

        <span class="cov8" title="1">return agentPoolSpec</span>
}

// SetAgentPoolProviderIDList sets a list of agent pool's Azure VM IDs.
func (s *ManagedMachinePoolScope) SetAgentPoolProviderIDList(providerIDs []string) <span class="cov0" title="0">{
        s.InfraMachinePool.Spec.ProviderIDList = providerIDs
}</span>

// SetAgentPoolReplicas sets the number of agent pool replicas.
func (s *ManagedMachinePoolScope) SetAgentPoolReplicas(replicas int32) <span class="cov0" title="0">{
        s.InfraMachinePool.Status.Replicas = replicas
}</span>

// SetAgentPoolReady sets the flag that indicates if the agent pool is ready or not.
func (s *ManagedMachinePoolScope) SetAgentPoolReady(ready bool) <span class="cov0" title="0">{
        s.InfraMachinePool.Status.Ready = ready
}</span>

// SetLongRunningOperationState will set the future on the AzureManagedControlPlane status to allow the resource to continue
// in the next reconciliation.
func (s *ManagedMachinePoolScope) SetLongRunningOperationState(future *infrav1.Future) <span class="cov0" title="0">{
        futures.Set(s.ControlPlane, future)
}</span>

// GetLongRunningOperationState will get the future on the AzureManagedControlPlane status.
func (s *ManagedMachinePoolScope) GetLongRunningOperationState(name, service string) *infrav1.Future <span class="cov0" title="0">{
        return futures.Get(s.ControlPlane, name, service)
}</span>

// DeleteLongRunningOperationState will delete the future from the AzureManagedControlPlane status.
func (s *ManagedMachinePoolScope) DeleteLongRunningOperationState(name, service string) <span class="cov0" title="0">{
        futures.Delete(s.ControlPlane, name, service)
}</span>

// UpdateDeleteStatus updates a condition on the AzureManagedControlPlane status after a DELETE operation.
func (s *ManagedMachinePoolScope) UpdateDeleteStatus(condition clusterv1.ConditionType, service string, err error) <span class="cov0" title="0">{
        switch </span>{
        case err == nil:<span class="cov0" title="0">
                conditions.MarkFalse(s.InfraMachinePool, condition, infrav1.DeletedReason, clusterv1.ConditionSeverityInfo, "%s successfully deleted", service)</span>
        case azure.IsOperationNotDoneError(err):<span class="cov0" title="0">
                conditions.MarkFalse(s.InfraMachinePool, condition, infrav1.DeletingReason, clusterv1.ConditionSeverityInfo, "%s deleting", service)</span>
        default:<span class="cov0" title="0">
                conditions.MarkFalse(s.InfraMachinePool, condition, infrav1.DeletionFailedReason, clusterv1.ConditionSeverityError, "%s failed to delete. err: %s", service, err.Error())</span>
        }
}

// UpdatePutStatus updates a condition on the AzureManagedMachinePool status after a PUT operation.
func (s *ManagedMachinePoolScope) UpdatePutStatus(condition clusterv1.ConditionType, service string, err error) <span class="cov0" title="0">{
        switch </span>{
        case err == nil:<span class="cov0" title="0">
                conditions.MarkTrue(s.InfraMachinePool, condition)</span>
        case azure.IsOperationNotDoneError(err):<span class="cov0" title="0">
                conditions.MarkFalse(s.InfraMachinePool, condition, infrav1.CreatingReason, clusterv1.ConditionSeverityInfo, "%s creating or updating", service)</span>
        default:<span class="cov0" title="0">
                conditions.MarkFalse(s.InfraMachinePool, condition, infrav1.FailedReason, clusterv1.ConditionSeverityError, "%s failed to create or update. err: %s", service, err.Error())</span>
        }
}

// UpdatePatchStatus updates a condition on the AzureManagedMachinePool status after a PATCH operation.
func (s *ManagedMachinePoolScope) UpdatePatchStatus(condition clusterv1.ConditionType, service string, err error) <span class="cov0" title="0">{
        switch </span>{
        case err == nil:<span class="cov0" title="0">
                conditions.MarkTrue(s.InfraMachinePool, condition)</span>
        case azure.IsOperationNotDoneError(err):<span class="cov0" title="0">
                conditions.MarkFalse(s.InfraMachinePool, condition, infrav1.UpdatingReason, clusterv1.ConditionSeverityInfo, "%s updating", service)</span>
        default:<span class="cov0" title="0">
                conditions.MarkFalse(s.InfraMachinePool, condition, infrav1.FailedReason, clusterv1.ConditionSeverityError, "%s failed to update. err: %s", service, err.Error())</span>
        }
}

// PatchCAPIMachinePoolObject persists the capi machinepool configuration and status.
func (s *ManagedMachinePoolScope) PatchCAPIMachinePoolObject(ctx context.Context) error <span class="cov0" title="0">{
        return s.capiMachinePoolPatchHelper.Patch(
                ctx,
                s.MachinePool,
        )
}</span>

// SetCAPIMachinePoolReplicas sets the associated MachinePool replica count.
func (s *ManagedMachinePoolScope) SetCAPIMachinePoolReplicas(replicas *int32) <span class="cov0" title="0">{
        s.MachinePool.Spec.Replicas = replicas
}</span>

// SetCAPIMachinePoolAnnotation sets the specified annotation on the associated MachinePool.
func (s *ManagedMachinePoolScope) SetCAPIMachinePoolAnnotation(key, value string) <span class="cov0" title="0">{
        s.MachinePool.Annotations[key] = value
}</span>

// RemoveCAPIMachinePoolAnnotation removes the specified annotation on the associated MachinePool.
func (s *ManagedMachinePoolScope) RemoveCAPIMachinePoolAnnotation(key string) <span class="cov0" title="0">{
        delete(s.MachinePool.Annotations, key)
}</span>

// GetCAPIMachinePoolAnnotation gets the specified annotation on the associated MachinePool.
func (s *ManagedMachinePoolScope) GetCAPIMachinePoolAnnotation(key string) (success bool, value string) <span class="cov0" title="0">{
        val, ok := s.MachinePool.Annotations[key]
        return ok, val
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package machinepool

import (
        "context"
        "math/rand"
        "sort"
        "time"

        "github.com/pkg/errors"
        "k8s.io/apimachinery/pkg/util/intstr"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        infrav1exp "sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
        ctrl "sigs.k8s.io/controller-runtime"
)

type (
        // Surger is the ability to surge a number of replica.
        Surger interface {
                Surge(desiredReplicaCount int) (int, error)
        }

        // DeleteSelector is the ability to select nodes to be delete with respect to a desired number of replicas.
        DeleteSelector interface {
                SelectMachinesToDelete(ctx context.Context, desiredReplicas int32, machinesByProviderID map[string]infrav1exp.AzureMachinePoolMachine) ([]infrav1exp.AzureMachinePoolMachine, error)
        }

        // TypedDeleteSelector is the ability to select nodes to be deleted with respect to a desired number of nodes, and
        // the ability to describe the underlying type of the deployment strategy.
        TypedDeleteSelector interface {
                DeleteSelector
                Type() infrav1exp.AzureMachinePoolDeploymentStrategyType
        }

        rollingUpdateStrategy struct {
                infrav1exp.MachineRollingUpdateDeployment
        }
)

// NewMachinePoolDeploymentStrategy constructs a strategy implementation described in the AzureMachinePoolDeploymentStrategy
// specification.
func NewMachinePoolDeploymentStrategy(strategy infrav1exp.AzureMachinePoolDeploymentStrategy) TypedDeleteSelector <span class="cov8" title="1">{
        switch strategy.Type </span>{
        case infrav1exp.RollingUpdateAzureMachinePoolDeploymentStrategyType:<span class="cov8" title="1">
                rollingUpdate := strategy.RollingUpdate
                if rollingUpdate == nil </span><span class="cov8" title="1">{
                        rollingUpdate = &amp;infrav1exp.MachineRollingUpdateDeployment{}
                }</span>

                <span class="cov8" title="1">return &amp;rollingUpdateStrategy{
                        MachineRollingUpdateDeployment: *rollingUpdate,
                }</span>
        default:<span class="cov0" title="0">
                // default to a rolling update strategy if unknown type
                return &amp;rollingUpdateStrategy{
                        MachineRollingUpdateDeployment: infrav1exp.MachineRollingUpdateDeployment{},
                }</span>
        }
}

// Type is the AzureMachinePoolDeploymentStrategyType for the strategy.
func (rollingUpdateStrategy *rollingUpdateStrategy) Type() infrav1exp.AzureMachinePoolDeploymentStrategyType <span class="cov8" title="1">{
        return infrav1exp.RollingUpdateAzureMachinePoolDeploymentStrategyType
}</span>

// Surge calculates the number of replicas that can be added during an upgrade operation.
func (rollingUpdateStrategy *rollingUpdateStrategy) Surge(desiredReplicaCount int) (int, error) <span class="cov8" title="1">{
        if rollingUpdateStrategy.MaxSurge == nil </span><span class="cov8" title="1">{
                return 1, nil
        }</span>

        <span class="cov8" title="1">return intstr.GetScaledValueFromIntOrPercent(rollingUpdateStrategy.MaxSurge, desiredReplicaCount, true)</span>
}

// maxUnavailable calculates the maximum number of replicas which can be unavailable at any time.
func (rollingUpdateStrategy *rollingUpdateStrategy) maxUnavailable(desiredReplicaCount int) (int, error) <span class="cov8" title="1">{
        if rollingUpdateStrategy.MaxUnavailable != nil </span><span class="cov8" title="1">{
                val, err := intstr.GetScaledValueFromIntOrPercent(rollingUpdateStrategy.MaxUnavailable, desiredReplicaCount, false)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, errors.Wrap(err, "failed to get scaled value or int from maxUnavailable")
                }</span>

                <span class="cov8" title="1">return val, nil</span>
        }

        <span class="cov8" title="1">return 0, nil</span>
}

// SelectMachinesToDelete selects the machines to delete based on the machine state, desired replica count, and
// the DeletePolicy.
func (rollingUpdateStrategy rollingUpdateStrategy) SelectMachinesToDelete(ctx context.Context, desiredReplicaCount int32, machinesByProviderID map[string]infrav1exp.AzureMachinePoolMachine) ([]infrav1exp.AzureMachinePoolMachine, error) <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(
                ctx,
                "strategies.rollingUpdateStrategy.SelectMachinesToDelete",
        )
        defer done()

        maxUnavailable, err := rollingUpdateStrategy.maxUnavailable(int(desiredReplicaCount))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var (
                order = func() func(machines []infrav1exp.AzureMachinePoolMachine) []infrav1exp.AzureMachinePoolMachine </span><span class="cov8" title="1">{
                        switch rollingUpdateStrategy.DeletePolicy </span>{
                        case infrav1exp.OldestDeletePolicyType:<span class="cov8" title="1">
                                return orderByOldest</span>
                        case infrav1exp.NewestDeletePolicyType:<span class="cov8" title="1">
                                return orderByNewest</span>
                        default:<span class="cov8" title="1">
                                return orderRandom</span>
                        }
                }()
                log                        = ctrl.LoggerFrom(ctx).V(4)
                failedMachines             = order(getFailedMachines(machinesByProviderID))
                deletingMachines           = order(getDeletingMachines(machinesByProviderID))
                readyMachines              = order(getReadyMachines(machinesByProviderID))
                machinesWithoutLatestModel = order(getMachinesWithoutLatestModel(machinesByProviderID))
                overProvisionCount         = len(readyMachines) - int(desiredReplicaCount)
                disruptionBudget           = func() int <span class="cov8" title="1">{
                        if maxUnavailable &gt; int(desiredReplicaCount) </span><span class="cov0" title="0">{
                                return int(desiredReplicaCount)
                        }</span>

                        <span class="cov8" title="1">return len(readyMachines) - int(desiredReplicaCount) + maxUnavailable</span>
                }()
        )

        <span class="cov8" title="1">log.Info("selecting machines to delete",
                "readyMachines", len(readyMachines),
                "desiredReplicaCount", desiredReplicaCount,
                "maxUnavailable", maxUnavailable,
                "disruptionBudget", disruptionBudget,
                "machinesWithoutTheLatestModel", len(machinesWithoutLatestModel),
                "failedMachines", len(failedMachines),
                "deletingMachines", len(deletingMachines),
        )

        // if we have failed or deleting machines, remove them
        if len(failedMachines) &gt; 0 || len(deletingMachines) &gt; 0 </span><span class="cov8" title="1">{
                log.Info("failed or deleting machines", "desiredReplicaCount", desiredReplicaCount, "maxUnavailable", maxUnavailable, "failedMachines", getProviderIDs(failedMachines), "deletingMachines", getProviderIDs(deletingMachines))
                return append(failedMachines, deletingMachines...), nil
        }</span>

        // if we have failed machines, remove them
        <span class="cov8" title="1">if len(failedMachines) &gt; 0 </span><span class="cov0" title="0">{
                log.Info("failed machines", "desiredReplicaCount", desiredReplicaCount, "maxUnavailable", maxUnavailable, "failedMachines", getProviderIDs(failedMachines))
                return failedMachines, nil
        }</span>

        // if we have not yet reached our desired count, don't try to delete anything but failed machines
        <span class="cov8" title="1">if len(readyMachines) &lt; int(desiredReplicaCount) </span><span class="cov0" title="0">{
                log.Info("not enough ready machines", "desiredReplicaCount", desiredReplicaCount, "readyMachinesCount", len(readyMachines), "machinesByProviderID", len(machinesByProviderID))
                return []infrav1exp.AzureMachinePoolMachine{}, nil
        }</span>

        // we have too many machines, let's choose the oldest to remove
        <span class="cov8" title="1">if overProvisionCount &gt; 0 </span><span class="cov8" title="1">{
                var toDelete []infrav1exp.AzureMachinePoolMachine
                log.Info("over-provisioned", "desiredReplicaCount", desiredReplicaCount, "overProvisionCount", overProvisionCount, "machinesWithoutLatestModel", getProviderIDs(machinesWithoutLatestModel))
                // we are over-provisioned try to remove old models
                for _, v := range machinesWithoutLatestModel </span><span class="cov8" title="1">{
                        if len(toDelete) &gt;= overProvisionCount </span><span class="cov0" title="0">{
                                return toDelete, nil
                        }</span>

                        <span class="cov8" title="1">toDelete = append(toDelete, v)</span>
                }

                <span class="cov8" title="1">log.Info("over-provisioned ready", "desiredReplicaCount", desiredReplicaCount, "overProvisionCount", overProvisionCount, "readyMachines", getProviderIDs(readyMachines))
                // remove ready machines
                for _, v := range readyMachines </span><span class="cov8" title="1">{
                        if len(toDelete) &gt;= overProvisionCount </span><span class="cov8" title="1">{
                                return toDelete, nil
                        }</span>

                        <span class="cov8" title="1">toDelete = append(toDelete, v)</span>
                }

                <span class="cov0" title="0">return toDelete, nil</span>
        }

        <span class="cov8" title="1">if len(machinesWithoutLatestModel) == 0 </span><span class="cov8" title="1">{
                log.Info("nothing more to do since all the AzureMachinePoolMachine(s) are the latest model and not over-provisioned")
                return []infrav1exp.AzureMachinePoolMachine{}, nil
        }</span>

        <span class="cov8" title="1">if disruptionBudget &lt;= 0 </span><span class="cov8" title="1">{
                log.Info("exit early since disruption budget is less than or equal to zero", "disruptionBudget", disruptionBudget, "desiredReplicaCount", desiredReplicaCount, "maxUnavailable", maxUnavailable, "readyMachines", getProviderIDs(readyMachines), "readyMachinesCount", len(readyMachines))
                return []infrav1exp.AzureMachinePoolMachine{}, nil
        }</span>

        <span class="cov8" title="1">var toDelete []infrav1exp.AzureMachinePoolMachine
        log.Info("removing ready machines within disruption budget", "desiredReplicaCount", desiredReplicaCount, "maxUnavailable", maxUnavailable, "readyMachines", getProviderIDs(readyMachines), "readyMachinesCount", len(readyMachines))
        for _, v := range readyMachines </span><span class="cov8" title="1">{
                if len(toDelete) &gt;= disruptionBudget </span><span class="cov8" title="1">{
                        return toDelete, nil
                }</span>

                <span class="cov8" title="1">if !v.Status.LatestModelApplied </span><span class="cov8" title="1">{
                        toDelete = append(toDelete, v)
                }</span>
        }

        <span class="cov8" title="1">log.Info("completed without filling toDelete", "toDelete", getProviderIDs(toDelete), "numToDelete", len(toDelete))
        return toDelete, nil</span>
}

func getFailedMachines(machinesByProviderID map[string]infrav1exp.AzureMachinePoolMachine) []infrav1exp.AzureMachinePoolMachine <span class="cov8" title="1">{
        var machines []infrav1exp.AzureMachinePoolMachine
        for _, v := range machinesByProviderID </span><span class="cov8" title="1">{
                // ready status, with provisioning state Succeeded, and not marked for delete
                if v.Status.ProvisioningState != nil &amp;&amp; *v.Status.ProvisioningState == infrav1.Failed </span><span class="cov0" title="0">{
                        machines = append(machines, v)
                }</span>
        }

        <span class="cov8" title="1">return machines</span>
}

// getDeletingMachines is responsible for identifying machines whose VMs are in an active state of deletion
// but whose corresponding AzureMachinePoolMachine resource has not yet been marked for deletion.
func getDeletingMachines(machinesByProviderID map[string]infrav1exp.AzureMachinePoolMachine) []infrav1exp.AzureMachinePoolMachine <span class="cov8" title="1">{
        var machines []infrav1exp.AzureMachinePoolMachine
        for _, v := range machinesByProviderID </span><span class="cov8" title="1">{
                if v.Status.ProvisioningState != nil &amp;&amp;
                        // provisioning state is Deleting
                        *v.Status.ProvisioningState == infrav1.Deleting &amp;&amp;
                        // Ensure that the machine has not already been marked for deletion
                        v.DeletionTimestamp.IsZero() </span><span class="cov8" title="1">{
                        machines = append(machines, v)
                }</span>
        }

        <span class="cov8" title="1">return machines</span>
}

func getReadyMachines(machinesByProviderID map[string]infrav1exp.AzureMachinePoolMachine) []infrav1exp.AzureMachinePoolMachine <span class="cov8" title="1">{
        var readyMachines []infrav1exp.AzureMachinePoolMachine
        for _, v := range machinesByProviderID </span><span class="cov8" title="1">{
                // ready status, with provisioning state Succeeded, and not marked for delete
                if v.Status.Ready &amp;&amp;
                        (v.Status.ProvisioningState != nil &amp;&amp; *v.Status.ProvisioningState == infrav1.Succeeded) &amp;&amp;
                        // Don't include machines that have already been marked for delete
                        v.DeletionTimestamp.IsZero() &amp;&amp;
                        // Don't include machines whose VMs are in an active state of deleting
                        *v.Status.ProvisioningState != infrav1.Deleting </span><span class="cov8" title="1">{
                        readyMachines = append(readyMachines, v)
                }</span>
        }

        <span class="cov8" title="1">return readyMachines</span>
}

func getMachinesWithoutLatestModel(machinesByProviderID map[string]infrav1exp.AzureMachinePoolMachine) []infrav1exp.AzureMachinePoolMachine <span class="cov8" title="1">{
        var machinesWithLatestModel []infrav1exp.AzureMachinePoolMachine
        for _, v := range machinesByProviderID </span><span class="cov8" title="1">{
                if !v.Status.LatestModelApplied </span><span class="cov8" title="1">{
                        machinesWithLatestModel = append(machinesWithLatestModel, v)
                }</span>
        }

        <span class="cov8" title="1">return machinesWithLatestModel</span>
}

func orderByNewest(machines []infrav1exp.AzureMachinePoolMachine) []infrav1exp.AzureMachinePoolMachine <span class="cov8" title="1">{
        sort.Slice(machines, func(i, j int) bool </span><span class="cov8" title="1">{
                return machines[i].ObjectMeta.CreationTimestamp.After(machines[j].ObjectMeta.CreationTimestamp.Time)
        }</span>)

        <span class="cov8" title="1">return machines</span>
}

func orderByOldest(machines []infrav1exp.AzureMachinePoolMachine) []infrav1exp.AzureMachinePoolMachine <span class="cov8" title="1">{
        sort.Slice(machines, func(i, j int) bool </span><span class="cov8" title="1">{
                return machines[j].ObjectMeta.CreationTimestamp.After(machines[i].ObjectMeta.CreationTimestamp.Time)
        }</span>)

        <span class="cov8" title="1">return machines</span>
}

func orderRandom(machines []infrav1exp.AzureMachinePoolMachine) []infrav1exp.AzureMachinePoolMachine <span class="cov8" title="1">{
        rand.Seed(time.Now().UnixNano())
        rand.Shuffle(len(machines), func(i, j int) </span><span class="cov8" title="1">{ machines[i], machines[j] = machines[j], machines[i] }</span>)
        <span class="cov8" title="1">return machines</span>
}

func getProviderIDs(machines []infrav1exp.AzureMachinePoolMachine) []string <span class="cov8" title="1">{
        ids := make([]string, len(machines))
        for i, machine := range machines </span><span class="cov8" title="1">{
                ids[i] = machine.Spec.ProviderID
        }</span>

        <span class="cov8" title="1">return ids</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package agentpools

import (
        "context"

        "github.com/Azure/azure-sdk-for-go/services/containerservice/mgmt/2021-05-01/containerservice"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/async"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

const serviceName = "agentpools"

// AgentPoolScope defines the scope interface for an agent pool.
type AgentPoolScope interface {
        azure.ClusterDescriber
        azure.AsyncStatusUpdater

        Name() string
        NodeResourceGroup() string
        AgentPoolAnnotations() map[string]string
        AgentPoolSpec() azure.ResourceSpecGetter
        SetAgentPoolProviderIDList([]string)
        SetAgentPoolReplicas(int32)
        SetAgentPoolReady(bool)
        SetCAPIMachinePoolReplicas(replicas *int32)
        SetCAPIMachinePoolAnnotation(key, value string)
        RemoveCAPIMachinePoolAnnotation(key string)
}

// Service provides operations on Azure resources.
type Service struct {
        scope AgentPoolScope
        async.Reconciler
}

// New creates a new service.
func New(scope AgentPoolScope) *Service <span class="cov0" title="0">{
        client := newClient(scope)
        return &amp;Service{
                scope:      scope,
                Reconciler: async.New(scope, client, client),
        }
}</span>

// Name returns the service name.
func (s *Service) Name() string <span class="cov0" title="0">{
        return serviceName
}</span>

// Reconcile idempotently creates or updates an agent pool, if possible.
func (s *Service) Reconcile(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "agentpools.Service.Reconcile")
        defer done()

        var resultingErr error
        if agentPoolSpec := s.scope.AgentPoolSpec(); agentPoolSpec != nil </span><span class="cov8" title="1">{
                result, err := s.CreateResource(ctx, agentPoolSpec, serviceName)
                if err != nil </span><span class="cov8" title="1">{
                        resultingErr = err
                }</span> else<span class="cov8" title="1"> {
                        agentPool, ok := result.(containerservice.AgentPool)
                        if !ok </span><span class="cov0" title="0">{
                                return errors.Errorf("%T is not a containerservice.AgentPool", result)
                        }</span>
                        // When autoscaling is set, add the annotation to the machine pool and update the replica count.
                        <span class="cov8" title="1">if to.Bool(agentPool.EnableAutoScaling) </span><span class="cov8" title="1">{
                                s.scope.SetCAPIMachinePoolAnnotation(azure.ReplicasManagedByAutoscalerAnnotation, "true")
                                s.scope.SetCAPIMachinePoolReplicas(agentPool.Count)
                        }</span> else<span class="cov8" title="1"> { // Otherwise, remove the annotation.
                                s.scope.RemoveCAPIMachinePoolAnnotation(azure.ReplicasManagedByAutoscalerAnnotation)
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                return nil
        }</span>

        <span class="cov8" title="1">s.scope.UpdatePutStatus(infrav1.AgentPoolsReadyCondition, serviceName, resultingErr)
        return resultingErr</span>
}

// Delete deletes the virtual network with the provided name.
func (s *Service) Delete(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "agentpools.Service.Delete")
        defer done()

        var resultingErr error
        if agentPoolSpec := s.scope.AgentPoolSpec(); agentPoolSpec != nil </span><span class="cov8" title="1">{
                resultingErr = s.DeleteResource(ctx, agentPoolSpec, serviceName)
        }</span> else<span class="cov8" title="1"> {
                return nil
        }</span>

        <span class="cov8" title="1">s.scope.UpdateDeleteStatus(infrav1.AgentPoolsReadyCondition, serviceName, resultingErr)
        return resultingErr</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package agentpools

import (
        "context"
        "encoding/json"

        "github.com/Azure/azure-sdk-for-go/services/containerservice/mgmt/2021-05-01/containerservice"
        "github.com/Azure/go-autorest/autorest"
        azureautorest "github.com/Azure/go-autorest/autorest/azure"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// azureClient contains the Azure go-sdk Client.
type azureClient struct {
        agentpools containerservice.AgentPoolsClient
}

// newClient creates a new agent pools client from subscription ID.
func newClient(auth azure.Authorizer) *azureClient <span class="cov0" title="0">{
        c := newAgentPoolsClient(auth.SubscriptionID(), auth.BaseURI(), auth.Authorizer())
        return &amp;azureClient{c}
}</span>

// newAgentPoolsClient creates a new agent pool client from subscription ID.
func newAgentPoolsClient(subscriptionID string, baseURI string, authorizer autorest.Authorizer) containerservice.AgentPoolsClient <span class="cov0" title="0">{
        agentPoolsClient := containerservice.NewAgentPoolsClientWithBaseURI(baseURI, subscriptionID)
        azure.SetAutoRestClientDefaults(&amp;agentPoolsClient.Client, authorizer)
        return agentPoolsClient
}</span>

// Get gets an agent pool.
func (ac *azureClient) Get(ctx context.Context, spec azure.ResourceSpecGetter) (result interface{}, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "agentpools.azureClient.Get")
        defer done()

        return ac.agentpools.Get(ctx, spec.ResourceGroupName(), spec.OwnerResourceName(), spec.ResourceName())
}</span>

// CreateOrUpdateAsync creates or updates an agent pool asynchronously.
// It sends a PUT request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *azureClient) CreateOrUpdateAsync(ctx context.Context, spec azure.ResourceSpecGetter, parameters interface{}) (result interface{}, future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "agentpools.azureClient.CreateOrUpdate")
        defer done()

        agentPool, ok := parameters.(containerservice.AgentPool)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.Errorf("%T is not a containerservice.AgentPool", parameters)
        }</span>

        <span class="cov0" title="0">preparer, err := ac.agentpools.CreateOrUpdatePreparer(ctx, spec.ResourceGroupName(), spec.OwnerResourceName(), spec.ResourceName(), agentPool)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errors.Wrap(err, "failed to prepare operation")
        }</span>

        <span class="cov0" title="0">headerSpec, ok := spec.(azure.ResourceSpecGetterWithHeaders)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.Errorf("%T is not a azure.ResourceSpecGetterWithHeaders", spec)
        }</span>
        <span class="cov0" title="0">for key, element := range headerSpec.CustomHeaders() </span><span class="cov0" title="0">{
                preparer.Header.Add(key, element)
        }</span>

        <span class="cov0" title="0">createFuture, err := ac.agentpools.CreateOrUpdateSender(preparer)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errors.Wrap(err, "failed to begin operation")
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = createFuture.WaitForCompletionRef(ctx, ac.agentpools.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return nil, &amp;createFuture, err
        }</span>
        <span class="cov0" title="0">result, err = createFuture.Result(ac.agentpools)
        // if the operation completed, return a nil future
        return result, nil, err</span>
}

// DeleteAsync deletes an agent pool asynchronously. DeleteAsync sends a DELETE
// request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *azureClient) DeleteAsync(ctx context.Context, spec azure.ResourceSpecGetter) (future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "agentpools.azureClient.Delete")
        defer done()

        deleteFuture, err := ac.agentpools.Delete(ctx, spec.ResourceGroupName(), spec.OwnerResourceName(), spec.ResourceName())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = deleteFuture.WaitForCompletionRef(ctx, ac.agentpools.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return &amp;deleteFuture, err
        }</span>
        <span class="cov0" title="0">_, err = deleteFuture.Result(ac.agentpools)
        // if the operation completed, return a nil future.
        return nil, err</span>
}

// IsDone returns true if the long-running operation has completed.
func (ac *azureClient) IsDone(ctx context.Context, future azureautorest.FutureAPI) (isDone bool, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "agentpools.azureClient.IsDone")
        defer done()

        isDone, err = future.DoneWithContext(ctx, ac.agentpools)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "failed checking if the operation was complete")
        }</span>

        <span class="cov0" title="0">return isDone, nil</span>
}

// Result fetches the result of a long-running operation future.
func (ac *azureClient) Result(ctx context.Context, future azureautorest.FutureAPI, futureType string) (result interface{}, err error) <span class="cov0" title="0">{
        _, _, done := tele.StartSpanWithLogger(ctx, "agentpools.azureClient.Result")
        defer done()

        if future == nil </span><span class="cov0" title="0">{
                return nil, errors.Errorf("cannot get result from nil future")
        }</span>

        <span class="cov0" title="0">switch futureType </span>{
        case infrav1.PutFuture:<span class="cov0" title="0">
                // Marshal and Unmarshal the future to put it into the correct future type so we can access the Result function.
                // Unfortunately the FutureAPI can't be casted directly to AgentPoolsCreateOrUpdateFuture because it is a azureautorest.Future, which doesn't implement the Result function. See PR #1686 for discussion on alternatives.
                // It was converted back to a generic azureautorest.Future from the CAPZ infrav1.Future type stored in Status: https://github.com/kubernetes-sigs/cluster-api-provider-azure/blob/main/azure/converters/futures.go#L49.
                var createFuture *containerservice.AgentPoolsCreateOrUpdateFuture
                jsonData, err := future.MarshalJSON()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to marshal future")
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal(jsonData, &amp;createFuture); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to unmarshal future data")
                }</span>
                <span class="cov0" title="0">return createFuture.Result(ac.agentpools)</span>

        case infrav1.DeleteFuture:<span class="cov0" title="0">
                // Delete does not return a result agentPool.
                return nil, nil</span>

        default:<span class="cov0" title="0">
                return nil, errors.Errorf("unknown future type %q", futureType)</span>
        }
}
</pre>
		
		<pre class="file" id="file78" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package agentpools

import (
        "fmt"
        "time"

        "github.com/Azure/azure-sdk-for-go/services/containerservice/mgmt/2021-05-01/containerservice"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/google/go-cmp/cmp"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
)

// AgentPoolSpec contains agent pool specification details.
type AgentPoolSpec struct {
        // Name is the name of agent pool.
        Name string

        // ResourceGroup is the name of the Azure resource group for the AKS Cluster.
        ResourceGroup string

        // Cluster is the name of the AKS cluster.
        Cluster string

        // Version defines the desired Kubernetes version.
        Version *string

        // SKU defines the Azure VM size for the agent pool VMs.
        SKU string

        // Replicas is the number of desired machines.
        Replicas int32

        // OSDiskSizeGB is the OS disk size in GB for every machine in this agent pool.
        OSDiskSizeGB int32

        // VnetSubnetID is the Azure Resource ID for the subnet which should contain nodes.
        VnetSubnetID string

        // Mode represents mode of an agent pool. Possible values include: 'System', 'User'.
        Mode string

        //  Maximum number of nodes for auto-scaling
        MaxCount *int32 `json:"maxCount,omitempty"`

        // Minimum number of nodes for auto-scaling
        MinCount *int32 `json:"minCount,omitempty"`

        // Node labels - labels for all of the nodes present in node pool
        NodeLabels map[string]*string `json:"nodeLabels,omitempty"`

        // NodeTaints specifies the taints for nodes present in this agent pool.
        NodeTaints []string `json:"nodeTaints,omitempty"`

        // EnableAutoScaling - Whether to enable auto-scaler
        EnableAutoScaling *bool `json:"enableAutoScaling,omitempty"`

        // AvailabilityZones represents the Availability zones for nodes in the AgentPool.
        AvailabilityZones []string

        // MaxPods specifies the kubelet --max-pods configuration for the agent pool.
        MaxPods *int32 `json:"maxPods,omitempty"`

        // OsDiskType specifies the OS disk type for each node in the pool. Allowed values are 'Ephemeral' and 'Managed'.
        OsDiskType *string `json:"osDiskType,omitempty"`

        // EnableUltraSSD enables the storage type UltraSSD_LRS for the agent pool.
        EnableUltraSSD *bool `json:"enableUltraSSD,omitempty"`

        // OSType specifies the operating system for the node pool. Allowed values are 'Linux' and 'Windows'
        OSType *string `json:"osType,omitempty"`

        // Headers is the list of headers to add to the HTTP requests to update this resource.
        Headers map[string]string

        // EnableNodePublicIP controls whether or not nodes in the agent pool each have a public IP address.
        EnableNodePublicIP *bool `json:"enableNodePublicIP,omitempty"`
}

// ResourceName returns the name of the agent pool.
func (s *AgentPoolSpec) ResourceName() string <span class="cov0" title="0">{
        return s.Name
}</span>

// ResourceGroupName returns the name of the resource group.
func (s *AgentPoolSpec) ResourceGroupName() string <span class="cov0" title="0">{
        return s.ResourceGroup
}</span>

// OwnerResourceName is a no-op for agent pools.
func (s *AgentPoolSpec) OwnerResourceName() string <span class="cov0" title="0">{
        return s.Cluster
}</span>

// CustomHeaders returns custom headers to be added to the Azure API calls.
func (s *AgentPoolSpec) CustomHeaders() map[string]string <span class="cov0" title="0">{
        return s.Headers
}</span>

// Parameters returns the parameters for the agent pool.
func (s *AgentPoolSpec) Parameters(existing interface{}) (params interface{}, err error) <span class="cov8" title="1">{
        if existing != nil </span><span class="cov8" title="1">{
                existingPool, ok := existing.(containerservice.AgentPool)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("%T is not a containerservice.AgentPool", existing)
                }</span>

                // agent pool already exists
                <span class="cov8" title="1">ps := *existingPool.ManagedClusterAgentPoolProfileProperties.ProvisioningState
                if ps != string(infrav1.Canceled) &amp;&amp; ps != string(infrav1.Failed) &amp;&amp; ps != string(infrav1.Succeeded) </span><span class="cov8" title="1">{
                        msg := fmt.Sprintf("Unable to update existing agent pool in non terminal state. Agent pool must be in one of the following provisioning states: Canceled, Failed, or Succeeded. Actual state: %s", ps)
                        return nil, azure.WithTransientError(errors.New(msg), 20*time.Second)
                }</span>

                // Normalize individual agent pools to diff in case we need to update
                <span class="cov8" title="1">existingProfile := containerservice.AgentPool{
                        ManagedClusterAgentPoolProfileProperties: &amp;containerservice.ManagedClusterAgentPoolProfileProperties{
                                Count:               existingPool.Count,
                                OrchestratorVersion: existingPool.OrchestratorVersion,
                                Mode:                existingPool.Mode,
                                EnableAutoScaling:   existingPool.EnableAutoScaling,
                                MinCount:            existingPool.MinCount,
                                MaxCount:            existingPool.MaxCount,
                                NodeLabels:          existingPool.NodeLabels,
                        },
                }

                normalizedProfile := containerservice.AgentPool{
                        ManagedClusterAgentPoolProfileProperties: &amp;containerservice.ManagedClusterAgentPoolProfileProperties{
                                Count:               &amp;s.Replicas,
                                OrchestratorVersion: s.Version,
                                Mode:                containerservice.AgentPoolMode(s.Mode),
                                EnableAutoScaling:   s.EnableAutoScaling,
                                MinCount:            s.MinCount,
                                MaxCount:            s.MaxCount,
                                NodeLabels:          s.NodeLabels,
                        },
                }

                // When autoscaling is set, the count of the nodes differ based on the autoscaler and should not depend on the
                // count present in MachinePool or AzureManagedMachinePool, hence we should not make an update API call based
                // on difference in count.
                if to.Bool(s.EnableAutoScaling) </span><span class="cov8" title="1">{
                        normalizedProfile.Count = existingProfile.Count
                }</span>

                // Compute a diff to check if we require an update
                <span class="cov8" title="1">diff := cmp.Diff(normalizedProfile, existingProfile)
                if diff == "" </span><span class="cov8" title="1">{
                        // agent pool is up to date, nothing to do
                        return nil, nil
                }</span>
        }

        <span class="cov8" title="1">var availabilityZones *[]string
        if len(s.AvailabilityZones) &gt; 0 </span><span class="cov8" title="1">{
                availabilityZones = &amp;s.AvailabilityZones
        }</span>
        <span class="cov8" title="1">var replicas *int32
        if s.Replicas &gt; 0 </span><span class="cov8" title="1">{
                replicas = &amp;s.Replicas
        }</span>
        <span class="cov8" title="1">var nodeTaints *[]string
        if len(s.NodeTaints) &gt; 0 </span><span class="cov8" title="1">{
                nodeTaints = &amp;s.NodeTaints
        }</span>
        <span class="cov8" title="1">var sku *string
        if s.SKU != "" </span><span class="cov8" title="1">{
                sku = &amp;s.SKU
        }</span>
        <span class="cov8" title="1">var vnetSubnetID *string
        if s.VnetSubnetID != "" </span><span class="cov8" title="1">{
                vnetSubnetID = &amp;s.VnetSubnetID
        }</span>

        <span class="cov8" title="1">return containerservice.AgentPool{
                ManagedClusterAgentPoolProfileProperties: &amp;containerservice.ManagedClusterAgentPoolProfileProperties{
                        AvailabilityZones:   availabilityZones,
                        Count:               replicas,
                        EnableAutoScaling:   s.EnableAutoScaling,
                        EnableUltraSSD:      s.EnableUltraSSD,
                        MaxCount:            s.MaxCount,
                        MaxPods:             s.MaxPods,
                        MinCount:            s.MinCount,
                        Mode:                containerservice.AgentPoolMode(s.Mode),
                        NodeLabels:          s.NodeLabels,
                        NodeTaints:          nodeTaints,
                        OrchestratorVersion: s.Version,
                        OsDiskSizeGB:        &amp;s.OSDiskSizeGB,
                        OsDiskType:          containerservice.OSDiskType(to.String(s.OsDiskType)),
                        OsType:              containerservice.OSType(to.String(s.OSType)),
                        Type:                containerservice.AgentPoolTypeVirtualMachineScaleSets,
                        VMSize:              sku,
                        VnetSubnetID:        vnetSubnetID,
                        EnableNodePublicIP:  s.EnableNodePublicIP,
                },
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package async

import (
        "context"
        "time"

        azureautorest "github.com/Azure/go-autorest/autorest/azure"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/converters"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// Service is an implementation of the Reconciler interface. It handles asynchronous creation and deletion of resources.
type Service struct {
        Scope FutureScope
        Creator
        Deleter
}

// New creates a new async service.
func New(scope FutureScope, createClient Creator, deleteClient Deleter) *Service <span class="cov8" title="1">{
        return &amp;Service{
                Scope:   scope,
                Creator: createClient,
                Deleter: deleteClient,
        }
}</span>

// processOngoingOperation is a helper function that will process an ongoing operation to check if it is done.
// If it is not done, it will return a transient error.
func processOngoingOperation(ctx context.Context, scope FutureScope, client FutureHandler, resourceName string, serviceName string) (result interface{}, err error) <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "async.Service.processOngoingOperation")
        defer done()

        future := scope.GetLongRunningOperationState(resourceName, serviceName)
        if future == nil </span><span class="cov8" title="1">{
                log.V(2).Info("no long running operation found", "service", serviceName, "resource", resourceName)
                return nil, nil
        }</span>
        <span class="cov8" title="1">sdkFuture, err := converters.FutureToSDK(*future)
        if err != nil </span><span class="cov8" title="1">{
                // Reset the future data to avoid getting stuck in a bad loop.
                // In theory, this should never happen, but if for some reason the future that is already stored in Status isn't properly formatted
                // and we don't reset it we would be stuck in an infinite loop trying to parse it.
                scope.DeleteLongRunningOperationState(resourceName, serviceName)
                return nil, errors.Wrap(err, "could not decode future data, resetting long-running operation state")
        }</span>

        <span class="cov8" title="1">isDone, err := client.IsDone(ctx, sdkFuture)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, "failed checking if the operation was complete")
        }</span>

        <span class="cov8" title="1">if !isDone </span><span class="cov8" title="1">{
                // Operation is still in progress, update conditions and requeue.
                log.V(2).Info("long running operation is still ongoing", "service", serviceName, "resource", resourceName)
                return nil, azure.WithTransientError(azure.NewOperationNotDoneError(future), retryAfter(sdkFuture))
        }</span>

        // Resource has been created/deleted/updated.
        <span class="cov8" title="1">log.V(2).Info("long running operation has completed", "service", serviceName, "resource", resourceName)
        result, err = client.Result(ctx, sdkFuture, future.Type)
        if err == nil || azure.ResourceNotFound(err) </span><span class="cov8" title="1">{
                // Once we have the result, we can delete the long running operation state.
                // If the resource is not found, we also reset the long-running operation state so we can attempt to create it again.
                // This can happen if the resource was deleted by another process before we could get the result.
                scope.DeleteLongRunningOperationState(resourceName, serviceName)
        }</span>
        <span class="cov8" title="1">return result, err</span>
}

// CreateResource implements the logic for creating a resource Asynchronously.
func (s *Service) CreateResource(ctx context.Context, spec azure.ResourceSpecGetter, serviceName string) (result interface{}, err error) <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "async.Service.CreateResource")
        defer done()

        resourceName := spec.ResourceName()
        rgName := spec.ResourceGroupName()

        // Check if there is an ongoing long running operation.
        future := s.Scope.GetLongRunningOperationState(resourceName, serviceName)
        if future != nil </span><span class="cov8" title="1">{
                return processOngoingOperation(ctx, s.Scope, s.Creator, resourceName, serviceName)
        }</span>

        // Get the resource if it already exists, and use it to construct the desired resource parameters.
        <span class="cov8" title="1">var existingResource interface{}
        if existing, err := s.Creator.Get(ctx, spec); err != nil &amp;&amp; !azure.ResourceNotFound(err) </span><span class="cov8" title="1">{
                return nil, errors.Wrapf(err, "failed to get existing resource %s/%s (service: %s)", rgName, resourceName, serviceName)
        }</span> else<span class="cov8" title="1"> if err == nil </span><span class="cov8" title="1">{
                existingResource = existing
                log.V(2).Info("successfully got existing resource", "service", serviceName, "resource", resourceName, "resourceGroup", rgName)
        }</span>

        // Construct parameters using the resource spec and information from the existing resource, if there is one.
        <span class="cov8" title="1">parameters, err := spec.Parameters(existingResource)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrapf(err, "failed to get desired parameters for resource %s/%s (service: %s)", rgName, resourceName, serviceName)
        }</span> else<span class="cov8" title="1"> if parameters == nil </span><span class="cov8" title="1">{
                // Nothing to do, don't create or update the resource and return the existing resource.
                log.V(2).Info("resource up to date", "service", serviceName, "resource", resourceName, "resourceGroup", rgName)
                return existingResource, nil
        }</span>

        // Create or update the resource with the desired parameters.
        <span class="cov8" title="1">log.V(2).Info("creating resource", "service", serviceName, "resource", resourceName, "resourceGroup", rgName)
        result, sdkFuture, err := s.Creator.CreateOrUpdateAsync(ctx, spec, parameters)
        if sdkFuture != nil </span><span class="cov8" title="1">{
                future, err := converters.SDKToFuture(sdkFuture, infrav1.PutFuture, serviceName, resourceName, rgName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrapf(err, "failed to create resource %s/%s (service: %s)", rgName, resourceName, serviceName)
                }</span>
                <span class="cov8" title="1">s.Scope.SetLongRunningOperationState(future)
                return nil, azure.WithTransientError(azure.NewOperationNotDoneError(future), retryAfter(sdkFuture))</span>
        } else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrapf(err, "failed to create resource %s/%s (service: %s)", rgName, resourceName, serviceName)
        }</span>

        <span class="cov8" title="1">log.V(2).Info("successfully created resource", "service", serviceName, "resource", resourceName, "resourceGroup", rgName)
        return result, nil</span>
}

// DeleteResource implements the logic for deleting a resource Asynchronously.
func (s *Service) DeleteResource(ctx context.Context, spec azure.ResourceSpecGetter, serviceName string) (err error) <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "async.Service.DeleteResource")
        defer done()

        resourceName := spec.ResourceName()
        rgName := spec.ResourceGroupName()

        // Check if there is an ongoing long running operation.
        future := s.Scope.GetLongRunningOperationState(resourceName, serviceName)
        if future != nil </span><span class="cov8" title="1">{
                _, err := processOngoingOperation(ctx, s.Scope, s.Deleter, resourceName, serviceName)
                return err
        }</span>

        // No long running operation is active, so delete the resource.
        <span class="cov8" title="1">log.V(2).Info("deleting resource", "service", serviceName, "resource", resourceName, "resourceGroup", rgName)
        sdkFuture, err := s.Deleter.DeleteAsync(ctx, spec)
        if sdkFuture != nil </span><span class="cov8" title="1">{
                future, err := converters.SDKToFuture(sdkFuture, infrav1.DeleteFuture, serviceName, resourceName, rgName)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrapf(err, "failed to delete resource %s/%s (service: %s)", rgName, resourceName, serviceName)
                }</span>
                <span class="cov8" title="1">s.Scope.SetLongRunningOperationState(future)
                return azure.WithTransientError(azure.NewOperationNotDoneError(future), retryAfter(sdkFuture))</span>
        } else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                if azure.ResourceNotFound(err) </span><span class="cov8" title="1">{
                        // already deleted
                        return nil
                }</span>
                <span class="cov8" title="1">return errors.Wrapf(err, "failed to delete resource %s/%s (service: %s)", rgName, resourceName, serviceName)</span>
        }

        <span class="cov8" title="1">log.V(2).Info("successfully deleted resource", "service", serviceName, "resource", resourceName, "resourceGroup", rgName)
        return nil</span>
}

// retryAfter returns the max between the `RETRY-AFTER` header and the default requeue time.
// This ensures we respect the retry-after header if it is set and avoid retrying too often during an API throttling event.
func retryAfter(sdkFuture azureautorest.FutureAPI) time.Duration <span class="cov8" title="1">{
        retryAfter, _ := sdkFuture.GetPollingDelay()
        if retryAfter &lt; reconciler.DefaultReconcilerRequeue </span><span class="cov8" title="1">{
                retryAfter = reconciler.DefaultReconcilerRequeue
        }</span>
        <span class="cov8" title="1">return retryAfter</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package availabilitysets

import (
        "context"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-11-01/compute"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/async"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/resourceskus"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

const serviceName = "availabilitysets"

// AvailabilitySetScope defines the scope interface for a availability sets service.
type AvailabilitySetScope interface {
        azure.ClusterDescriber
        azure.AsyncStatusUpdater
        AvailabilitySetSpec() azure.ResourceSpecGetter
}

// Service provides operations on Azure resources.
type Service struct {
        Scope AvailabilitySetScope
        async.Getter
        async.Reconciler
        resourceSKUCache *resourceskus.Cache
}

// New creates a new availability sets service.
func New(scope AvailabilitySetScope, skuCache *resourceskus.Cache) *Service <span class="cov0" title="0">{
        client := NewClient(scope)
        return &amp;Service{
                Scope:            scope,
                Getter:           client,
                resourceSKUCache: skuCache,
                Reconciler:       async.New(scope, client, client),
        }
}</span>

// Name returns the service name.
func (s *Service) Name() string <span class="cov0" title="0">{
        return serviceName
}</span>

// Reconcile creates or updates availability sets.
func (s *Service) Reconcile(ctx context.Context) error <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "availabilitysets.Service.Reconcile")
        defer done()

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        var err error
        if setSpec := s.Scope.AvailabilitySetSpec(); setSpec != nil </span><span class="cov8" title="1">{
                _, err = s.CreateResource(ctx, setSpec, serviceName)
        }</span> else<span class="cov8" title="1"> {
                log.V(2).Info("skip creation when no availability set spec is found")
                return nil
        }</span>

        <span class="cov8" title="1">s.Scope.UpdatePutStatus(infrav1.AvailabilitySetReadyCondition, serviceName, err)
        return err</span>
}

// Delete deletes availability sets.
func (s *Service) Delete(ctx context.Context) error <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "availabilitysets.Service.Delete")
        defer done()

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        var resultingErr error
        setSpec := s.Scope.AvailabilitySetSpec()
        if setSpec == nil </span><span class="cov8" title="1">{
                log.V(2).Info("skip deletion when no availability set spec is found")
                return nil
        }</span>

        <span class="cov8" title="1">existingSet, err := s.Get(ctx, setSpec)
        if err != nil </span><span class="cov8" title="1">{
                if !azure.ResourceNotFound(err) </span><span class="cov8" title="1">{
                        resultingErr = errors.Wrapf(err, "failed to get availability set %s in resource group %s", setSpec.ResourceName(), setSpec.ResourceGroupName())
                }</span>
        } else<span class="cov8" title="1"> {
                availabilitySet, ok := existingSet.(compute.AvailabilitySet)
                if !ok </span><span class="cov8" title="1">{
                        resultingErr = errors.Errorf("%T is not a compute.AvailabilitySet", existingSet)
                }</span> else<span class="cov8" title="1"> {
                        // only delete when the availability set does not have any vms
                        if availabilitySet.AvailabilitySetProperties != nil &amp;&amp; availabilitySet.VirtualMachines != nil &amp;&amp; len(*availabilitySet.VirtualMachines) &gt; 0 </span><span class="cov8" title="1">{
                                log.V(2).Info("skip deleting availability set with VMs", "availability set", setSpec.ResourceName())
                        }</span> else<span class="cov8" title="1"> {
                                resultingErr = s.DeleteResource(ctx, setSpec, serviceName)
                        }</span>
                }
        }

        <span class="cov8" title="1">s.Scope.UpdateDeleteStatus(infrav1.AvailabilitySetReadyCondition, serviceName, resultingErr)
        return resultingErr</span>
}

// IsManaged returns always returns true as CAPZ does not support BYO availability set.
func (s *Service) IsManaged(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>
</pre>
		
		<pre class="file" id="file81" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package availabilitysets

import (
        "context"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-11-01/compute"
        "github.com/Azure/go-autorest/autorest"
        azureautorest "github.com/Azure/go-autorest/autorest/azure"
        "github.com/pkg/errors"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// AzureClient contains the Azure go-sdk Client.
type AzureClient struct {
        availabilitySets compute.AvailabilitySetsClient
}

// NewClient creates a new Resource SKUs Client from subscription ID.
func NewClient(auth azure.Authorizer) *AzureClient <span class="cov0" title="0">{
        return &amp;AzureClient{
                availabilitySets: newAvailabilitySetsClient(auth.SubscriptionID(), auth.BaseURI(), auth.Authorizer()),
        }
}</span>

// newAvailabilitySetsClient creates a new AvailabilitySets Client from subscription ID.
func newAvailabilitySetsClient(subscriptionID string, baseURI string, authorizer autorest.Authorizer) compute.AvailabilitySetsClient <span class="cov0" title="0">{
        asClient := compute.NewAvailabilitySetsClientWithBaseURI(baseURI, subscriptionID)
        azure.SetAutoRestClientDefaults(&amp;asClient.Client, authorizer)
        return asClient
}</span>

// Get gets an availability set.
func (ac *AzureClient) Get(ctx context.Context, spec azure.ResourceSpecGetter) (result interface{}, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "availabilitysets.AzureClient.Get")
        defer done()

        return ac.availabilitySets.Get(ctx, spec.ResourceGroupName(), spec.ResourceName())
}</span>

// CreateOrUpdateAsync creates or updates a availability set asynchronously.
// It sends a PUT request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *AzureClient) CreateOrUpdateAsync(ctx context.Context, spec azure.ResourceSpecGetter, parameters interface{}) (result interface{}, future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "availabilitySets.AzureClient.CreateOrUpdateAsync")
        defer done()

        availabilitySet, ok := parameters.(compute.AvailabilitySet)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.Errorf("%T is not a compute.AvailabilitySet", parameters)
        }</span>

        <span class="cov0" title="0">result, err = ac.availabilitySets.CreateOrUpdate(ctx, spec.ResourceGroupName(), spec.ResourceName(), availabilitySet)
        return result, nil, err</span>
}

// DeleteAsync deletes a availability set asynchronously. DeleteAsync sends a DELETE
// request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *AzureClient) DeleteAsync(ctx context.Context, spec azure.ResourceSpecGetter) (future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "availabilitysets.AzureClient.Delete")
        defer done()

        _, err = ac.availabilitySets.Delete(ctx, spec.ResourceGroupName(), spec.ResourceName())

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return nil, nil</span>
}

// Result fetches the result of a long-running operation future.
func (ac *AzureClient) Result(ctx context.Context, future azureautorest.FutureAPI, futureType string) (result interface{}, err error) <span class="cov0" title="0">{
        // Result is a no-op for resource groups as only Delete operations return a future.
        return nil, nil
}</span>

// IsDone returns true if the long-running operation has completed.
func (ac *AzureClient) IsDone(ctx context.Context, future azureautorest.FutureAPI) (isDone bool, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "availabilitysets.AzureClient.IsDone")
        defer done()

        isDone, err = future.DoneWithContext(ctx, ac.availabilitySets)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "failed checking if the operation was complete")
        }</span>

        <span class="cov0" title="0">return isDone, nil</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package availabilitysets

import (
        "strconv"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-11-01/compute"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure/converters"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/resourceskus"
)

// AvailabilitySetSpec defines the specification for an availability set.
type AvailabilitySetSpec struct {
        Name           string
        ResourceGroup  string
        ClusterName    string
        Location       string
        SKU            *resourceskus.SKU
        AdditionalTags infrav1.Tags
}

// ResourceName returns the name of the availability set.
func (s *AvailabilitySetSpec) ResourceName() string <span class="cov8" title="1">{
        return s.Name
}</span>

// ResourceGroupName returns the name of the resource group.
func (s *AvailabilitySetSpec) ResourceGroupName() string <span class="cov8" title="1">{
        return s.ResourceGroup
}</span>

// OwnerResourceName is a no-op for availability sets.
func (s *AvailabilitySetSpec) OwnerResourceName() string <span class="cov0" title="0">{
        return ""
}</span>

// Parameters returns the parameters for the availability set.
func (s *AvailabilitySetSpec) Parameters(existing interface{}) (params interface{}, err error) <span class="cov8" title="1">{
        if existing != nil </span><span class="cov0" title="0">{
                if _, ok := existing.(compute.AvailabilitySet); !ok </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("%T is not a compute.AvailabilitySet", existing)
                }</span>
                // availability set already exists
                <span class="cov0" title="0">return nil, nil</span>
        }

        <span class="cov8" title="1">if s.SKU == nil </span><span class="cov8" title="1">{
                return nil, errors.New("unable to get required availability set SKU from machine cache")
        }</span>

        <span class="cov8" title="1">var faultDomainCount *int32
        faultDomainCountStr, ok := s.SKU.GetCapability(resourceskus.MaximumPlatformFaultDomainCount)
        if !ok </span><span class="cov8" title="1">{
                return nil, errors.Errorf("unable to get required availability set SKU capability %s", resourceskus.MaximumPlatformFaultDomainCount)
        }</span>
        <span class="cov8" title="1">count, err := strconv.ParseInt(faultDomainCountStr, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "unable to parse availability set fault domain count")
        }</span>
        <span class="cov8" title="1">faultDomainCount = to.Int32Ptr(int32(count))

        asParams := compute.AvailabilitySet{
                Sku: &amp;compute.Sku{
                        Name: to.StringPtr(string(compute.AvailabilitySetSkuTypesAligned)),
                },
                AvailabilitySetProperties: &amp;compute.AvailabilitySetProperties{
                        PlatformFaultDomainCount: faultDomainCount,
                },
                Tags: converters.TagsToMap(infrav1.Build(infrav1.BuildParams{
                        ClusterName: s.ClusterName,
                        Lifecycle:   infrav1.ResourceLifecycleOwned,
                        Name:        to.StringPtr(s.Name),
                        Role:        to.StringPtr(infrav1.CommonRole),
                        Additional:  s.AdditionalTags,
                })),
                Location: to.StringPtr(s.Location),
        }

        return asParams, nil</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package bastionhosts

import (
        "context"

        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/async"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

const serviceName = "bastionhosts"

// BastionScope defines the scope interface for a bastion host service.
type BastionScope interface {
        azure.ClusterScoper
        azure.AsyncStatusUpdater
        AzureBastionSpec() azure.ResourceSpecGetter
}

// Service provides operations on Azure resources.
type Service struct {
        Scope BastionScope
        async.Reconciler
}

// New creates a new service.
func New(scope BastionScope) *Service <span class="cov0" title="0">{
        client := newClient(scope)
        return &amp;Service{
                Scope:      scope,
                Reconciler: async.New(scope, client, client),
        }
}</span>

// Name returns the service name.
func (s *Service) Name() string <span class="cov0" title="0">{
        return serviceName
}</span>

// Reconcile gets/creates/updates a bastion host.
func (s *Service) Reconcile(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "bastionhosts.Service.Reconcile")
        defer done()

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        var resultingErr error
        if bastionSpec := s.Scope.AzureBastionSpec(); bastionSpec != nil </span><span class="cov8" title="1">{
                _, resultingErr = s.CreateResource(ctx, bastionSpec, serviceName)
        }</span> else<span class="cov8" title="1"> {
                return nil
        }</span>

        <span class="cov8" title="1">s.Scope.UpdatePutStatus(infrav1.BastionHostReadyCondition, serviceName, resultingErr)
        return resultingErr</span>
}

// Delete deletes the bastion host with the provided scope.
func (s *Service) Delete(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "bastionhosts.Service.Delete")
        defer done()

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        var resultingErr error
        if bastionSpec := s.Scope.AzureBastionSpec(); bastionSpec != nil </span><span class="cov8" title="1">{
                resultingErr = s.DeleteResource(ctx, bastionSpec, serviceName)
        }</span> else<span class="cov8" title="1"> {
                return nil
        }</span>

        <span class="cov8" title="1">s.Scope.UpdateDeleteStatus(infrav1.BastionHostReadyCondition, serviceName, resultingErr)
        return resultingErr</span>
}

// IsManaged returns always returns true as CAPZ does not support BYO bastion.
func (s *Service) IsManaged(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>
</pre>
		
		<pre class="file" id="file84" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package bastionhosts

import (
        "context"
        "encoding/json"

        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-08-01/network"
        "github.com/Azure/go-autorest/autorest"
        azureautorest "github.com/Azure/go-autorest/autorest/azure"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// azureClient contains the Azure go-sdk Client.
type azureClient struct {
        bastionhosts network.BastionHostsClient
}

// newClient creates a new VM client from subscription ID.
func newClient(auth azure.Authorizer) *azureClient <span class="cov0" title="0">{
        c := newBastionHostsClient(auth.SubscriptionID(), auth.BaseURI(), auth.Authorizer())
        return &amp;azureClient{c}
}</span>

// newBastionHostsClient creates a new bastion host client from subscription ID.
func newBastionHostsClient(subscriptionID string, baseURI string, authorizer autorest.Authorizer) network.BastionHostsClient <span class="cov0" title="0">{
        bastionClient := network.NewBastionHostsClientWithBaseURI(baseURI, subscriptionID)
        azure.SetAutoRestClientDefaults(&amp;bastionClient.Client, authorizer)
        return bastionClient
}</span>

// Get gets the specified bastion host.
func (ac *azureClient) Get(ctx context.Context, spec azure.ResourceSpecGetter) (result interface{}, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "bastionhosts.azureClient.Get")
        defer done()

        return ac.bastionhosts.Get(ctx, spec.ResourceGroupName(), spec.ResourceName())
}</span>

// CreateOrUpdateAsync creates or updates a bastion host asynchronously.
// It sends a PUT request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *azureClient) CreateOrUpdateAsync(ctx context.Context, spec azure.ResourceSpecGetter, parameters interface{}) (result interface{}, future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "bastionhosts.azureClient.CreateOrUpdateAsync")
        defer done()

        host, ok := parameters.(network.BastionHost)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.Errorf("%T is not a network.BastionHost", parameters)
        }</span>

        <span class="cov0" title="0">createFuture, err := ac.bastionhosts.CreateOrUpdate(ctx, spec.ResourceGroupName(), spec.ResourceName(), host)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = createFuture.WaitForCompletionRef(ctx, ac.bastionhosts.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return nil, &amp;createFuture, err
        }</span>

        <span class="cov0" title="0">result, err = createFuture.Result(ac.bastionhosts)
        // if the operation completed, return a nil future
        return result, nil, err</span>
}

// DeleteAsync deletes a bastion host asynchronously. DeleteAsync sends a DELETE
// request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *azureClient) DeleteAsync(ctx context.Context, spec azure.ResourceSpecGetter) (future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "bastionhosts.azureClient.Delete")
        defer done()

        deleteFuture, err := ac.bastionhosts.Delete(ctx, spec.ResourceGroupName(), spec.ResourceName())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = deleteFuture.WaitForCompletionRef(ctx, ac.bastionhosts.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return &amp;deleteFuture, err
        }</span>
        <span class="cov0" title="0">_, err = deleteFuture.Result(ac.bastionhosts)
        // if the operation completed, return a nil future.
        return nil, err</span>
}

// IsDone returns true if the long-running operation has completed.
func (ac *azureClient) IsDone(ctx context.Context, future azureautorest.FutureAPI) (isDone bool, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "bastionhosts.azureClient.IsDone")
        defer done()

        isDone, err = future.DoneWithContext(ctx, ac.bastionhosts)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "failed checking if the operation was complete")
        }</span>

        <span class="cov0" title="0">return isDone, nil</span>
}

// Result fetches the result of a long-running operation future.
func (ac *azureClient) Result(ctx context.Context, future azureautorest.FutureAPI, futureType string) (result interface{}, err error) <span class="cov0" title="0">{
        _, _, done := tele.StartSpanWithLogger(ctx, "bastionhosts.azureClient.Result")
        defer done()

        if future == nil </span><span class="cov0" title="0">{
                return nil, errors.Errorf("cannot get result from nil future")
        }</span>

        <span class="cov0" title="0">switch futureType </span>{
        case infrav1.PutFuture:<span class="cov0" title="0">
                // Marshal and Unmarshal the future to put it into the correct future type so we can access the Result function.
                // Unfortunately the FutureAPI can't be casted directly to BastionHostsCreateOrUpdateFuture because it is a azureautorest.Future, which doesn't implement the Result function. See PR #1686 for discussion on alternatives.
                // It was converted back to a generic azureautorest.Future from the CAPZ infrav1.Future type stored in Status: https://github.com/kubernetes-sigs/cluster-api-provider-azure/blob/main/azure/converters/futures.go#L49.
                var createFuture *network.BastionHostsCreateOrUpdateFuture
                jsonData, err := future.MarshalJSON()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to marshal future")
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal(jsonData, &amp;createFuture); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to unmarshal future data")
                }</span>
                <span class="cov0" title="0">return createFuture.Result(ac.bastionhosts)</span>

        case infrav1.DeleteFuture:<span class="cov0" title="0">
                // Delete does not return a result bastion host
                return nil, nil</span>

        default:<span class="cov0" title="0">
                return nil, errors.Errorf("unknown future type %q", futureType)</span>
        }
}
</pre>
		
		<pre class="file" id="file85" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package bastionhosts

import (
        "fmt"
        "strings"

        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-08-01/network"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure/converters"
)

// AzureBastionSpec defines the specification for azure bastion feature.
type AzureBastionSpec struct {
        Name          string
        ResourceGroup string
        Location      string
        ClusterName   string
        SubnetID      string
        PublicIPID    string
}

// AzureBastionSpecInput defines the required inputs to construct an azure bastion spec.
type AzureBastionSpecInput struct {
        SubnetName   string
        PublicIPName string
        VNetName     string
}

// ResourceName returns the name of the bastion host.
func (s *AzureBastionSpec) ResourceName() string <span class="cov0" title="0">{
        return s.Name
}</span>

// ResourceGroupName returns the name of the resource group.
func (s *AzureBastionSpec) ResourceGroupName() string <span class="cov0" title="0">{
        return s.ResourceGroup
}</span>

// OwnerResourceName is a no-op for bastion hosts.
func (s *AzureBastionSpec) OwnerResourceName() string <span class="cov0" title="0">{
        return ""
}</span>

// Parameters returns the parameters for the bastion host.
func (s *AzureBastionSpec) Parameters(existing interface{}) (parameters interface{}, err error) <span class="cov0" title="0">{
        if existing != nil </span><span class="cov0" title="0">{
                if _, ok := existing.(network.BastionHost); !ok </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("%T is not a network.BastionHost", existing)
                }</span>
                // bastion host already exists
                <span class="cov0" title="0">return nil, nil</span>
        }

        <span class="cov0" title="0">bastionHostIPConfigName := fmt.Sprintf("%s-%s", s.Name, "bastionIP")

        return network.BastionHost{
                Name:     to.StringPtr(s.Name),
                Location: to.StringPtr(s.Location),
                Tags: converters.TagsToMap(infrav1.Build(infrav1.BuildParams{
                        ClusterName: s.ClusterName,
                        Lifecycle:   infrav1.ResourceLifecycleOwned,
                        Name:        to.StringPtr(s.Name),
                        Role:        to.StringPtr("Bastion"),
                })),
                BastionHostPropertiesFormat: &amp;network.BastionHostPropertiesFormat{
                        DNSName: to.StringPtr(fmt.Sprintf("%s-bastion", strings.ToLower(s.Name))),
                        IPConfigurations: &amp;[]network.BastionHostIPConfiguration{
                                {
                                        Name: to.StringPtr(bastionHostIPConfigName),
                                        BastionHostIPConfigurationPropertiesFormat: &amp;network.BastionHostIPConfigurationPropertiesFormat{
                                                Subnet: &amp;network.SubResource{
                                                        ID: &amp;s.SubnetID,
                                                },
                                                PublicIPAddress: &amp;network.SubResource{
                                                        ID: &amp;s.PublicIPID,
                                                },
                                                PrivateIPAllocationMethod: network.IPAllocationMethodDynamic,
                                        },
                                },
                        },
                },
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package disks

import (
        "context"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-11-01/compute"
        "github.com/Azure/go-autorest/autorest"
        azureautorest "github.com/Azure/go-autorest/autorest/azure"
        "github.com/pkg/errors"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// azureClient contains the Azure go-sdk Client.
type azureClient struct {
        disks compute.DisksClient
}

// newClient creates a new disk Client from subscription ID.
func newClient(auth azure.Authorizer) *azureClient <span class="cov0" title="0">{
        c := NewDisksClient(auth.SubscriptionID(), auth.BaseURI(), auth.Authorizer())
        return &amp;azureClient{c}
}</span>

// NewDisksClient creates a new disks Client from subscription ID.
func NewDisksClient(subscriptionID string, baseURI string, authorizer autorest.Authorizer) compute.DisksClient <span class="cov0" title="0">{
        disksClient := compute.NewDisksClientWithBaseURI(baseURI, subscriptionID)
        azure.SetAutoRestClientDefaults(&amp;disksClient.Client, authorizer)
        return disksClient
}</span>

// DeleteAsync deletes a route table asynchronously. DeleteAsync sends a DELETE
// request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *azureClient) DeleteAsync(ctx context.Context, spec azure.ResourceSpecGetter) (future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "disks.azureClient.DeleteAsync")
        defer done()

        deleteFuture, err := ac.disks.Delete(ctx, spec.ResourceGroupName(), spec.ResourceName())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = deleteFuture.WaitForCompletionRef(ctx, ac.disks.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return &amp;deleteFuture, err
        }</span>
        <span class="cov0" title="0">_, err = deleteFuture.Result(ac.disks)
        // if the operation completed, return a nil future.
        return nil, err</span>
}

// Result fetches the result of a long-running operation future.
func (ac *azureClient) Result(ctx context.Context, future azureautorest.FutureAPI, futureType string) (result interface{}, err error) <span class="cov0" title="0">{
        return nil, nil
}</span>

// IsDone returns true if the long-running operation has completed.
func (ac *azureClient) IsDone(ctx context.Context, future azureautorest.FutureAPI) (isDone bool, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "disks.azureClient.IsDone")
        defer done()

        isDone, err = future.DoneWithContext(ctx, ac.disks)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "failed checking if the operation was complete")
        }</span>

        <span class="cov0" title="0">return isDone, nil</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package disks

import (
        "context"

        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/async"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

const serviceName = "disks"

// DiskScope defines the scope interface for a disk service.
type DiskScope interface {
        azure.ClusterDescriber
        azure.AsyncStatusUpdater
        DiskSpecs() []azure.ResourceSpecGetter
}

// Service provides operations on Azure resources.
type Service struct {
        Scope DiskScope
        async.Reconciler
}

// New creates a new disks service.
func New(scope DiskScope) *Service <span class="cov0" title="0">{
        client := newClient(scope)
        return &amp;Service{
                Scope:      scope,
                Reconciler: async.New(scope, nil, client),
        }
}</span>

// Name returns the service name.
func (s *Service) Name() string <span class="cov0" title="0">{
        return serviceName
}</span>

// Reconcile on disk is currently no-op. OS disks should only be deleted and will create with the VM automatically.
func (s *Service) Reconcile(ctx context.Context) error <span class="cov0" title="0">{
        _, _, done := tele.StartSpanWithLogger(ctx, "disks.Service.Reconcile")
        defer done()

        // DisksReadyCondition is set in the VM service.
        return nil
}</span>

// Delete deletes the disk associated with a VM.
func (s *Service) Delete(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "disks.Service.Delete")
        defer done()

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        specs := s.Scope.DiskSpecs()
        if len(specs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // We go through the list of DiskSpecs to delete each one, independently of the result of the previous one.
        // If multiple errors occur, we return the most pressing one.
        //  Order of precedence (highest -&gt; lowest) is: error that is not an operationNotDoneError (i.e. error creating) -&gt; operationNotDoneError (i.e. creating in progress) -&gt; no error (i.e. created)
        <span class="cov8" title="1">var result error
        for _, diskSpec := range specs </span><span class="cov8" title="1">{
                if err := s.DeleteResource(ctx, diskSpec, serviceName); err != nil </span><span class="cov8" title="1">{
                        if !azure.IsOperationNotDoneError(err) || result == nil </span><span class="cov8" title="1">{
                                result = err
                        }</span>
                }
        }
        <span class="cov8" title="1">s.Scope.UpdateDeleteStatus(infrav1.DisksReadyCondition, serviceName, result)
        return result</span>
}

// IsManaged returns always returns true as CAPZ does not support BYO disk.
func (s *Service) IsManaged(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>
</pre>
		
		<pre class="file" id="file88" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package disks

// DiskSpec defines the specification for a disk.
type DiskSpec struct {
        Name          string
        ResourceGroup string
}

// ResourceName returns the name of the disk.
func (s *DiskSpec) ResourceName() string <span class="cov0" title="0">{
        return s.Name
}</span>

// ResourceGroupName returns the name of the resource group.
func (s *DiskSpec) ResourceGroupName() string <span class="cov0" title="0">{
        return s.ResourceGroup
}</span>

// OwnerResourceName is a no-op for disks.
func (s *DiskSpec) OwnerResourceName() string <span class="cov0" title="0">{
        return ""
}</span>

// Parameters is a no-op for disks.
func (s *DiskSpec) Parameters(existing interface{}) (params interface{}, err error) <span class="cov0" title="0">{
        return nil, nil
}</span>
</pre>
		
		<pre class="file" id="file89" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package groups

import (
        "context"

        "github.com/Azure/azure-sdk-for-go/services/resources/mgmt/2019-05-01/resources"
        "github.com/Azure/go-autorest/autorest"
        azureautorest "github.com/Azure/go-autorest/autorest/azure"
        "github.com/pkg/errors"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// client wraps go-sdk.
type client interface {
        Get(context.Context, azure.ResourceSpecGetter) (interface{}, error)
        CreateOrUpdateAsync(ctx context.Context, spec azure.ResourceSpecGetter, parameters interface{}) (result interface{}, future azureautorest.FutureAPI, err error)
        DeleteAsync(ctx context.Context, spec azure.ResourceSpecGetter) (future azureautorest.FutureAPI, err error)
        IsDone(ctx context.Context, future azureautorest.FutureAPI) (isDone bool, err error)
        Result(ctx context.Context, future azureautorest.FutureAPI, futureType string) (result interface{}, err error)
}

// azureClient contains the Azure go-sdk Client.
type azureClient struct {
        groups resources.GroupsClient
}

var _ client = (*azureClient)(nil)

// newClient creates a new VM client from subscription ID.
func newClient(auth azure.Authorizer) *azureClient <span class="cov0" title="0">{
        c := newGroupsClient(auth.SubscriptionID(), auth.BaseURI(), auth.Authorizer())
        return &amp;azureClient{
                groups: c,
        }
}</span>

// newGroupsClient creates a new groups client from subscription ID.
func newGroupsClient(subscriptionID string, baseURI string, authorizer autorest.Authorizer) resources.GroupsClient <span class="cov0" title="0">{
        groupsClient := resources.NewGroupsClientWithBaseURI(baseURI, subscriptionID)
        azure.SetAutoRestClientDefaults(&amp;groupsClient.Client, authorizer)
        return groupsClient
}</span>

// Get gets a resource group.
func (ac *azureClient) Get(ctx context.Context, spec azure.ResourceSpecGetter) (result interface{}, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "groups.AzureClient.Get")
        defer done()

        return ac.groups.Get(ctx, spec.ResourceName())
}</span>

// CreateOrUpdateAsync creates or updates a resource group.
// Creating a resource group is not a long running operation, so we don't ever return a future.
func (ac *azureClient) CreateOrUpdateAsync(ctx context.Context, spec azure.ResourceSpecGetter, parameters interface{}) (result interface{}, future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "groups.AzureClient.CreateOrUpdate")
        defer done()

        group, ok := parameters.(resources.Group)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.Errorf("%T is not a resources.Group", parameters)
        }</span>

        <span class="cov0" title="0">result, err = ac.groups.CreateOrUpdate(ctx, spec.ResourceName(), group)
        return result, nil, err</span>
}

// DeleteAsync deletes a resource group asynchronously. DeleteAsync sends a DELETE
// request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
//
// NOTE: When you delete a resource group, all of its resources are also deleted.
func (ac *azureClient) DeleteAsync(ctx context.Context, spec azure.ResourceSpecGetter) (future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "groups.AzureClient.Delete")
        defer done()

        deleteFuture, err := ac.groups.Delete(ctx, spec.ResourceName())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = deleteFuture.WaitForCompletionRef(ctx, ac.groups.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return &amp;deleteFuture, err
        }</span>
        <span class="cov0" title="0">_, err = deleteFuture.Result(ac.groups)
        // if the operation completed, return a nil future.
        return nil, err</span>
}

// IsDone returns true if the long-running operation has completed.
func (ac *azureClient) IsDone(ctx context.Context, future azureautorest.FutureAPI) (isDone bool, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "groups.AzureClient.IsDone")
        defer done()

        isDone, err = future.DoneWithContext(ctx, ac.groups)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "failed checking if the operation was complete")
        }</span>

        <span class="cov0" title="0">return isDone, nil</span>
}

// Result fetches the result of a long-running operation future.
func (ac *azureClient) Result(ctx context.Context, future azureautorest.FutureAPI, futureType string) (result interface{}, err error) <span class="cov0" title="0">{
        // Result is a no-op for resource groups as only Delete operations return a future.
        return nil, nil
}</span>
</pre>
		
		<pre class="file" id="file90" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package groups

import (
        "context"

        "github.com/Azure/azure-sdk-for-go/services/resources/mgmt/2019-05-01/resources"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/converters"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/async"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// ServiceName is the name of this service.
const ServiceName = "group"

// Service provides operations on Azure resources.
type Service struct {
        Scope GroupScope
        async.Reconciler
        client
}

// GroupScope defines the scope interface for a group service.
type GroupScope interface {
        azure.Authorizer
        azure.AsyncStatusUpdater
        GroupSpec() azure.ResourceSpecGetter
        ClusterName() string
}

// New creates a new service.
func New(scope GroupScope) *Service <span class="cov0" title="0">{
        client := newClient(scope)
        return &amp;Service{
                Scope:      scope,
                client:     client,
                Reconciler: async.New(scope, client, client),
        }
}</span>

// Name returns the service name.
func (s *Service) Name() string <span class="cov0" title="0">{
        return ServiceName
}</span>

// Reconcile gets/creates/updates a resource group.
func (s *Service) Reconcile(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "groups.Service.Reconcile")
        defer done()

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        groupSpec := s.Scope.GroupSpec()
        if groupSpec == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">_, err := s.CreateResource(ctx, groupSpec, ServiceName)
        s.Scope.UpdatePutStatus(infrav1.ResourceGroupReadyCondition, ServiceName, err)
        return err</span>
}

// Delete deletes the resource group if it is managed by capz.
func (s *Service) Delete(ctx context.Context) error <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "groups.Service.Delete")
        defer done()

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        groupSpec := s.Scope.GroupSpec()
        if groupSpec == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // check that the resource group is not BYO.
        <span class="cov8" title="1">managed, err := s.IsManaged(ctx)
        if err != nil </span><span class="cov8" title="1">{
                if azure.ResourceNotFound(err) </span><span class="cov8" title="1">{
                        // already deleted or doesn't exist, cleanup status and return.
                        s.Scope.DeleteLongRunningOperationState(groupSpec.ResourceName(), ServiceName)
                        s.Scope.UpdateDeleteStatus(infrav1.ResourceGroupReadyCondition, ServiceName, nil)
                        return nil
                }</span>
                <span class="cov8" title="1">return errors.Wrap(err, "could not get resource group management state")</span>
        }
        <span class="cov8" title="1">if !managed </span><span class="cov8" title="1">{
                log.V(2).Info("Skipping resource group deletion in unmanaged mode")
                return nil
        }</span>

        <span class="cov8" title="1">err = s.DeleteResource(ctx, groupSpec, ServiceName)
        s.Scope.UpdateDeleteStatus(infrav1.ResourceGroupReadyCondition, ServiceName, err)
        return err</span>
}

// IsManaged returns true if the resource group has an owned tag with the cluster name as value,
// meaning that the resource group's lifecycle is managed.
func (s *Service) IsManaged(ctx context.Context) (bool, error) <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "groups.Service.IsManaged")
        defer done()

        groupSpec := s.Scope.GroupSpec()
        groupIface, err := s.client.Get(ctx, groupSpec)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">group, ok := groupIface.(resources.Group)
        if !ok </span><span class="cov0" title="0">{
                return false, errors.Errorf("%T is not a resources.Group", groupIface)
        }</span>

        <span class="cov8" title="1">tags := converters.MapToTags(group.Tags)
        return tags.HasOwned(s.Scope.ClusterName()), nil</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package groups

import (
        "github.com/Azure/azure-sdk-for-go/services/resources/mgmt/2019-05-01/resources"
        "github.com/Azure/go-autorest/autorest/to"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure/converters"
)

// GroupSpec defines the specification for a Resource Group.
type GroupSpec struct {
        Name           string
        Location       string
        ClusterName    string
        AdditionalTags infrav1.Tags
}

// ResourceName returns the name of the group.
func (s *GroupSpec) ResourceName() string <span class="cov8" title="1">{
        return s.Name
}</span>

// ResourceGroupName returns the name of the group.
// Note that it is the same as the resource name in this case.
func (s *GroupSpec) ResourceGroupName() string <span class="cov0" title="0">{
        return s.Name
}</span>

// OwnerResourceName is a no-op for groups.
func (s *GroupSpec) OwnerResourceName() string <span class="cov0" title="0">{
        return "" // not applicable
}</span>

// Parameters returns the parameters for the group.
func (s *GroupSpec) Parameters(existing interface{}) (params interface{}, err error) <span class="cov0" title="0">{
        if existing != nil </span><span class="cov0" title="0">{
                // rg already exists, nothing to update.
                // Note that rg tags are updated separately using tags service.
                return nil, nil
        }</span>
        <span class="cov0" title="0">return resources.Group{
                Location: to.StringPtr(s.Location),
                // User defined additional tags are created with the resource group and updated using tags service.
                Tags: converters.TagsToMap(infrav1.Build(infrav1.BuildParams{
                        ClusterName: s.ClusterName,
                        Lifecycle:   infrav1.ResourceLifecycleOwned,
                        Name:        to.StringPtr(s.Name),
                        Role:        to.StringPtr(infrav1.CommonRole),
                        Additional:  s.AdditionalTags,
                })),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package inboundnatrules

import (
        "context"
        "encoding/json"
        "fmt"

        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-08-01/network"
        "github.com/Azure/go-autorest/autorest"
        azureautorest "github.com/Azure/go-autorest/autorest/azure"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// client wraps go-sdk.
type client interface {
        List(context.Context, string, string) (result []network.InboundNatRule, err error)
        Get(context.Context, azure.ResourceSpecGetter) (result interface{}, err error)
        CreateOrUpdateAsync(context.Context, azure.ResourceSpecGetter, interface{}) (result interface{}, future azureautorest.FutureAPI, err error)
        DeleteAsync(context.Context, azure.ResourceSpecGetter) (future azureautorest.FutureAPI, err error)
        IsDone(context.Context, azureautorest.FutureAPI) (isDone bool, err error)
        Result(context.Context, azureautorest.FutureAPI, string) (result interface{}, err error)
}

// azureClient contains the Azure go-sdk Client.
type azureClient struct {
        inboundnatrules network.InboundNatRulesClient
}

var _ client = (*azureClient)(nil)

// newClient creates a new inbound NAT rules client from subscription ID.
func newClient(auth azure.Authorizer) *azureClient <span class="cov0" title="0">{
        inboundNatRulesClient := newInboundNatRulesClient(auth.SubscriptionID(), auth.BaseURI(), auth.Authorizer())
        return &amp;azureClient{
                inboundnatrules: inboundNatRulesClient,
        }
}</span>

// newInboundNatClient creates a new inbound NAT rules client from subscription ID.
func newInboundNatRulesClient(subscriptionID string, baseURI string, authorizer autorest.Authorizer) network.InboundNatRulesClient <span class="cov0" title="0">{
        inboundNatRulesClient := network.NewInboundNatRulesClientWithBaseURI(baseURI, subscriptionID)
        azure.SetAutoRestClientDefaults(&amp;inboundNatRulesClient.Client, authorizer)
        return inboundNatRulesClient
}</span>

// Get gets the specified inbound NAT rules.
func (ac *azureClient) Get(ctx context.Context, spec azure.ResourceSpecGetter) (result interface{}, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "inboundnatrules.azureClient.Get")
        defer done()

        return ac.inboundnatrules.Get(ctx, spec.ResourceGroupName(), spec.OwnerResourceName(), spec.ResourceName(), "")
}</span>

// List returns all inbound NAT rules on a load balancer.
func (ac *azureClient) List(ctx context.Context, resourceGroupName, lbName string) (result []network.InboundNatRule, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "inboundnatrules.azureClient.List")
        defer done()

        iter, err := ac.inboundnatrules.ListComplete(ctx, resourceGroupName, lbName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, fmt.Sprintf("could not list inbound NAT rules for load balancer %s", lbName))
        }</span>

        <span class="cov0" title="0">var natRules []network.InboundNatRule
        for iter.NotDone() </span><span class="cov0" title="0">{
                natRules = append(natRules, iter.Value())
                if err := iter.NextWithContext(ctx); err != nil </span><span class="cov0" title="0">{
                        return natRules, errors.Wrap(err, "could not iterate inbound NAT rules")
                }</span>
        }

        <span class="cov0" title="0">return natRules, nil</span>
}

// CreateOrUpdateAsync creates or updates an inbound NAT rule asynchronously.
// It sends a PUT request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *azureClient) CreateOrUpdateAsync(ctx context.Context, spec azure.ResourceSpecGetter, parameters interface{}) (result interface{}, future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "inboundnatrules.azureClient.CreateOrUpdateAsync")
        defer done()

        natRule, ok := parameters.(network.InboundNatRule)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.Errorf("%T is not a network.InboundNatRule", parameters)
        }</span>

        <span class="cov0" title="0">createFuture, err := ac.inboundnatrules.CreateOrUpdate(ctx, spec.ResourceGroupName(), spec.OwnerResourceName(), spec.ResourceName(), natRule)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = createFuture.WaitForCompletionRef(ctx, ac.inboundnatrules.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return nil, &amp;createFuture, err
        }</span>

        <span class="cov0" title="0">result, err = createFuture.Result(ac.inboundnatrules)
        // if the operation completed, return a nil future
        return result, nil, err</span>
}

// DeleteAsync deletes an inbound NAT rule asynchronously. DeleteAsync sends a DELETE
// request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *azureClient) DeleteAsync(ctx context.Context, spec azure.ResourceSpecGetter) (future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "inboundnatrules.azureClient.DeleteAsync")
        defer done()

        deleteFuture, err := ac.inboundnatrules.Delete(ctx, spec.ResourceGroupName(), spec.OwnerResourceName(), spec.ResourceName())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = deleteFuture.WaitForCompletionRef(ctx, ac.inboundnatrules.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return &amp;deleteFuture, err
        }</span>
        <span class="cov0" title="0">_, err = deleteFuture.Result(ac.inboundnatrules)
        // if the operation completed, return a nil future.
        return nil, err</span>
}

// IsDone returns true if the long-running operation has completed.
func (ac *azureClient) IsDone(ctx context.Context, future azureautorest.FutureAPI) (isDone bool, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "inboundnatrules.azureClient.IsDone")
        defer done()

        isDone, err = future.DoneWithContext(ctx, ac.inboundnatrules)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "failed checking if the operation was complete")
        }</span>

        <span class="cov0" title="0">return isDone, nil</span>
}

// Result fetches the result of a long-running operation future.
func (ac *azureClient) Result(ctx context.Context, future azureautorest.FutureAPI, futureType string) (result interface{}, err error) <span class="cov0" title="0">{
        _, _, done := tele.StartSpanWithLogger(ctx, "inboundnatrules.azureClient.Result")
        defer done()

        if future == nil </span><span class="cov0" title="0">{
                return nil, errors.Errorf("cannot get result from nil future")
        }</span>

        <span class="cov0" title="0">switch futureType </span>{
        case infrav1.PutFuture:<span class="cov0" title="0">
                // Marshal and Unmarshal the future to put it into the correct future type so we can access the Result function.
                // Unfortunately the FutureAPI can't be casted directly to InboundNatRulesCreateOrUpdateFuture because it is a azureautorest.Future, which doesn't implement the Result function. See PR #1686 for discussion on alternatives.
                // It was converted back to a generic azureautorest.Future from the CAPZ infrav1.Future type stored in Status: https://github.com/kubernetes-sigs/cluster-api-provider-azure/blob/main/azure/converters/futures.go#L49.
                var createFuture *network.InboundNatRulesCreateOrUpdateFuture
                jsonData, err := future.MarshalJSON()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to marshal future")
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal(jsonData, &amp;createFuture); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to unmarshal future data")
                }</span>
                <span class="cov0" title="0">return createFuture.Result(ac.inboundnatrules)</span>

        case infrav1.DeleteFuture:<span class="cov0" title="0">
                // Delete does not return a result inbound NAT rule
                return nil, nil</span>

        default:<span class="cov0" title="0">
                return nil, errors.Errorf("unknown future type %q", futureType)</span>
        }
}
</pre>
		
		<pre class="file" id="file93" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package inboundnatrules

import (
        "context"

        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/async"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

const serviceName = "inboundnatrules"

// InboundNatScope defines the scope interface for an inbound NAT service.
type InboundNatScope interface {
        azure.ClusterDescriber
        azure.AsyncStatusUpdater
        APIServerLBName() string
        InboundNatSpecs() []azure.ResourceSpecGetter
}

// Service provides operations on Azure resources.
type Service struct {
        Scope InboundNatScope
        client
        async.Reconciler
}

// New creates a new service.
func New(scope InboundNatScope) *Service <span class="cov0" title="0">{
        client := newClient(scope)
        return &amp;Service{
                Scope:      scope,
                client:     client,
                Reconciler: async.New(scope, client, client),
        }
}</span>

// Name returns the service name.
func (s *Service) Name() string <span class="cov0" title="0">{
        return serviceName
}</span>

// Reconcile gets/creates/updates an inbound NAT rule.
func (s *Service) Reconcile(ctx context.Context) error <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "inboundnatrules.Service.Reconcile")
        defer done()

        // Externally managed clusters might not have an LB
        if s.Scope.APIServerLBName() == "" </span><span class="cov8" title="1">{
                log.V(4).Info("Skipping InboundNatRule reconciliation as the cluster has no LB configured")
                return nil
        }</span>

        <span class="cov8" title="1">specs := s.Scope.InboundNatSpecs()
        if len(specs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        existingRules, err := s.client.List(ctx, s.Scope.ResourceGroup(), s.Scope.APIServerLBName())
        if err != nil </span><span class="cov8" title="1">{
                result := errors.Wrapf(err, "failed to get existing NAT rules")
                s.Scope.UpdatePutStatus(infrav1.InboundNATRulesReadyCondition, serviceName, result)
                return result
        }</span>

        <span class="cov8" title="1">portsInUse := make(map[int32]struct{})
        for _, rule := range existingRules </span><span class="cov8" title="1">{
                portsInUse[*rule.InboundNatRulePropertiesFormat.FrontendPort] = struct{}{} // Mark frontend port as in use
        }</span>

        // We go through the list of InboundNatSpecs to reconcile each one, independently of the result of the previous one.
        // If multiple errors occur, we return the most pressing one.
        //  Order of precedence (highest -&gt; lowest) is: error that is not an operationNotDoneError (i.e. error creating) -&gt; operationNotDoneError (i.e. creating in progress) -&gt; no error (i.e. created)
        <span class="cov8" title="1">var result error
        for _, spec := range specs </span><span class="cov8" title="1">{
                // Find an available SSH port for the rule.
                sshFrontendPort, err := getAvailableSSHFrontendPort(portsInUse)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrapf(err, "failed to find available SSH Frontend port for NAT Rule %s in load balancer %s", spec.ResourceName(), spec.OwnerResourceName())
                }</span>
                <span class="cov8" title="1">natRule, ok := spec.(*InboundNatSpec)
                if !ok </span><span class="cov0" title="0">{
                        result = errors.Errorf("%T is not of type InboundNatSpec", spec)
                }</span>
                <span class="cov8" title="1">natRule.SSHFrontendPort = &amp;sshFrontendPort
                // Add the SSH frontend port to the list of ports in use
                portsInUse[sshFrontendPort] = struct{}{}
                if _, err := s.CreateResource(ctx, natRule, serviceName); err != nil </span><span class="cov8" title="1">{
                        if !azure.IsOperationNotDoneError(err) || result == nil </span><span class="cov8" title="1">{
                                result = err
                        }</span>
                }
        }

        <span class="cov8" title="1">s.Scope.UpdatePutStatus(infrav1.InboundNATRulesReadyCondition, serviceName, result)

        return result</span>
}

// Delete deletes the inbound NAT rule with the provided name.
func (s *Service) Delete(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "inboundnatrules.Service.Delete")
        defer done()

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        specs := s.Scope.InboundNatSpecs()
        if len(specs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // We go through the list of InboundNatSpecs to delete each one, independently of the result of the previous one.
        // If multiple errors occur, we return the most pressing one.
        //  Order of precedence (highest -&gt; lowest) is: error that is not an operationNotDoneError (i.e. error deleting) -&gt; operationNotDoneError (i.e. deleting in progress) -&gt; no error (i.e. deleted)
        <span class="cov8" title="1">var result error
        for _, natRule := range specs </span><span class="cov8" title="1">{
                if err := s.DeleteResource(ctx, natRule, serviceName); err != nil </span><span class="cov8" title="1">{
                        if !azure.IsOperationNotDoneError(err) || result == nil </span><span class="cov8" title="1">{
                                result = err
                        }</span>
                }
        }

        <span class="cov8" title="1">s.Scope.UpdateDeleteStatus(infrav1.InboundNATRulesReadyCondition, serviceName, result)
        return result</span>
}

// IsManaged returns always returns true as CAPZ does not support BYO inbound NAT rules.
func (s *Service) IsManaged(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>
</pre>
		
		<pre class="file" id="file94" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package inboundnatrules

import (
        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-08-01/network"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
)

// InboundNatSpec defines the specification for an inbound NAT rule.
type InboundNatSpec struct {
        Name                      string
        LoadBalancerName          string
        ResourceGroup             string
        FrontendIPConfigurationID *string
        SSHFrontendPort           *int32
}

// ResourceName returns the name of the inbound NAT rule.
func (s *InboundNatSpec) ResourceName() string <span class="cov0" title="0">{
        return s.Name
}</span>

// ResourceGroupName returns the name of the resource group.
func (s *InboundNatSpec) ResourceGroupName() string <span class="cov0" title="0">{
        return s.ResourceGroup
}</span>

// OwnerResourceName returns the name of the load balancer associated with an inbound NAT rule.
func (s *InboundNatSpec) OwnerResourceName() string <span class="cov0" title="0">{
        return s.LoadBalancerName
}</span>

// Parameters returns the parameters for the inbound NAT rule.
func (s *InboundNatSpec) Parameters(existing interface{}) (parameters interface{}, err error) <span class="cov0" title="0">{
        if existing != nil </span><span class="cov0" title="0">{
                if _, ok := existing.(network.InboundNatRule); !ok </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("%T is not a network.InboundNatRule", existing)
                }</span>

                <span class="cov0" title="0">return nil, nil</span>
        }

        <span class="cov0" title="0">if s.FrontendIPConfigurationID == nil </span><span class="cov0" title="0">{
                return nil, errors.Errorf("FrontendIPConfigurationID is not set")
        }</span>

        <span class="cov0" title="0">rule := network.InboundNatRule{
                Name: to.StringPtr(s.ResourceName()),
                InboundNatRulePropertiesFormat: &amp;network.InboundNatRulePropertiesFormat{
                        BackendPort:          to.Int32Ptr(22),
                        EnableFloatingIP:     to.BoolPtr(false),
                        IdleTimeoutInMinutes: to.Int32Ptr(4),
                        FrontendIPConfiguration: &amp;network.SubResource{
                                ID: s.FrontendIPConfigurationID,
                        },
                        Protocol:     network.TransportProtocolTCP,
                        FrontendPort: s.SSHFrontendPort,
                },
        }

        return rule, nil</span>
}

func getAvailableSSHFrontendPort(portsInUse map[int32]struct{}) (int32, error) <span class="cov8" title="1">{
        // NAT rules need to use a unique port. Since we need one NAT rule per control plane and we expect to have 1, 3, 5, maybe 9 control planes, there should never be more than 9 ports in use.
        // This is an artificial limit of 20 ports that we can pick from, which should be plenty enough (in reality we should never reach that limit).
        // These NAT rules are used for SSH purposes which is why we start at 22 and then use 2201, 2202, etc.
        var i int32 = 22
        if _, ok := portsInUse[22]; ok </span><span class="cov8" title="1">{
                for i = 2201; i &lt; 2220; i++ </span><span class="cov8" title="1">{
                        if _, ok := portsInUse[i]; !ok </span><span class="cov8" title="1">{
                                // Found available port
                                return i, nil
                        }</span>
                }
                <span class="cov8" title="1">return i, errors.Errorf("No available SSH Frontend ports")</span>
        }

        <span class="cov8" title="1">return i, nil</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package loadbalancers

import (
        "context"
        "encoding/json"

        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-08-01/network"
        "github.com/Azure/go-autorest/autorest"
        azureautorest "github.com/Azure/go-autorest/autorest/azure"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// azureClient contains the Azure go-sdk Client.
type azureClient struct {
        loadbalancers network.LoadBalancersClient
}

// newClient creates a new load balancer client from subscription ID.
func newClient(auth azure.Authorizer) *azureClient <span class="cov0" title="0">{
        c := newLoadBalancersClient(auth.SubscriptionID(), auth.BaseURI(), auth.Authorizer())
        return &amp;azureClient{c}
}</span>

// newLoadbalancersClient creates a new load balancer client from subscription ID.
func newLoadBalancersClient(subscriptionID string, baseURI string, authorizer autorest.Authorizer) network.LoadBalancersClient <span class="cov0" title="0">{
        loadBalancersClient := network.NewLoadBalancersClientWithBaseURI(baseURI, subscriptionID)
        azure.SetAutoRestClientDefaults(&amp;loadBalancersClient.Client, authorizer)
        return loadBalancersClient
}</span>

// Get gets the specified load balancer.
func (ac *azureClient) Get(ctx context.Context, spec azure.ResourceSpecGetter) (result interface{}, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "loadbalancers.azureClient.Get")
        defer done()

        return ac.loadbalancers.Get(ctx, spec.ResourceGroupName(), spec.ResourceName(), "")
}</span>

// CreateOrUpdateAsync creates or updates a load balancer asynchronously.
// It sends a PUT request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *azureClient) CreateOrUpdateAsync(ctx context.Context, spec azure.ResourceSpecGetter, parameters interface{}) (result interface{}, future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "loadbalancers.azureClient.CreateOrUpdate")
        defer done()

        loadBalancer, ok := parameters.(network.LoadBalancer)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.Errorf("%T is not a network.LoadBalancer", parameters)
        }</span>

        <span class="cov0" title="0">var etag string
        if loadBalancer.Etag != nil </span><span class="cov0" title="0">{
                etag = *loadBalancer.Etag
        }</span>

        <span class="cov0" title="0">req, err := ac.loadbalancers.CreateOrUpdatePreparer(ctx, spec.ResourceGroupName(), spec.ResourceName(), loadBalancer)
        if err != nil </span><span class="cov0" title="0">{
                err = autorest.NewErrorWithError(err, "network.LoadBalancersClient", "CreateOrUpdate", nil, "Failure preparing request")
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">if etag != "" </span><span class="cov0" title="0">{
                req.Header.Add("If-Match", etag)
        }</span>

        <span class="cov0" title="0">createFuture, err := ac.loadbalancers.CreateOrUpdateSender(req)
        if err != nil </span><span class="cov0" title="0">{
                res := createFuture.Response()
                err = autorest.NewErrorWithError(err, "network.LoadBalancersClient", "CreateOrUpdate", res, "Failure sending request")
                // response body must be closed
                res.Body.Close()
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = createFuture.WaitForCompletionRef(ctx, ac.loadbalancers.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return nil, &amp;createFuture, err
        }</span>

        <span class="cov0" title="0">result, err = createFuture.Result(ac.loadbalancers)
        // if the operation completed, return a nil future
        return result, nil, err</span>
}

// DeleteAsync deletes a load balancer asynchronously. DeleteAsync sends a DELETE
// request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *azureClient) DeleteAsync(ctx context.Context, spec azure.ResourceSpecGetter) (future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "loadbalancers.azureClient.Delete")
        defer done()

        deleteFuture, err := ac.loadbalancers.Delete(ctx, spec.ResourceGroupName(), spec.ResourceName())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = deleteFuture.WaitForCompletionRef(ctx, ac.loadbalancers.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return &amp;deleteFuture, err
        }</span>
        <span class="cov0" title="0">_, err = deleteFuture.Result(ac.loadbalancers)
        // if the operation completed, return a nil future.
        return nil, err</span>
}

// IsDone returns true if the long-running operation has completed.
func (ac *azureClient) IsDone(ctx context.Context, future azureautorest.FutureAPI) (isDone bool, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "loadbalancers.azureClient.IsDone")
        defer done()

        isDone, err = future.DoneWithContext(ctx, ac.loadbalancers)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "failed checking if the operation was complete")
        }</span>

        <span class="cov0" title="0">return isDone, nil</span>
}

// Result fetches the result of a long-running operation future.
func (ac *azureClient) Result(ctx context.Context, future azureautorest.FutureAPI, futureType string) (result interface{}, err error) <span class="cov0" title="0">{
        _, _, done := tele.StartSpanWithLogger(ctx, "loadbalancers.azureClient.Result")
        defer done()

        if future == nil </span><span class="cov0" title="0">{
                return nil, errors.Errorf("cannot get result from nil future")
        }</span>

        <span class="cov0" title="0">switch futureType </span>{
        case infrav1.PutFuture:<span class="cov0" title="0">
                // Marshal and Unmarshal the future to put it into the correct future type so we can access the Result function.
                // Unfortunately the FutureAPI can't be casted directly to LoadBalancersCreateOrUpdateFuture because it is a azureautorest.Future, which doesn't implement the Result function. See PR #1686 for discussion on alternatives.
                // It was converted back to a generic azureautorest.Future from the CAPZ infrav1.Future type stored in Status: https://github.com/kubernetes-sigs/cluster-api-provider-azure/blob/main/azure/converters/futures.go#L49.
                var createFuture *network.LoadBalancersCreateOrUpdateFuture
                jsonData, err := future.MarshalJSON()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to marshal future")
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal(jsonData, &amp;createFuture); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to unmarshal future data")
                }</span>
                <span class="cov0" title="0">return createFuture.Result(ac.loadbalancers)</span>

        case infrav1.DeleteFuture:<span class="cov0" title="0">
                // Delete does not return a result load balancer
                return nil, nil</span>

        default:<span class="cov0" title="0">
                return nil, errors.Errorf("unknown future type %q", futureType)</span>
        }
}
</pre>
		
		<pre class="file" id="file96" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package loadbalancers

import (
        "context"

        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/async"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

const (
        serviceName = "loadbalancers"
        tcpProbe    = "TCPProbe"
        lbRuleHTTPS = "LBRuleHTTPS"
        outboundNAT = "OutboundNATAllProtocols"
)

// LBScope defines the scope interface for a load balancer service.
type LBScope interface {
        azure.ClusterScoper
        azure.AsyncStatusUpdater
        LBSpecs() []azure.ResourceSpecGetter
}

// Service provides operations on Azure resources.
type Service struct {
        Scope LBScope
        async.Reconciler
}

// New creates a new service.
func New(scope LBScope) *Service <span class="cov0" title="0">{
        client := newClient(scope)
        return &amp;Service{
                Scope:      scope,
                Reconciler: async.New(scope, client, client),
        }
}</span>

// Name returns the service name.
func (s *Service) Name() string <span class="cov0" title="0">{
        return serviceName
}</span>

// Reconcile gets/creates/updates a load balancer.
func (s *Service) Reconcile(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "loadbalancers.Service.Reconcile")
        defer done()

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        specs := s.Scope.LBSpecs()
        if len(specs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // We go through the list of LBSpecs to reconcile each one, independently of the result of the previous one.
        // If multiple errors occur, we return the most pressing one.
        //  Order of precedence (highest -&gt; lowest) is: error that is not an operationNotDoneError (i.e. error creating) -&gt; operationNotDoneError (i.e. creating in progress) -&gt; no error (i.e. created)
        <span class="cov8" title="1">var result error
        for _, lbSpec := range specs </span><span class="cov8" title="1">{
                if _, err := s.CreateResource(ctx, lbSpec, serviceName); err != nil </span><span class="cov8" title="1">{
                        if !azure.IsOperationNotDoneError(err) || result == nil </span><span class="cov8" title="1">{
                                result = err
                        }</span>
                }
        }

        <span class="cov8" title="1">s.Scope.UpdatePutStatus(infrav1.LoadBalancersReadyCondition, serviceName, result)
        return result</span>
}

// Delete deletes the public load balancer with the provided name.
func (s *Service) Delete(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "loadbalancers.Service.Delete")
        defer done()

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        specs := s.Scope.LBSpecs()
        if len(specs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // We go through the list of LBSpecs to delete each one, independently of the result of the previous one.
        // If multiple errors occur, we return the most pressing one.
        //  Order of precedence (highest -&gt; lowest) is: error that is not an operationNotDoneError (i.e. error deleting) -&gt; operationNotDoneError (i.e. deleting in progress) -&gt; no error (i.e. deleted)
        <span class="cov8" title="1">var result error
        for _, lbSpec := range specs </span><span class="cov8" title="1">{
                if err := s.DeleteResource(ctx, lbSpec, serviceName); err != nil </span><span class="cov8" title="1">{
                        if !azure.IsOperationNotDoneError(err) || result == nil </span><span class="cov8" title="1">{
                                result = err
                        }</span>
                }
        }

        <span class="cov8" title="1">s.Scope.UpdateDeleteStatus(infrav1.LoadBalancersReadyCondition, serviceName, result)
        return result</span>
}

// IsManaged returns always returns true as CAPZ does not support BYO load balancers.
func (s *Service) IsManaged(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>
</pre>
		
		<pre class="file" id="file97" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package loadbalancers

import (
        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-08-01/network"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/converters"
)

// LBSpec defines the specification for a Load Balancer.
type LBSpec struct {
        Name                 string
        ResourceGroup        string
        SubscriptionID       string
        ClusterName          string
        Location             string
        Role                 string
        Type                 infrav1.LBType
        SKU                  infrav1.SKU
        VNetName             string
        VNetResourceGroup    string
        SubnetName           string
        BackendPoolName      string
        FrontendIPConfigs    []infrav1.FrontendIP
        APIServerPort        int32
        IdleTimeoutInMinutes *int32
        AdditionalTags       map[string]string
}

// ResourceName returns the name of the load balancer.
func (s *LBSpec) ResourceName() string <span class="cov0" title="0">{
        return s.Name
}</span>

// ResourceGroupName returns the name of the resource group.
func (s *LBSpec) ResourceGroupName() string <span class="cov0" title="0">{
        return s.ResourceGroup
}</span>

// OwnerResourceName is a no-op for load balancers.
func (s *LBSpec) OwnerResourceName() string <span class="cov0" title="0">{
        return ""
}</span>

// Parameters returns the parameters for the load balancer.
func (s *LBSpec) Parameters(existing interface{}) (parameters interface{}, err error) <span class="cov8" title="1">{
        var (
                etag                *string
                frontendIDs         []network.SubResource
                frontendIPConfigs   = make([]network.FrontendIPConfiguration, 0)
                loadBalancingRules  = make([]network.LoadBalancingRule, 0)
                backendAddressPools = make([]network.BackendAddressPool, 0)
                outboundRules       = make([]network.OutboundRule, 0)
                probes              = make([]network.Probe, 0)
        )

        if existing != nil </span><span class="cov8" title="1">{
                existingLB, ok := existing.(network.LoadBalancer)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("%T is not a network.LoadBalancer", existing)
                }</span>
                // LB already exists
                // We append the existing LB etag to the header to ensure we only apply the updates if the LB has not been modified.
                <span class="cov8" title="1">etag = existingLB.Etag
                update := false

                // merge existing LB properties with desired properties
                frontendIPConfigs = *existingLB.FrontendIPConfigurations
                wantedIPs, wantedFrontendIDs := getFrontendIPConfigs(*s)
                for _, ip := range wantedIPs </span><span class="cov8" title="1">{
                        if !ipExists(frontendIPConfigs, ip) </span><span class="cov8" title="1">{
                                update = true
                                frontendIPConfigs = append(frontendIPConfigs, ip)
                        }</span>
                }

                <span class="cov8" title="1">loadBalancingRules = *existingLB.LoadBalancingRules
                for _, rule := range getLoadBalancingRules(*s, wantedFrontendIDs) </span><span class="cov8" title="1">{
                        if !lbRuleExists(loadBalancingRules, rule) </span><span class="cov8" title="1">{
                                update = true
                                loadBalancingRules = append(loadBalancingRules, rule)
                        }</span>
                }

                <span class="cov8" title="1">backendAddressPools = *existingLB.BackendAddressPools
                for _, pool := range getBackendAddressPools(*s) </span><span class="cov8" title="1">{
                        if !poolExists(backendAddressPools, pool) </span><span class="cov8" title="1">{
                                update = true
                                backendAddressPools = append(backendAddressPools, pool)
                        }</span>
                }

                <span class="cov8" title="1">outboundRules = *existingLB.OutboundRules
                for _, rule := range getOutboundRules(*s, wantedFrontendIDs) </span><span class="cov8" title="1">{
                        if !outboundRuleExists(outboundRules, rule) </span><span class="cov8" title="1">{
                                update = true
                                outboundRules = append(outboundRules, rule)
                        }</span>
                }

                <span class="cov8" title="1">probes = *existingLB.Probes
                for _, probe := range getProbes(*s) </span><span class="cov8" title="1">{
                        if !probeExists(probes, probe) </span><span class="cov8" title="1">{
                                update = true
                                probes = append(probes, probe)
                        }</span>
                }

                <span class="cov8" title="1">if !update </span><span class="cov8" title="1">{
                        // load balancer already exists with all required defaults
                        return nil, nil
                }</span>
        } else<span class="cov0" title="0"> {
                frontendIPConfigs, frontendIDs = getFrontendIPConfigs(*s)
                loadBalancingRules = getLoadBalancingRules(*s, frontendIDs)
                backendAddressPools = getBackendAddressPools(*s)
                outboundRules = getOutboundRules(*s, frontendIDs)
                probes = getProbes(*s)
        }</span>

        <span class="cov8" title="1">lb := network.LoadBalancer{
                Etag:     etag,
                Sku:      &amp;network.LoadBalancerSku{Name: converters.SKUtoSDK(s.SKU)},
                Location: to.StringPtr(s.Location),
                Tags: converters.TagsToMap(infrav1.Build(infrav1.BuildParams{
                        ClusterName: s.ClusterName,
                        Lifecycle:   infrav1.ResourceLifecycleOwned,
                        Role:        to.StringPtr(s.Role),
                        Additional:  s.AdditionalTags,
                })),
                LoadBalancerPropertiesFormat: &amp;network.LoadBalancerPropertiesFormat{
                        FrontendIPConfigurations: &amp;frontendIPConfigs,
                        BackendAddressPools:      &amp;backendAddressPools,
                        OutboundRules:            &amp;outboundRules,
                        Probes:                   &amp;probes,
                        LoadBalancingRules:       &amp;loadBalancingRules,
                },
        }

        return lb, nil</span>
}

func getFrontendIPConfigs(lbSpec LBSpec) ([]network.FrontendIPConfiguration, []network.SubResource) <span class="cov8" title="1">{
        frontendIPConfigurations := make([]network.FrontendIPConfiguration, 0)
        frontendIDs := make([]network.SubResource, 0)
        for _, ipConfig := range lbSpec.FrontendIPConfigs </span><span class="cov8" title="1">{
                var properties network.FrontendIPConfigurationPropertiesFormat
                if lbSpec.Type == infrav1.Internal </span><span class="cov8" title="1">{
                        properties = network.FrontendIPConfigurationPropertiesFormat{
                                PrivateIPAllocationMethod: network.IPAllocationMethodStatic,
                                Subnet: &amp;network.Subnet{
                                        ID: to.StringPtr(azure.SubnetID(lbSpec.SubscriptionID, lbSpec.VNetResourceGroup, lbSpec.VNetName, lbSpec.SubnetName)),
                                },
                                PrivateIPAddress: to.StringPtr(ipConfig.PrivateIPAddress),
                        }
                }</span> else<span class="cov8" title="1"> {
                        properties = network.FrontendIPConfigurationPropertiesFormat{
                                PublicIPAddress: &amp;network.PublicIPAddress{
                                        ID: to.StringPtr(azure.PublicIPID(lbSpec.SubscriptionID, lbSpec.ResourceGroup, ipConfig.PublicIP.Name)),
                                },
                        }
                }</span>
                <span class="cov8" title="1">frontendIPConfigurations = append(frontendIPConfigurations, network.FrontendIPConfiguration{
                        FrontendIPConfigurationPropertiesFormat: &amp;properties,
                        Name:                                    to.StringPtr(ipConfig.Name),
                })
                frontendIDs = append(frontendIDs, network.SubResource{
                        ID: to.StringPtr(azure.FrontendIPConfigID(lbSpec.SubscriptionID, lbSpec.ResourceGroup, lbSpec.Name, ipConfig.Name)),
                })</span>
        }
        <span class="cov8" title="1">return frontendIPConfigurations, frontendIDs</span>
}

func getOutboundRules(lbSpec LBSpec, frontendIDs []network.SubResource) []network.OutboundRule <span class="cov8" title="1">{
        if lbSpec.Type == infrav1.Internal </span><span class="cov8" title="1">{
                return []network.OutboundRule{}
        }</span>
        <span class="cov8" title="1">return []network.OutboundRule{
                {
                        Name: to.StringPtr(outboundNAT),
                        OutboundRulePropertiesFormat: &amp;network.OutboundRulePropertiesFormat{
                                Protocol:                 network.LoadBalancerOutboundRuleProtocolAll,
                                IdleTimeoutInMinutes:     lbSpec.IdleTimeoutInMinutes,
                                FrontendIPConfigurations: &amp;frontendIDs,
                                BackendAddressPool: &amp;network.SubResource{
                                        ID: to.StringPtr(azure.AddressPoolID(lbSpec.SubscriptionID, lbSpec.ResourceGroup, lbSpec.Name, lbSpec.BackendPoolName)),
                                },
                        },
                },
        }</span>
}

func getLoadBalancingRules(lbSpec LBSpec, frontendIDs []network.SubResource) []network.LoadBalancingRule <span class="cov8" title="1">{
        if lbSpec.Role == infrav1.APIServerRole </span><span class="cov8" title="1">{
                // We disable outbound SNAT explicitly in the HTTPS LB rule and enable TCP and UDP outbound NAT with an outbound rule.
                // For more information on Standard LB outbound connections see https://docs.microsoft.com/en-us/azure/load-balancer/load-balancer-outbound-connections.
                var frontendIPConfig network.SubResource
                if len(frontendIDs) != 0 </span><span class="cov8" title="1">{
                        frontendIPConfig = frontendIDs[0]
                }</span>
                <span class="cov8" title="1">return []network.LoadBalancingRule{
                        {
                                Name: to.StringPtr(lbRuleHTTPS),
                                LoadBalancingRulePropertiesFormat: &amp;network.LoadBalancingRulePropertiesFormat{
                                        DisableOutboundSnat:     to.BoolPtr(true),
                                        Protocol:                network.TransportProtocolTCP,
                                        FrontendPort:            to.Int32Ptr(lbSpec.APIServerPort),
                                        BackendPort:             to.Int32Ptr(lbSpec.APIServerPort),
                                        IdleTimeoutInMinutes:    lbSpec.IdleTimeoutInMinutes,
                                        EnableFloatingIP:        to.BoolPtr(false),
                                        LoadDistribution:        network.LoadDistributionDefault,
                                        FrontendIPConfiguration: &amp;frontendIPConfig,
                                        BackendAddressPool: &amp;network.SubResource{
                                                ID: to.StringPtr(azure.AddressPoolID(lbSpec.SubscriptionID, lbSpec.ResourceGroup, lbSpec.Name, lbSpec.BackendPoolName)),
                                        },
                                        Probe: &amp;network.SubResource{
                                                ID: to.StringPtr(azure.ProbeID(lbSpec.SubscriptionID, lbSpec.ResourceGroup, lbSpec.Name, tcpProbe)),
                                        },
                                },
                        },
                }</span>
        }
        <span class="cov8" title="1">return []network.LoadBalancingRule{}</span>
}

func getBackendAddressPools(lbSpec LBSpec) []network.BackendAddressPool <span class="cov8" title="1">{
        return []network.BackendAddressPool{
                {
                        Name: to.StringPtr(lbSpec.BackendPoolName),
                },
        }
}</span>

func getProbes(lbSpec LBSpec) []network.Probe <span class="cov8" title="1">{
        if lbSpec.Role == infrav1.APIServerRole </span><span class="cov8" title="1">{
                return []network.Probe{
                        {
                                Name: to.StringPtr(tcpProbe),
                                ProbePropertiesFormat: &amp;network.ProbePropertiesFormat{
                                        Protocol:          network.ProbeProtocolTCP,
                                        Port:              to.Int32Ptr(lbSpec.APIServerPort),
                                        IntervalInSeconds: to.Int32Ptr(15),
                                        NumberOfProbes:    to.Int32Ptr(4),
                                },
                        },
                }
        }</span>
        <span class="cov8" title="1">return []network.Probe{}</span>
}

func probeExists(probes []network.Probe, probe network.Probe) bool <span class="cov8" title="1">{
        for _, p := range probes </span><span class="cov8" title="1">{
                if to.String(p.Name) == to.String(probe.Name) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func outboundRuleExists(rules []network.OutboundRule, rule network.OutboundRule) bool <span class="cov8" title="1">{
        for _, r := range rules </span><span class="cov8" title="1">{
                if to.String(r.Name) == to.String(rule.Name) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func poolExists(pools []network.BackendAddressPool, pool network.BackendAddressPool) bool <span class="cov8" title="1">{
        for _, p := range pools </span><span class="cov8" title="1">{
                if to.String(p.Name) == to.String(pool.Name) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func lbRuleExists(rules []network.LoadBalancingRule, rule network.LoadBalancingRule) bool <span class="cov8" title="1">{
        for _, r := range rules </span><span class="cov8" title="1">{
                if to.String(r.Name) == to.String(rule.Name) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func ipExists(configs []network.FrontendIPConfiguration, config network.FrontendIPConfiguration) bool <span class="cov8" title="1">{
        for _, ip := range configs </span><span class="cov8" title="1">{
                if to.String(ip.Name) == to.String(config.Name) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package managedclusters

import (
        "context"
        "encoding/json"

        "github.com/Azure/azure-sdk-for-go/services/containerservice/mgmt/2021-05-01/containerservice"
        "github.com/Azure/go-autorest/autorest"
        azureautorest "github.com/Azure/go-autorest/autorest/azure"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// CredentialGetter is a helper interface for getting managed cluster credentials.
type CredentialGetter interface {
        GetCredentials(context.Context, string, string) ([]byte, error)
}

// azureClient contains the Azure go-sdk Client.
type azureClient struct {
        managedclusters containerservice.ManagedClustersClient
}

// newClient creates a new managed cluster client from an authorizer.
func newClient(auth azure.Authorizer) *azureClient <span class="cov0" title="0">{
        return &amp;azureClient{
                managedclusters: newManagedClustersClient(auth.SubscriptionID(), auth.BaseURI(), auth.Authorizer()),
        }
}</span>

// newManagedClustersClient creates a new managed clusters client from subscription ID.
func newManagedClustersClient(subscriptionID string, baseURI string, authorizer autorest.Authorizer) containerservice.ManagedClustersClient <span class="cov0" title="0">{
        managedClustersClient := containerservice.NewManagedClustersClientWithBaseURI(baseURI, subscriptionID)
        azure.SetAutoRestClientDefaults(&amp;managedClustersClient.Client, authorizer)
        return managedClustersClient
}</span>

// Get gets a managed cluster.
func (ac *azureClient) Get(ctx context.Context, spec azure.ResourceSpecGetter) (result interface{}, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "managedclusters.azureClient.Get")
        defer done()

        return ac.managedclusters.Get(ctx, spec.ResourceGroupName(), spec.ResourceName())
}</span>

// GetCredentials fetches the admin kubeconfig for a managed cluster.
func (ac *azureClient) GetCredentials(ctx context.Context, resourceGroupName, name string) ([]byte, error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "managedclusters.azureClient.GetCredentials")
        defer done()

        credentialList, err := ac.managedclusters.ListClusterAdminCredentials(ctx, resourceGroupName, name, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if credentialList.Kubeconfigs == nil || len(*credentialList.Kubeconfigs) &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("no kubeconfigs available for the managed cluster cluster")
        }</span>

        <span class="cov0" title="0">return *(*credentialList.Kubeconfigs)[0].Value, nil</span>
}

// CreateOrUpdateAsync creates or updates a managed cluster.
// It sends a PUT request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *azureClient) CreateOrUpdateAsync(ctx context.Context, spec azure.ResourceSpecGetter, parameters interface{}) (result interface{}, future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "managedclusters.azureClient.CreateOrUpdate")
        defer done()

        managedcluster, ok := parameters.(containerservice.ManagedCluster)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.Errorf("%T is not a containerservice.ManagedCluster", parameters)
        }</span>

        <span class="cov0" title="0">preparer, err := ac.managedclusters.CreateOrUpdatePreparer(ctx, spec.ResourceGroupName(), spec.ResourceName(), managedcluster)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errors.Wrap(err, "failed to prepare operation")
        }</span>

        <span class="cov0" title="0">headerSpec, ok := spec.(azure.ResourceSpecGetterWithHeaders)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.Errorf("%T is not a azure.ResourceSpecGetterWithHeaders", spec)
        }</span>

        <span class="cov0" title="0">for key, value := range headerSpec.CustomHeaders() </span><span class="cov0" title="0">{
                preparer.Header.Add(key, value)
        }</span>

        <span class="cov0" title="0">createFuture, err := ac.managedclusters.CreateOrUpdateSender(preparer)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = createFuture.WaitForCompletionRef(ctx, ac.managedclusters.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return nil, &amp;createFuture, err
        }</span>

        <span class="cov0" title="0">result, err = createFuture.Result(ac.managedclusters)
        // if the operation completed, return a nil future
        return result, nil, err</span>
}

// DeleteAsync deletes a managed cluster asynchronously. DeleteAsync sends a DELETE
// request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *azureClient) DeleteAsync(ctx context.Context, spec azure.ResourceSpecGetter) (future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "managedclusters.azureClient.DeleteAsync")
        defer done()

        deleteFuture, err := ac.managedclusters.Delete(ctx, spec.ResourceGroupName(), spec.ResourceName())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = deleteFuture.WaitForCompletionRef(ctx, ac.managedclusters.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return &amp;deleteFuture, err
        }</span>
        <span class="cov0" title="0">_, err = deleteFuture.Result(ac.managedclusters)
        // if the operation completed, return a nil future.
        return nil, err</span>
}

// IsDone returns true if the long-running operation has completed.
func (ac *azureClient) IsDone(ctx context.Context, future azureautorest.FutureAPI) (bool, error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "managedclusters.azureClient.IsDone")
        defer done()

        isDone, err := future.DoneWithContext(ctx, ac.managedclusters)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "failed checking if the operation was complete")
        }</span>

        <span class="cov0" title="0">return isDone, nil</span>
}

// Result fetches the result of a long-running operation future.
func (ac *azureClient) Result(ctx context.Context, future azureautorest.FutureAPI, futureType string) (result interface{}, err error) <span class="cov0" title="0">{
        _, _, done := tele.StartSpanWithLogger(ctx, "managedclusters.azureClient.Result")
        defer done()

        if future == nil </span><span class="cov0" title="0">{
                return nil, errors.Errorf("cannot get result from nil future")
        }</span>

        <span class="cov0" title="0">switch futureType </span>{
        case infrav1.PutFuture:<span class="cov0" title="0">
                // Marshal and Unmarshal the future to put it into the correct future type so we can access the Result function.
                // Unfortunately the FutureAPI can't be casted directly to ManagedClustersCreateOrUpdateFuture because it is a azureautorest.Future, which doesn't implement the Result function. See PR #1686 for discussion on alternatives.
                // It was converted back to a generic azureautorest.Future from the CAPZ infrav1.Future type stored in Status: https://github.com/kubernetes-sigs/cluster-api-provider-azure/blob/main/azure/converters/futures.go#L49.
                var createFuture *containerservice.ManagedClustersCreateOrUpdateFuture
                jsonData, err := future.MarshalJSON()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to marshal future")
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal(jsonData, &amp;createFuture); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to unmarshal future data")
                }</span>
                <span class="cov0" title="0">return createFuture.Result(ac.managedclusters)</span>

        case infrav1.DeleteFuture:<span class="cov0" title="0">
                // Delete does not return a result managed cluster.
                return nil, nil</span>

        default:<span class="cov0" title="0">
                return nil, errors.Errorf("unknown future type %q", futureType)</span>
        }
}
</pre>
		
		<pre class="file" id="file99" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package managedclusters

import (
        "context"

        "github.com/Azure/azure-sdk-for-go/services/containerservice/mgmt/2021-05-01/containerservice"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        corev1 "k8s.io/api/core/v1"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/async"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
)

const serviceName = "managedcluster"

// ManagedClusterScope defines the scope interface for a managed cluster.
type ManagedClusterScope interface {
        azure.Authorizer
        azure.AsyncStatusUpdater
        ManagedClusterSpec(context.Context) azure.ResourceSpecGetter
        SetControlPlaneEndpoint(clusterv1.APIEndpoint)
        MakeEmptyKubeConfigSecret() corev1.Secret
        GetKubeConfigData() []byte
        SetKubeConfigData([]byte)
}

// Service provides operations on azure resources.
type Service struct {
        Scope ManagedClusterScope
        async.Reconciler
        CredentialGetter
}

// New creates a new service.
func New(scope ManagedClusterScope) *Service <span class="cov0" title="0">{
        client := newClient(scope)
        return &amp;Service{
                Scope:            scope,
                Reconciler:       async.New(scope, client, client),
                CredentialGetter: client,
        }
}</span>

// Name returns the service name.
func (s *Service) Name() string <span class="cov0" title="0">{
        return serviceName
}</span>

// Reconcile idempotently creates or updates a managed cluster, if possible.
func (s *Service) Reconcile(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "managedclusters.Service.Reconcile")
        defer done()

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        managedClusterSpec := s.Scope.ManagedClusterSpec(ctx)
        if managedClusterSpec == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">result, resultErr := s.CreateResource(ctx, managedClusterSpec, serviceName)
        if resultErr == nil </span><span class="cov8" title="1">{
                managedCluster, ok := result.(containerservice.ManagedCluster)
                if !ok </span><span class="cov0" title="0">{
                        return errors.Errorf("%T is not a containerservice.ManagedCluster", result)
                }</span>
                // Update control plane endpoint.
                <span class="cov8" title="1">endpoint := clusterv1.APIEndpoint{
                        Host: to.String(managedCluster.ManagedClusterProperties.Fqdn),
                        Port: 443,
                }
                s.Scope.SetControlPlaneEndpoint(endpoint)

                // Update kubeconfig data
                // Always fetch credentials in case of rotation
                kubeConfigData, err := s.GetCredentials(ctx, managedClusterSpec.ResourceGroupName(), managedClusterSpec.ResourceName())
                if err != nil </span><span class="cov8" title="1">{
                        return errors.Wrap(err, "failed to get credentials for managed cluster")
                }</span>
                <span class="cov8" title="1">s.Scope.SetKubeConfigData(kubeConfigData)</span>
        }
        <span class="cov8" title="1">s.Scope.UpdatePutStatus(infrav1.ManagedClusterRunningCondition, serviceName, resultErr)
        return resultErr</span>
}

// Delete deletes the managed cluster.
func (s *Service) Delete(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "managedclusters.Service.Delete")
        defer done()

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        managedClusterSpec := s.Scope.ManagedClusterSpec(ctx)
        if managedClusterSpec == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">err := s.DeleteResource(ctx, managedClusterSpec, serviceName)
        s.Scope.UpdateDeleteStatus(infrav1.ManagedClusterRunningCondition, serviceName, err)
        return err</span>
}

// IsManaged returns always returns true as CAPZ does not support BYO managed cluster.
func (s *Service) IsManaged(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>
</pre>
		
		<pre class="file" id="file100" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package managedclusters

import (
        "encoding/base64"
        "fmt"
        "net"
        "time"

        "github.com/Azure/azure-sdk-for-go/services/containerservice/mgmt/2021-05-01/containerservice"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/google/go-cmp/cmp"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/converters"
)

// ManagedClusterSpec contains properties to create a managed cluster.
type ManagedClusterSpec struct {
        // Name is the name of this AKS Cluster.
        Name string

        // ResourceGroup is the name of the Azure resource group for this AKS Cluster.
        ResourceGroup string

        // NodeResourceGroup is the name of the Azure resource group containing IaaS VMs.
        NodeResourceGroup string

        // VnetSubnetID is the Azure Resource ID for the subnet which should contain nodes.
        VnetSubnetID string

        // Location is a string matching one of the canonical Azure region names. Examples: "westus2", "eastus".
        Location string

        // Tags is a set of tags to add to this cluster.
        Tags map[string]string

        // Version defines the desired Kubernetes version.
        Version string

        // LoadBalancerSKU for the managed cluster. Possible values include: 'Standard', 'Basic'. Defaults to Standard.
        LoadBalancerSKU string

        // NetworkPlugin used for building Kubernetes network. Possible values include: 'azure', 'kubenet'. Defaults to azure.
        NetworkPlugin string

        // NetworkPolicy used for building Kubernetes network. Possible values include: 'calico', 'azure'. Defaults to azure.
        NetworkPolicy string

        // SSHPublicKey is a string literal containing an ssh public key. Will autogenerate and discard if not provided.
        SSHPublicKey string

        // GetAllAgentPools is a function that returns the list of agent pool specifications in this cluster.
        GetAllAgentPools func() ([]azure.ResourceSpecGetter, error)

        // PodCIDR is the CIDR block for IP addresses distributed to pods
        PodCIDR string

        // ServiceCIDR is the CIDR block for IP addresses distributed to services
        ServiceCIDR string

        // DNSServiceIP is an IP address assigned to the Kubernetes DNS service
        DNSServiceIP *string

        // AddonProfiles are the profiles of managed cluster add-on.
        AddonProfiles []AddonProfile

        // AADProfile is Azure Active Directory configuration to integrate with AKS, for aad authentication.
        AADProfile *AADProfile

        // SKU is the SKU of the AKS to be provisioned.
        SKU *SKU

        // LoadBalancerProfile is the profile of the cluster load balancer.
        LoadBalancerProfile *LoadBalancerProfile

        // APIServerAccessProfile is the access profile for AKS API server.
        APIServerAccessProfile *APIServerAccessProfile

        // Headers is the list of headers to add to the HTTP requests to update this resource.
        Headers map[string]string
}

// AADProfile is Azure Active Directory configuration to integrate with AKS, for aad authentication.
type AADProfile struct {
        // Managed defines whether to enable managed AAD.
        Managed bool

        // EnableAzureRBAC defines whether to enable Azure RBAC for Kubernetes authorization.
        EnableAzureRBAC bool

        // AdminGroupObjectIDs are the AAD group object IDs that will have admin role of the cluster.
        AdminGroupObjectIDs []string
}

// AddonProfile is the profile of a managed cluster add-on.
type AddonProfile struct {
        Name    string
        Config  map[string]string
        Enabled bool
}

// SKU is an AKS SKU.
type SKU struct {
        // Tier is the tier of a managed cluster SKU.
        Tier string
}

// LoadBalancerProfile is the profile of the cluster load balancer.
type LoadBalancerProfile struct {
        // Load balancer profile must specify at most one of ManagedOutboundIPs, OutboundIPPrefixes and OutboundIPs.
        // By default the AKS cluster automatically creates a public IP in the AKS-managed infrastructure resource group and assigns it to the load balancer outbound pool.
        // Alternatively, you can assign your own custom public IP or public IP prefix at cluster creation time.
        // See https://docs.microsoft.com/en-us/azure/aks/load-balancer-standard#provide-your-own-outbound-public-ips-or-prefixes

        // ManagedOutboundIPs are the desired managed outbound IPs for the cluster load balancer.
        ManagedOutboundIPs *int32

        // OutboundIPPrefixes are the desired outbound IP Prefix resources for the cluster load balancer.
        OutboundIPPrefixes []string

        // OutboundIPs are the desired outbound IP resources for the cluster load balancer.
        OutboundIPs []string

        // AllocatedOutboundPorts are the desired number of allocated SNAT ports per VM. Allowed values must be in the range of 0 to 64000 (inclusive). The default value is 0 which results in Azure dynamically allocating ports.
        AllocatedOutboundPorts *int32

        // IdleTimeoutInMinutes  are the desired outbound flow idle timeout in minutes. Allowed values must be in the range of 4 to 120 (inclusive). The default value is 30 minutes.
        IdleTimeoutInMinutes *int32
}

// APIServerAccessProfile is the access profile for AKS API server.
type APIServerAccessProfile struct {
        // AuthorizedIPRanges are the authorized IP Ranges to kubernetes API server.
        AuthorizedIPRanges []string
        // EnablePrivateCluster defines hether to create the cluster as a private cluster or not.
        EnablePrivateCluster *bool
        // PrivateDNSZone is the private dns zone for private clusters.
        PrivateDNSZone *string
        // EnablePrivateClusterPublicFQDN defines whether to create additional public FQDN for private cluster or not.
        EnablePrivateClusterPublicFQDN *bool
}

var _ azure.ResourceSpecGetterWithHeaders = (*ManagedClusterSpec)(nil)

// ResourceName returns the name of the AKS cluster.
func (s *ManagedClusterSpec) ResourceName() string <span class="cov8" title="1">{
        return s.Name
}</span>

// ResourceGroupName returns the name of the resource group.
func (s *ManagedClusterSpec) ResourceGroupName() string <span class="cov8" title="1">{
        return s.ResourceGroup
}</span>

// OwnerResourceName is a no-op for managed clusters.
func (s *ManagedClusterSpec) OwnerResourceName() string <span class="cov0" title="0">{
        return "" // not applicable
}</span>

// CustomHeaders returns custom headers to be added to the Azure API calls.
func (s *ManagedClusterSpec) CustomHeaders() map[string]string <span class="cov0" title="0">{
        return s.Headers
}</span>

// Parameters returns the parameters for the managed clusters.
func (s *ManagedClusterSpec) Parameters(existing interface{}) (params interface{}, err error) <span class="cov8" title="1">{
        decodedSSHPublicKey, err := base64.StdEncoding.DecodeString(s.SSHPublicKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to decode SSHPublicKey")
        }</span>
        <span class="cov8" title="1">managedCluster := containerservice.ManagedCluster{
                Identity: &amp;containerservice.ManagedClusterIdentity{
                        Type: containerservice.ResourceIdentityTypeSystemAssigned,
                },
                Location: &amp;s.Location,
                ManagedClusterProperties: &amp;containerservice.ManagedClusterProperties{
                        NodeResourceGroup: &amp;s.NodeResourceGroup,
                        EnableRBAC:        to.BoolPtr(true),
                        DNSPrefix:         &amp;s.Name,
                        KubernetesVersion: &amp;s.Version,
                        LinuxProfile: &amp;containerservice.LinuxProfile{
                                AdminUsername: to.StringPtr(azure.DefaultAKSUserName),
                                SSH: &amp;containerservice.SSHConfiguration{
                                        PublicKeys: &amp;[]containerservice.SSHPublicKey{
                                                {
                                                        KeyData: to.StringPtr(string(decodedSSHPublicKey)),
                                                },
                                        },
                                },
                        },
                        ServicePrincipalProfile: &amp;containerservice.ManagedClusterServicePrincipalProfile{
                                ClientID: to.StringPtr("msi"),
                        },
                        AgentPoolProfiles: &amp;[]containerservice.ManagedClusterAgentPoolProfile{},
                        NetworkProfile: &amp;containerservice.NetworkProfile{
                                NetworkPlugin:   containerservice.NetworkPlugin(s.NetworkPlugin),
                                LoadBalancerSku: containerservice.LoadBalancerSku(s.LoadBalancerSKU),
                                NetworkPolicy:   containerservice.NetworkPolicy(s.NetworkPolicy),
                        },
                },
        }

        if tags := *to.StringMapPtr(s.Tags); len(tags) != 0 </span><span class="cov8" title="1">{
                managedCluster.Tags = tags
        }</span>

        <span class="cov8" title="1">if s.PodCIDR != "" </span><span class="cov0" title="0">{
                managedCluster.NetworkProfile.PodCidr = &amp;s.PodCIDR
        }</span>

        <span class="cov8" title="1">if s.ServiceCIDR != "" </span><span class="cov0" title="0">{
                if s.DNSServiceIP == nil </span><span class="cov0" title="0">{
                        managedCluster.NetworkProfile.ServiceCidr = &amp;s.ServiceCIDR
                        ip, _, err := net.ParseCIDR(s.ServiceCIDR)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to parse service cidr: %w", err)
                        }</span>
                        // HACK: set the last octet of the IP to .10
                        // This ensures the dns IP is valid in the service cidr without forcing the user
                        // to specify it in both the Capi cluster and the Azure control plane.
                        // https://golang.org/src/net/ip.go#L48
                        <span class="cov0" title="0">ip[15] = byte(10)
                        dnsIP := ip.String()
                        managedCluster.NetworkProfile.DNSServiceIP = &amp;dnsIP</span>
                } else<span class="cov0" title="0"> {
                        managedCluster.NetworkProfile.DNSServiceIP = s.DNSServiceIP
                }</span>
        }

        <span class="cov8" title="1">if s.AADProfile != nil </span><span class="cov0" title="0">{
                managedCluster.AadProfile = &amp;containerservice.ManagedClusterAADProfile{
                        Managed:             &amp;s.AADProfile.Managed,
                        EnableAzureRBAC:     &amp;s.AADProfile.EnableAzureRBAC,
                        AdminGroupObjectIDs: &amp;s.AADProfile.AdminGroupObjectIDs,
                }
        }</span>

        <span class="cov8" title="1">for i := range s.AddonProfiles </span><span class="cov0" title="0">{
                if managedCluster.AddonProfiles == nil </span><span class="cov0" title="0">{
                        managedCluster.AddonProfiles = map[string]*containerservice.ManagedClusterAddonProfile{}
                }</span>
                <span class="cov0" title="0">item := s.AddonProfiles[i]
                addonProfile := &amp;containerservice.ManagedClusterAddonProfile{
                        Enabled: &amp;item.Enabled,
                }
                if item.Config != nil </span><span class="cov0" title="0">{
                        addonProfile.Config = *to.StringMapPtr(item.Config)
                }</span>
                <span class="cov0" title="0">managedCluster.AddonProfiles[item.Name] = addonProfile</span>
        }

        <span class="cov8" title="1">if s.SKU != nil </span><span class="cov0" title="0">{
                tierName := containerservice.ManagedClusterSKUTier(s.SKU.Tier)
                managedCluster.Sku = &amp;containerservice.ManagedClusterSKU{
                        Name: containerservice.ManagedClusterSKUNameBasic,
                        Tier: tierName,
                }
        }</span>

        <span class="cov8" title="1">if s.LoadBalancerProfile != nil </span><span class="cov0" title="0">{
                managedCluster.NetworkProfile.LoadBalancerProfile = &amp;containerservice.ManagedClusterLoadBalancerProfile{
                        AllocatedOutboundPorts: s.LoadBalancerProfile.AllocatedOutboundPorts,
                        IdleTimeoutInMinutes:   s.LoadBalancerProfile.IdleTimeoutInMinutes,
                }
                if s.LoadBalancerProfile.ManagedOutboundIPs != nil </span><span class="cov0" title="0">{
                        managedCluster.NetworkProfile.LoadBalancerProfile.ManagedOutboundIPs = &amp;containerservice.ManagedClusterLoadBalancerProfileManagedOutboundIPs{Count: s.LoadBalancerProfile.ManagedOutboundIPs}
                }</span>
                <span class="cov0" title="0">if len(s.LoadBalancerProfile.OutboundIPPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                        managedCluster.NetworkProfile.LoadBalancerProfile.OutboundIPPrefixes = &amp;containerservice.ManagedClusterLoadBalancerProfileOutboundIPPrefixes{
                                PublicIPPrefixes: convertToResourceReferences(s.LoadBalancerProfile.OutboundIPPrefixes),
                        }
                }</span>
                <span class="cov0" title="0">if len(s.LoadBalancerProfile.OutboundIPs) &gt; 0 </span><span class="cov0" title="0">{
                        managedCluster.NetworkProfile.LoadBalancerProfile.OutboundIPs = &amp;containerservice.ManagedClusterLoadBalancerProfileOutboundIPs{
                                PublicIPs: convertToResourceReferences(s.LoadBalancerProfile.OutboundIPs),
                        }
                }</span>
        }

        <span class="cov8" title="1">if s.APIServerAccessProfile != nil </span><span class="cov0" title="0">{
                managedCluster.APIServerAccessProfile = &amp;containerservice.ManagedClusterAPIServerAccessProfile{
                        AuthorizedIPRanges:             &amp;s.APIServerAccessProfile.AuthorizedIPRanges,
                        EnablePrivateCluster:           s.APIServerAccessProfile.EnablePrivateCluster,
                        PrivateDNSZone:                 s.APIServerAccessProfile.PrivateDNSZone,
                        EnablePrivateClusterPublicFQDN: s.APIServerAccessProfile.EnablePrivateClusterPublicFQDN,
                }
        }</span>

        <span class="cov8" title="1">if existing != nil </span><span class="cov8" title="1">{
                existingMC, ok := existing.(containerservice.ManagedCluster)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%T is not a containerservice.ManagedCluster", existing)
                }</span>
                <span class="cov8" title="1">ps := *existingMC.ManagedClusterProperties.ProvisioningState
                if ps != string(infrav1.Canceled) &amp;&amp; ps != string(infrav1.Failed) &amp;&amp; ps != string(infrav1.Succeeded) </span><span class="cov8" title="1">{
                        return nil, azure.WithTransientError(errors.Errorf("Unable to update existing managed cluster in non-terminal state. Managed cluster must be in one of the following provisioning states: Canceled, Failed, or Succeeded. Actual state: %s", ps), 20*time.Second)
                }</span>

                // Normalize the LoadBalancerProfile so the diff below doesn't get thrown off by AKS added properties.
                <span class="cov8" title="1">if managedCluster.NetworkProfile.LoadBalancerProfile == nil </span><span class="cov8" title="1">{
                        // If our LoadBalancerProfile generated by the spec is nil, then don't worry about what AKS has added.
                        existingMC.NetworkProfile.LoadBalancerProfile = nil
                }</span> else<span class="cov0" title="0"> {
                        // If our LoadBalancerProfile generated by the spec is not nil, then remove the effective outbound IPs from
                        // AKS.
                        existingMC.NetworkProfile.LoadBalancerProfile.EffectiveOutboundIPs = nil
                }</span>

                // Avoid changing agent pool profiles through AMCP and just use the existing agent pool profiles
                // AgentPool changes are managed through AMMP.
                <span class="cov8" title="1">managedCluster.AgentPoolProfiles = existingMC.AgentPoolProfiles

                diff := computeDiffOfNormalizedClusters(managedCluster, existingMC)
                if diff == "" </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
        } else<span class="cov8" title="1"> {
                // Add all agent pools to cluster spec that will be submitted to the API
                agentPoolSpecs, err := s.GetAllAgentPools()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrapf(err, "failed to get agent pool specs for managed cluster %s", s.Name)
                }</span>

                <span class="cov8" title="1">for _, spec := range agentPoolSpecs </span><span class="cov8" title="1">{
                        params, err := spec.Parameters(nil)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errors.Wrapf(err, "failed to get agent pool parameters for managed cluster %s", s.Name)
                        }</span>
                        <span class="cov8" title="1">agentPool, ok := params.(containerservice.AgentPool)
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("%T is not a containerservice.AgentPool", agentPool)
                        }</span>
                        <span class="cov8" title="1">agentPool.Name = to.StringPtr(spec.ResourceName())
                        profile := converters.AgentPoolToManagedClusterAgentPoolProfile(agentPool)
                        *managedCluster.AgentPoolProfiles = append(*managedCluster.AgentPoolProfiles, profile)</span>
                }
        }

        <span class="cov8" title="1">return managedCluster, nil</span>
}

func convertToResourceReferences(resources []string) *[]containerservice.ResourceReference <span class="cov0" title="0">{
        resourceReferences := make([]containerservice.ResourceReference, len(resources))
        for i := range resources </span><span class="cov0" title="0">{
                resourceReferences[i] = containerservice.ResourceReference{ID: &amp;resources[i]}
        }</span>
        <span class="cov0" title="0">return &amp;resourceReferences</span>
}

func computeDiffOfNormalizedClusters(managedCluster containerservice.ManagedCluster, existingMC containerservice.ManagedCluster) string <span class="cov8" title="1">{
        // Normalize properties for the desired (CR spec) and existing managed
        // cluster, so that we check only those fields that were specified in
        // the initial CreateOrUpdate request and that can be modified.
        // Without comparing to normalized properties, we would always get a
        // difference in desired and existing, which would result in sending
        // unnecessary Azure API requests.
        propertiesNormalized := &amp;containerservice.ManagedClusterProperties{
                KubernetesVersion: managedCluster.ManagedClusterProperties.KubernetesVersion,
                NetworkProfile:    &amp;containerservice.NetworkProfile{},
        }

        existingMCPropertiesNormalized := &amp;containerservice.ManagedClusterProperties{
                KubernetesVersion: existingMC.ManagedClusterProperties.KubernetesVersion,
                NetworkProfile:    &amp;containerservice.NetworkProfile{},
        }

        if managedCluster.AadProfile != nil </span><span class="cov0" title="0">{
                propertiesNormalized.AadProfile = &amp;containerservice.ManagedClusterAADProfile{
                        Managed:             managedCluster.AadProfile.Managed,
                        EnableAzureRBAC:     managedCluster.AadProfile.EnableAzureRBAC,
                        AdminGroupObjectIDs: managedCluster.AadProfile.AdminGroupObjectIDs,
                }
        }</span>

        <span class="cov8" title="1">if existingMC.AadProfile != nil </span><span class="cov0" title="0">{
                existingMCPropertiesNormalized.AadProfile = &amp;containerservice.ManagedClusterAADProfile{
                        Managed:             existingMC.AadProfile.Managed,
                        EnableAzureRBAC:     existingMC.AadProfile.EnableAzureRBAC,
                        AdminGroupObjectIDs: existingMC.AadProfile.AdminGroupObjectIDs,
                }
        }</span>

        <span class="cov8" title="1">if managedCluster.NetworkProfile != nil </span><span class="cov8" title="1">{
                propertiesNormalized.NetworkProfile.LoadBalancerProfile = managedCluster.NetworkProfile.LoadBalancerProfile
        }</span>

        <span class="cov8" title="1">if existingMC.NetworkProfile != nil </span><span class="cov8" title="1">{
                existingMCPropertiesNormalized.NetworkProfile.LoadBalancerProfile = existingMC.NetworkProfile.LoadBalancerProfile
        }</span>

        <span class="cov8" title="1">if managedCluster.APIServerAccessProfile != nil </span><span class="cov0" title="0">{
                propertiesNormalized.APIServerAccessProfile = &amp;containerservice.ManagedClusterAPIServerAccessProfile{
                        AuthorizedIPRanges: managedCluster.APIServerAccessProfile.AuthorizedIPRanges,
                }
        }</span>

        <span class="cov8" title="1">if existingMC.APIServerAccessProfile != nil </span><span class="cov0" title="0">{
                existingMCPropertiesNormalized.APIServerAccessProfile = &amp;containerservice.ManagedClusterAPIServerAccessProfile{
                        AuthorizedIPRanges: existingMC.APIServerAccessProfile.AuthorizedIPRanges,
                }
        }</span>

        <span class="cov8" title="1">clusterNormalized := &amp;containerservice.ManagedCluster{
                ManagedClusterProperties: propertiesNormalized,
                Tags:                     managedCluster.Tags,
        }
        existingMCClusterNormalized := &amp;containerservice.ManagedCluster{
                ManagedClusterProperties: existingMCPropertiesNormalized,
                Tags:                     existingMC.Tags,
        }

        if managedCluster.Sku != nil </span><span class="cov0" title="0">{
                clusterNormalized.Sku = managedCluster.Sku
        }</span>
        <span class="cov8" title="1">if existingMC.Sku != nil </span><span class="cov0" title="0">{
                existingMCClusterNormalized.Sku = existingMC.Sku
        }</span>

        <span class="cov8" title="1">diff := cmp.Diff(clusterNormalized, existingMCClusterNormalized)
        return diff</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package natgateways

import (
        "context"
        "encoding/json"

        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-08-01/network"
        "github.com/Azure/go-autorest/autorest"
        azureautorest "github.com/Azure/go-autorest/autorest/azure"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// azureClient contains the Azure go-sdk Client.
type azureClient struct {
        natgateways network.NatGatewaysClient
}

// newClient creates a new VM client from subscription ID.
func newClient(auth azure.Authorizer) *azureClient <span class="cov0" title="0">{
        c := netNatGatewaysClient(auth.SubscriptionID(), auth.BaseURI(), auth.Authorizer())
        return &amp;azureClient{c}
}</span>

// netNatGatewaysClient creates a new nat gateways client from subscription ID.
func netNatGatewaysClient(subscriptionID string, baseURI string, authorizer autorest.Authorizer) network.NatGatewaysClient <span class="cov0" title="0">{
        natGatewaysClient := network.NewNatGatewaysClientWithBaseURI(baseURI, subscriptionID)
        azure.SetAutoRestClientDefaults(&amp;natGatewaysClient.Client, authorizer)
        return natGatewaysClient
}</span>

// Get gets the specified nat gateway.
func (ac *azureClient) Get(ctx context.Context, spec azure.ResourceSpecGetter) (result interface{}, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "natgateways.azureClient.Get")
        defer done()

        return ac.natgateways.Get(ctx, spec.ResourceGroupName(), spec.ResourceName(), "")
}</span>

// CreateOrUpdateAsync creates or updates a Nat Gateway asynchronously.
// It sends a PUT request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *azureClient) CreateOrUpdateAsync(ctx context.Context, spec azure.ResourceSpecGetter, parameters interface{}) (result interface{}, future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "natgateways.azureClient.CreateOrUpdateAsync")
        defer done()

        natGateway, ok := parameters.(network.NatGateway)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.Errorf("%T is not a network.NatGateway", parameters)
        }</span>

        <span class="cov0" title="0">createFuture, err := ac.natgateways.CreateOrUpdate(ctx, spec.ResourceGroupName(), spec.ResourceName(), natGateway)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = createFuture.WaitForCompletionRef(ctx, ac.natgateways.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return nil, &amp;createFuture, err
        }</span>

        <span class="cov0" title="0">result, err = createFuture.Result(ac.natgateways)
        // if the operation completed, return a nil future
        return result, nil, err</span>
}

// DeleteAsync deletes a Nat Gateway asynchronously. DeleteAsync sends a DELETE
// request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *azureClient) DeleteAsync(ctx context.Context, spec azure.ResourceSpecGetter) (future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "natgateways.azureClient.DeleteAsync")
        defer done()

        deleteFuture, err := ac.natgateways.Delete(ctx, spec.ResourceGroupName(), spec.ResourceName())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = deleteFuture.WaitForCompletionRef(ctx, ac.natgateways.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return &amp;deleteFuture, err
        }</span>
        <span class="cov0" title="0">_, err = deleteFuture.Result(ac.natgateways)
        // if the operation completed, return a nil future.
        return nil, err</span>
}

// IsDone returns true if the long-running operation has completed.
func (ac *azureClient) IsDone(ctx context.Context, future azureautorest.FutureAPI) (isDone bool, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "natgateways.azureClient.IsDone")
        defer done()

        isDone, err = future.DoneWithContext(ctx, ac.natgateways)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "failed checking if the operation was complete")
        }</span>

        <span class="cov0" title="0">return isDone, nil</span>
}

// Result fetches the result of a long-running operation future.
func (ac *azureClient) Result(ctx context.Context, future azureautorest.FutureAPI, futureType string) (result interface{}, err error) <span class="cov0" title="0">{
        _, _, done := tele.StartSpanWithLogger(ctx, "natgateways.azureClient.Result")
        defer done()

        if future == nil </span><span class="cov0" title="0">{
                return nil, errors.Errorf("cannot get result from nil future")
        }</span>

        <span class="cov0" title="0">switch futureType </span>{
        case infrav1.PutFuture:<span class="cov0" title="0">
                // Marshal and Unmarshal the future to put it into the correct future type so we can access the Result function.
                // Unfortunately the FutureAPI can't be casted directly to NatGatewaysCreateOrUpdateFuture because it is a azureautorest.Future, which doesn't implement the Result function. See PR #1686 for discussion on alternatives.
                // It was converted back to a generic azureautorest.Future from the CAPZ infrav1.Future type stored in Status: https://github.com/kubernetes-sigs/cluster-api-provider-azure/blob/main/azure/converters/futures.go#L49.
                var createFuture *network.NatGatewaysCreateOrUpdateFuture
                jsonData, err := future.MarshalJSON()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to marshal future")
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal(jsonData, &amp;createFuture); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to unmarshal future data")
                }</span>
                <span class="cov0" title="0">return createFuture.Result(ac.natgateways)</span>

        case infrav1.DeleteFuture:<span class="cov0" title="0">
                // Delete does not return a result NAT gateway
                return nil, nil</span>

        default:<span class="cov0" title="0">
                return nil, errors.Errorf("unknown future type %q", futureType)</span>
        }
}
</pre>
		
		<pre class="file" id="file102" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package natgateways

import (
        "context"

        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-08-01/network"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/async"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

const serviceName = "natgateways"

// NatGatewayScope defines the scope interface for NAT gateway service.
type NatGatewayScope interface {
        azure.ClusterScoper
        azure.AsyncStatusUpdater
        SetNatGatewayIDInSubnets(natGatewayName string, natGatewayID string)
        NatGatewaySpecs() []azure.ResourceSpecGetter
}

// Service provides operations on azure resources.
type Service struct {
        Scope NatGatewayScope
        async.Reconciler
}

// New creates a new service.
func New(scope NatGatewayScope) *Service <span class="cov0" title="0">{
        client := newClient(scope)
        return &amp;Service{
                Scope:      scope,
                Reconciler: async.New(scope, client, client),
        }
}</span>

// Name returns the service name.
func (s *Service) Name() string <span class="cov0" title="0">{
        return serviceName
}</span>

// Reconcile gets/creates/updates a NAT gateway.
// Only when the NAT gateway 'Name' property is defined we create the NAT gateway: it's opt-in.
func (s *Service) Reconcile(ctx context.Context) error <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "natgateways.Service.Reconcile")
        defer done()

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        if managed, err := s.IsManaged(ctx); err == nil &amp;&amp; !managed </span><span class="cov8" title="1">{
                log.V(4).Info("Skipping nat gateways reconcile in custom vnet mode")
                return nil
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to check if NAT gateways are managed")
        }</span>

        // We go through the list of NatGatewaySpecs to reconcile each one, independently of the resultingErr of the previous one.
        <span class="cov8" title="1">specs := s.Scope.NatGatewaySpecs()
        if len(specs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // If multiple errors occur, we return the most pressing one.
        //  Order of precedence (highest -&gt; lowest) is: error that is not an operationNotDoneError (ie. error creating) -&gt; operationNotDoneError (ie. creating in progress) -&gt; no error (ie. created)
        <span class="cov8" title="1">var resultingErr error
        for _, natGatewaySpec := range specs </span><span class="cov8" title="1">{
                result, err := s.CreateResource(ctx, natGatewaySpec, serviceName)
                if err != nil </span><span class="cov8" title="1">{
                        if !azure.IsOperationNotDoneError(err) || resultingErr == nil </span><span class="cov8" title="1">{
                                resultingErr = err
                        }</span>
                }
                <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                        natGateway, ok := result.(network.NatGateway)
                        if !ok </span><span class="cov8" title="1">{
                                // Return out of loop since this would be an unexpected fatal error
                                resultingErr = errors.Errorf("created resource %T is not a network.NatGateway", result)
                                break</span>
                        }

                        // TODO: ideally we wouldn't need to set the subnet spec based on the result of the create operation
                        <span class="cov8" title="1">s.Scope.SetNatGatewayIDInSubnets(natGatewaySpec.ResourceName(), *natGateway.ID)</span>
                }
        }

        <span class="cov8" title="1">s.Scope.UpdatePutStatus(infrav1.NATGatewaysReadyCondition, serviceName, resultingErr)
        return resultingErr</span>
}

// Delete deletes the NAT gateway with the provided name.
func (s *Service) Delete(ctx context.Context) error <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "natgateways.Service.Delete")
        defer done()

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        if managed, err := s.IsManaged(ctx); err == nil &amp;&amp; !managed </span><span class="cov8" title="1">{
                log.V(4).Info("Skipping nat gateway deletion in custom vnet mode")
                return nil
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to check if NAT gateways are managed")
        }</span>

        <span class="cov8" title="1">specs := s.Scope.NatGatewaySpecs()
        if len(specs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // We go through the list of NatGatewaySpecs to delete each one, independently of the resultingErr of the previous one.
        // If multiple errors occur, we return the most pressing one.
        //  Order of precedence (highest -&gt; lowest) is: error that is not an operationNotDoneError (ie. error creating) -&gt; operationNotDoneError (ie. creating in progress) -&gt; no error (ie. created)
        <span class="cov8" title="1">var resultingErr error
        for _, natGatewaySpec := range specs </span><span class="cov8" title="1">{
                if err := s.DeleteResource(ctx, natGatewaySpec, serviceName); err != nil </span><span class="cov8" title="1">{
                        if !azure.IsOperationNotDoneError(err) || resultingErr == nil </span><span class="cov8" title="1">{
                                resultingErr = err
                        }</span>
                }
        }
        <span class="cov8" title="1">s.Scope.UpdateDeleteStatus(infrav1.NATGatewaysReadyCondition, serviceName, resultingErr)
        return resultingErr</span>
}

// IsManaged returns true if the NAT gateways' lifecycles are managed.
func (s *Service) IsManaged(ctx context.Context) (bool, error) <span class="cov8" title="1">{
        _, _, done := tele.StartSpanWithLogger(ctx, "natgateways.Service.IsManaged")
        defer done()

        return s.Scope.IsVnetManaged(), nil
}</span>
</pre>
		
		<pre class="file" id="file103" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package natgateways

import (
        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-08-01/network"
        autorest "github.com/Azure/go-autorest/autorest/azure"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/converters"
)

// NatGatewaySpec defines the specification for a NAT gateway.
type NatGatewaySpec struct {
        Name           string
        ResourceGroup  string
        SubscriptionID string
        Location       string
        NatGatewayIP   infrav1.PublicIPSpec
        ClusterName    string
        AdditionalTags infrav1.Tags
}

// ResourceName returns the name of the NAT gateway.
func (s *NatGatewaySpec) ResourceName() string <span class="cov8" title="1">{
        return s.Name
}</span>

// ResourceGroupName returns the name of the resource group.
func (s *NatGatewaySpec) ResourceGroupName() string <span class="cov0" title="0">{
        return s.ResourceGroup
}</span>

// OwnerResourceName is a no-op for NAT gateways.
func (s *NatGatewaySpec) OwnerResourceName() string <span class="cov0" title="0">{
        return ""
}</span>

// Parameters returns the parameters for the NAT gateway.
func (s *NatGatewaySpec) Parameters(existing interface{}) (params interface{}, err error) <span class="cov0" title="0">{
        if existing != nil </span><span class="cov0" title="0">{
                existingNatGateway, ok := existing.(network.NatGateway)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("%T is not a network.NatGateway", existing)
                }</span>

                <span class="cov0" title="0">if hasPublicIP(existingNatGateway, s.NatGatewayIP.Name) </span><span class="cov0" title="0">{
                        // Skip update for NAT gateway as it exists with expected values
                        return nil, nil
                }</span>
        }

        <span class="cov0" title="0">natGatewayToCreate := network.NatGateway{
                Name:     to.StringPtr(s.Name),
                Location: to.StringPtr(s.Location),
                Sku:      &amp;network.NatGatewaySku{Name: network.NatGatewaySkuNameStandard},
                NatGatewayPropertiesFormat: &amp;network.NatGatewayPropertiesFormat{
                        PublicIPAddresses: &amp;[]network.SubResource{
                                {
                                        ID: to.StringPtr(azure.PublicIPID(s.SubscriptionID, s.ResourceGroupName(), s.NatGatewayIP.Name)),
                                },
                        },
                },
                Tags: converters.TagsToMap(infrav1.Build(infrav1.BuildParams{
                        ClusterName: s.ClusterName,
                        Lifecycle:   infrav1.ResourceLifecycleOwned,
                        Name:        to.StringPtr(s.Name),
                        Additional:  s.AdditionalTags,
                })),
        }

        return natGatewayToCreate, nil</span>
}

func hasPublicIP(natGateway network.NatGateway, publicIPName string) bool <span class="cov0" title="0">{
        // We must have a non-nil, non-"empty" PublicIPAddresses
        if !(natGateway.PublicIPAddresses != nil &amp;&amp; len(*natGateway.PublicIPAddresses) &gt; 0) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for _, publicIP := range *natGateway.PublicIPAddresses </span><span class="cov0" title="0">{
                resource, err := autorest.ParseResourceID(*publicIP.ID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if resource.ResourceName == publicIPName </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file104" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package networkinterfaces

import (
        "context"
        "encoding/json"

        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-08-01/network"
        "github.com/Azure/go-autorest/autorest"
        azureautorest "github.com/Azure/go-autorest/autorest/azure"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// AzureClient contains the Azure go-sdk Client.
type AzureClient struct {
        interfaces network.InterfacesClient
}

// NewClient creates a new VM client from subscription ID.
func NewClient(auth azure.Authorizer) *AzureClient <span class="cov0" title="0">{
        c := newInterfacesClient(auth.SubscriptionID(), auth.BaseURI(), auth.Authorizer())
        return &amp;AzureClient{c}
}</span>

// newInterfacesClient creates a new network interfaces client from subscription ID.
func newInterfacesClient(subscriptionID string, baseURI string, authorizer autorest.Authorizer) network.InterfacesClient <span class="cov0" title="0">{
        nicClient := network.NewInterfacesClientWithBaseURI(baseURI, subscriptionID)
        azure.SetAutoRestClientDefaults(&amp;nicClient.Client, authorizer)
        return nicClient
}</span>

// Get gets the specified network interface.
func (ac *AzureClient) Get(ctx context.Context, spec azure.ResourceSpecGetter) (result interface{}, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "networkinterfaces.AzureClient.Get")
        defer done()

        return ac.interfaces.Get(ctx, spec.ResourceGroupName(), spec.ResourceName(), "")
}</span>

// CreateOrUpdateAsync creates or updates a network interface asynchronously.
// It sends a PUT request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *AzureClient) CreateOrUpdateAsync(ctx context.Context, spec azure.ResourceSpecGetter, parameters interface{}) (result interface{}, future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "networkinterfaces.AzureClient.CreateOrUpdateAsync")
        defer done()

        networkInterface, ok := parameters.(network.Interface)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.Errorf("%T is not a network.Interface", parameters)
        }</span>

        <span class="cov0" title="0">createFuture, err := ac.interfaces.CreateOrUpdate(ctx, spec.ResourceGroupName(), spec.ResourceName(), networkInterface)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = createFuture.WaitForCompletionRef(ctx, ac.interfaces.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return nil, &amp;createFuture, err
        }</span>

        <span class="cov0" title="0">result, err = createFuture.Result(ac.interfaces)
        // if the operation completed, return a nil future
        return result, nil, err</span>
}

// DeleteAsync deletes a network interface asynchronously. DeleteAsync sends a DELETE
// request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *AzureClient) DeleteAsync(ctx context.Context, spec azure.ResourceSpecGetter) (future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "networkinterfaces.AzureClient.DeleteAsync")
        defer done()

        deleteFuture, err := ac.interfaces.Delete(ctx, spec.ResourceGroupName(), spec.ResourceName())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = deleteFuture.WaitForCompletionRef(ctx, ac.interfaces.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return &amp;deleteFuture, err
        }</span>
        <span class="cov0" title="0">_, err = deleteFuture.Result(ac.interfaces)
        // if the operation completed, return a nil future.
        return nil, err</span>
}

// IsDone returns true if the long-running operation has completed.
func (ac *AzureClient) IsDone(ctx context.Context, future azureautorest.FutureAPI) (isDone bool, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "networkinterfaces.AzureClient.IsDone")
        defer done()

        isDone, err = future.DoneWithContext(ctx, ac.interfaces)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "failed checking if the operation was complete")
        }</span>

        <span class="cov0" title="0">return isDone, nil</span>
}

// Result fetches the result of a long-running operation future.
func (ac *AzureClient) Result(ctx context.Context, future azureautorest.FutureAPI, futureType string) (result interface{}, err error) <span class="cov0" title="0">{
        _, _, done := tele.StartSpanWithLogger(ctx, "networkinterfaces.AzureClient.Result")
        defer done()

        if future == nil </span><span class="cov0" title="0">{
                return nil, errors.Errorf("cannot get result from nil future")
        }</span>

        <span class="cov0" title="0">switch futureType </span>{
        case infrav1.PutFuture:<span class="cov0" title="0">
                // Marshal and Unmarshal the future to put it into the correct future type so we can access the Result function.
                // Unfortunately the FutureAPI can't be casted directly to InterfacesCreateOrUpdateFuture because it is a azureautorest.Future, which doesn't implement the Result function. See PR #1686 for discussion on alternatives.
                // It was converted back to a generic azureautorest.Future from the CAPZ infrav1.Future type stored in Status: https://github.com/kubernetes-sigs/cluster-api-provider-azure/blob/main/azure/converters/futures.go#L49.
                var createFuture *network.InterfacesCreateOrUpdateFuture
                jsonData, err := future.MarshalJSON()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to marshal future")
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal(jsonData, &amp;createFuture); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to unmarshal future data")
                }</span>
                <span class="cov0" title="0">return createFuture.Result(ac.interfaces)</span>

        case infrav1.DeleteFuture:<span class="cov0" title="0">
                // Delete does not return a result network interface
                return nil, nil</span>

        default:<span class="cov0" title="0">
                return nil, errors.Errorf("unknown future type %q", futureType)</span>
        }
}
</pre>
		
		<pre class="file" id="file105" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package networkinterfaces

import (
        "context"

        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/async"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/resourceskus"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

const serviceName = "interfaces"

// NICScope defines the scope interface for a network interfaces service.
type NICScope interface {
        azure.ClusterDescriber
        azure.AsyncStatusUpdater
        NICSpecs() []azure.ResourceSpecGetter
}

// Service provides operations on Azure resources.
type Service struct {
        Scope NICScope
        async.Reconciler
        resourceSKUCache *resourceskus.Cache
}

// New creates a new service.
func New(scope NICScope, skuCache *resourceskus.Cache) *Service <span class="cov0" title="0">{
        Client := NewClient(scope)
        return &amp;Service{
                Scope:            scope,
                Reconciler:       async.New(scope, Client, Client),
                resourceSKUCache: skuCache,
        }
}</span>

// Name returns the service name.
func (s *Service) Name() string <span class="cov0" title="0">{
        return serviceName
}</span>

// Reconcile gets/creates/updates a network interface.
func (s *Service) Reconcile(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "networkinterfaces.Service.Reconcile")
        defer done()

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        specs := s.Scope.NICSpecs()
        if len(specs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // We go through the list of NICSpecs to reconcile each one, independently of the result of the previous one.
        // If multiple errors occur, we return the most pressing one.
        //  Order of precedence (highest -&gt; lowest) is: error that is not an operationNotDoneError (i.e. error creating) -&gt; operationNotDoneError (i.e. creating in progress) -&gt; no error (i.e. created)
        <span class="cov8" title="1">var result error
        for _, nicSpec := range specs </span><span class="cov8" title="1">{
                if _, err := s.CreateResource(ctx, nicSpec, serviceName); err != nil </span><span class="cov8" title="1">{
                        if !azure.IsOperationNotDoneError(err) || result == nil </span><span class="cov8" title="1">{
                                result = err
                        }</span>
                }
        }

        <span class="cov8" title="1">s.Scope.UpdatePutStatus(infrav1.NetworkInterfaceReadyCondition, serviceName, result)
        return result</span>
}

// Delete deletes the network interface with the provided name.
func (s *Service) Delete(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "networkinterfaces.Service.Delete")
        defer done()

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        specs := s.Scope.NICSpecs()
        if len(specs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // We go through the list of NICSpecs to delete each one, independently of the result of the previous one.
        // If multiple errors occur, we return the most pressing one.
        //  Order of precedence (highest -&gt; lowest) is: error that is not an operationNotDoneError (i.e. error deleting) -&gt; operationNotDoneError (i.e. deleting in progress) -&gt; no error (i.e. deleted)
        <span class="cov8" title="1">var result error
        for _, nicSpec := range specs </span><span class="cov8" title="1">{
                if err := s.DeleteResource(ctx, nicSpec, serviceName); err != nil </span><span class="cov8" title="1">{
                        if !azure.IsOperationNotDoneError(err) || result == nil </span><span class="cov8" title="1">{
                                result = err
                        }</span>
                }
        }

        <span class="cov8" title="1">s.Scope.UpdateDeleteStatus(infrav1.NetworkInterfaceReadyCondition, serviceName, result)
        return result</span>
}

// IsManaged returns always returns true as CAPZ does not support BYO network interfaces.
func (s *Service) IsManaged(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>
</pre>
		
		<pre class="file" id="file106" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package networkinterfaces

import (
        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-08-01/network"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/converters"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/resourceskus"
)

// NICSpec defines the specification for a Network Interface.
type NICSpec struct {
        Name                      string
        ResourceGroup             string
        Location                  string
        SubscriptionID            string
        MachineName               string
        SubnetName                string
        VNetName                  string
        VNetResourceGroup         string
        StaticIPAddress           string
        PublicLBName              string
        PublicLBAddressPoolName   string
        PublicLBNATRuleName       string
        InternalLBName            string
        InternalLBAddressPoolName string
        PublicIPName              string
        AcceleratedNetworking     *bool
        IPv6Enabled               bool
        EnableIPForwarding        bool
        SKU                       *resourceskus.SKU
        DNSServers                []string
        AdditionalTags            infrav1.Tags
        ClusterName               string
}

// ResourceName returns the name of the network interface.
func (s *NICSpec) ResourceName() string <span class="cov0" title="0">{
        return s.Name
}</span>

// ResourceGroupName returns the name of the resource group.
func (s *NICSpec) ResourceGroupName() string <span class="cov0" title="0">{
        return s.ResourceGroup
}</span>

// OwnerResourceName is a no-op for network interfaces.
func (s *NICSpec) OwnerResourceName() string <span class="cov0" title="0">{
        return ""
}</span>

// Parameters returns the parameters for the network interface.
func (s *NICSpec) Parameters(existing interface{}) (parameters interface{}, err error) <span class="cov8" title="1">{
        if existing != nil </span><span class="cov0" title="0">{
                if _, ok := existing.(network.Interface); !ok </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("%T is not a network.Interface", existing)
                }</span>
                // network interface already exists
                <span class="cov0" title="0">return nil, nil</span>
        }

        <span class="cov8" title="1">nicConfig := &amp;network.InterfaceIPConfigurationPropertiesFormat{}

        subnet := &amp;network.Subnet{
                ID: to.StringPtr(azure.SubnetID(s.SubscriptionID, s.VNetResourceGroup, s.VNetName, s.SubnetName)),
        }
        nicConfig.Subnet = subnet

        nicConfig.PrivateIPAllocationMethod = network.IPAllocationMethodDynamic
        if s.StaticIPAddress != "" </span><span class="cov8" title="1">{
                nicConfig.PrivateIPAllocationMethod = network.IPAllocationMethodStatic
                nicConfig.PrivateIPAddress = to.StringPtr(s.StaticIPAddress)
        }</span>

        <span class="cov8" title="1">backendAddressPools := []network.BackendAddressPool{}
        if s.PublicLBName != "" </span><span class="cov8" title="1">{
                if s.PublicLBAddressPoolName != "" </span><span class="cov8" title="1">{
                        backendAddressPools = append(backendAddressPools,
                                network.BackendAddressPool{
                                        ID: to.StringPtr(azure.AddressPoolID(s.SubscriptionID, s.ResourceGroup, s.PublicLBName, s.PublicLBAddressPoolName)),
                                })
                }</span>
                <span class="cov8" title="1">if s.PublicLBNATRuleName != "" </span><span class="cov8" title="1">{
                        nicConfig.LoadBalancerInboundNatRules = &amp;[]network.InboundNatRule{
                                {
                                        ID: to.StringPtr(azure.NATRuleID(s.SubscriptionID, s.ResourceGroup, s.PublicLBName, s.PublicLBNATRuleName)),
                                },
                        }
                }</span>
        }
        <span class="cov8" title="1">if s.InternalLBName != "" &amp;&amp; s.InternalLBAddressPoolName != "" </span><span class="cov8" title="1">{
                backendAddressPools = append(backendAddressPools,
                        network.BackendAddressPool{
                                ID: to.StringPtr(azure.AddressPoolID(s.SubscriptionID, s.ResourceGroup, s.InternalLBName, s.InternalLBAddressPoolName)),
                        })
        }</span>
        <span class="cov8" title="1">nicConfig.LoadBalancerBackendAddressPools = &amp;backendAddressPools

        if s.PublicIPName != "" </span><span class="cov0" title="0">{
                nicConfig.PublicIPAddress = &amp;network.PublicIPAddress{
                        ID: to.StringPtr(azure.PublicIPID(s.SubscriptionID, s.ResourceGroup, s.PublicIPName)),
                }
        }</span>

        <span class="cov8" title="1">if s.AcceleratedNetworking == nil </span><span class="cov8" title="1">{
                // set accelerated networking to the capability of the VMSize
                if s.SKU == nil </span><span class="cov8" title="1">{
                        return nil, errors.New("unable to get required network interface SKU from machine cache")
                }</span>

                <span class="cov8" title="1">accelNet := s.SKU.HasCapability(resourceskus.AcceleratedNetworking)
                s.AcceleratedNetworking = &amp;accelNet</span>
        }

        <span class="cov8" title="1">dnsSettings := network.InterfaceDNSSettings{}
        if len(s.DNSServers) &gt; 0 </span><span class="cov8" title="1">{
                dnsSettings.DNSServers = &amp;s.DNSServers
        }</span>

        <span class="cov8" title="1">ipConfigurations := []network.InterfaceIPConfiguration{
                {
                        Name:                                     to.StringPtr("pipConfig"),
                        InterfaceIPConfigurationPropertiesFormat: nicConfig,
                },
        }

        if s.IPv6Enabled </span><span class="cov8" title="1">{
                ipv6Config := network.InterfaceIPConfiguration{
                        Name: to.StringPtr("ipConfigv6"),
                        InterfaceIPConfigurationPropertiesFormat: &amp;network.InterfaceIPConfigurationPropertiesFormat{
                                PrivateIPAddressVersion: "IPv6",
                                Primary:                 to.BoolPtr(false),
                                Subnet:                  &amp;network.Subnet{ID: subnet.ID},
                        },
                }

                ipConfigurations = append(ipConfigurations, ipv6Config)
        }</span>

        <span class="cov8" title="1">return network.Interface{
                Location: to.StringPtr(s.Location),
                InterfacePropertiesFormat: &amp;network.InterfacePropertiesFormat{
                        EnableAcceleratedNetworking: s.AcceleratedNetworking,
                        IPConfigurations:            &amp;ipConfigurations,
                        DNSSettings:                 &amp;dnsSettings,
                        EnableIPForwarding:          to.BoolPtr(s.EnableIPForwarding),
                },
                Tags: converters.TagsToMap(infrav1.Build(infrav1.BuildParams{
                        ClusterName: s.ClusterName,
                        Lifecycle:   infrav1.ResourceLifecycleOwned,
                        Name:        to.StringPtr(s.Name),
                        Additional:  s.AdditionalTags,
                })),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file107" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package privatedns

import (
        "context"
        "encoding/json"

        "github.com/Azure/azure-sdk-for-go/services/privatedns/mgmt/2018-09-01/privatedns"
        azureautorest "github.com/Azure/go-autorest/autorest/azure"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// azureVirtualNetworkLinksClient contains the Azure go-sdk Client for virtual network links.
type azureVirtualNetworkLinksClient struct {
        vnetlinks privatedns.VirtualNetworkLinksClient
}

// newVirtualNetworkLinksClient creates a new virtual network link client.
func newVirtualNetworkLinksClient(auth azure.Authorizer) *azureVirtualNetworkLinksClient <span class="cov0" title="0">{
        linksClient := privatedns.NewVirtualNetworkLinksClientWithBaseURI(auth.BaseURI(), auth.SubscriptionID())
        azure.SetAutoRestClientDefaults(&amp;linksClient.Client, auth.Authorizer())
        return &amp;azureVirtualNetworkLinksClient{
                vnetlinks: linksClient,
        }
}</span>

// CreateOrUpdateAsync creates or updates a virtual network link asynchronously.
// It sends a PUT request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (avc *azureVirtualNetworkLinksClient) CreateOrUpdateAsync(ctx context.Context, spec azure.ResourceSpecGetter, parameters interface{}) (result interface{}, future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "privatedns.azureVirtualNetworkLinksClient.CreateOrUpdateAsync")
        defer done()

        link, ok := parameters.(privatedns.VirtualNetworkLink)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.Errorf("%T is not a privatedns.VirtualNetworkLink", parameters)
        }</span>

        <span class="cov0" title="0">createFuture, err := avc.vnetlinks.CreateOrUpdate(ctx, spec.ResourceGroupName(), spec.OwnerResourceName(), spec.ResourceName(), link, "", "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = createFuture.WaitForCompletionRef(ctx, avc.vnetlinks.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return nil, &amp;createFuture, err
        }</span>
        <span class="cov0" title="0">result, err = createFuture.Result(avc.vnetlinks)
        // if the operation completed, return a nil future
        return result, nil, err</span>
}

// Get gets the specified virtual network link.
func (avc *azureVirtualNetworkLinksClient) Get(ctx context.Context, spec azure.ResourceSpecGetter) (result interface{}, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "privatedns.azureVirtualNetworkLinksClient.Get")
        defer done()
        link, err := avc.vnetlinks.Get(ctx, spec.ResourceGroupName(), spec.OwnerResourceName(), spec.ResourceName())
        if err != nil </span><span class="cov0" title="0">{
                return privatedns.VirtualNetworkLink{}, err
        }</span>
        <span class="cov0" title="0">return link, nil</span>
}

// DeleteAsync deletes a virtual network link asynchronously. DeleteAsync sends a DELETE
// request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (avc *azureVirtualNetworkLinksClient) DeleteAsync(ctx context.Context, spec azure.ResourceSpecGetter) (future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "privatedns.azureVirtualNetworkLinksClient.DeleteAsync")
        defer done()

        deleteFuture, err := avc.vnetlinks.Delete(ctx, spec.ResourceGroupName(), spec.OwnerResourceName(), spec.ResourceName(), "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = deleteFuture.WaitForCompletionRef(ctx, avc.vnetlinks.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return &amp;deleteFuture, err
        }</span>
        <span class="cov0" title="0">_, err = deleteFuture.Result(avc.vnetlinks)
        // if the operation completed, return a nil future.
        return nil, err</span>
}

// IsDone returns true if the long-running operation has completed.
func (avc *azureVirtualNetworkLinksClient) IsDone(ctx context.Context, future azureautorest.FutureAPI) (isDone bool, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "privatedns.azureVirtualNetworkLinksClient.IsDone")
        defer done()

        isDone, err = future.DoneWithContext(ctx, avc.vnetlinks)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "failed checking if the operation was complete")
        }</span>

        <span class="cov0" title="0">return isDone, nil</span>
}

// Result fetches the result of a long-running operation future.
func (avc *azureVirtualNetworkLinksClient) Result(ctx context.Context, future azureautorest.FutureAPI, futureType string) (result interface{}, err error) <span class="cov0" title="0">{
        _, _, done := tele.StartSpanWithLogger(ctx, "privatedns.azureVirtualNetworkLinksClient.Result")
        defer done()

        if future == nil </span><span class="cov0" title="0">{
                return nil, errors.Errorf("cannot get result from nil future")
        }</span>

        <span class="cov0" title="0">switch futureType </span>{
        case infrav1.PutFuture:<span class="cov0" title="0">
                // Marshal and Unmarshal the future to put it into the correct future type so we can access the Result function.
                // Unfortunately the FutureAPI can't be casted directly to VirtualNetworkLinksCreateOrUpdateFuture because it is a azureautorest.Future, which doesn't implement the Result function. See PR #1686 for discussion on alternatives.
                // It was converted back to a generic azureautorest.Future from the CAPZ infrav1.Future type stored in Status: https://github.com/kubernetes-sigs/cluster-api-provider-azure/blob/main/azure/converters/futures.go#L49.
                var createFuture *privatedns.VirtualNetworkLinksCreateOrUpdateFuture
                jsonData, err := future.MarshalJSON()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to marshal future")
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal(jsonData, &amp;createFuture); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to unmarshal future data")
                }</span>
                <span class="cov0" title="0">return createFuture.Result(avc.vnetlinks)</span>

        case infrav1.DeleteFuture:<span class="cov0" title="0">
                // Delete does not return a result private dns virtual network link.
                return nil, nil</span>

        default:<span class="cov0" title="0">
                return nil, errors.Errorf("unknown future type %q", futureType)</span>
        }
}
</pre>
		
		<pre class="file" id="file108" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package privatedns

import (
        "context"

        "github.com/pkg/errors"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

func (s *Service) reconcileLinks(ctx context.Context, links []azure.ResourceSpecGetter) (managed bool, err error) <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "privatedns.Service.reconcileLinks")
        defer done()

        var resErr error

        // We go through the list of links to reconcile each one, independently of the result of the previous one.
        // If multiple errors occur, we return the most pressing one.
        // Order of precedence (highest -&gt; lowest) is: error that is not an operationNotDoneError (i.e. error creating) -&gt; operationNotDoneError (i.e. creating in progress) -&gt; no error (i.e. created)
        for _, linkSpec := range links </span><span class="cov8" title="1">{
                isLinkManaged, err := s.isVnetLinkManaged(ctx, linkSpec)
                if err != nil </span><span class="cov8" title="1">{
                        if azure.ResourceNotFound(err) </span><span class="cov8" title="1">{
                                isLinkManaged = true
                        }</span> else<span class="cov0" title="0"> {
                                return managed, err
                        }</span>
                }

                <span class="cov8" title="1">if !isLinkManaged </span><span class="cov8" title="1">{
                        log.V(2).Info("Skipping vnet link reconciliation for unmanaged vnet link", "vnet link",
                                linkSpec.ResourceName(), "private dns zone", linkSpec.OwnerResourceName())
                        continue</span>
                }

                // we consider VnetLinks as managed if at least of the links is managed.
                <span class="cov8" title="1">managed = true
                if _, err := s.vnetLinkReconciler.CreateResource(ctx, linkSpec, serviceName); err != nil </span><span class="cov8" title="1">{
                        if !azure.IsOperationNotDoneError(err) || resErr == nil </span><span class="cov8" title="1">{
                                resErr = err
                        }</span>
                }
        }

        <span class="cov8" title="1">return managed, resErr</span>
}

func (s *Service) deleteLinks(ctx context.Context, links []azure.ResourceSpecGetter) (managed bool, err error) <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "privatedns.Service.deleteLinks")
        defer done()

        var resErr error

        // We go through the list of links to delete each one, independently of the result of the previous one.
        // If multiple errors occur, we return the most pressing one.
        // Order of precedence (highest -&gt; lowest) is: error that is not an operationNotDoneError (i.e. error creating) -&gt; operationNotDoneError (i.e. creating in progress) -&gt; no error (i.e. created)
        for _, linkSpec := range links </span><span class="cov8" title="1">{
                // If the virtual network link is not managed by capz, skip its reconciliation
                isVnetLinkManaged, err := s.isVnetLinkManaged(ctx, linkSpec)
                if err != nil </span><span class="cov0" title="0">{
                        if azure.ResourceNotFound(err) </span><span class="cov0" title="0">{
                                // already deleted or doesn't exist, cleanup status and return.
                                s.Scope.DeleteLongRunningOperationState(linkSpec.ResourceName(), serviceName)
                                continue</span>
                        }
                        <span class="cov0" title="0">return managed, errors.Wrapf(err, "could not get vnet link state of %s in resource group %s",
                                linkSpec.OwnerResourceName(), linkSpec.ResourceGroupName())</span>
                }

                <span class="cov8" title="1">if !isVnetLinkManaged </span><span class="cov8" title="1">{
                        log.V(2).Info("Skipping vnet link deletion for unmanaged vnet link", "vnet link",
                                linkSpec.ResourceName(), "private dns zone", linkSpec.OwnerResourceName())
                        continue</span>
                }

                // if we reach here, it means that this vnet link is managed by capz.
                <span class="cov8" title="1">managed = true

                if err := s.vnetLinkReconciler.DeleteResource(ctx, linkSpec, serviceName); err != nil </span><span class="cov8" title="1">{
                        if !azure.IsOperationNotDoneError(err) || resErr == nil </span><span class="cov8" title="1">{
                                resErr = err
                        }</span>
                }
        }

        <span class="cov8" title="1">return managed, resErr</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package privatedns

import (
        "github.com/Azure/azure-sdk-for-go/services/privatedns/mgmt/2018-09-01/privatedns"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/converters"
)

// LinkSpec defines the specification for a virtual network link in a private DNS zone.
type LinkSpec struct {
        Name              string
        ZoneName          string
        SubscriptionID    string
        VNetResourceGroup string
        VNetName          string
        ResourceGroup     string
        ClusterName       string
        AdditionalTags    infrav1.Tags
}

// ResourceName returns the name of the virtual network link.
func (s LinkSpec) ResourceName() string <span class="cov8" title="1">{
        return s.Name
}</span>

// OwnerResourceName returns the zone name of the virtual network link.
func (s LinkSpec) OwnerResourceName() string <span class="cov8" title="1">{
        return s.ZoneName
}</span>

// ResourceGroupName returns the name of the resource group of the virtual network link.
func (s LinkSpec) ResourceGroupName() string <span class="cov8" title="1">{
        return s.ResourceGroup
}</span>

// Parameters returns the parameters for the virtual network link.
func (s LinkSpec) Parameters(existing interface{}) (params interface{}, err error) <span class="cov8" title="1">{
        if existing != nil </span><span class="cov8" title="1">{
                _, ok := existing.(privatedns.VirtualNetworkLink)
                if !ok </span><span class="cov8" title="1">{
                        return nil, errors.Errorf("%T is not a privatedns.VirtualNetworkLink", existing)
                }</span>
                <span class="cov8" title="1">return nil, nil</span>
        }

        <span class="cov8" title="1">return privatedns.VirtualNetworkLink{
                VirtualNetworkLinkProperties: &amp;privatedns.VirtualNetworkLinkProperties{
                        VirtualNetwork: &amp;privatedns.SubResource{
                                ID: to.StringPtr(azure.VNetID(s.SubscriptionID, s.VNetResourceGroup, s.VNetName)),
                        },
                        RegistrationEnabled: to.BoolPtr(false),
                },
                Location: to.StringPtr(azure.Global),
                Tags: converters.TagsToMap(infrav1.Build(infrav1.BuildParams{
                        ClusterName: s.ClusterName,
                        Lifecycle:   infrav1.ResourceLifecycleOwned,
                        Additional:  s.AdditionalTags,
                })),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package privatedns

import (
        "context"

        "github.com/Azure/azure-sdk-for-go/services/privatedns/mgmt/2018-09-01/privatedns"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/converters"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/async"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

const serviceName = "privatedns"

// Scope defines the scope interface for a private dns service.
type Scope interface {
        azure.ClusterDescriber
        azure.Authorizer
        azure.AsyncStatusUpdater
        PrivateDNSSpec() (zoneSpec azure.ResourceSpecGetter, linksSpec, recordsSpec []azure.ResourceSpecGetter)
}

// Service provides operations on Azure resources.
type Service struct {
        Scope              Scope
        zoneGetter         async.Getter
        vnetLinkGetter     async.Getter
        zoneReconciler     async.Reconciler
        vnetLinkReconciler async.Reconciler
        recordReconciler   async.Reconciler
}

// New creates a new private dns service.
func New(scope Scope) *Service <span class="cov0" title="0">{
        zoneClient := newPrivateZonesClient(scope)
        vnetLinkClient := newVirtualNetworkLinksClient(scope)
        recordSetsClient := newRecordSetsClient(scope)
        return &amp;Service{
                Scope:              scope,
                zoneGetter:         zoneClient,
                vnetLinkGetter:     vnetLinkClient,
                zoneReconciler:     async.New(scope, zoneClient, zoneClient),
                vnetLinkReconciler: async.New(scope, vnetLinkClient, vnetLinkClient),
                recordReconciler:   async.New(scope, recordSetsClient, recordSetsClient),
        }
}</span>

// Name returns the service name.
func (s *Service) Name() string <span class="cov0" title="0">{
        return serviceName
}</span>

// Reconcile creates or updates the private zone, links it to the vnet, and creates DNS records.
func (s *Service) Reconcile(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "privatedns.Service.Reconcile")
        defer done()

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        zoneSpec, links, records := s.Scope.PrivateDNSSpec()
        if zoneSpec == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">managed, err := s.reconcileZone(ctx, zoneSpec)
        if managed </span><span class="cov8" title="1">{
                s.Scope.UpdatePutStatus(infrav1.PrivateDNSZoneReadyCondition, serviceName, err)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">managed, err = s.reconcileLinks(ctx, links)
        if managed </span><span class="cov8" title="1">{
                s.Scope.UpdatePutStatus(infrav1.PrivateDNSLinkReadyCondition, serviceName, err)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = s.reconcileRecords(ctx, records)
        s.Scope.UpdatePutStatus(infrav1.PrivateDNSRecordReadyCondition, serviceName, err)
        return err</span>
}

// Delete deletes the private zone and vnet links.
func (s *Service) Delete(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "privatedns.Service.Delete")
        defer done()

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        zoneSpec, links, _ := s.Scope.PrivateDNSSpec()
        if zoneSpec == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">managed, err := s.deleteLinks(ctx, links)
        if managed </span><span class="cov8" title="1">{
                s.Scope.UpdateDeleteStatus(infrav1.PrivateDNSLinkReadyCondition, serviceName, err)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">managed, err = s.deleteZone(ctx, zoneSpec)
        if managed </span><span class="cov8" title="1">{
                s.Scope.UpdateDeleteStatus(infrav1.PrivateDNSZoneReadyCondition, serviceName, err)
                s.Scope.UpdateDeleteStatus(infrav1.PrivateDNSRecordReadyCondition, serviceName, err)
        }</span>

        <span class="cov8" title="1">return err</span>
}

// isVnetLinkManaged returns true if the vnet link has an owned tag with the cluster name as value,
// meaning that the vnet link lifecycle is managed.
func (s *Service) isVnetLinkManaged(ctx context.Context, spec azure.ResourceSpecGetter) (bool, error) <span class="cov8" title="1">{
        result, err := s.vnetLinkGetter.Get(ctx, spec)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">link, ok := result.(privatedns.VirtualNetworkLink)
        if !ok </span><span class="cov0" title="0">{
                return false, errors.Errorf("%T is not a privatedns.VirtualNetworkLink", link)
        }</span>

        <span class="cov8" title="1">tags := converters.MapToTags(link.Tags)
        return tags.HasOwned(s.Scope.ClusterName()), nil</span>
}

// IsManaged returns true if the private DNS has an owned tag with the cluster name as value,
// meaning that the DNS lifecycle is managed.
func (s *Service) IsManaged(ctx context.Context) (bool, error) <span class="cov8" title="1">{
        zoneSpec, _, _ := s.Scope.PrivateDNSSpec()
        if zoneSpec == nil </span><span class="cov0" title="0">{
                return false, errors.Errorf("no private dns zone spec available")
        }</span>

        <span class="cov8" title="1">result, err := s.zoneGetter.Get(ctx, zoneSpec)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">zone, ok := result.(privatedns.PrivateZone)
        if !ok </span><span class="cov0" title="0">{
                return false, errors.Errorf("%T is not a privatedns.PrivateZone", zone)
        }</span>

        <span class="cov8" title="1">tags := converters.MapToTags(zone.Tags)
        return tags.HasOwned(s.Scope.ClusterName()), nil</span>
}
</pre>
		
		<pre class="file" id="file111" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package privatedns

import (
        "context"

        "github.com/Azure/azure-sdk-for-go/services/privatedns/mgmt/2018-09-01/privatedns"
        azureautorest "github.com/Azure/go-autorest/autorest/azure"
        "github.com/pkg/errors"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// azureRecordsClient contains the Azure go-sdk Client for record sets.
type azureRecordsClient struct {
        recordsets privatedns.RecordSetsClient
}

// newRecordSetsClient creates a new record sets client from subscription ID.
func newRecordSetsClient(auth azure.Authorizer) *azureRecordsClient <span class="cov0" title="0">{
        recordsClient := privatedns.NewRecordSetsClientWithBaseURI(auth.BaseURI(), auth.SubscriptionID())
        azure.SetAutoRestClientDefaults(&amp;recordsClient.Client, auth.Authorizer())
        return &amp;azureRecordsClient{
                recordsets: recordsClient,
        }
}</span>

// CreateOrUpdateAsync creates or updates a record asynchronously.
// Creating a record set is not a long running operation, so we don't ever return a future.
func (arc *azureRecordsClient) CreateOrUpdateAsync(ctx context.Context, spec azure.ResourceSpecGetter, parameters interface{}) (result interface{}, future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "privatedns.azureRecordsClient.CreateOrUpdateAsync")
        defer done()

        set, ok := parameters.(privatedns.RecordSet)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.Errorf("%T is not a privatedns.RecordSet", parameters)
        }</span>

        // Determine record type.
        <span class="cov0" title="0">var (
                recordType privatedns.RecordType
                aRecords   = set.RecordSetProperties.ARecords
                aaaRecords = set.RecordSetProperties.AaaaRecords
        )
        if aRecords != nil &amp;&amp; len(*aRecords) &gt; 0 &amp;&amp; (*aRecords)[0].Ipv4Address != nil </span><span class="cov0" title="0">{
                recordType = privatedns.A
        }</span> else<span class="cov0" title="0"> if aaaRecords != nil &amp;&amp; len(*aaaRecords) &gt; 0 &amp;&amp; (*aaaRecords)[0].Ipv6Address != nil </span><span class="cov0" title="0">{
                recordType = privatedns.AAAA
        }</span>

        <span class="cov0" title="0">recordSet, err := arc.recordsets.CreateOrUpdate(ctx, spec.ResourceGroupName(), spec.OwnerResourceName(), recordType, spec.ResourceName(), set, "", "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">return recordSet, nil, err</span>
}

// Get gets the specified record set. Noop for records.
func (arc *azureRecordsClient) Get(ctx context.Context, spec azure.ResourceSpecGetter) (result interface{}, err error) <span class="cov0" title="0">{
        return nil, nil
}</span>

// DeleteAsync deletes a record asynchronously. Noop for records.
func (arc *azureRecordsClient) DeleteAsync(ctx context.Context, spec azure.ResourceSpecGetter) (future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        return nil, nil
}</span>

// IsDone returns true if the long-running operation has completed. Noop for records.
func (arc *azureRecordsClient) IsDone(ctx context.Context, future azureautorest.FutureAPI) (isDone bool, err error) <span class="cov0" title="0">{
        return true, nil
}</span>

// Result fetches the result of a long-running operation future. Noop for records.
func (arc *azureRecordsClient) Result(ctx context.Context, future azureautorest.FutureAPI, futureType string) (result interface{}, err error) <span class="cov0" title="0">{
        return nil, nil
}</span>
</pre>
		
		<pre class="file" id="file112" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package privatedns

import (
        "context"

        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

func (s *Service) reconcileRecords(ctx context.Context, records []azure.ResourceSpecGetter) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "privatedns.Service.reconcileRecords")
        defer done()

        var resErr error

        // We go through the list of links to reconcile each one, independently of the result of the previous one.
        // If multiple errors occur, we return the most pressing one.
        // Order of precedence (highest -&gt; lowest) is: error that is not an operationNotDoneError (i.e. error creating) -&gt; operationNotDoneError (i.e. creating in progress) -&gt; no error (i.e. created)
        for _, recordSpec := range records </span><span class="cov8" title="1">{
                if _, err := s.recordReconciler.CreateResource(ctx, recordSpec, serviceName); err != nil </span><span class="cov8" title="1">{
                        if !azure.IsOperationNotDoneError(err) || resErr == nil </span><span class="cov8" title="1">{
                                resErr = err
                        }</span>
                }
        }

        <span class="cov8" title="1">return resErr</span>
}
</pre>
		
		<pre class="file" id="file113" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package privatedns

import (
        "github.com/Azure/azure-sdk-for-go/services/privatedns/mgmt/2018-09-01/privatedns"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure/converters"
)

// RecordSpec defines the specification for a record set.
type RecordSpec struct {
        Record        infrav1.AddressRecord
        ZoneName      string
        ResourceGroup string
}

// ResourceName returns the name of a record set.
func (s RecordSpec) ResourceName() string <span class="cov8" title="1">{
        return s.Record.Hostname
}</span>

// OwnerResourceName returns the zone name of a record set.
func (s RecordSpec) OwnerResourceName() string <span class="cov8" title="1">{
        return s.ZoneName
}</span>

// ResourceGroupName returns the name of the resource group of a record set.
func (s RecordSpec) ResourceGroupName() string <span class="cov8" title="1">{
        return s.ResourceGroup
}</span>

// Parameters returns the parameters for a record set.
func (s RecordSpec) Parameters(existing interface{}) (params interface{}, err error) <span class="cov8" title="1">{
        if existing != nil </span><span class="cov0" title="0">{
                if _, ok := existing.(privatedns.RecordSet); !ok </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("%T is not a privatedns.RecordSet", existing)
                }</span>
        }
        <span class="cov8" title="1">set := privatedns.RecordSet{
                RecordSetProperties: &amp;privatedns.RecordSetProperties{
                        TTL: to.Int64Ptr(300),
                },
        }
        recordType := converters.GetRecordType(s.Record.IP)
        switch recordType </span>{
        case privatedns.A:<span class="cov8" title="1">
                set.RecordSetProperties.ARecords = &amp;[]privatedns.ARecord{{
                        Ipv4Address: &amp;s.Record.IP,
                }}</span>
        case privatedns.AAAA:<span class="cov8" title="1">
                set.RecordSetProperties.AaaaRecords = &amp;[]privatedns.AaaaRecord{{
                        Ipv6Address: &amp;s.Record.IP,
                }}</span>
        default:<span class="cov0" title="0">
                return nil, errors.Errorf("unknown record type %s", recordType)</span>
        }

        <span class="cov8" title="1">return set, nil</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package privatedns

import (
        "context"
        "encoding/json"

        "github.com/Azure/azure-sdk-for-go/services/privatedns/mgmt/2018-09-01/privatedns"
        azureautorest "github.com/Azure/go-autorest/autorest/azure"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// azureZonesClient contains the Azure go-sdk Client for private dns zone.
type azureZonesClient struct {
        privatezones privatedns.PrivateZonesClient
}

// newPrivateZonesClient creates a new private zones client from subscription ID.
func newPrivateZonesClient(auth azure.Authorizer) *azureZonesClient <span class="cov0" title="0">{
        c := privatedns.NewPrivateZonesClientWithBaseURI(auth.BaseURI(), auth.SubscriptionID())
        azure.SetAutoRestClientDefaults(&amp;c.Client, auth.Authorizer())
        return &amp;azureZonesClient{
                privatezones: c,
        }
}</span>

// CreateOrUpdateAsync creates or updates a private dns zone asynchronously.
// It sends a PUT request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (azc *azureZonesClient) CreateOrUpdateAsync(ctx context.Context, spec azure.ResourceSpecGetter, parameters interface{}) (result interface{}, future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "privatedns.azureZonesClient.CreateOrUpdateAsync")
        defer done()

        zone, ok := parameters.(privatedns.PrivateZone)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.Errorf("%T is not a privatedns.PrivateZone", parameters)
        }</span>

        <span class="cov0" title="0">createFuture, err := azc.privatezones.CreateOrUpdate(ctx, spec.ResourceGroupName(), spec.ResourceName(), zone, "", "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = createFuture.WaitForCompletionRef(ctx, azc.privatezones.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return nil, &amp;createFuture, err
        }</span>
        <span class="cov0" title="0">result, err = createFuture.Result(azc.privatezones)
        // if the operation completed, return a nil future
        return result, nil, err</span>
}

// Get gets the specified private dns zone.
func (azc *azureZonesClient) Get(ctx context.Context, spec azure.ResourceSpecGetter) (result interface{}, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "privatedns.azureZonesClient.Get")
        defer done()
        zone, err := azc.privatezones.Get(ctx, spec.ResourceGroupName(), spec.ResourceName())
        if err != nil </span><span class="cov0" title="0">{
                return privatedns.PrivateZone{}, err
        }</span>
        <span class="cov0" title="0">return zone, nil</span>
}

// DeleteAsync deletes a private dns zone asynchronously. DeleteAsync sends a DELETE
// request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (azc *azureZonesClient) DeleteAsync(ctx context.Context, spec azure.ResourceSpecGetter) (future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "privatedns.azureZonesClient.DeleteAsync")
        defer done()

        deleteFuture, err := azc.privatezones.Delete(ctx, spec.ResourceGroupName(), spec.ResourceName(), "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = deleteFuture.WaitForCompletionRef(ctx, azc.privatezones.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return &amp;deleteFuture, err
        }</span>
        <span class="cov0" title="0">_, err = deleteFuture.Result(azc.privatezones)
        // if the operation completed, return a nil future.
        return nil, err</span>
}

// IsDone returns true if the long-running operation has completed.
func (azc *azureZonesClient) IsDone(ctx context.Context, future azureautorest.FutureAPI) (isDone bool, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "privatedns.azureZonesClient.IsDone")
        defer done()

        isDone, err = future.DoneWithContext(ctx, azc.privatezones)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "failed checking if the operation was complete")
        }</span>

        <span class="cov0" title="0">return isDone, nil</span>
}

// Result fetches the result of a long-running operation future.
func (azc *azureZonesClient) Result(ctx context.Context, future azureautorest.FutureAPI, futureType string) (result interface{}, err error) <span class="cov0" title="0">{
        _, _, done := tele.StartSpanWithLogger(ctx, "privatedns.azureZonesClient.Result")
        defer done()

        if future == nil </span><span class="cov0" title="0">{
                return nil, errors.Errorf("cannot get result from nil future")
        }</span>

        <span class="cov0" title="0">switch futureType </span>{
        case infrav1.PutFuture:<span class="cov0" title="0">
                // Marshal and Unmarshal the future to put it into the correct future type so we can access the Result function.
                // Unfortunately the FutureAPI can't be casted directly to PrivateZonesCreateOrUpdateFuture because it is a azureautorest.Future, which doesn't implement the Result function. See PR #1686 for discussion on alternatives.
                // It was converted back to a generic azureautorest.Future from the CAPZ infrav1.Future type stored in Status: https://github.com/kubernetes-sigs/cluster-api-provider-azure/blob/main/azure/converters/futures.go#L49.
                var createFuture *privatedns.PrivateZonesCreateOrUpdateFuture
                jsonData, err := future.MarshalJSON()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to marshal future")
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal(jsonData, &amp;createFuture); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to unmarshal future data")
                }</span>
                <span class="cov0" title="0">return createFuture.Result(azc.privatezones)</span>

        case infrav1.DeleteFuture:<span class="cov0" title="0">
                // Delete does not return a result private dns zone.
                return nil, nil</span>

        default:<span class="cov0" title="0">
                return nil, errors.Errorf("unknown future type %q", futureType)</span>
        }
}
</pre>
		
		<pre class="file" id="file115" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package privatedns

import (
        "context"

        "github.com/pkg/errors"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

func (s *Service) reconcileZone(ctx context.Context, zoneSpec azure.ResourceSpecGetter) (managed bool, err error) <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "privatedns.Service.reconcileZone")
        defer done()

        managed, err = s.IsManaged(ctx)
        if err != nil </span><span class="cov8" title="1">{
                if azure.ResourceNotFound(err) </span><span class="cov8" title="1">{
                        managed = true
                }</span> else<span class="cov0" title="0"> {
                        return managed, err
                }</span>
        }

        <span class="cov8" title="1">if !managed </span><span class="cov8" title="1">{
                log.V(1).Info("Skipping reconciliation of unmanaged private DNS zone", "private DNS", zoneSpec.ResourceName())
                // TODO: Remove this log in future release. This is only required because older clusters created before https://github.com/kubernetes-sigs/cluster-api-provider-azure/pull/1791 will not have capz ownership tags.
                log.V(1).Info("Tag the DNS manually from azure to manage it with capz."+
                        "Please see https://capz.sigs.k8s.io/topics/custom-dns.html#manage-dns-via-capz-tool", "private DNS", zoneSpec.ResourceName())
                return managed, nil
        }</span>

        <span class="cov8" title="1">_, err = s.zoneReconciler.CreateResource(ctx, zoneSpec, serviceName)
        return managed, err</span>
}

func (s *Service) deleteZone(ctx context.Context, zoneSpec azure.ResourceSpecGetter) (managed bool, err error) <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "privatedns.Service.deleteZone")
        defer done()

        // Skip deleting the private DNS zone when it's not managed by capz.
        isManaged, err := s.IsManaged(ctx)
        if err != nil </span><span class="cov0" title="0">{
                if azure.ResourceNotFound(err) </span><span class="cov0" title="0">{
                        // already deleted or doesn't exist, cleanup status and return.
                        s.Scope.DeleteLongRunningOperationState(zoneSpec.ResourceName(), serviceName)
                        return managed, nil
                }</span>
                <span class="cov0" title="0">return managed, errors.Wrapf(err, "could not get private DNS zone state of %s in resource group %s", zoneSpec.ResourceName(), zoneSpec.ResourceGroupName())</span>
        }

        <span class="cov8" title="1">if !isManaged </span><span class="cov8" title="1">{
                log.V(1).Info("Skipping deletion of unmanaged private DNS zone", "private DNS", zoneSpec.ResourceName())
                return managed, nil
        }</span>

        // if we reach here, it means that this vnet link is managed by capz.
        <span class="cov8" title="1">managed = true

        // Delete the private DNS zone, which also deletes all records
        err = s.zoneReconciler.DeleteResource(ctx, zoneSpec, serviceName)
        return managed, err</span>
}
</pre>
		
		<pre class="file" id="file116" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package privatedns

import (
        "github.com/Azure/azure-sdk-for-go/services/privatedns/mgmt/2018-09-01/privatedns"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/converters"
)

// ZoneSpec defines the specification for private dns zone.
type ZoneSpec struct {
        Name           string
        ResourceGroup  string
        ClusterName    string
        AdditionalTags infrav1.Tags
}

// ResourceName returns the name of the private dns zone.
func (s ZoneSpec) ResourceName() string <span class="cov8" title="1">{
        return s.Name
}</span>

// OwnerResourceName is a no-op for private dns zone.
func (s ZoneSpec) OwnerResourceName() string <span class="cov8" title="1">{
        return ""
}</span>

// ResourceGroupName returns the name of the resource group of the private dns zone.
func (s ZoneSpec) ResourceGroupName() string <span class="cov8" title="1">{
        return s.ResourceGroup
}</span>

// Parameters returns the parameters for the private dns zone.
func (s ZoneSpec) Parameters(existing interface{}) (params interface{}, err error) <span class="cov8" title="1">{
        if existing != nil </span><span class="cov8" title="1">{
                _, ok := existing.(privatedns.PrivateZone)
                if !ok </span><span class="cov8" title="1">{
                        return nil, errors.Errorf("%T is not a privatedns.PrivateZone", existing)
                }</span>
                <span class="cov8" title="1">return nil, nil</span>
        }

        <span class="cov8" title="1">return privatedns.PrivateZone{
                Location: to.StringPtr(azure.Global),
                Tags: converters.TagsToMap(infrav1.Build(infrav1.BuildParams{
                        ClusterName: s.ClusterName,
                        Lifecycle:   infrav1.ResourceLifecycleOwned,
                        Additional:  s.AdditionalTags,
                })),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file117" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package publicips

import (
        "context"
        "encoding/json"

        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-08-01/network"
        "github.com/Azure/go-autorest/autorest"
        azureautorest "github.com/Azure/go-autorest/autorest/azure"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// AzureClient contains the Azure go-sdk Client.
type AzureClient struct {
        publicips network.PublicIPAddressesClient
}

// NewClient creates a new public IP client from subscription ID.
func NewClient(auth azure.Authorizer) *AzureClient <span class="cov0" title="0">{
        c := newPublicIPAddressesClient(auth.SubscriptionID(), auth.BaseURI(), auth.Authorizer())
        return &amp;AzureClient{c}
}</span>

// newPublicIPAddressesClient creates a new public IP client from subscription ID.
func newPublicIPAddressesClient(subscriptionID string, baseURI string, authorizer autorest.Authorizer) network.PublicIPAddressesClient <span class="cov0" title="0">{
        publicIPsClient := network.NewPublicIPAddressesClientWithBaseURI(baseURI, subscriptionID)
        azure.SetAutoRestClientDefaults(&amp;publicIPsClient.Client, authorizer)
        return publicIPsClient
}</span>

// Get gets the specified public IP address in a specified resource group.
func (ac *AzureClient) Get(ctx context.Context, spec azure.ResourceSpecGetter) (result interface{}, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "publicips.AzureClient.Get")
        defer done()

        return ac.publicips.Get(ctx, spec.ResourceGroupName(), spec.ResourceName(), "")
}</span>

// CreateOrUpdateAsync creates or updates a static or dynamic public IP address.
// It sends a PUT request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *AzureClient) CreateOrUpdateAsync(ctx context.Context, spec azure.ResourceSpecGetter, parameters interface{}) (result interface{}, future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "publicips.AzureClient.CreateOrUpdate")
        defer done()

        publicip, ok := parameters.(network.PublicIPAddress)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.Errorf("%T is not a network.PublicIPAddress", parameters)
        }</span>

        <span class="cov0" title="0">createFuture, err := ac.publicips.CreateOrUpdate(ctx, spec.ResourceGroupName(), spec.ResourceName(), publicip)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = createFuture.WaitForCompletionRef(ctx, ac.publicips.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return nil, &amp;createFuture, err
        }</span>

        <span class="cov0" title="0">result, err = createFuture.Result(ac.publicips)
        // if the operation completed, return a nil future
        return result, nil, err</span>
}

// DeleteAsync deletes the specified public IP address asynchronously. DeleteAsync sends a DELETE
// request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *AzureClient) DeleteAsync(ctx context.Context, spec azure.ResourceSpecGetter) (future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "publicips.AzureClient.DeleteAsync")
        defer done()

        deleteFuture, err := ac.publicips.Delete(ctx, spec.ResourceGroupName(), spec.ResourceName())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = deleteFuture.WaitForCompletionRef(ctx, ac.publicips.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return &amp;deleteFuture, err
        }</span>
        <span class="cov0" title="0">_, err = deleteFuture.Result(ac.publicips)
        // if the operation completed, return a nil future.
        return nil, err</span>
}

// IsDone returns true if the long-running operation has completed.
func (ac *AzureClient) IsDone(ctx context.Context, future azureautorest.FutureAPI) (isDone bool, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "publicips.AzureClient.IsDone")
        defer done()

        isDone, err = future.DoneWithContext(ctx, ac.publicips)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "failed checking if the operation was complete")
        }</span>

        <span class="cov0" title="0">return isDone, nil</span>
}

// Result fetches the result of a long-running operation future.
func (ac *AzureClient) Result(ctx context.Context, future azureautorest.FutureAPI, futureType string) (result interface{}, err error) <span class="cov0" title="0">{
        _, _, done := tele.StartSpanWithLogger(ctx, "publicips.AzureClient.Result")
        defer done()

        if future == nil </span><span class="cov0" title="0">{
                return nil, errors.Errorf("cannot get result from nil future")
        }</span>

        <span class="cov0" title="0">switch futureType </span>{
        case infrav1.PutFuture:<span class="cov0" title="0">
                // Marshal and Unmarshal the future to put it into the correct future type so we can access the Result function.
                // Unfortunately the FutureAPI can't be casted directly to PublicIPAddressesCreateOrUpdateFuture because it is a azureautorest.Future, which doesn't implement the Result function. See PR #1686 for discussion on alternatives.
                // It was converted back to a generic azureautorest.Future from the CAPZ infrav1.Future type stored in Status: https://github.com/kubernetes-sigs/cluster-api-provider-azure/blob/main/azure/converters/futures.go#L49.
                var createFuture *network.PublicIPAddressesCreateOrUpdateFuture
                jsonData, err := future.MarshalJSON()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to marshal future")
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal(jsonData, &amp;createFuture); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to unmarshal future data")
                }</span>
                <span class="cov0" title="0">return createFuture.Result(ac.publicips)</span>

        case infrav1.DeleteFuture:<span class="cov0" title="0">
                // Delete does not return a result inbound NAT rule
                return nil, nil</span>

        default:<span class="cov0" title="0">
                return nil, errors.Errorf("unknown future type %q", futureType)</span>
        }
}
</pre>
		
		<pre class="file" id="file118" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package publicips

import (
        "context"

        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-08-01/network"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/converters"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/async"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

const serviceName = "publicips"

// PublicIPScope defines the scope interface for a public IP service.
type PublicIPScope interface {
        azure.Authorizer
        azure.AsyncStatusUpdater
        azure.ClusterDescriber
        PublicIPSpecs() []azure.ResourceSpecGetter
}

// Service provides operations on Azure resources.
type Service struct {
        Scope PublicIPScope
        async.Reconciler
        async.Getter
}

// New creates a new service.
func New(scope PublicIPScope) *Service <span class="cov0" title="0">{
        client := NewClient(scope)
        return &amp;Service{
                Scope:      scope,
                Getter:     client,
                Reconciler: async.New(scope, client, client),
        }
}</span>

// Name returns the service name.
func (s *Service) Name() string <span class="cov0" title="0">{
        return serviceName
}</span>

// Reconcile gets/creates/updates a public ip.
func (s *Service) Reconcile(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "publicips.Service.Reconcile")
        defer done()

        specs := s.Scope.PublicIPSpecs()
        if len(specs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // We go through the list of PublicIPSpecs to reconcile each one, independently of the result of the previous one.
        // If multiple errors occur, we return the most pressing one.
        //  Order of precedence (highest -&gt; lowest) is: error that is not an operationNotDoneError (i.e. error creating) -&gt; operationNotDoneError (i.e. creating in progress) -&gt; no error (i.e. created)
        <span class="cov8" title="1">var result error
        for _, publicIPSpec := range specs </span><span class="cov8" title="1">{
                if _, err := s.CreateResource(ctx, publicIPSpec, serviceName); err != nil </span><span class="cov8" title="1">{
                        if !azure.IsOperationNotDoneError(err) || result == nil </span><span class="cov8" title="1">{
                                result = err
                        }</span>
                }
        }

        <span class="cov8" title="1">s.Scope.UpdatePutStatus(infrav1.PublicIPsReadyCondition, serviceName, result)
        return result</span>
}

// Delete deletes the public IP with the provided scope.
func (s *Service) Delete(ctx context.Context) error <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "publicips.Service.Delete")
        defer done()

        specs := s.Scope.PublicIPSpecs()
        if len(specs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">hasManagedPublicIPs := false

        // We go through the list of VnetPeeringSpecs to delete each one, independently of the result of the previous one.
        // If multiple errors occur, we return the most pressing one.
        //  Order of precedence (highest -&gt; lowest) is: error that is not an operationNotDoneError (i.e. error deleting) -&gt; operationNotDoneError (i.e. deleting in progress) -&gt; no error (i.e. deleted)
        var result error
        for _, publicIPSpec := range specs </span><span class="cov8" title="1">{
                managed, err := s.isIPManaged(ctx, publicIPSpec)
                if err != nil &amp;&amp; !azure.ResourceNotFound(err) </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "could not get public IP management state")
                }</span>

                <span class="cov8" title="1">if !managed </span><span class="cov8" title="1">{
                        log.V(2).Info("Skipping IP deletion for unmanaged public IP", "public ip", publicIPSpec.ResourceName())
                        continue</span>
                }

                <span class="cov8" title="1">log.V(2).Info("deleting public IP", "public ip", publicIPSpec.ResourceName())
                hasManagedPublicIPs = true
                if err := s.DeleteResource(ctx, publicIPSpec, serviceName); err != nil </span><span class="cov8" title="1">{
                        if !azure.IsOperationNotDoneError(err) || result == nil </span><span class="cov8" title="1">{
                                result = err
                        }</span>
                }

                <span class="cov8" title="1">log.V(2).Info("deleted public IP", "public ip", publicIPSpec.ResourceName())</span>
        }

        <span class="cov8" title="1">if hasManagedPublicIPs </span><span class="cov8" title="1">{
                s.Scope.UpdateDeleteStatus(infrav1.PublicIPsReadyCondition, serviceName, result)
        }</span>

        <span class="cov8" title="1">return result</span>
}

// isIPManaged returns true if the IP has an owned tag with the cluster name as value,
// meaning that the IP's lifecycle is managed.
func (s *Service) isIPManaged(ctx context.Context, spec azure.ResourceSpecGetter) (bool, error) <span class="cov8" title="1">{
        result, err := s.Get(ctx, spec)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">publicIP, ok := result.(network.PublicIPAddress)
        if !ok </span><span class="cov0" title="0">{
                return false, errors.Errorf("%T is not a network.PublicIPAddress", publicIP)
        }</span>

        <span class="cov8" title="1">tags := converters.MapToTags(publicIP.Tags)
        return tags.HasOwned(s.Scope.ClusterName()), nil</span>
}

// IsManaged returns always returns true as public IPs are managed on a one-by-one basis.
func (s *Service) IsManaged(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>
</pre>
		
		<pre class="file" id="file119" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package publicips

import (
        "strings"

        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-08-01/network"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure/converters"
)

// PublicIPSpec defines the specification for a Public IP.
type PublicIPSpec struct {
        Name           string
        ResourceGroup  string
        ClusterName    string
        DNSName        string
        IsIPv6         bool
        Location       string
        FailureDomains []string
        AdditionalTags infrav1.Tags
        IPTags         []infrav1.IPTag
}

// ResourceName returns the name of the public IP.
func (s *PublicIPSpec) ResourceName() string <span class="cov8" title="1">{
        return s.Name
}</span>

// ResourceGroupName returns the name of the resource group.
func (s *PublicIPSpec) ResourceGroupName() string <span class="cov0" title="0">{
        return s.ResourceGroup
}</span>

// OwnerResourceName is a no-op for public IPs.
func (s *PublicIPSpec) OwnerResourceName() string <span class="cov0" title="0">{
        return ""
}</span>

// Parameters returns the parameters for the public IP.
func (s *PublicIPSpec) Parameters(existing interface{}) (params interface{}, err error) <span class="cov8" title="1">{
        if existing != nil </span><span class="cov8" title="1">{
                if _, ok := existing.(network.PublicIPAddress); !ok </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("%T is not a network.PublicIPAddress", existing)
                }</span>
                // public IP already exists
                <span class="cov8" title="1">return nil, nil</span>
        }

        <span class="cov8" title="1">addressVersion := network.IPVersionIPv4
        if s.IsIPv6 </span><span class="cov8" title="1">{
                addressVersion = network.IPVersionIPv6
        }</span>

        // only set DNS properties if there is a DNS name specified
        <span class="cov8" title="1">var dnsSettings *network.PublicIPAddressDNSSettings
        if s.DNSName != "" </span><span class="cov8" title="1">{
                dnsSettings = &amp;network.PublicIPAddressDNSSettings{
                        DomainNameLabel: to.StringPtr(strings.Split(s.DNSName, ".")[0]),
                        Fqdn:            to.StringPtr(s.DNSName),
                }
        }</span>

        <span class="cov8" title="1">return network.PublicIPAddress{
                Tags: converters.TagsToMap(infrav1.Build(infrav1.BuildParams{
                        ClusterName: s.ClusterName,
                        Lifecycle:   infrav1.ResourceLifecycleOwned,
                        Name:        to.StringPtr(s.Name),
                        Additional:  s.AdditionalTags,
                })),
                Sku:      &amp;network.PublicIPAddressSku{Name: network.PublicIPAddressSkuNameStandard},
                Name:     to.StringPtr(s.Name),
                Location: to.StringPtr(s.Location),
                PublicIPAddressPropertiesFormat: &amp;network.PublicIPAddressPropertiesFormat{
                        PublicIPAddressVersion:   addressVersion,
                        PublicIPAllocationMethod: network.IPAllocationMethodStatic,
                        DNSSettings:              dnsSettings,
                        IPTags:                   converters.IPTagsToSDK(s.IPTags),
                },
                Zones: to.StringSlicePtr(s.FailureDomains),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file120" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resourceskus

import (
        "context"
        "fmt"
        "sort"
        "strings"
        "sync"
        "time"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-11-01/compute"
        "github.com/pkg/errors"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/cache/ttllru"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// Cache loads resource SKUs at the beginning of reconcile to expose
// features available on compute resources. It exposes convenience
// functionality for trawling Azure SKU capabilities. It may be adapted
// to periodically refresh data in the background.
type Cache struct {
        client Client

        // location is the Azure location for which this cache stores sku info.
        // we do lookup once per reconcile for the given cluster/location.
        location string

        // data is the cached sku information from Azure.
        // synchronization required if data is cached across reconcile calls, (i.e., refreshed in background as Runnable via mgr.Add(...))
        data []compute.ResourceSku
}

// Cacher describes the ability to get and to add items to cache.
type Cacher interface {
        Get(key interface{}) (value interface{}, ok bool)
        Add(key interface{}, value interface{}) bool
}

// NewCacheFunc allows for mocking out the underlying client.
type NewCacheFunc func(azure.Authorizer, string) *Cache

var (
        _           Client = &amp;AzureClient{}
        doOnce      sync.Once
        clientCache Cacher
)

// newCache instantiates a cache and initializes its contents.
func newCache(auth azure.Authorizer, location string) *Cache <span class="cov0" title="0">{
        return &amp;Cache{
                client:   NewClient(auth),
                location: location,
        }
}</span>

// GetCache either creates a new SKUs cache or returns an existing one based on the location + Authorizer HashKey().
func GetCache(auth azure.Authorizer, location string) (*Cache, error) <span class="cov0" title="0">{
        var err error
        doOnce.Do(func() </span><span class="cov0" title="0">{
                clientCache, err = ttllru.New(128, 24*time.Hour)
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed creating LRU cache for resourceSKUs cache")
        }</span>

        <span class="cov0" title="0">key := location + "_" + auth.HashKey()
        c, ok := clientCache.Get(key)
        if ok </span><span class="cov0" title="0">{
                return c.(*Cache), nil
        }</span>

        <span class="cov0" title="0">c = newCache(auth, location)
        _ = clientCache.Add(key, c)
        return c.(*Cache), nil</span>
}

// NewStaticCache initializes a cache with data and no ability to refresh. Used for testing.
func NewStaticCache(data []compute.ResourceSku, location string) *Cache <span class="cov0" title="0">{
        return &amp;Cache{
                data:     data,
                location: location,
        }
}</span>

func (c *Cache) refresh(ctx context.Context, location string) error <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "resourceskus.Cache.refresh")
        defer done()

        data, err := c.client.List(ctx, fmt.Sprintf("location eq '%s'", location))
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to refresh resource sku cache")
        }</span>

        <span class="cov0" title="0">c.data = data

        return nil</span>
}

// Get returns a resource SKU with the provided name and category. It
// returns an error if we could not find a match. We should consider
// enhancing this function to handle restrictions (e.g. SKU not
// supported in region), which is why it returns an error and not a
// boolean.
func (c *Cache) Get(ctx context.Context, name string, kind ResourceType) (SKU, error) <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "resourceskus.Cache.Get")
        defer done()

        if c.data == nil </span><span class="cov0" title="0">{
                if err := c.refresh(ctx, c.location); err != nil </span><span class="cov0" title="0">{
                        return SKU{}, err
                }</span>
        }

        <span class="cov8" title="1">for _, sku := range c.data </span><span class="cov8" title="1">{
                if sku.Name != nil &amp;&amp; *sku.Name == name </span><span class="cov8" title="1">{
                        return SKU(sku), nil
                }</span>
        }
        <span class="cov8" title="1">return SKU{}, azure.WithTerminalError(fmt.Errorf("resource sku with name '%s' and category '%s' not found in location '%s'", name, string(kind), c.location))</span>
}

// Map invokes a function over all cached values.
func (c *Cache) Map(ctx context.Context, mapFn func(sku SKU)) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "resourceskus.Cache.Map")
        defer done()

        if c.data == nil </span><span class="cov0" title="0">{
                if err := c.refresh(ctx, c.location); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">for i := range c.data </span><span class="cov8" title="1">{
                val := SKU(c.data[i])
                mapFn(val)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetZones looks at all virtual machine sizes and returns the unique
// set of zones into which some machine size may deploy. It removes
// restricted virtual machine sizes and duplicates.
func (c *Cache) GetZones(ctx context.Context, location string) ([]string, error) <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "resourceskus.Cache.GetZones")
        defer done()

        var allZones = make(map[string]bool)
        mapFn := func(sku SKU) </span><span class="cov8" title="1">{
                // Look for VMs only
                if sku.ResourceType != nil &amp;&amp; strings.EqualFold(*sku.ResourceType, string(VirtualMachines)) </span><span class="cov8" title="1">{
                        // find matching location
                        for _, locationInfo := range *sku.LocationInfo </span><span class="cov8" title="1">{
                                if !strings.EqualFold(*locationInfo.Location, location) </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                // Use map for easy deletion and iteration
                                <span class="cov8" title="1">availableZones := make(map[string]bool)

                                // add all zones
                                for _, zone := range *locationInfo.Zones </span><span class="cov8" title="1">{
                                        availableZones[zone] = true
                                }</span>

                                <span class="cov8" title="1">if sku.Restrictions != nil </span><span class="cov8" title="1">{
                                        for _, restriction := range *sku.Restrictions </span><span class="cov8" title="1">{
                                                // Can't deploy anything in this subscription in this location. Bail out.
                                                if restriction.Type == compute.ResourceSkuRestrictionsTypeLocation </span><span class="cov8" title="1">{
                                                        availableZones = nil
                                                        break</span>
                                                }

                                                // remove restricted zones
                                                <span class="cov8" title="1">for _, restrictedZone := range *restriction.RestrictionInfo.Zones </span><span class="cov8" title="1">{
                                                        delete(availableZones, restrictedZone)
                                                }</span>
                                        }
                                }

                                // add to global list, if any exist. it's okay for the final list to be empty.
                                // that means the region may not support AZ yet.
                                <span class="cov8" title="1">for zone := range availableZones </span><span class="cov8" title="1">{
                                        allZones[zone] = true
                                }</span>

                                <span class="cov8" title="1">break</span>
                        }
                }
        }

        <span class="cov8" title="1">if err := c.Map(ctx, mapFn); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var zones = make([]string, 0, len(allZones))
        for zone := range allZones </span><span class="cov8" title="1">{
                zones = append(zones, zone)
        }</span>

        // lexical sort for testing
        <span class="cov8" title="1">sort.Strings(zones)

        return zones, nil</span>
}

// GetZonesWithVMSize returns available zones for a virtual machine size in the given location.
func (c *Cache) GetZonesWithVMSize(ctx context.Context, size, location string) ([]string, error) <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "resourceskus.Cache.GetZonesWithVMSize")
        defer done()

        var allZones = make(map[string]bool)
        mapFn := func(sku SKU) </span><span class="cov8" title="1">{
                if sku.Name != nil &amp;&amp; strings.EqualFold(*sku.Name, size) &amp;&amp; sku.ResourceType != nil &amp;&amp; strings.EqualFold(*sku.ResourceType, string(VirtualMachines)) </span><span class="cov8" title="1">{
                        // find matching location
                        for _, locationInfo := range *sku.LocationInfo </span><span class="cov8" title="1">{
                                if !strings.EqualFold(*locationInfo.Location, location) </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                // Use map for easy deletion and iteration
                                <span class="cov8" title="1">availableZones := make(map[string]bool)

                                // add all zones
                                for _, zone := range *locationInfo.Zones </span><span class="cov8" title="1">{
                                        availableZones[zone] = true
                                }</span>

                                <span class="cov8" title="1">if sku.Restrictions != nil </span><span class="cov8" title="1">{
                                        for _, restriction := range *sku.Restrictions </span><span class="cov8" title="1">{
                                                // Can't deploy anything in this subscription in this location. Bail out.
                                                if restriction.Type == compute.ResourceSkuRestrictionsTypeLocation </span><span class="cov8" title="1">{
                                                        availableZones = nil
                                                        break</span>
                                                }

                                                // remove restricted zones
                                                <span class="cov8" title="1">for _, restrictedZone := range *restriction.RestrictionInfo.Zones </span><span class="cov8" title="1">{
                                                        delete(availableZones, restrictedZone)
                                                }</span>
                                        }
                                }

                                // add to global list, if any exist. it's okay for the final list to be empty.
                                // that means the region may not support AZ yet.
                                <span class="cov8" title="1">for zone := range availableZones </span><span class="cov8" title="1">{
                                        allZones[zone] = true
                                }</span>

                                <span class="cov8" title="1">break</span>
                        }
                }
        }

        <span class="cov8" title="1">if err := c.Map(ctx, mapFn); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var zones = make([]string, 0, len(allZones))
        for zone := range allZones </span><span class="cov8" title="1">{
                zones = append(zones, zone)
        }</span>

        // lexical sort for testing
        <span class="cov8" title="1">sort.Strings(zones)

        return zones, nil</span>
}
</pre>
		
		<pre class="file" id="file121" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resourceskus

import (
        "context"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-11-01/compute"
        "github.com/Azure/go-autorest/autorest"
        "github.com/pkg/errors"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// Client wraps go-sdk.
type Client interface {
        List(context.Context, string) ([]compute.ResourceSku, error)
}

// AzureClient contains the Azure go-sdk Client.
type AzureClient struct {
        skus compute.ResourceSkusClient
}

var _ Client = &amp;AzureClient{}

// NewClient creates a new Resource SKUs client from subscription ID.
func NewClient(auth azure.Authorizer) *AzureClient <span class="cov0" title="0">{
        return &amp;AzureClient{
                skus: newResourceSkusClient(auth.SubscriptionID(), auth.BaseURI(), auth.Authorizer()),
        }
}</span>

// newResourceSkusClient creates a new Resource SKUs client from subscription ID.
func newResourceSkusClient(subscriptionID string, baseURI string, authorizer autorest.Authorizer) compute.ResourceSkusClient <span class="cov0" title="0">{
        c := compute.NewResourceSkusClientWithBaseURI(baseURI, subscriptionID)
        azure.SetAutoRestClientDefaults(&amp;c.Client, authorizer)
        return c
}</span>

// List returns all Resource SKUs available to the subscription.
func (ac *AzureClient) List(ctx context.Context, filter string) ([]compute.ResourceSku, error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "resourceskus.AzureClient.List")
        defer done()

        iter, err := ac.skus.ListComplete(ctx, filter, "true")
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "could not list resource skus")
        }</span>

        <span class="cov0" title="0">var skus []compute.ResourceSku
        for iter.NotDone() </span><span class="cov0" title="0">{
                skus = append(skus, iter.Value())
                if err := iter.NextWithContext(ctx); err != nil </span><span class="cov0" title="0">{
                        return skus, errors.Wrap(err, "could not iterate resource skus")
                }</span>
        }

        <span class="cov0" title="0">return skus, nil</span>
}
</pre>
		
		<pre class="file" id="file122" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resourceskus

import (
        "strconv"
        "strings"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-11-01/compute"
        "github.com/pkg/errors"
)

// SKU is a thin layer over the Azure resource SKU API to better introspect capabilities.
type SKU compute.ResourceSku

// ResourceType models available resource types as a set of known string constants.
type ResourceType string

const (
        // VirtualMachines is a convenience constant to filter resource SKUs to only include VMs.
        VirtualMachines ResourceType = "virtualMachines"
        // Disks is a convenience constant to filter resource SKUs to only include disks.
        Disks ResourceType = "disks"
        // AvailabilitySets is a convenience constant to filter resource SKUs to only include availability sets.
        AvailabilitySets ResourceType = "availabilitySets"
)

// Supported models an enum of possible boolean values for resource support in the Azure API.
type Supported string

const (
        // CapabilitySupported is the value returned by this API from Azure when the capability is supported.
        CapabilitySupported Supported = "True"
        // CapabilityUnsupported is the value returned by this API from Azure when the capability is unsupported.
        CapabilityUnsupported Supported = "False"
)

const (
        // EphemeralOSDisk identifies the capability for ephemeral os support.
        EphemeralOSDisk = "EphemeralOSDiskSupported"
        // AcceleratedNetworking identifies the capability for accelerated networking support.
        AcceleratedNetworking = "AcceleratedNetworkingEnabled"
        // VCPUs identifies the capability for the number of vCPUS.
        VCPUs = "vCPUs"
        // MemoryGB identifies the capability for memory Size.
        MemoryGB = "MemoryGB"
        // MinimumVCPUS is the minimum vCPUS allowed.
        MinimumVCPUS = 2
        // MinimumMemory is the minimum memory allowed.
        MinimumMemory = 2
        // EncryptionAtHost identifies the capability for encryption at host.
        EncryptionAtHost = "EncryptionAtHostSupported"
        // MaximumPlatformFaultDomainCount identifies the maximum fault domain count for an availability set in a region.
        MaximumPlatformFaultDomainCount = "MaximumPlatformFaultDomainCount"
        // UltraSSDAvailable identifies the capability for the support of UltraSSD data disks.
        UltraSSDAvailable = "UltraSSDAvailable"
)

// HasCapability return true for a capability which can be either
// supported or not. Examples include "EphemeralOSDiskSupported",
// "UltraSSDAvavailable" "EncryptionAtHostSupported",
// "AcceleratedNetworkingEnabled", and "RdmaEnabled".
func (s SKU) HasCapability(name string) bool <span class="cov0" title="0">{
        if s.Capabilities != nil </span><span class="cov0" title="0">{
                for _, capability := range *s.Capabilities </span><span class="cov0" title="0">{
                        if capability.Name != nil &amp;&amp; *capability.Name == name </span><span class="cov0" title="0">{
                                if capability.Value != nil &amp;&amp; strings.EqualFold(*capability.Value, string(CapabilitySupported)) </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return false</span>
}

// HasCapabilityWithCapacity returns true when the provided resource
// exposes a numeric capability and the maximum value exposed by that
// capability exceeds the value requested by the user. Examples include
// "MaxResourceVolumeMB", "OSVhdSizeMB", "vCPUs",
// "MemoryGB","MaxDataDiskCount", "CombinedTempDiskAndCachedIOPS",
// "CombinedTempDiskAndCachedReadBytesPerSecond",
// "CombinedTempDiskAndCachedWriteBytesPerSecond", "UncachedDiskIOPS",
// and "UncachedDiskBytesPerSecond".
func (s SKU) HasCapabilityWithCapacity(name string, value int64) (bool, error) <span class="cov0" title="0">{
        if s.Capabilities == nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">for _, capability := range *s.Capabilities </span><span class="cov0" title="0">{
                if capability.Name == nil || *capability.Name != name || capability.Value == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">intVal, err := strconv.ParseInt(*capability.Value, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return false, errors.Wrapf(err, "failed to parse string '%s' as int64", *capability.Value)
                }</span>

                <span class="cov0" title="0">if intVal &gt;= value </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }

        <span class="cov0" title="0">return false, nil</span>
}

// GetCapability gets the value assigned to the given capability.
// Eg. MaximumPlatformFaultDomainCount -&gt; "3" will return "3" for the capability "MaximumPlatformFaultDomainCount".
func (s SKU) GetCapability(name string) (string, bool) <span class="cov0" title="0">{
        if s.Capabilities != nil </span><span class="cov0" title="0">{
                for _, capability := range *s.Capabilities </span><span class="cov0" title="0">{
                        if capability.Name != nil &amp;&amp; *capability.Name == name </span><span class="cov0" title="0">{
                                return *capability.Value, true
                        }</span>
                }
        }
        <span class="cov0" title="0">return "", false</span>
}

// HasLocationCapability returns true if the provided resource supports the location capability.
func (s SKU) HasLocationCapability(capabilityName, location, zone string) bool <span class="cov0" title="0">{
        if s.LocationInfo == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for _, info := range *s.LocationInfo </span><span class="cov0" title="0">{
                if info.Location == nil || *info.Location != location || info.ZoneDetails == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, zoneDetail := range *info.ZoneDetails </span><span class="cov0" title="0">{
                        if zoneDetail.Capabilities == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">for _, capability := range *zoneDetail.Capabilities </span><span class="cov0" title="0">{
                                if capability.Name != nil &amp;&amp; *capability.Name == capabilityName </span><span class="cov0" title="0">{
                                        if zoneDetail.Name == nil </span><span class="cov0" title="0">{
                                                return false
                                        }</span>

                                        <span class="cov0" title="0">for _, name := range *zoneDetail.Name </span><span class="cov0" title="0">{
                                                if name == zone </span><span class="cov0" title="0">{
                                                        return true
                                                }</span>
                                        }
                                        <span class="cov0" title="0">return false</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file123" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package roleassignments

import (
        "context"

        "github.com/Azure/azure-sdk-for-go/profiles/2019-03-01/authorization/mgmt/authorization"
        "github.com/Azure/go-autorest/autorest"
        azureautorest "github.com/Azure/go-autorest/autorest/azure"
        "github.com/pkg/errors"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// azureClient contains the Azure go-sdk Client.
type azureClient struct {
        roleassignments authorization.RoleAssignmentsClient
}

// newClient creates a new role assignment client from subscription ID.
func newClient(auth azure.Authorizer) *azureClient <span class="cov0" title="0">{
        c := newRoleAssignmentClient(auth.SubscriptionID(), auth.BaseURI(), auth.Authorizer())
        return &amp;azureClient{c}
}</span>

// newRoleAssignmentClient creates a role assignments client from subscription ID.
func newRoleAssignmentClient(subscriptionID string, baseURI string, authorizer autorest.Authorizer) authorization.RoleAssignmentsClient <span class="cov0" title="0">{
        roleClient := authorization.NewRoleAssignmentsClientWithBaseURI(baseURI, subscriptionID)
        azure.SetAutoRestClientDefaults(&amp;roleClient.Client, authorizer)
        return roleClient
}</span>

// Get gets the specified role assignment by the role assignment name.
func (ac *azureClient) Get(ctx context.Context, spec azure.ResourceSpecGetter) (interface{}, error) <span class="cov0" title="0">{
        ctx, span := tele.Tracer().Start(ctx, "roleassignments.AzureClient.Get")
        defer span.End()
        return ac.roleassignments.Get(ctx, spec.OwnerResourceName(), spec.ResourceName())
}</span>

// CreateOrUpdateAsync creates a roleassignment.
// Creating a roleassignment is not a long running operation, so we don't ever return a future.
func (ac *azureClient) CreateOrUpdateAsync(ctx context.Context, spec azure.ResourceSpecGetter, parameters interface{}) (interface{}, azureautorest.FutureAPI, error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "groups.AzureClient.CreateOrUpdate")
        defer done()
        createParams, ok := parameters.(authorization.RoleAssignmentCreateParameters)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.Errorf("%T is not a authorization.RoleAssignmentCreateParameters", parameters)
        }</span>
        <span class="cov0" title="0">result, err := ac.roleassignments.Create(ctx, spec.OwnerResourceName(), spec.ResourceName(), createParams)
        return result, nil, err</span>
}

// IsDone returns true if the long-running operation has completed.
func (ac *azureClient) IsDone(ctx context.Context, future azureautorest.FutureAPI) (bool, error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "roleassignments.AzureClient.IsDone")
        defer done()

        isDone, err := future.DoneWithContext(ctx, ac.roleassignments)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "failed checking if the operation was complete")
        }</span>
        <span class="cov0" title="0">return isDone, nil</span>
}

// Result fetches the result of a long-running operation future.
func (ac *azureClient) Result(ctx context.Context, futureData azureautorest.FutureAPI, futureType string) (interface{}, error) <span class="cov0" title="0">{
        // Result is a no-op for role assignment as only Delete operations return a future.
        return nil, nil
}</span>

// DeleteAsync is no-op for role assignments. It gets deleted as part of the VM deletion.
func (ac *azureClient) DeleteAsync(ctx context.Context, spec azure.ResourceSpecGetter) (azureautorest.FutureAPI, error) <span class="cov0" title="0">{
        return nil, nil
}</span>
</pre>
		
		<pre class="file" id="file124" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package roleassignments

import (
        "context"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-11-01/compute"
        "github.com/pkg/errors"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/async"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/scalesets"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/virtualmachines"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

const serviceName = "roleassignments"

// RoleAssignmentScope defines the scope interface for a role assignment service.
type RoleAssignmentScope interface {
        azure.AsyncStatusUpdater
        azure.Authorizer
        RoleAssignmentSpecs(principalID *string) []azure.ResourceSpecGetter
        HasSystemAssignedIdentity() bool
        RoleAssignmentResourceType() string
        Name() string
        ResourceGroup() string
}

// Service provides operations on Azure resources.
type Service struct {
        Scope                 RoleAssignmentScope
        virtualMachinesGetter async.Getter
        async.Reconciler
        virtualMachineScaleSetClient scalesets.Client
}

// New creates a new service.
func New(scope RoleAssignmentScope) *Service <span class="cov0" title="0">{
        client := newClient(scope)
        return &amp;Service{
                Scope:                        scope,
                virtualMachinesGetter:        virtualmachines.NewClient(scope),
                virtualMachineScaleSetClient: scalesets.NewClient(scope),
                Reconciler:                   async.New(scope, client, client),
        }
}</span>

// Name returns the service name.
func (s *Service) Name() string <span class="cov0" title="0">{
        return serviceName
}</span>

// Reconcile creates a role assignment.
func (s *Service) Reconcile(ctx context.Context) error <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "roleassignments.Service.Reconcile")
        defer done()
        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()
        log.V(2).Info("reconciling role assignment")

        // Return early if the identity is not system assigned as there will be no
        // role assignment spec in this case.
        if !s.Scope.HasSystemAssignedIdentity() </span><span class="cov0" title="0">{
                log.V(2).Info("no role assignment spec to reconcile")
                return nil
        }</span>

        <span class="cov8" title="1">var principalID *string
        resourceType := s.Scope.RoleAssignmentResourceType()
        switch resourceType </span>{
        case azure.VirtualMachine:<span class="cov8" title="1">
                ID, err := s.getVMPrincipalID(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        return errors.Wrap(err, "failed to assign role to system assigned identity")
                }</span>
                <span class="cov8" title="1">principalID = ID</span>
        case azure.VirtualMachineScaleSet:<span class="cov8" title="1">
                ID, err := s.getVMSSPrincipalID(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        return errors.Wrap(err, "failed to assign role to system assigned identity")
                }</span>
                <span class="cov8" title="1">principalID = ID</span>
        default:<span class="cov0" title="0">
                return errors.Errorf("unexpected resource type %q. Expected one of [%s, %s]", resourceType,
                        azure.VirtualMachine, azure.VirtualMachineScaleSet)</span>
        }

        <span class="cov8" title="1">for _, roleAssignmentSpec := range s.Scope.RoleAssignmentSpecs(principalID) </span><span class="cov8" title="1">{
                log.V(2).Info("Creating role assignment")
                _, err := s.CreateResource(ctx, roleAssignmentSpec, serviceName)
                if err != nil </span><span class="cov8" title="1">{
                        return errors.Wrapf(err, "cannot assign role to %s system assigned identity", resourceType)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// getVMPrincipalID returns the VM principal ID.
func (s *Service) getVMPrincipalID(ctx context.Context) (*string, error) <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "roleassignments.Service.getVMPrincipalID")
        defer done()
        log.V(2).Info("fetching principal ID for VM")
        spec := &amp;virtualmachines.VMSpec{
                Name:          s.Scope.Name(),
                ResourceGroup: s.Scope.ResourceGroup(),
        }

        resultVMIface, err := s.virtualMachinesGetter.Get(ctx, spec)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, "failed to get principal ID for VM")
        }</span>
        <span class="cov8" title="1">resultVM, ok := resultVMIface.(compute.VirtualMachine)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.Errorf("%T is not a compute.VirtualMachine", resultVMIface)
        }</span>
        <span class="cov8" title="1">return resultVM.Identity.PrincipalID, nil</span>
}

// getVMSSPrincipalID returns the VMSS principal ID.
func (s *Service) getVMSSPrincipalID(ctx context.Context) (*string, error) <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "roleassignments.Service.getVMPrincipalID")
        defer done()
        log.V(2).Info("fetching principal ID for VMSS")
        resultVMSS, err := s.virtualMachineScaleSetClient.Get(ctx, s.Scope.ResourceGroup(), s.Scope.Name())
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, "failed to get principal ID for VMSS")
        }</span>
        <span class="cov8" title="1">return resultVMSS.Identity.PrincipalID, nil</span>
}

// Delete is a no-op as the role assignments get deleted as part of VM deletion.
func (s *Service) Delete(ctx context.Context) error <span class="cov0" title="0">{
        _, _, done := tele.StartSpanWithLogger(ctx, "roleassignments.Service.Delete")
        defer done()
        return nil
}</span>

// IsManaged returns always returns true as CAPZ does not support BYO role assignments.
func (s *Service) IsManaged(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>
</pre>
		
		<pre class="file" id="file125" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package roleassignments

import (
        "github.com/Azure/azure-sdk-for-go/profiles/2019-03-01/authorization/mgmt/authorization"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
)

// RoleAssignmentSpec defines the specification for a role assignment.
type RoleAssignmentSpec struct {
        Name             string
        MachineName      string
        ResourceGroup    string
        ResourceType     string
        PrincipalID      *string
        RoleDefinitionID string
        Scope            string
}

// ResourceName returns the name of the role assignment.
func (s *RoleAssignmentSpec) ResourceName() string <span class="cov0" title="0">{
        return s.Name
}</span>

// ResourceGroupName returns the name of the resource group.
func (s *RoleAssignmentSpec) ResourceGroupName() string <span class="cov0" title="0">{
        return s.ResourceGroup
}</span>

// OwnerResourceName returns the scope for role assignment.
// TODO: Consider renaming the function for better readability (@sonasingh46).
func (s *RoleAssignmentSpec) OwnerResourceName() string <span class="cov0" title="0">{
        return s.Scope
}</span>

// Parameters returns the parameters for the RoleAssignmentSpec.
func (s *RoleAssignmentSpec) Parameters(existing interface{}) (interface{}, error) <span class="cov0" title="0">{
        if existing != nil </span><span class="cov0" title="0">{
                if _, ok := existing.(authorization.RoleAssignment); !ok </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("%T is not a authorization.RoleAssignment", existing)
                }</span>
                // RoleAssignmentSpec already exists
                <span class="cov0" title="0">return nil, nil</span>
        }
        <span class="cov0" title="0">return authorization.RoleAssignmentCreateParameters{
                Properties: &amp;authorization.RoleAssignmentProperties{
                        PrincipalID:      s.PrincipalID,
                        RoleDefinitionID: to.StringPtr(s.RoleDefinitionID),
                },
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file126" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package routetables

import (
        "context"
        "encoding/json"

        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-08-01/network"
        "github.com/Azure/go-autorest/autorest"
        azureautorest "github.com/Azure/go-autorest/autorest/azure"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// azureClient contains the Azure go-sdk Client.
type azureClient struct {
        routetables network.RouteTablesClient
}

// newClient creates a new route tables client from subscription ID.
func newClient(auth azure.Authorizer) *azureClient <span class="cov0" title="0">{
        c := newRouteTablesClient(auth.SubscriptionID(), auth.BaseURI(), auth.Authorizer())
        return &amp;azureClient{c}
}</span>

// newRouteTablesClient creates a new route tables client from subscription ID.
func newRouteTablesClient(subscriptionID string, baseURI string, authorizer autorest.Authorizer) network.RouteTablesClient <span class="cov0" title="0">{
        routeTablesClient := network.NewRouteTablesClientWithBaseURI(baseURI, subscriptionID)
        azure.SetAutoRestClientDefaults(&amp;routeTablesClient.Client, authorizer)
        return routeTablesClient
}</span>

// Get gets the specified route table.
func (ac *azureClient) Get(ctx context.Context, spec azure.ResourceSpecGetter) (result interface{}, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "routetables.azureClient.Get")
        defer done()

        return ac.routetables.Get(ctx, spec.ResourceGroupName(), spec.ResourceName(), "")
}</span>

// CreateOrUpdateAsync creates or updates a route table asynchronously.
// It sends a PUT request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *azureClient) CreateOrUpdateAsync(ctx context.Context, spec azure.ResourceSpecGetter, parameters interface{}) (result interface{}, future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "routetables.azureClient.CreateOrUpdateAsync")
        defer done()

        rt, ok := parameters.(network.RouteTable)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.Errorf("%T is not a network.RouteTable", parameters)
        }</span>

        <span class="cov0" title="0">createFuture, err := ac.routetables.CreateOrUpdate(ctx, spec.ResourceGroupName(), spec.ResourceName(), rt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = createFuture.WaitForCompletionRef(ctx, ac.routetables.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return nil, &amp;createFuture, err
        }</span>
        <span class="cov0" title="0">result, err = createFuture.Result(ac.routetables)
        // if the operation completed, return a nil future
        return result, nil, err</span>
}

// DeleteAsync deletes a route table asynchronously. DeleteAsync sends a DELETE
// request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *azureClient) DeleteAsync(ctx context.Context, spec azure.ResourceSpecGetter) (future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "routetables.azureClient.DeleteAsync")
        defer done()

        deleteFuture, err := ac.routetables.Delete(ctx, spec.ResourceGroupName(), spec.ResourceName())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = deleteFuture.WaitForCompletionRef(ctx, ac.routetables.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return &amp;deleteFuture, err
        }</span>
        <span class="cov0" title="0">_, err = deleteFuture.Result(ac.routetables)
        // if the operation completed, return a nil future.
        return nil, err</span>
}

// IsDone returns true if the long-running operation has completed.
func (ac *azureClient) IsDone(ctx context.Context, future azureautorest.FutureAPI) (isDone bool, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "routetables.azureClient.IsDone")
        defer done()

        isDone, err = future.DoneWithContext(ctx, ac.routetables)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "failed checking if the operation was complete")
        }</span>

        <span class="cov0" title="0">return isDone, nil</span>
}

// Result fetches the result of a long-running operation future.
func (ac *azureClient) Result(ctx context.Context, future azureautorest.FutureAPI, futureType string) (result interface{}, err error) <span class="cov0" title="0">{
        _, _, done := tele.StartSpanWithLogger(ctx, "routetables.azureClient.Result")
        defer done()

        if future == nil </span><span class="cov0" title="0">{
                return nil, errors.Errorf("cannot get result from nil future")
        }</span>

        <span class="cov0" title="0">switch futureType </span>{
        case infrav1.PutFuture:<span class="cov0" title="0">
                // Marshal and Unmarshal the future to put it into the correct future type so we can access the Result function.
                // Unfortunately the FutureAPI can't be casted directly to RouteTablesCreateOrUpdateFuture because it is a azureautorest.Future, which doesn't implement the Result function. See PR #1686 for discussion on alternatives.
                // It was converted back to a generic azureautorest.Future from the CAPZ infrav1.Future type stored in Status: https://github.com/kubernetes-sigs/cluster-api-provider-azure/blob/main/azure/converters/futures.go#L49.
                var createFuture *network.RouteTablesCreateOrUpdateFuture
                jsonData, err := future.MarshalJSON()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to marshal future")
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal(jsonData, &amp;createFuture); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to unmarshal future data")
                }</span>
                <span class="cov0" title="0">return createFuture.Result(ac.routetables)</span>

        case infrav1.DeleteFuture:<span class="cov0" title="0">
                // Delete does not return a result route table.
                return nil, nil</span>

        default:<span class="cov0" title="0">
                return nil, errors.Errorf("unknown future type %q", futureType)</span>
        }
}
</pre>
		
		<pre class="file" id="file127" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package routetables

import (
        "context"

        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/async"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

const serviceName = "routetables"

// RouteTableScope defines the scope interface for route table service.
type RouteTableScope interface {
        azure.Authorizer
        azure.AsyncStatusUpdater
        RouteTableSpecs() []azure.ResourceSpecGetter
        IsVnetManaged() bool
}

// Service provides operations on azure resources.
type Service struct {
        Scope RouteTableScope
        async.Reconciler
}

// New creates a new service.
func New(scope RouteTableScope) *Service <span class="cov0" title="0">{
        client := newClient(scope)
        return &amp;Service{
                Scope:      scope,
                Reconciler: async.New(scope, client, client),
        }
}</span>

// Name returns the service name.
func (s *Service) Name() string <span class="cov0" title="0">{
        return serviceName
}</span>

// Reconcile gets/creates/updates route tables.
func (s *Service) Reconcile(ctx context.Context) error <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "routetables.Service.Reconcile")
        defer done()

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        var resErr error

        if managed, err := s.IsManaged(ctx); err == nil &amp;&amp; !managed </span><span class="cov8" title="1">{
                log.V(4).Info("Skipping route tables reconcile in custom vnet mode")
                return nil
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to check if route tables are managed")
        }</span>

        <span class="cov8" title="1">specs := s.Scope.RouteTableSpecs()
        if len(specs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // We go through the list of route tables to reconcile each one, independently of the result of the previous one.
        // If multiple errors occur, we return the most pressing one.
        //  Order of precedence (highest -&gt; lowest) is: error that is not an operationNotDoneError (i.e. error creating) -&gt; operationNotDoneError (i.e. creating in progress) -&gt; no error (i.e. created)
        <span class="cov8" title="1">for _, rtSpec := range specs </span><span class="cov8" title="1">{
                if _, err := s.CreateResource(ctx, rtSpec, serviceName); err != nil </span><span class="cov8" title="1">{
                        if !azure.IsOperationNotDoneError(err) || resErr == nil </span><span class="cov8" title="1">{
                                resErr = err
                        }</span>
                }
        }

        <span class="cov8" title="1">s.Scope.UpdatePutStatus(infrav1.RouteTablesReadyCondition, serviceName, resErr)
        return resErr</span>
}

// Delete deletes route tables.
func (s *Service) Delete(ctx context.Context) error <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "routetables.Service.Delete")
        defer done()

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        // Only delete the route tables if their lifecycle is managed by this controller.
        // route tables are managed if and only if the vnet is managed.
        if managed, err := s.IsManaged(ctx); err == nil &amp;&amp; !managed </span><span class="cov8" title="1">{
                log.V(4).Info("Skipping route table deletion in custom vnet mode")
                return nil
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to check if route tables are managed")
        }</span>

        <span class="cov8" title="1">specs := s.Scope.RouteTableSpecs()
        if len(specs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // We go through the list of RouteTableSpecs to delete each one, independently of the result of the previous one.
        // If multiple errors occur, we return the most pressing one
        // order of precedence is: error deleting -&gt; deleting in progress -&gt; deleted (no error)
        <span class="cov8" title="1">var result error
        for _, rtSpec := range specs </span><span class="cov8" title="1">{
                if err := s.DeleteResource(ctx, rtSpec, serviceName); err != nil </span><span class="cov8" title="1">{
                        if !azure.IsOperationNotDoneError(err) || result == nil </span><span class="cov8" title="1">{
                                result = err
                        }</span>
                }
        }
        <span class="cov8" title="1">s.Scope.UpdateDeleteStatus(infrav1.RouteTablesReadyCondition, serviceName, result)
        return result</span>
}

// IsManaged returns true if the route tables' lifecycles are managed.
func (s *Service) IsManaged(ctx context.Context) (bool, error) <span class="cov8" title="1">{
        _, _, done := tele.StartSpanWithLogger(ctx, "routetables.Service.IsManaged")
        defer done()

        return s.Scope.IsVnetManaged(), nil
}</span>
</pre>
		
		<pre class="file" id="file128" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package routetables

import (
        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-08-01/network"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure/converters"
)

// RouteTableSpec defines the specification for a route table.
type RouteTableSpec struct {
        Name           string
        ResourceGroup  string
        Location       string
        ClusterName    string
        AdditionalTags infrav1.Tags
}

// ResourceName returns the name of the route table.
func (s *RouteTableSpec) ResourceName() string <span class="cov0" title="0">{
        return s.Name
}</span>

// ResourceGroupName returns the name of the resource group.
func (s *RouteTableSpec) ResourceGroupName() string <span class="cov0" title="0">{
        return s.ResourceGroup
}</span>

// OwnerResourceName is a no-op for route tables.
func (s *RouteTableSpec) OwnerResourceName() string <span class="cov0" title="0">{
        return ""
}</span>

// Parameters returns the parameters for the route table.
func (s *RouteTableSpec) Parameters(existing interface{}) (params interface{}, err error) <span class="cov0" title="0">{
        if existing != nil </span><span class="cov0" title="0">{
                if _, ok := existing.(network.RouteTable); !ok </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("%T is not a network.RouteTable", existing)
                }</span>
                // route table already exists
                // currently don't support specifying your own routes via spec.
                <span class="cov0" title="0">return nil, nil</span>
        }
        <span class="cov0" title="0">return network.RouteTable{
                Location:                   to.StringPtr(s.Location),
                RouteTablePropertiesFormat: &amp;network.RouteTablePropertiesFormat{},
                Tags: converters.TagsToMap(infrav1.Build(infrav1.BuildParams{
                        ClusterName: s.ClusterName,
                        Lifecycle:   infrav1.ResourceLifecycleOwned,
                        Name:        to.StringPtr(s.Name),
                        Additional:  s.AdditionalTags,
                })),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file129" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package scalesets

import (
        "context"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "time"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-11-01/compute"
        "github.com/Azure/go-autorest/autorest"
        azureautorest "github.com/Azure/go-autorest/autorest/azure"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/converters"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// Client wraps go-sdk.
type Client interface {
        List(context.Context, string) ([]compute.VirtualMachineScaleSet, error)
        ListInstances(context.Context, string, string) ([]compute.VirtualMachineScaleSetVM, error)
        Get(context.Context, string, string) (compute.VirtualMachineScaleSet, error)
        CreateOrUpdateAsync(context.Context, string, string, compute.VirtualMachineScaleSet) (*infrav1.Future, error)
        UpdateAsync(context.Context, string, string, compute.VirtualMachineScaleSetUpdate) (*infrav1.Future, error)
        GetResultIfDone(ctx context.Context, future *infrav1.Future) (compute.VirtualMachineScaleSet, error)
        UpdateInstances(context.Context, string, string, []string) error
        DeleteAsync(context.Context, string, string) (*infrav1.Future, error)
}

type (
        // AzureClient contains the Azure go-sdk Client.
        AzureClient struct {
                scalesetvms compute.VirtualMachineScaleSetVMsClient
                scalesets   compute.VirtualMachineScaleSetsClient
        }

        genericScaleSetFuture interface {
                DoneWithContext(ctx context.Context, sender autorest.Sender) (done bool, err error)
                Result(client compute.VirtualMachineScaleSetsClient) (vmss compute.VirtualMachineScaleSet, err error)
        }

        genericScaleSetFutureImpl struct {
                azureautorest.FutureAPI
                result func(client compute.VirtualMachineScaleSetsClient) (vmss compute.VirtualMachineScaleSet, err error)
        }

        deleteResultAdapter struct {
                compute.VirtualMachineScaleSetsDeleteFuture
        }
)

var _ Client = &amp;AzureClient{}

// NewClient creates a new VMSS client from subscription ID.
func NewClient(auth azure.Authorizer) *AzureClient <span class="cov0" title="0">{
        return &amp;AzureClient{
                scalesetvms: newVirtualMachineScaleSetVMsClient(auth.SubscriptionID(), auth.BaseURI(), auth.Authorizer()),
                scalesets:   newVirtualMachineScaleSetsClient(auth.SubscriptionID(), auth.BaseURI(), auth.Authorizer()),
        }
}</span>

// newVirtualMachineScaleSetVMsClient creates a new vmss VM client from subscription ID.
func newVirtualMachineScaleSetVMsClient(subscriptionID string, baseURI string, authorizer autorest.Authorizer) compute.VirtualMachineScaleSetVMsClient <span class="cov0" title="0">{
        c := compute.NewVirtualMachineScaleSetVMsClientWithBaseURI(baseURI, subscriptionID)
        azure.SetAutoRestClientDefaults(&amp;c.Client, authorizer)
        return c
}</span>

// newVirtualMachineScaleSetsClient creates a new vmss client from subscription ID.
func newVirtualMachineScaleSetsClient(subscriptionID string, baseURI string, authorizer autorest.Authorizer) compute.VirtualMachineScaleSetsClient <span class="cov0" title="0">{
        c := compute.NewVirtualMachineScaleSetsClientWithBaseURI(baseURI, subscriptionID)
        azure.SetAutoRestClientDefaults(&amp;c.Client, authorizer)
        return c
}</span>

// ListInstances retrieves information about the model views of a virtual machine scale set.
func (ac *AzureClient) ListInstances(ctx context.Context, resourceGroupName, vmssName string) ([]compute.VirtualMachineScaleSetVM, error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "scalesets.AzureClient.ListInstances")
        defer done()

        itr, err := ac.scalesetvms.ListComplete(ctx, resourceGroupName, vmssName, "", "", "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var instances []compute.VirtualMachineScaleSetVM
        for ; itr.NotDone(); err = itr.NextWithContext(ctx) </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to iterate vm scale set vms [%w]", err)
                }</span>
                <span class="cov0" title="0">vm := itr.Value()
                instances = append(instances, vm)</span>
        }
        <span class="cov0" title="0">return instances, nil</span>
}

// List returns all scale sets in a resource group.
func (ac *AzureClient) List(ctx context.Context, resourceGroupName string) ([]compute.VirtualMachineScaleSet, error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "scalesets.AzureClient.List")
        defer done()

        itr, err := ac.scalesets.ListComplete(ctx, resourceGroupName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to list scalesets in the resource group")
        }</span>

        <span class="cov0" title="0">var instances []compute.VirtualMachineScaleSet
        for ; itr.NotDone(); err = itr.NextWithContext(ctx) </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to iterate vm scale sets [%w]", err)
                }</span>
                <span class="cov0" title="0">vm := itr.Value()
                instances = append(instances, vm)</span>
        }
        <span class="cov0" title="0">return instances, nil</span>
}

// Get retrieves information about the model view of a virtual machine scale set.
func (ac *AzureClient) Get(ctx context.Context, resourceGroupName, vmssName string) (compute.VirtualMachineScaleSet, error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "scalesets.AzureClient.Get")
        defer done()

        return ac.scalesets.Get(ctx, resourceGroupName, vmssName, "")
}</span>

// CreateOrUpdateAsync the operation to create or update a virtual machine scale set without waiting for the operation
// to complete.
func (ac *AzureClient) CreateOrUpdateAsync(ctx context.Context, resourceGroupName, vmssName string, vmss compute.VirtualMachineScaleSet) (*infrav1.Future, error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "scalesets.AzureClient.CreateOrUpdateAsync")
        defer done()

        future, err := ac.scalesets.CreateOrUpdate(ctx, resourceGroupName, vmssName, vmss)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = future.WaitForCompletionRef(ctx, ac.scalesets.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return converters.SDKToFuture(&amp;future, infrav1.PutFuture, serviceName, vmssName, resourceGroupName)
        }</span>

        // todo: this returns the result VMSS, we should use it
        <span class="cov0" title="0">_, err = future.Result(ac.scalesets)

        // if the operation completed, return a nil future.
        return nil, err</span>
}

// UpdateAsync update a VM scale set without waiting for the result of the operation. UpdateAsync sends a PATCH
// request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
//
// Parameters:
//   resourceGroupName - the name of the resource group.
//   vmssName - the name of the VM scale set to create or update. parameters - the scale set object.
func (ac *AzureClient) UpdateAsync(ctx context.Context, resourceGroupName, vmssName string, parameters compute.VirtualMachineScaleSetUpdate) (*infrav1.Future, error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "scalesets.AzureClient.UpdateAsync")
        defer done()

        future, err := ac.scalesets.Update(ctx, resourceGroupName, vmssName, parameters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "failed updating vmss named %q", vmssName)
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = future.WaitForCompletionRef(ctx, ac.scalesets.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return converters.SDKToFuture(&amp;future, infrav1.PatchFuture, serviceName, vmssName, resourceGroupName)
        }</span>
        // todo: this returns the result VMSS, we should use it
        <span class="cov0" title="0">_, err = future.Result(ac.scalesets)

        // if the operation completed, return a nil future.
        return nil, err</span>
}

// GetResultIfDone fetches the result of a long-running operation future if it is done.
func (ac *AzureClient) GetResultIfDone(ctx context.Context, future *infrav1.Future) (compute.VirtualMachineScaleSet, error) <span class="cov0" title="0">{
        var genericFuture genericScaleSetFuture
        futureData, err := base64.URLEncoding.DecodeString(future.Data)
        if err != nil </span><span class="cov0" title="0">{
                return compute.VirtualMachineScaleSet{}, errors.Wrap(err, "failed to base64 decode future data")
        }</span>

        <span class="cov0" title="0">switch future.Type </span>{
        case infrav1.PatchFuture:<span class="cov0" title="0">
                var future compute.VirtualMachineScaleSetsUpdateFuture
                if err := json.Unmarshal(futureData, &amp;future); err != nil </span><span class="cov0" title="0">{
                        return compute.VirtualMachineScaleSet{}, errors.Wrap(err, "failed to unmarshal future data")
                }</span>

                <span class="cov0" title="0">genericFuture = &amp;genericScaleSetFutureImpl{
                        FutureAPI: &amp;future,
                        result:    future.Result,
                }</span>
        case infrav1.PutFuture:<span class="cov0" title="0">
                var future compute.VirtualMachineScaleSetsCreateOrUpdateFuture
                if err := json.Unmarshal(futureData, &amp;future); err != nil </span><span class="cov0" title="0">{
                        return compute.VirtualMachineScaleSet{}, errors.Wrap(err, "failed to unmarshal future data")
                }</span>

                <span class="cov0" title="0">genericFuture = &amp;genericScaleSetFutureImpl{
                        FutureAPI: &amp;future,
                        result:    future.Result,
                }</span>
        case infrav1.DeleteFuture:<span class="cov0" title="0">
                var future compute.VirtualMachineScaleSetsDeleteFuture
                if err := json.Unmarshal(futureData, &amp;future); err != nil </span><span class="cov0" title="0">{
                        return compute.VirtualMachineScaleSet{}, errors.Wrap(err, "failed to unmarshal future data")
                }</span>

                <span class="cov0" title="0">genericFuture = &amp;deleteResultAdapter{
                        VirtualMachineScaleSetsDeleteFuture: future,
                }</span>
        default:<span class="cov0" title="0">
                return compute.VirtualMachineScaleSet{}, errors.Errorf("unknown future type %q", future.Type)</span>
        }

        <span class="cov0" title="0">done, err := genericFuture.DoneWithContext(ctx, ac.scalesets)
        if err != nil </span><span class="cov0" title="0">{
                return compute.VirtualMachineScaleSet{}, errors.Wrap(err, "failed checking if the operation was complete")
        }</span>

        <span class="cov0" title="0">if !done </span><span class="cov0" title="0">{
                return compute.VirtualMachineScaleSet{}, azure.WithTransientError(azure.NewOperationNotDoneError(future), 15*time.Second)
        }</span>

        <span class="cov0" title="0">vmss, err := genericFuture.Result(ac.scalesets)
        if err != nil </span><span class="cov0" title="0">{
                return vmss, errors.Wrap(err, "failed fetching the result of operation for vmss")
        }</span>

        <span class="cov0" title="0">return vmss, nil</span>
}

// UpdateInstances update instances of a VM scale set.
func (ac *AzureClient) UpdateInstances(ctx context.Context, resourceGroupName, vmssName string, instanceIDs []string) error <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "scalesets.AzureClient.UpdateInstances")
        defer done()

        params := compute.VirtualMachineScaleSetVMInstanceRequiredIDs{
                InstanceIds: &amp;instanceIDs,
        }
        future, err := ac.scalesets.UpdateInstances(ctx, resourceGroupName, vmssName, params)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = future.WaitForCompletionRef(ctx, ac.scalesets.Client)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">_, err = future.Result(ac.scalesets)
        return err</span>
}

// DeleteAsync is the operation to delete a virtual machine scale set asynchronously. DeleteAsync sends a DELETE
// request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
//
// Parameters:
//   resourceGroupName - the name of the resource group.
//   vmssName - the name of the VM scale set to create or update. parameters - the scale set object.
func (ac *AzureClient) DeleteAsync(ctx context.Context, resourceGroupName, vmssName string) (*infrav1.Future, error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "scalesets.AzureClient.DeleteAsync")
        defer done()

        future, err := ac.scalesets.Delete(ctx, resourceGroupName, vmssName, to.BoolPtr(false))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "failed deleting vmss named %q", vmssName)
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = future.WaitForCompletionRef(ctx, ac.scalesets.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return converters.SDKToFuture(&amp;future, infrav1.DeleteFuture, serviceName, vmssName, resourceGroupName)
        }</span>
        <span class="cov0" title="0">_, err = future.Result(ac.scalesets)

        // if the operation completed, return a nil future.
        return nil, err</span>
}

// Result wraps the delete result so that we can treat it generically. The only thing we care about is if the delete
// was successful. If it wasn't, an error will be returned.
func (da *deleteResultAdapter) Result(client compute.VirtualMachineScaleSetsClient) (compute.VirtualMachineScaleSet, error) <span class="cov0" title="0">{
        _, err := da.VirtualMachineScaleSetsDeleteFuture.Result(client)
        return compute.VirtualMachineScaleSet{}, err
}</span>

// Result returns the Result so that we can treat it generically.
func (g *genericScaleSetFutureImpl) Result(client compute.VirtualMachineScaleSetsClient) (compute.VirtualMachineScaleSet, error) <span class="cov0" title="0">{
        return g.result(client)
}</span>
</pre>
		
		<pre class="file" id="file130" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package scalesets

import (
        "context"
        "encoding/base64"
        "fmt"
        "time"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-11-01/compute"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/converters"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/resourceskus"
        azureutil "sigs.k8s.io/cluster-api-provider-azure/util/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/generators"
        "sigs.k8s.io/cluster-api-provider-azure/util/slice"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

const serviceName = "scalesets"

type (
        // ScaleSetScope defines the scope interface for a scale sets service.
        ScaleSetScope interface {
                azure.ClusterDescriber
                azure.AsyncStatusUpdater
                GetBootstrapData(context.Context) (string, error)
                GetVMImage(context.Context) (*infrav1.Image, error)
                SaveVMImageToStatus(*infrav1.Image)
                MaxSurge() (int, error)
                ScaleSetSpec() azure.ScaleSetSpec
                VMSSExtensionSpecs() []azure.ResourceSpecGetter
                SetAnnotation(string, string)
                SetProviderID(string)
                SetVMSSState(*azure.VMSS)
        }

        // Service provides operations on Azure resources.
        Service struct {
                Scope ScaleSetScope
                Client
                resourceSKUCache *resourceskus.Cache
        }
)

// New creates a new service.
func New(scope ScaleSetScope, skuCache *resourceskus.Cache) *Service <span class="cov0" title="0">{
        return &amp;Service{
                Client:           NewClient(scope),
                Scope:            scope,
                resourceSKUCache: skuCache,
        }
}</span>

// Name returns the service name.
func (s *Service) Name() string <span class="cov0" title="0">{
        return serviceName
}</span>

// Reconcile idempotently gets, creates, and updates a scale set.
func (s *Service) Reconcile(ctx context.Context) (retErr error) <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "scalesets.Service.Reconcile")
        defer done()

        if err := s.validateSpec(ctx); err != nil </span><span class="cov8" title="1">{
                // do as much early validation as possible to limit calls to Azure
                return err
        }</span>

        <span class="cov8" title="1">var err error

        scaleSetSpec := s.Scope.ScaleSetSpec()

        // check if there is an ongoing long running operation
        var (
                future      = s.Scope.GetLongRunningOperationState(s.Scope.ScaleSetSpec().Name, serviceName)
                fetchedVMSS *azure.VMSS
        )

        defer func() </span><span class="cov8" title="1">{
                // save the updated state of the VMSS for the MachinePoolScope to use for updating K8s state
                if fetchedVMSS == nil </span><span class="cov8" title="1">{
                        fetchedVMSS, err = s.getVirtualMachineScaleSet(ctx, scaleSetSpec.Name)
                        if err != nil &amp;&amp; !azure.ResourceNotFound(err) </span><span class="cov0" title="0">{
                                log.Error(err, "failed to get vmss in deferred update")
                        }</span>
                }

                <span class="cov8" title="1">if fetchedVMSS != nil </span><span class="cov8" title="1">{
                        // Transform the VMSS resource representation to conform to the cloud-provider-azure representation
                        providerID, err := azureutil.ConvertResourceGroupNameToLower(azure.ProviderIDPrefix + fetchedVMSS.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error(err, "failed to parse VMSS ID", "ID", fetchedVMSS.ID)
                        }</span>
                        <span class="cov8" title="1">s.Scope.SetProviderID(providerID)
                        s.Scope.SetVMSSState(fetchedVMSS)</span>
                }
        }()

        <span class="cov8" title="1">if future == nil </span><span class="cov8" title="1">{
                fetchedVMSS, err = s.getVirtualMachineScaleSet(ctx, scaleSetSpec.Name)
        }</span> else<span class="cov8" title="1"> {
                fetchedVMSS, err = s.getVirtualMachineScaleSetIfDone(ctx, future)
        }</span>

        <span class="cov8" title="1">switch </span>{
        case err != nil &amp;&amp; !azure.ResourceNotFound(err):<span class="cov0" title="0">
                // There was an error and it was not an HTTP 404 not found. This is either a transient error, like long running operation not done, or an Azure service error.
                return errors.Wrapf(err, "failed to get VMSS %s", scaleSetSpec.Name)</span>
        case err != nil &amp;&amp; azure.ResourceNotFound(err):<span class="cov8" title="1">
                // HTTP(404) resource was not found, so we need to create it with a PUT
                future, err = s.createVMSS(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        return errors.Wrap(err, "failed to start creating VMSS")
                }</span>
        case err == nil:<span class="cov8" title="1">
                // HTTP(200)
                // VMSS already exists and may have changes; update it with a PATCH
                // we do this to avoid overwriting fields in networkProfile modified by cloud-provider
                future, err = s.patchVMSSIfNeeded(ctx, fetchedVMSS)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to start updating VMSS")
                }</span>
        }

        // Try to get the VMSS to update status if we have created a long running operation. If the VMSS is still in a long
        // running operation, getVirtualMachineScaleSetIfDone will return an azure.WithTransientError and requeue.
        <span class="cov8" title="1">if future != nil </span><span class="cov8" title="1">{
                fetchedVMSS, err = s.getVirtualMachineScaleSetIfDone(ctx, future)
                if err != nil </span><span class="cov8" title="1">{
                        return errors.Wrapf(err, "failed to get VMSS %s after create or update", scaleSetSpec.Name)
                }</span>
        }

        // If we get to here, we have completed any long running VMSS operations (creates / updates)
        <span class="cov8" title="1">s.Scope.DeleteLongRunningOperationState(s.Scope.ScaleSetSpec().Name, serviceName)
        // This also means that the VMSS extensions were successfully installed
        // Note: we want to handle UpdatePutStatus when VMSSExtensions have an error when scalesets become an async service
        s.Scope.UpdatePutStatus(infrav1.BootstrapSucceededCondition, serviceName, nil)

        return nil</span>
}

// Delete deletes a scale set asynchronously. Delete sends a DELETE request to Azure and if accepted without error,
// the VMSS will be considered deleted. The actual delete in Azure may take longer, but should eventually complete.
func (s *Service) Delete(ctx context.Context) error <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "scalesets.Service.Delete")
        defer done()

        var err error

        vmssSpec := s.Scope.ScaleSetSpec()

        defer func() </span><span class="cov8" title="1">{
                // save the updated state of the VMSS for the MachinePoolScope to use for updating K8s state
                fetchedVMSS, err := s.getVirtualMachineScaleSet(ctx, vmssSpec.Name)
                if err != nil &amp;&amp; !azure.ResourceNotFound(err) </span><span class="cov0" title="0">{
                        log.Error(err, "failed to get vmss in deferred update")
                }</span>

                <span class="cov8" title="1">if fetchedVMSS != nil </span><span class="cov8" title="1">{
                        s.Scope.SetVMSSState(fetchedVMSS)
                }</span>
        }()

        // check if there is an ongoing long running operation
        <span class="cov8" title="1">future := s.Scope.GetLongRunningOperationState(vmssSpec.Name, serviceName)
        if future != nil </span><span class="cov8" title="1">{
                // if the operation is not complete this will return an error
                _, err := s.GetResultIfDone(ctx, future)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to get result from future")
                }</span>

                // ScaleSet has been deleted
                <span class="cov8" title="1">s.Scope.DeleteLongRunningOperationState(vmssSpec.Name, serviceName)
                // Note: we want to handle UpdateDeleteStatus when VMSSExtensions have an error when scalesets become an async service
                s.Scope.UpdateDeleteStatus(infrav1.BootstrapSucceededCondition, serviceName, nil)

                return nil</span>
        }

        // no long running delete operation is active, so delete the ScaleSet
        <span class="cov8" title="1">log.V(2).Info("deleting VMSS", "scale set", vmssSpec.Name)
        future, err = s.Client.DeleteAsync(ctx, s.Scope.ResourceGroup(), vmssSpec.Name)
        if err != nil </span><span class="cov8" title="1">{
                if azure.ResourceNotFound(err) </span><span class="cov8" title="1">{
                        // already deleted
                        return nil
                }</span>
                <span class="cov8" title="1">return errors.Wrapf(err, "failed to delete VMSS %s in resource group %s", vmssSpec.Name, s.Scope.ResourceGroup())</span>
        }

        <span class="cov0" title="0">s.Scope.SetLongRunningOperationState(future)
        if future != nil </span><span class="cov0" title="0">{
                // if future exists, check state of the future
                if _, err = s.GetResultIfDone(ctx, future); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "not done with long running operation, or failed to get result")
                }</span>
        }

        // future is either nil, or the result of the future is complete
        <span class="cov0" title="0">s.Scope.DeleteLongRunningOperationState(vmssSpec.Name, serviceName)
        // Note: we want to handle UpdateDeleteStatus when VMSSExtensions have an error when scalesets become an async service
        s.Scope.UpdateDeleteStatus(infrav1.BootstrapSucceededCondition, serviceName, nil)

        return nil</span>
}

func (s *Service) createVMSS(ctx context.Context) (*infrav1.Future, error) <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "scalesets.Service.createVMSS")
        defer done()

        spec := s.Scope.ScaleSetSpec()

        vmss, err := s.buildVMSSFromSpec(ctx, spec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed building VMSS from spec")
        }</span>

        <span class="cov8" title="1">future, err := s.Client.CreateOrUpdateAsync(ctx, s.Scope.ResourceGroup(), spec.Name, vmss)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, "cannot create VMSS")
        }</span>

        <span class="cov8" title="1">log.V(2).Info("starting to create VMSS", "scale set", spec.Name)
        s.Scope.SetLongRunningOperationState(future)
        return future, err</span>
}

func (s *Service) patchVMSSIfNeeded(ctx context.Context, infraVMSS *azure.VMSS) (*infrav1.Future, error) <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "scalesets.Service.patchVMSSIfNeeded")
        defer done()

        spec := s.Scope.ScaleSetSpec()

        vmss, err := s.buildVMSSFromSpec(ctx, spec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "failed to generate scale set update parameters for %s", spec.Name)
        }</span>

        <span class="cov8" title="1">patch, err := getVMSSUpdateFromVMSS(vmss)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "failed to generate vmss patch for %s", spec.Name)
        }</span>

        <span class="cov8" title="1">maxSurge, err := s.Scope.MaxSurge()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to calculate maxSurge")
        }</span>

        <span class="cov8" title="1">hasModelChanges := hasModelModifyingDifferences(infraVMSS, vmss)
        if maxSurge &gt; 0 &amp;&amp; (hasModelChanges || !infraVMSS.HasEnoughLatestModelOrNotMixedModel()) </span><span class="cov8" title="1">{
                // surge capacity with the intention of lowering during instance reconciliation
                surge := spec.Capacity + int64(maxSurge)
                log.V(4).Info("surging...", "surge", surge)
                patch.Sku.Capacity = to.Int64Ptr(surge)
        }</span>

        // If there are no model changes and no increase in the replica count, do not update the VMSS.
        // Decreases in replica count is handled by deleting AzureMachinePoolMachine instances in the MachinePoolScope
        <span class="cov8" title="1">if *patch.Sku.Capacity &lt;= infraVMSS.Capacity &amp;&amp; !hasModelChanges </span><span class="cov8" title="1">{
                log.V(4).Info("nothing to update on vmss", "scale set", spec.Name, "newReplicas", *patch.Sku.Capacity, "oldReplicas", infraVMSS.Capacity, "hasChanges", hasModelChanges)
                return nil, nil
        }</span>

        <span class="cov8" title="1">log.V(4).Info("patching vmss", "scale set", spec.Name, "patch", patch)
        future, err := s.UpdateAsync(ctx, s.Scope.ResourceGroup(), spec.Name, patch)
        if err != nil </span><span class="cov0" title="0">{
                if azure.ResourceConflict(err) </span><span class="cov0" title="0">{
                        return nil, azure.WithTransientError(err, 30*time.Second)
                }</span>
                <span class="cov0" title="0">return nil, errors.Wrap(err, "failed updating VMSS")</span>
        }

        <span class="cov8" title="1">s.Scope.SetLongRunningOperationState(future)
        log.V(2).Info("successfully started to update vmss", "scale set", spec.Name)
        return future, err</span>
}

func hasModelModifyingDifferences(infraVMSS *azure.VMSS, vmss compute.VirtualMachineScaleSet) bool <span class="cov8" title="1">{
        other := converters.SDKToVMSS(vmss, []compute.VirtualMachineScaleSetVM{})
        return infraVMSS.HasModelChanges(*other)
}</span>

func (s *Service) validateSpec(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "scalesets.Service.validateSpec")
        defer done()

        spec := s.Scope.ScaleSetSpec()

        sku, err := s.resourceSKUCache.Get(ctx, spec.Size, resourceskus.VirtualMachines)
        if err != nil </span><span class="cov8" title="1">{
                return errors.Wrapf(err, "failed to get SKU %s in compute api", spec.Size)
        }</span>

        // Checking if the requested VM size has at least 2 vCPUS
        <span class="cov8" title="1">vCPUCapability, err := sku.HasCapabilityWithCapacity(resourceskus.VCPUs, resourceskus.MinimumVCPUS)
        if err != nil </span><span class="cov0" title="0">{
                return azure.WithTerminalError(errors.Wrap(err, "failed to validate the vCPU capability"))
        }</span>

        <span class="cov8" title="1">if !vCPUCapability </span><span class="cov8" title="1">{
                return azure.WithTerminalError(errors.New("vm size should be bigger or equal to at least 2 vCPUs"))
        }</span>

        // Checking if the requested VM size has at least 2 Gi of memory
        <span class="cov8" title="1">MemoryCapability, err := sku.HasCapabilityWithCapacity(resourceskus.MemoryGB, resourceskus.MinimumMemory)
        if err != nil </span><span class="cov0" title="0">{
                return azure.WithTerminalError(errors.Wrap(err, "failed to validate the memory capability"))
        }</span>

        <span class="cov8" title="1">if !MemoryCapability </span><span class="cov8" title="1">{
                return azure.WithTerminalError(errors.New("vm memory should be bigger or equal to at least 2Gi"))
        }</span>

        // enable ephemeral OS
        <span class="cov8" title="1">if spec.OSDisk.DiffDiskSettings != nil &amp;&amp; !sku.HasCapability(resourceskus.EphemeralOSDisk) </span><span class="cov0" title="0">{
                return azure.WithTerminalError(fmt.Errorf("vm size %s does not support ephemeral os. select a different vm size or disable ephemeral os", spec.Size))
        }</span>

        <span class="cov8" title="1">if spec.SecurityProfile != nil &amp;&amp; !sku.HasCapability(resourceskus.EncryptionAtHost) </span><span class="cov8" title="1">{
                return azure.WithTerminalError(errors.Errorf("encryption at host is not supported for VM type %s", spec.Size))
        }</span>

        // Fetch location and zone to check for their support of ultra disks.
        <span class="cov8" title="1">location := s.Scope.Location()
        zones, err := s.resourceSKUCache.GetZones(ctx, location)
        if err != nil </span><span class="cov0" title="0">{
                return azure.WithTerminalError(errors.Wrapf(err, "failed to get the zones for location %s", location))
        }</span>

        <span class="cov8" title="1">for _, zone := range zones </span><span class="cov8" title="1">{
                hasLocationCapability := sku.HasLocationCapability(resourceskus.UltraSSDAvailable, location, zone)
                err := fmt.Errorf("vm size %s does not support ultra disks in location %s. select a different vm size or disable ultra disks", spec.Size, location)

                // Check support for ultra disks as data disks.
                for _, disks := range spec.DataDisks </span><span class="cov8" title="1">{
                        if disks.ManagedDisk != nil &amp;&amp;
                                disks.ManagedDisk.StorageAccountType == string(compute.StorageAccountTypesUltraSSDLRS) &amp;&amp;
                                !hasLocationCapability </span><span class="cov8" title="1">{
                                return azure.WithTerminalError(err)
                        }</span>
                }
                // Check support for ultra disks as persistent volumes.
                <span class="cov8" title="1">if spec.AdditionalCapabilities != nil &amp;&amp; spec.AdditionalCapabilities.UltraSSDEnabled != nil </span><span class="cov8" title="1">{
                        if *spec.AdditionalCapabilities.UltraSSDEnabled &amp;&amp;
                                !hasLocationCapability </span><span class="cov8" title="1">{
                                return azure.WithTerminalError(err)
                        }</span>
                }
        }

        // Checking if selected availability zones are available selected VM type in location
        <span class="cov8" title="1">azsInLocation, err := s.resourceSKUCache.GetZonesWithVMSize(ctx, spec.Size, s.Scope.Location())
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to get zones for VM type %s in location %s", spec.Size, s.Scope.Location())
        }</span>

        <span class="cov8" title="1">for _, az := range spec.FailureDomains </span><span class="cov8" title="1">{
                if !slice.Contains(azsInLocation, az) </span><span class="cov0" title="0">{
                        return azure.WithTerminalError(errors.Errorf("availability zone %s is not available for VM type %s in location %s", az, spec.Size, s.Scope.Location()))
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (s *Service) buildVMSSFromSpec(ctx context.Context, vmssSpec azure.ScaleSetSpec) (compute.VirtualMachineScaleSet, error) <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "scalesets.Service.buildVMSSFromSpec")
        defer done()

        sku, err := s.resourceSKUCache.Get(ctx, vmssSpec.Size, resourceskus.VirtualMachines)
        if err != nil </span><span class="cov0" title="0">{
                return compute.VirtualMachineScaleSet{}, errors.Wrapf(err, "failed to get find SKU %s in compute api", vmssSpec.Size)
        }</span>

        <span class="cov8" title="1">if vmssSpec.AcceleratedNetworking == nil </span><span class="cov8" title="1">{
                // set accelerated networking to the capability of the VMSize
                accelNet := sku.HasCapability(resourceskus.AcceleratedNetworking)
                vmssSpec.AcceleratedNetworking = &amp;accelNet
        }</span>

        <span class="cov8" title="1">extensions, err := s.generateExtensions()
        if err != nil </span><span class="cov0" title="0">{
                return compute.VirtualMachineScaleSet{}, err
        }</span>

        <span class="cov8" title="1">storageProfile, err := s.generateStorageProfile(ctx, vmssSpec, sku)
        if err != nil </span><span class="cov0" title="0">{
                return compute.VirtualMachineScaleSet{}, err
        }</span>

        <span class="cov8" title="1">securityProfile, err := getSecurityProfile(vmssSpec, sku)
        if err != nil </span><span class="cov0" title="0">{
                return compute.VirtualMachineScaleSet{}, err
        }</span>

        <span class="cov8" title="1">priority, evictionPolicy, billingProfile, err := converters.GetSpotVMOptions(vmssSpec.SpotVMOptions, vmssSpec.OSDisk.DiffDiskSettings)
        if err != nil </span><span class="cov0" title="0">{
                return compute.VirtualMachineScaleSet{}, errors.Wrapf(err, "failed to get Spot VM options")
        }</span>

        // Get the node outbound LB backend pool ID
        <span class="cov8" title="1">var backendAddressPools []compute.SubResource
        if vmssSpec.PublicLBName != "" </span><span class="cov8" title="1">{
                if vmssSpec.PublicLBAddressPoolName != "" </span><span class="cov8" title="1">{
                        backendAddressPools = append(backendAddressPools,
                                compute.SubResource{
                                        ID: to.StringPtr(azure.AddressPoolID(s.Scope.SubscriptionID(), s.Scope.ResourceGroup(), vmssSpec.PublicLBName, vmssSpec.PublicLBAddressPoolName)),
                                })
                }</span>
        }

        <span class="cov8" title="1">osProfile, err := s.generateOSProfile(ctx, vmssSpec)
        if err != nil </span><span class="cov0" title="0">{
                return compute.VirtualMachineScaleSet{}, err
        }</span>

        <span class="cov8" title="1">vmss := compute.VirtualMachineScaleSet{
                Location: to.StringPtr(s.Scope.Location()),
                Sku: &amp;compute.Sku{
                        Name:     to.StringPtr(vmssSpec.Size),
                        Tier:     to.StringPtr("Standard"),
                        Capacity: to.Int64Ptr(vmssSpec.Capacity),
                },
                Zones: to.StringSlicePtr(vmssSpec.FailureDomains),
                Plan:  s.generateImagePlan(ctx),
                VirtualMachineScaleSetProperties: &amp;compute.VirtualMachineScaleSetProperties{
                        SinglePlacementGroup: to.BoolPtr(false),
                        UpgradePolicy: &amp;compute.UpgradePolicy{
                                Mode: compute.UpgradeModeManual,
                        },
                        Overprovision: to.BoolPtr(false),
                        VirtualMachineProfile: &amp;compute.VirtualMachineScaleSetVMProfile{
                                OsProfile:       osProfile,
                                StorageProfile:  storageProfile,
                                SecurityProfile: securityProfile,
                                DiagnosticsProfile: &amp;compute.DiagnosticsProfile{
                                        BootDiagnostics: &amp;compute.BootDiagnostics{
                                                Enabled: to.BoolPtr(true),
                                        },
                                },
                                NetworkProfile: &amp;compute.VirtualMachineScaleSetNetworkProfile{
                                        NetworkInterfaceConfigurations: &amp;[]compute.VirtualMachineScaleSetNetworkConfiguration{
                                                {
                                                        Name: to.StringPtr(vmssSpec.Name),
                                                        VirtualMachineScaleSetNetworkConfigurationProperties: &amp;compute.VirtualMachineScaleSetNetworkConfigurationProperties{
                                                                Primary:            to.BoolPtr(true),
                                                                EnableIPForwarding: to.BoolPtr(true),
                                                                IPConfigurations: &amp;[]compute.VirtualMachineScaleSetIPConfiguration{
                                                                        {
                                                                                Name: to.StringPtr(vmssSpec.Name),
                                                                                VirtualMachineScaleSetIPConfigurationProperties: &amp;compute.VirtualMachineScaleSetIPConfigurationProperties{
                                                                                        Subnet: &amp;compute.APIEntityReference{
                                                                                                ID: to.StringPtr(azure.SubnetID(s.Scope.SubscriptionID(), vmssSpec.VNetResourceGroup, vmssSpec.VNetName, vmssSpec.SubnetName)),
                                                                                        },
                                                                                        Primary:                         to.BoolPtr(true),
                                                                                        PrivateIPAddressVersion:         compute.IPVersionIPv4,
                                                                                        LoadBalancerBackendAddressPools: &amp;backendAddressPools,
                                                                                },
                                                                        },
                                                                },
                                                                EnableAcceleratedNetworking: vmssSpec.AcceleratedNetworking,
                                                        },
                                                },
                                        },
                                },
                                Priority:       priority,
                                EvictionPolicy: evictionPolicy,
                                BillingProfile: billingProfile,
                                ExtensionProfile: &amp;compute.VirtualMachineScaleSetExtensionProfile{
                                        Extensions: &amp;extensions,
                                },
                        },
                },
        }

        // Assign Identity to VMSS
        if vmssSpec.Identity == infrav1.VMIdentitySystemAssigned </span><span class="cov0" title="0">{
                vmss.Identity = &amp;compute.VirtualMachineScaleSetIdentity{
                        Type: compute.ResourceIdentityTypeSystemAssigned,
                }
        }</span> else<span class="cov8" title="1"> if vmssSpec.Identity == infrav1.VMIdentityUserAssigned </span><span class="cov8" title="1">{
                userIdentitiesMap, err := converters.UserAssignedIdentitiesToVMSSSDK(vmssSpec.UserAssignedIdentities)
                if err != nil </span><span class="cov0" title="0">{
                        return vmss, errors.Wrapf(err, "failed to assign identity %q", vmssSpec.Name)
                }</span>
                <span class="cov8" title="1">vmss.Identity = &amp;compute.VirtualMachineScaleSetIdentity{
                        Type:                   compute.ResourceIdentityTypeUserAssigned,
                        UserAssignedIdentities: userIdentitiesMap,
                }</span>
        }

        // Provisionally detect whether there is any Data Disk defined which uses UltraSSDs.
        // If that's the case, enable the UltraSSD capability.
        <span class="cov8" title="1">for _, dataDisk := range vmssSpec.DataDisks </span><span class="cov8" title="1">{
                if dataDisk.ManagedDisk != nil &amp;&amp; dataDisk.ManagedDisk.StorageAccountType == string(compute.StorageAccountTypesUltraSSDLRS) </span><span class="cov8" title="1">{
                        vmss.VirtualMachineScaleSetProperties.AdditionalCapabilities = &amp;compute.AdditionalCapabilities{
                                UltraSSDEnabled: to.BoolPtr(true),
                        }
                }</span>
        }

        // Set Additional Capabilities if any is present on the spec.
        <span class="cov8" title="1">if vmssSpec.AdditionalCapabilities != nil </span><span class="cov0" title="0">{
                // Set UltraSSDEnabled if a specific value is set on the spec for it.
                if vmssSpec.AdditionalCapabilities.UltraSSDEnabled != nil </span><span class="cov0" title="0">{
                        vmss.AdditionalCapabilities.UltraSSDEnabled = vmssSpec.AdditionalCapabilities.UltraSSDEnabled
                }</span>
        }

        <span class="cov8" title="1">if vmssSpec.TerminateNotificationTimeout != nil </span><span class="cov8" title="1">{
                vmss.VirtualMachineScaleSetProperties.VirtualMachineProfile.ScheduledEventsProfile = &amp;compute.ScheduledEventsProfile{
                        TerminateNotificationProfile: &amp;compute.TerminateNotificationProfile{
                                NotBeforeTimeout: to.StringPtr(fmt.Sprintf("PT%dM", *vmssSpec.TerminateNotificationTimeout)),
                                Enable:           to.BoolPtr(true),
                        },
                }
        }</span>

        <span class="cov8" title="1">tags := infrav1.Build(infrav1.BuildParams{
                ClusterName: s.Scope.ClusterName(),
                Lifecycle:   infrav1.ResourceLifecycleOwned,
                Name:        to.StringPtr(vmssSpec.Name),
                Role:        to.StringPtr(infrav1.Node),
                Additional:  s.Scope.AdditionalTags(),
        })

        vmss.Tags = converters.TagsToMap(tags)
        return vmss, nil</span>
}

// getVirtualMachineScaleSet provides information about a Virtual Machine Scale Set and its instances.
func (s *Service) getVirtualMachineScaleSet(ctx context.Context, vmssName string) (*azure.VMSS, error) <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "scalesets.Service.getVirtualMachineScaleSet")
        defer done()

        vmss, err := s.Client.Get(ctx, s.Scope.ResourceGroup(), vmssName)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, "failed to get existing vmss")
        }</span>

        <span class="cov8" title="1">vmssInstances, err := s.Client.ListInstances(ctx, s.Scope.ResourceGroup(), vmssName)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, "failed to list instances")
        }</span>

        <span class="cov8" title="1">return converters.SDKToVMSS(vmss, vmssInstances), nil</span>
}

// getVirtualMachineScaleSetIfDone gets a Virtual Machine Scale Set and its instances from Azure if the future is completed.
func (s *Service) getVirtualMachineScaleSetIfDone(ctx context.Context, future *infrav1.Future) (*azure.VMSS, error) <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "scalesets.Service.getVirtualMachineScaleSetIfDone")
        defer done()

        vmss, err := s.GetResultIfDone(ctx, future)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, "failed to get result from future")
        }</span>

        <span class="cov8" title="1">vmssInstances, err := s.Client.ListInstances(ctx, future.ResourceGroup, future.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to list instances")
        }</span>

        <span class="cov8" title="1">return converters.SDKToVMSS(vmss, vmssInstances), nil</span>
}

func (s *Service) generateExtensions() ([]compute.VirtualMachineScaleSetExtension, error) <span class="cov8" title="1">{
        extensions := make([]compute.VirtualMachineScaleSetExtension, len(s.Scope.VMSSExtensionSpecs()))
        for i, extensionSpec := range s.Scope.VMSSExtensionSpecs() </span><span class="cov8" title="1">{
                extensionSpec := extensionSpec
                parameters, err := extensionSpec.Parameters(nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">vmssextension, ok := parameters.(compute.VirtualMachineScaleSetExtension)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("%T is not a compute.VirtualMachineScaleSetExtension", parameters)
                }</span>
                <span class="cov8" title="1">extensions[i] = vmssextension</span>
        }

        <span class="cov8" title="1">return extensions, nil</span>
}

// generateStorageProfile generates a pointer to a compute.VirtualMachineScaleSetStorageProfile which can utilized for VM creation.
func (s *Service) generateStorageProfile(ctx context.Context, vmssSpec azure.ScaleSetSpec, sku resourceskus.SKU) (*compute.VirtualMachineScaleSetStorageProfile, error) <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "scalesets.Service.generateStorageProfile")
        defer done()

        storageProfile := &amp;compute.VirtualMachineScaleSetStorageProfile{
                OsDisk: &amp;compute.VirtualMachineScaleSetOSDisk{
                        OsType:       compute.OperatingSystemTypes(vmssSpec.OSDisk.OSType),
                        CreateOption: compute.DiskCreateOptionTypesFromImage,
                        DiskSizeGB:   vmssSpec.OSDisk.DiskSizeGB,
                },
        }

        // enable ephemeral OS
        if vmssSpec.OSDisk.DiffDiskSettings != nil </span><span class="cov8" title="1">{
                if !sku.HasCapability(resourceskus.EphemeralOSDisk) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("vm size %s does not support ephemeral os. select a different vm size or disable ephemeral os", vmssSpec.Size)
                }</span>

                <span class="cov8" title="1">storageProfile.OsDisk.DiffDiskSettings = &amp;compute.DiffDiskSettings{
                        Option: compute.DiffDiskOptions(vmssSpec.OSDisk.DiffDiskSettings.Option),
                }</span>
        }

        <span class="cov8" title="1">if vmssSpec.OSDisk.ManagedDisk != nil </span><span class="cov8" title="1">{
                storageProfile.OsDisk.ManagedDisk = &amp;compute.VirtualMachineScaleSetManagedDiskParameters{}
                if vmssSpec.OSDisk.ManagedDisk.StorageAccountType != "" </span><span class="cov8" title="1">{
                        storageProfile.OsDisk.ManagedDisk.StorageAccountType = compute.StorageAccountTypes(vmssSpec.OSDisk.ManagedDisk.StorageAccountType)
                }</span>
                <span class="cov8" title="1">if vmssSpec.OSDisk.ManagedDisk.DiskEncryptionSet != nil </span><span class="cov8" title="1">{
                        storageProfile.OsDisk.ManagedDisk.DiskEncryptionSet = &amp;compute.DiskEncryptionSetParameters{ID: to.StringPtr(vmssSpec.OSDisk.ManagedDisk.DiskEncryptionSet.ID)}
                }</span>
        }

        <span class="cov8" title="1">if vmssSpec.OSDisk.CachingType != "" </span><span class="cov8" title="1">{
                storageProfile.OsDisk.Caching = compute.CachingTypes(vmssSpec.OSDisk.CachingType)
        }</span>

        <span class="cov8" title="1">dataDisks := make([]compute.VirtualMachineScaleSetDataDisk, len(vmssSpec.DataDisks))
        for i, disk := range vmssSpec.DataDisks </span><span class="cov8" title="1">{
                dataDisks[i] = compute.VirtualMachineScaleSetDataDisk{
                        CreateOption: compute.DiskCreateOptionTypesEmpty,
                        DiskSizeGB:   to.Int32Ptr(disk.DiskSizeGB),
                        Lun:          disk.Lun,
                        Name:         to.StringPtr(azure.GenerateDataDiskName(vmssSpec.Name, disk.NameSuffix)),
                }

                if disk.ManagedDisk != nil </span><span class="cov8" title="1">{
                        dataDisks[i].ManagedDisk = &amp;compute.VirtualMachineScaleSetManagedDiskParameters{
                                StorageAccountType: compute.StorageAccountTypes(disk.ManagedDisk.StorageAccountType),
                        }

                        if disk.ManagedDisk.DiskEncryptionSet != nil </span><span class="cov8" title="1">{
                                dataDisks[i].ManagedDisk.DiskEncryptionSet = &amp;compute.DiskEncryptionSetParameters{ID: to.StringPtr(disk.ManagedDisk.DiskEncryptionSet.ID)}
                        }</span>
                }
        }
        <span class="cov8" title="1">storageProfile.DataDisks = &amp;dataDisks

        image, err := s.Scope.GetVMImage(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to get VM image")
        }</span>

        <span class="cov8" title="1">s.Scope.SaveVMImageToStatus(image)

        imageRef, err := converters.ImageToSDK(image)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">storageProfile.ImageReference = imageRef

        return storageProfile, nil</span>
}

func (s *Service) generateOSProfile(ctx context.Context, vmssSpec azure.ScaleSetSpec) (*compute.VirtualMachineScaleSetOSProfile, error) <span class="cov8" title="1">{
        sshKey, err := base64.StdEncoding.DecodeString(vmssSpec.SSHKeyData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to decode ssh public key")
        }</span>
        <span class="cov8" title="1">bootstrapData, err := s.Scope.GetBootstrapData(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to retrieve bootstrap data")
        }</span>

        <span class="cov8" title="1">osProfile := &amp;compute.VirtualMachineScaleSetOSProfile{
                ComputerNamePrefix: to.StringPtr(vmssSpec.Name),
                AdminUsername:      to.StringPtr(azure.DefaultUserName),
                CustomData:         to.StringPtr(bootstrapData),
        }

        switch vmssSpec.OSDisk.OSType </span>{
        case string(compute.OperatingSystemTypesWindows):<span class="cov8" title="1">
                // Cloudbase-init is used to generate a password.
                // https://cloudbase-init.readthedocs.io/en/latest/plugins.html#setting-password-main
                //
                // We generate a random password here in case of failure
                // but the password on the VM will NOT be the same as created here.
                // Access is provided via SSH public key that is set during deployment
                // Azure also provides a way to reset user passwords in the case of need.
                osProfile.AdminPassword = to.StringPtr(generators.SudoRandomPassword(123))
                osProfile.WindowsConfiguration = &amp;compute.WindowsConfiguration{
                        EnableAutomaticUpdates: to.BoolPtr(false),
                }</span>
        default:<span class="cov8" title="1">
                osProfile.LinuxConfiguration = &amp;compute.LinuxConfiguration{
                        DisablePasswordAuthentication: to.BoolPtr(true),
                        SSH: &amp;compute.SSHConfiguration{
                                PublicKeys: &amp;[]compute.SSHPublicKey{
                                        {
                                                Path:    to.StringPtr(fmt.Sprintf("/home/%s/.ssh/authorized_keys", azure.DefaultUserName)),
                                                KeyData: to.StringPtr(string(sshKey)),
                                        },
                                },
                        },
                }</span>
        }

        <span class="cov8" title="1">return osProfile, nil</span>
}

func (s *Service) generateImagePlan(ctx context.Context) *compute.Plan <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "scalesets.Service.generateImagePlan")
        defer done()

        image, err := s.Scope.GetVMImage(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to get vm image, disabling Plan")
                return nil
        }</span>

        <span class="cov8" title="1">if image.SharedGallery != nil &amp;&amp; image.SharedGallery.Publisher != nil &amp;&amp; image.SharedGallery.SKU != nil &amp;&amp; image.SharedGallery.Offer != nil </span><span class="cov0" title="0">{
                return &amp;compute.Plan{
                        Publisher: image.SharedGallery.Publisher,
                        Name:      image.SharedGallery.SKU,
                        Product:   image.SharedGallery.Offer,
                }
        }</span>

        <span class="cov8" title="1">if image.Marketplace == nil || !image.Marketplace.ThirdPartyImage </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">if image.Marketplace.Publisher == "" || image.Marketplace.SKU == "" || image.Marketplace.Offer == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;compute.Plan{
                Publisher: to.StringPtr(image.Marketplace.Publisher),
                Name:      to.StringPtr(image.Marketplace.SKU),
                Product:   to.StringPtr(image.Marketplace.Offer),
        }</span>
}

func getVMSSUpdateFromVMSS(vmss compute.VirtualMachineScaleSet) (compute.VirtualMachineScaleSetUpdate, error) <span class="cov8" title="1">{
        jsonData, err := vmss.MarshalJSON()
        if err != nil </span><span class="cov0" title="0">{
                return compute.VirtualMachineScaleSetUpdate{}, err
        }</span>

        <span class="cov8" title="1">var update compute.VirtualMachineScaleSetUpdate
        if err := update.UnmarshalJSON(jsonData); err != nil </span><span class="cov0" title="0">{
                return update, err
        }</span>

        // wipe out network profile, so updates won't conflict with Cloud Provider updates
        <span class="cov8" title="1">update.VirtualMachineProfile.NetworkProfile = nil
        return update, nil</span>
}

func getSecurityProfile(vmssSpec azure.ScaleSetSpec, sku resourceskus.SKU) (*compute.SecurityProfile, error) <span class="cov8" title="1">{
        if vmssSpec.SecurityProfile == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">if !sku.HasCapability(resourceskus.EncryptionAtHost) </span><span class="cov0" title="0">{
                return nil, azure.WithTerminalError(errors.Errorf("encryption at host is not supported for VM type %s", vmssSpec.Size))
        }</span>

        <span class="cov8" title="1">return &amp;compute.SecurityProfile{
                EncryptionAtHost: to.BoolPtr(*vmssSpec.SecurityProfile.EncryptionAtHost),
        }, nil</span>
}

// IsManaged returns always returns true as CAPZ does not support BYO scale set.
func (s *Service) IsManaged(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>
</pre>
		
		<pre class="file" id="file131" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package scalesets

import (
        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-11-01/compute"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
)

// VMSSExtensionSpec defines the specification for a VM or VMScaleSet extension.
type VMSSExtensionSpec struct {
        azure.ExtensionSpec
        ResourceGroup string
}

// ResourceName returns the name of the VMSS extension.
func (s *VMSSExtensionSpec) ResourceName() string <span class="cov0" title="0">{
        return s.Name
}</span>

// ResourceGroupName returns the name of the resource group.
func (s *VMSSExtensionSpec) ResourceGroupName() string <span class="cov0" title="0">{
        return s.ResourceGroup
}</span>

// OwnerResourceName returns the name of the VMSS that owns this VMSS extension.
func (s *VMSSExtensionSpec) OwnerResourceName() string <span class="cov0" title="0">{
        return s.VMName
}</span>

// Parameters returns the parameters for the VMSS extension.
func (s *VMSSExtensionSpec) Parameters(existing interface{}) (interface{}, error) <span class="cov8" title="1">{
        if existing != nil </span><span class="cov0" title="0">{
                _, ok := existing.(compute.VirtualMachineScaleSetExtension)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("%T is not a compute.VirtualMachineScaleSetExtension", existing)
                }</span>

                // VMSS extension already exists, nothing to update.
                <span class="cov0" title="0">return nil, nil</span>
        }

        <span class="cov8" title="1">return compute.VirtualMachineScaleSetExtension{
                Name: to.StringPtr(s.Name),
                VirtualMachineScaleSetExtensionProperties: &amp;compute.VirtualMachineScaleSetExtensionProperties{
                        Publisher:          to.StringPtr(s.Publisher),
                        Type:               to.StringPtr(s.Name),
                        TypeHandlerVersion: to.StringPtr(s.Version),
                        Settings:           nil,
                        ProtectedSettings:  s.ProtectedSettings,
                },
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file132" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package scalesetvms

import (
        "context"
        "encoding/base64"
        "encoding/json"
        "time"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-11-01/compute"
        "github.com/Azure/go-autorest/autorest"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/converters"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// client wraps go-sdk.
type client interface {
        Get(context.Context, string, string, string) (compute.VirtualMachineScaleSetVM, error)
        GetResultIfDone(ctx context.Context, future *infrav1.Future) (compute.VirtualMachineScaleSetVM, error)
        DeleteAsync(context.Context, string, string, string) (*infrav1.Future, error)
}

type (
        // azureClient contains the Azure go-sdk Client.
        azureClient struct {
                scalesetvms compute.VirtualMachineScaleSetVMsClient
        }

        genericScaleSetVMFuture interface {
                DoneWithContext(ctx context.Context, sender autorest.Sender) (done bool, err error)
                Result(client compute.VirtualMachineScaleSetVMsClient) (vmss compute.VirtualMachineScaleSetVM, err error)
        }

        deleteFutureAdapter struct {
                compute.VirtualMachineScaleSetVMsDeleteFuture
        }
)

var _ client = &amp;azureClient{}

// newClient creates a new VMSS client from subscription ID.
func newClient(auth azure.Authorizer) *azureClient <span class="cov8" title="1">{
        return &amp;azureClient{
                scalesetvms: newVirtualMachineScaleSetVMsClient(auth.SubscriptionID(), auth.BaseURI(), auth.Authorizer()),
        }
}</span>

// newVirtualMachineScaleSetVMsClient creates a new vmss VM client from subscription ID.
func newVirtualMachineScaleSetVMsClient(subscriptionID string, baseURI string, authorizer autorest.Authorizer) compute.VirtualMachineScaleSetVMsClient <span class="cov8" title="1">{
        c := compute.NewVirtualMachineScaleSetVMsClientWithBaseURI(baseURI, subscriptionID)
        c.Authorizer = authorizer
        c.RetryAttempts = 1
        _ = c.AddToUserAgent(azure.UserAgent()) // intentionally ignore error as it doesn't matter
        return c
}</span>

// Get retrieves the Virtual Machine Scale Set Virtual Machine.
func (ac *azureClient) Get(ctx context.Context, resourceGroupName, vmssName, instanceID string) (compute.VirtualMachineScaleSetVM, error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "scalesetvms.azureClient.Get")
        defer done()

        return ac.scalesetvms.Get(ctx, resourceGroupName, vmssName, instanceID, "")
}</span>

// GetResultIfDone fetches the result of a long-running operation future if it is done.
func (ac *azureClient) GetResultIfDone(ctx context.Context, future *infrav1.Future) (compute.VirtualMachineScaleSetVM, error) <span class="cov0" title="0">{
        ctx, _, spanDone := tele.StartSpanWithLogger(ctx, "scalesetvms.azureClient.GetResultIfDone")
        defer spanDone()

        var genericFuture genericScaleSetVMFuture
        futureData, err := base64.URLEncoding.DecodeString(future.Data)
        if err != nil </span><span class="cov0" title="0">{
                return compute.VirtualMachineScaleSetVM{}, errors.Wrapf(err, "failed to base64 decode future data")
        }</span>

        <span class="cov0" title="0">switch future.Type </span>{
        case infrav1.DeleteFuture:<span class="cov0" title="0">
                var future compute.VirtualMachineScaleSetVMsDeleteFuture
                if err := json.Unmarshal(futureData, &amp;future); err != nil </span><span class="cov0" title="0">{
                        return compute.VirtualMachineScaleSetVM{}, errors.Wrap(err, "failed to unmarshal future data")
                }</span>

                <span class="cov0" title="0">genericFuture = &amp;deleteFutureAdapter{
                        VirtualMachineScaleSetVMsDeleteFuture: future,
                }</span>
        default:<span class="cov0" title="0">
                return compute.VirtualMachineScaleSetVM{}, errors.Errorf("unknown future type %q", future.Type)</span>
        }

        <span class="cov0" title="0">done, err := genericFuture.DoneWithContext(ctx, ac.scalesetvms)
        if err != nil </span><span class="cov0" title="0">{
                return compute.VirtualMachineScaleSetVM{}, errors.Wrapf(err, "failed checking if the operation was complete")
        }</span>

        <span class="cov0" title="0">if !done </span><span class="cov0" title="0">{
                return compute.VirtualMachineScaleSetVM{}, azure.WithTransientError(azure.NewOperationNotDoneError(future), 15*time.Second)
        }</span>

        <span class="cov0" title="0">vm, err := genericFuture.Result(ac.scalesetvms)
        if err != nil </span><span class="cov0" title="0">{
                return vm, errors.Wrapf(err, "failed fetching the result of operation for vmss")
        }</span>

        <span class="cov0" title="0">return vm, nil</span>
}

// DeleteAsync is the operation to delete a virtual machine scale set instance asynchronously. DeleteAsync sends a DELETE
// request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
//
// Parameters:
//   resourceGroupName - the name of the resource group.
//   vmssName - the name of the VM scale set to create or update. parameters - the scale set object.
//   instanceID - the ID of the VM scale set VM.
func (ac *azureClient) DeleteAsync(ctx context.Context, resourceGroupName, vmssName, instanceID string) (*infrav1.Future, error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "scalesetvms.azureClient.DeleteAsync")
        defer done()

        future, err := ac.scalesetvms.Delete(ctx, resourceGroupName, vmssName, instanceID, to.BoolPtr(false))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "failed deleting vmss named %q", vmssName)
        }</span>

        <span class="cov0" title="0">return converters.SDKToFuture(&amp;future, infrav1.DeleteFuture, serviceName, instanceID, resourceGroupName)</span>
}

// Result wraps the delete result so that we can treat it generically. The only thing we care about is if the delete
// was successful. If it wasn't, an error will be returned.
func (da *deleteFutureAdapter) Result(client compute.VirtualMachineScaleSetVMsClient) (compute.VirtualMachineScaleSetVM, error) <span class="cov0" title="0">{
        _, err := da.VirtualMachineScaleSetVMsDeleteFuture.Result(client)
        return compute.VirtualMachineScaleSetVM{}, err
}</span>
</pre>
		
		<pre class="file" id="file133" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package scalesetvms

import (
        "context"
        "time"

        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/converters"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

const serviceName = "scalesetvms"

type (
        // ScaleSetVMScope defines the scope interface for a scale sets service.
        ScaleSetVMScope interface {
                azure.ClusterDescriber
                azure.AsyncStatusUpdater
                InstanceID() string
                ScaleSetName() string
                SetVMSSVM(vmssvm *azure.VMSSVM)
        }

        // Service provides operations on Azure resources.
        Service struct {
                Client client
                Scope  ScaleSetVMScope
        }
)

// NewService creates a new service.
func NewService(scope ScaleSetVMScope) *Service <span class="cov8" title="1">{
        return &amp;Service{
                Client: newClient(scope),
                Scope:  scope,
        }
}</span>

// Name returns the service name.
func (s *Service) Name() string <span class="cov0" title="0">{
        return serviceName
}</span>

// Reconcile idempotently gets, creates, and updates a scale set.
func (s *Service) Reconcile(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "scalesetvms.Service.Reconcile")
        defer done()

        var (
                resourceGroup = s.Scope.ResourceGroup()
                vmssName      = s.Scope.ScaleSetName()
                instanceID    = s.Scope.InstanceID()
        )

        // fetch the latest data about the instance -- model mutations are handled by the AzureMachinePoolReconciler
        instance, err := s.Client.Get(ctx, resourceGroup, vmssName, instanceID)
        if err != nil </span><span class="cov8" title="1">{
                if azure.ResourceNotFound(err) </span><span class="cov8" title="1">{
                        return azure.WithTransientError(errors.New("instance does not exist yet"), 30*time.Second)
                }</span>
                <span class="cov8" title="1">return errors.Wrap(err, "failed getting instance")</span>
        }

        <span class="cov8" title="1">s.Scope.SetVMSSVM(converters.SDKToVMSSVM(instance))
        return nil</span>
}

// Delete deletes a scaleset instance asynchronously returning a future which encapsulates the long-running operation.
func (s *Service) Delete(ctx context.Context) error <span class="cov8" title="1">{
        var (
                resourceGroup = s.Scope.ResourceGroup()
                vmssName      = s.Scope.ScaleSetName()
                instanceID    = s.Scope.InstanceID()
        )

        ctx, log, done := tele.StartSpanWithLogger(
                ctx,
                "scalesetvms.Service.Delete",
                tele.KVP("resourceGroup", resourceGroup),
                tele.KVP("scaleset", vmssName),
                tele.KVP("instanceID", instanceID),
        )
        defer done()

        defer func() </span><span class="cov8" title="1">{
                if instance, err := s.Client.Get(ctx, resourceGroup, vmssName, instanceID); err == nil &amp;&amp; instance.VirtualMachineScaleSetVMProperties != nil </span><span class="cov0" title="0">{
                        log.V(4).Info("updating vmss vm state", "state", instance.ProvisioningState)
                        s.Scope.SetVMSSVM(converters.SDKToVMSSVM(instance))
                }</span>
        }()

        <span class="cov8" title="1">log.V(4).Info("entering delete")
        future := s.Scope.GetLongRunningOperationState(instanceID, serviceName)
        if future != nil </span><span class="cov8" title="1">{
                if future.Type != infrav1.DeleteFuture </span><span class="cov0" title="0">{
                        return azure.WithTransientError(errors.New("attempting to delete, non-delete operation in progress"), 30*time.Second)
                }</span>

                <span class="cov8" title="1">log.V(4).Info("checking if the instance is done deleting")
                if _, err := s.Client.GetResultIfDone(ctx, future); err != nil </span><span class="cov8" title="1">{
                        // fetch instance to update status
                        return errors.Wrap(err, "failed to get result of long running operation")
                }</span>

                // there was no error in fetching the result, the future has been completed
                <span class="cov8" title="1">log.V(4).Info("successfully deleted the instance")
                s.Scope.DeleteLongRunningOperationState(instanceID, serviceName)
                return nil</span>
        }

        // since the future was nil, there is no ongoing activity; start deleting the instance
        <span class="cov8" title="1">future, err := s.Client.DeleteAsync(ctx, resourceGroup, vmssName, instanceID)
        if err != nil </span><span class="cov8" title="1">{
                if azure.ResourceNotFound(err) </span><span class="cov8" title="1">{
                        // already deleted
                        return nil
                }</span>
                <span class="cov8" title="1">return errors.Wrapf(err, "failed to delete instance %s/%s", vmssName, instanceID)</span>
        }

        <span class="cov8" title="1">s.Scope.SetLongRunningOperationState(future)

        log.V(4).Info("checking if the instance is done deleting")
        if _, err := s.Client.GetResultIfDone(ctx, future); err != nil </span><span class="cov8" title="1">{
                // fetch instance to update status
                return errors.Wrap(err, "failed to get result of long running operation")
        }</span>

        <span class="cov0" title="0">s.Scope.DeleteLongRunningOperationState(instanceID, serviceName)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file134" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package securitygroups

import (
        "context"
        "encoding/json"

        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-08-01/network"
        "github.com/Azure/go-autorest/autorest"
        azureautorest "github.com/Azure/go-autorest/autorest/azure"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// azureClient contains the Azure go-sdk Client.
type azureClient struct {
        securitygroups network.SecurityGroupsClient
}

// newClient creates a new VM client from subscription ID.
func newClient(auth azure.Authorizer) *azureClient <span class="cov0" title="0">{
        c := newSecurityGroupsClient(auth.SubscriptionID(), auth.BaseURI(), auth.Authorizer())
        return &amp;azureClient{c}
}</span>

// newSecurityGroupsClient creates a new security groups client from subscription ID.
func newSecurityGroupsClient(subscriptionID string, baseURI string, authorizer autorest.Authorizer) network.SecurityGroupsClient <span class="cov0" title="0">{
        securityGroupsClient := network.NewSecurityGroupsClientWithBaseURI(baseURI, subscriptionID)
        azure.SetAutoRestClientDefaults(&amp;securityGroupsClient.Client, authorizer)
        return securityGroupsClient
}</span>

// Get gets the specified network security group.
func (ac *azureClient) Get(ctx context.Context, spec azure.ResourceSpecGetter) (result interface{}, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "securitygroups.azureClient.Get")
        defer done()

        return ac.securitygroups.Get(ctx, spec.ResourceGroupName(), spec.ResourceName(), "")
}</span>

// CreateOrUpdateAsync creates or updates a network security group in the specified resource group.
// It sends a PUT request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *azureClient) CreateOrUpdateAsync(ctx context.Context, spec azure.ResourceSpecGetter, parameters interface{}) (result interface{}, future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "securitygroups.azureClient.CreateOrUpdate")
        defer done()

        sg, ok := parameters.(network.SecurityGroup)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.Errorf("%T is not a network.SecurityGroup", parameters)
        }</span>

        <span class="cov0" title="0">var etag string
        if sg.Etag != nil </span><span class="cov0" title="0">{
                etag = *sg.Etag
        }</span>
        <span class="cov0" title="0">req, err := ac.securitygroups.CreateOrUpdatePreparer(ctx, spec.ResourceGroupName(), spec.ResourceName(), sg)
        if err != nil </span><span class="cov0" title="0">{
                err = autorest.NewErrorWithError(err, "network.SecurityGroupsClient", "CreateOrUpdate", nil, "Failure preparing request")
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">if etag != "" </span><span class="cov0" title="0">{
                req.Header.Add("If-Match", etag)
        }</span>

        <span class="cov0" title="0">createFuture, err := ac.securitygroups.CreateOrUpdateSender(req)
        if err != nil </span><span class="cov0" title="0">{
                err = autorest.NewErrorWithError(err, "network.SecurityGroupsClient", "CreateOrUpdate", createFuture.Response(), "Failure sending request")
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = createFuture.WaitForCompletionRef(ctx, ac.securitygroups.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return nil, &amp;createFuture, err
        }</span>
        <span class="cov0" title="0">result, err = createFuture.Result(ac.securitygroups)
        // if the operation completed, return a nil future.
        return result, nil, err</span>
}

// Delete deletes the specified network security group. DeleteAsync sends a DELETE
// request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *azureClient) DeleteAsync(ctx context.Context, spec azure.ResourceSpecGetter) (future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "securitygroups.azureClient.Delete")
        defer done()

        deleteFuture, err := ac.securitygroups.Delete(ctx, spec.ResourceGroupName(), spec.ResourceName())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = deleteFuture.WaitForCompletionRef(ctx, ac.securitygroups.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return &amp;deleteFuture, err
        }</span>
        <span class="cov0" title="0">_, err = deleteFuture.Result(ac.securitygroups)
        // if the operation completed, return a nil future.
        return nil, err</span>
}

// IsDone returns true if the long-running operation has completed.
func (ac *azureClient) IsDone(ctx context.Context, future azureautorest.FutureAPI) (isDone bool, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "securitygroups.azureClient.IsDone")
        defer done()

        isDone, err = future.DoneWithContext(ctx, ac.securitygroups)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "failed checking if the operation was complete")
        }</span>

        <span class="cov0" title="0">return isDone, nil</span>
}

// Result fetches the result of a long-running operation future.
func (ac *azureClient) Result(ctx context.Context, future azureautorest.FutureAPI, futureType string) (result interface{}, err error) <span class="cov0" title="0">{
        _, _, done := tele.StartSpanWithLogger(ctx, "securitygroups.azureClient.Result")
        defer done()

        if future == nil </span><span class="cov0" title="0">{
                return nil, errors.Errorf("cannot get result from nil future")
        }</span>

        <span class="cov0" title="0">switch futureType </span>{
        case infrav1.PutFuture:<span class="cov0" title="0">
                // Marshal and Unmarshal the future to put it into the correct future type so we can access the Result function.
                // Unfortunately the FutureAPI can't be casted directly to SecurityGroupsCreateOrUpdateFuture because it is a azureautorest.Future, which doesn't implement the Result function. See PR #1686 for discussion on alternatives.
                // It was converted back to a generic azureautorest.Future from the CAPZ infrav1.Future type stored in Status: https://github.com/kubernetes-sigs/cluster-api-provider-azure/blob/main/azure/converters/futures.go#L49.
                var createFuture *network.SecurityGroupsCreateOrUpdateFuture
                jsonData, err := future.MarshalJSON()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to marshal future")
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal(jsonData, &amp;createFuture); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to unmarshal future data")
                }</span>
                <span class="cov0" title="0">return createFuture.Result(ac.securitygroups)</span>

        case infrav1.DeleteFuture:<span class="cov0" title="0">
                // Delete does not return a result security group.
                return nil, nil</span>

        default:<span class="cov0" title="0">
                return nil, errors.Errorf("unknown future type %q", futureType)</span>
        }
}
</pre>
		
		<pre class="file" id="file135" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package securitygroups

import (
        "context"

        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/async"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

const serviceName = "securitygroups"

// NSGScope defines the scope interface for a security groups service.
type NSGScope interface {
        azure.Authorizer
        azure.AsyncStatusUpdater
        NSGSpecs() []azure.ResourceSpecGetter
        IsVnetManaged() bool
}

// Service provides operations on Azure resources.
type Service struct {
        Scope NSGScope
        async.Reconciler
}

// New creates a new service.
func New(scope NSGScope) *Service <span class="cov0" title="0">{
        client := newClient(scope)
        return &amp;Service{
                Scope:      scope,
                Reconciler: async.New(scope, client, client),
        }
}</span>

// Name returns the service name.
func (s *Service) Name() string <span class="cov0" title="0">{
        return serviceName
}</span>

// Reconcile gets/creates/updates network security groups.
func (s *Service) Reconcile(ctx context.Context) error <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "securitygroups.Service.Reconcile")
        defer done()

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        // Only create the NSGs if their lifecycle is managed by this controller.
        if managed, err := s.IsManaged(ctx); err == nil &amp;&amp; !managed </span><span class="cov8" title="1">{
                log.V(4).Info("Skipping network security groups reconcile in custom VNet mode")
                return nil
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to check if security groups are managed")
        }</span>

        <span class="cov8" title="1">specs := s.Scope.NSGSpecs()
        if len(specs) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">var resErr error

        // We go through the list of security groups to reconcile each one, independently of the result of the previous one.
        // If multiple errors occur, we return the most pressing one.
        //  Order of precedence (highest -&gt; lowest) is: error that is not an operationNotDoneError (i.e. error creating) -&gt; operationNotDoneError (i.e. creating in progress) -&gt; no error (i.e. created)
        for _, nsgSpec := range specs </span><span class="cov8" title="1">{
                if _, err := s.CreateResource(ctx, nsgSpec, serviceName); err != nil </span><span class="cov8" title="1">{
                        if !azure.IsOperationNotDoneError(err) || resErr == nil </span><span class="cov8" title="1">{
                                resErr = err
                        }</span>
                }
        }

        <span class="cov8" title="1">s.Scope.UpdatePutStatus(infrav1.SecurityGroupsReadyCondition, serviceName, resErr)
        return resErr</span>
}

// Delete deletes network security groups.
func (s *Service) Delete(ctx context.Context) error <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "securitygroups.Service.Delete")
        defer done()

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        // Only delete the security groups if their lifecycle is managed by this controller.
        if managed, err := s.IsManaged(ctx); err == nil &amp;&amp; !managed </span><span class="cov8" title="1">{
                log.V(4).Info("Skipping network security groups delete in custom VNet mode")
                return nil
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to check if security groups are managed")
        }</span>

        <span class="cov8" title="1">specs := s.Scope.NSGSpecs()
        if len(specs) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">var result error

        // We go through the list of security groups to delete each one, independently of the result of the previous one.
        // If multiple errors occur, we return the most pressing one.
        //  Order of precedence (highest -&gt; lowest) is: error that is not an operationNotDoneError (i.e. error deleting) -&gt; operationNotDoneError (i.e. deleting in progress) -&gt; no error (i.e. deleted)
        for _, nsgSpec := range specs </span><span class="cov8" title="1">{
                if err := s.DeleteResource(ctx, nsgSpec, serviceName); err != nil </span><span class="cov8" title="1">{
                        if !azure.IsOperationNotDoneError(err) || result == nil </span><span class="cov8" title="1">{
                                result = err
                        }</span>
                }
        }

        <span class="cov8" title="1">s.Scope.UpdateDeleteStatus(infrav1.SecurityGroupsReadyCondition, serviceName, result)
        return result</span>
}

// IsManaged returns true if the security groups' lifecycles are managed.
func (s *Service) IsManaged(ctx context.Context) (bool, error) <span class="cov8" title="1">{
        _, _, done := tele.StartSpanWithLogger(ctx, "securitygroups.Service.IsManaged")
        defer done()

        return s.Scope.IsVnetManaged(), nil
}</span>
</pre>
		
		<pre class="file" id="file136" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package securitygroups

import (
        "strings"

        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-08-01/network"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure/converters"
)

// NSGSpec defines the specification for a security group.
type NSGSpec struct {
        Name           string
        SecurityRules  infrav1.SecurityRules
        Location       string
        ClusterName    string
        ResourceGroup  string
        AdditionalTags infrav1.Tags
}

// ResourceName returns the name of the security group.
func (s *NSGSpec) ResourceName() string <span class="cov0" title="0">{
        return s.Name
}</span>

// ResourceGroupName returns the name of the resource group.
func (s *NSGSpec) ResourceGroupName() string <span class="cov0" title="0">{
        return s.ResourceGroup
}</span>

// OwnerResourceName is a no-op for security groups.
func (s *NSGSpec) OwnerResourceName() string <span class="cov0" title="0">{
        return ""
}</span>

// Parameters returns the parameters for the security group.
func (s *NSGSpec) Parameters(existing interface{}) (interface{}, error) <span class="cov8" title="1">{
        securityRules := make([]network.SecurityRule, 0)
        var etag *string

        if existing != nil </span><span class="cov8" title="1">{
                existingNSG, ok := existing.(network.SecurityGroup)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("%T is not a network.SecurityGroup", existing)
                }</span>
                // security group already exists
                // We append the existing NSG etag to the header to ensure we only apply the updates if the NSG has not been modified.
                <span class="cov8" title="1">etag = existingNSG.Etag
                // Check if the expected rules are present
                update := false
                securityRules = *existingNSG.SecurityRules
                for _, rule := range s.SecurityRules </span><span class="cov8" title="1">{
                        sdkRule := converters.SecurityRuleToSDK(rule)
                        if !ruleExists(securityRules, sdkRule) </span><span class="cov8" title="1">{
                                update = true
                                securityRules = append(securityRules, sdkRule)
                        }</span>
                }
                <span class="cov8" title="1">if !update </span><span class="cov8" title="1">{
                        // Skip update for NSG as the required default rules are present
                        return nil, nil
                }</span>
        } else<span class="cov8" title="1"> {
                // new security group
                for _, rule := range s.SecurityRules </span><span class="cov8" title="1">{
                        securityRules = append(securityRules, converters.SecurityRuleToSDK(rule))
                }</span>
        }

        <span class="cov8" title="1">return network.SecurityGroup{
                Location: to.StringPtr(s.Location),
                SecurityGroupPropertiesFormat: &amp;network.SecurityGroupPropertiesFormat{
                        SecurityRules: &amp;securityRules,
                },
                Etag: etag,
                Tags: converters.TagsToMap(infrav1.Build(infrav1.BuildParams{
                        ClusterName: s.ClusterName,
                        Lifecycle:   infrav1.ResourceLifecycleOwned,
                        Name:        to.StringPtr(s.Name),
                        Additional:  s.AdditionalTags,
                })),
        }, nil</span>
}

// TODO: review this logic and make sure it is what we want. It seems incorrect to skip rules that don't have a certain protocol, etc.
func ruleExists(rules []network.SecurityRule, rule network.SecurityRule) bool <span class="cov8" title="1">{
        for _, existingRule := range rules </span><span class="cov8" title="1">{
                if !strings.EqualFold(to.String(existingRule.Name), to.String(rule.Name)) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if !strings.EqualFold(to.String(existingRule.DestinationPortRange), to.String(rule.DestinationPortRange)) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if existingRule.Protocol != network.SecurityRuleProtocolTCP &amp;&amp;
                        existingRule.Access != network.SecurityRuleAccessAllow &amp;&amp;
                        existingRule.Direction != network.SecurityRuleDirectionInbound </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if !strings.EqualFold(to.String(existingRule.SourcePortRange), "*") &amp;&amp;
                        !strings.EqualFold(to.String(existingRule.SourceAddressPrefix), "*") &amp;&amp;
                        !strings.EqualFold(to.String(existingRule.DestinationAddressPrefix), "*") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">return true</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file137" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package subnets

import (
        "context"
        "encoding/json"

        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-08-01/network"
        "github.com/Azure/go-autorest/autorest"
        azureautorest "github.com/Azure/go-autorest/autorest/azure"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// AzureClient contains the Azure go-sdk Client.
type AzureClient struct {
        subnets network.SubnetsClient
}

// NewClient creates a new subnets client from subscription ID.
func NewClient(auth azure.Authorizer) *AzureClient <span class="cov0" title="0">{
        c := newSubnetsClient(auth.SubscriptionID(), auth.BaseURI(), auth.Authorizer())
        return &amp;AzureClient{c}
}</span>

// newSubnetsClient creates a new subnets client from subscription ID.
func newSubnetsClient(subscriptionID string, baseURI string, authorizer autorest.Authorizer) network.SubnetsClient <span class="cov0" title="0">{
        subnetsClient := network.NewSubnetsClientWithBaseURI(baseURI, subscriptionID)
        azure.SetAutoRestClientDefaults(&amp;subnetsClient.Client, authorizer)
        return subnetsClient
}</span>

// Get gets the specified subnet by virtual network and resource group.
func (ac *AzureClient) Get(ctx context.Context, spec azure.ResourceSpecGetter) (result interface{}, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "subnets.AzureClient.Get")
        defer done()

        return ac.subnets.Get(ctx, spec.ResourceGroupName(), spec.OwnerResourceName(), spec.ResourceName(), "")
}</span>

// CreateOrUpdateAsync creates or updates a subnet asynchronously.
// It sends a PUT request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *AzureClient) CreateOrUpdateAsync(ctx context.Context, spec azure.ResourceSpecGetter, parameters interface{}) (result interface{}, future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "subnets.AzureClient.CreateOrUpdateAsync")
        defer done()

        subnet, ok := parameters.(network.Subnet)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.Errorf("%T is not a network.Subnet", parameters)
        }</span>

        <span class="cov0" title="0">createFuture, err := ac.subnets.CreateOrUpdate(ctx, spec.ResourceGroupName(), spec.OwnerResourceName(), spec.ResourceName(), subnet)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = createFuture.WaitForCompletionRef(ctx, ac.subnets.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return nil, &amp;createFuture, err
        }</span>

        <span class="cov0" title="0">result, err = createFuture.Result(ac.subnets)
        // if the operation completed, return a nil future
        return result, nil, err</span>
}

// DeleteAsync deletes a subnet asynchronously. DeleteAsync sends a DELETE
// request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *AzureClient) DeleteAsync(ctx context.Context, spec azure.ResourceSpecGetter) (future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "subnets.AzureClient.DeleteAsync")
        defer done()

        deleteFuture, err := ac.subnets.Delete(ctx, spec.ResourceGroupName(), spec.OwnerResourceName(), spec.ResourceName())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = deleteFuture.WaitForCompletionRef(ctx, ac.subnets.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return &amp;deleteFuture, err
        }</span>
        <span class="cov0" title="0">_, err = deleteFuture.Result(ac.subnets)
        // if the operation completed, return a nil future.
        return nil, err</span>
}

// IsDone returns true if the long-running operation has completed.
func (ac *AzureClient) IsDone(ctx context.Context, future azureautorest.FutureAPI) (bool, error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "subnets.AzureClient.IsDone")
        defer done()

        isDone, err := future.DoneWithContext(ctx, ac.subnets)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "failed checking if the operation was complete")
        }</span>

        <span class="cov0" title="0">return isDone, nil</span>
}

// Result fetches the result of a long-running operation future.
func (ac *AzureClient) Result(ctx context.Context, future azureautorest.FutureAPI, futureType string) (result interface{}, err error) <span class="cov0" title="0">{
        _, _, done := tele.StartSpanWithLogger(ctx, "subnets.AzureClient.Result")
        defer done()

        if future == nil </span><span class="cov0" title="0">{
                return nil, errors.Errorf("cannot get result from nil future")
        }</span>

        <span class="cov0" title="0">switch futureType </span>{
        case infrav1.PutFuture:<span class="cov0" title="0">
                // Marshal and Unmarshal the future to put it into the correct future type so we can access the Result function.
                // Unfortunately the FutureAPI can't be casted directly to SubnetsCreateOrUpdateFuture because it is a azureautorest.Future, which doesn't implement the Result function. See PR #1686 for discussion on alternatives.
                // It was converted back to a generic azureautorest.Future from the CAPZ infrav1.Future type stored in Status: https://github.com/kubernetes-sigs/cluster-api-provider-azure/blob/main/azure/converters/futures.go#L49.
                var createFuture *network.SubnetsCreateOrUpdateFuture
                jsonData, err := future.MarshalJSON()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to marshal future")
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal(jsonData, &amp;createFuture); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to unmarshal future data")
                }</span>
                <span class="cov0" title="0">return createFuture.Result(ac.subnets)</span>

        case infrav1.DeleteFuture:<span class="cov0" title="0">
                // Delete does not return a result subnet
                return nil, nil</span>

        default:<span class="cov0" title="0">
                return nil, errors.Errorf("unknown future type %q", futureType)</span>
        }
}
</pre>
		
		<pre class="file" id="file138" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package subnets

import (
        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-08-01/network"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
)

// SubnetSpec defines the specification for a Subnet.
type SubnetSpec struct {
        Name              string
        ResourceGroup     string
        SubscriptionID    string
        CIDRs             []string
        VNetName          string
        VNetResourceGroup string
        IsVNetManaged     bool
        RouteTableName    string
        SecurityGroupName string
        Role              infrav1.SubnetRole
        NatGatewayName    string
}

// ResourceName returns the name of the subnet.
func (s *SubnetSpec) ResourceName() string <span class="cov8" title="1">{
        return s.Name
}</span>

// ResourceGroupName returns the name of the resource group of the VNet that owns this subnet.
func (s *SubnetSpec) ResourceGroupName() string <span class="cov0" title="0">{
        return s.VNetResourceGroup
}</span>

// OwnerResourceName returns the name of the VNet that owns this subnet.
func (s *SubnetSpec) OwnerResourceName() string <span class="cov0" title="0">{
        return s.VNetName
}</span>

// Parameters returns the parameters for the subnet.
func (s *SubnetSpec) Parameters(existing interface{}) (parameters interface{}, err error) <span class="cov8" title="1">{
        if existing != nil </span><span class="cov8" title="1">{
                _, ok := existing.(network.Subnet)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("%T is not a network.Subnet", existing)
                }</span>

                <span class="cov8" title="1">return nil, nil</span>
        }

        <span class="cov8" title="1">if !s.IsVNetManaged </span><span class="cov8" title="1">{
                // TODO: change this to terminal error once we add support for handling them
                return nil, errors.Errorf("custom vnet was provided but subnet %s is missing", s.Name)
        }</span>
        <span class="cov8" title="1">subnetProperties := network.SubnetPropertiesFormat{
                AddressPrefixes: &amp;s.CIDRs,
        }

        // workaround needed to avoid SubscriptionNotRegisteredForFeature for feature Microsoft.Network/AllowMultipleAddressPrefixesOnSubnet.
        if len(s.CIDRs) == 1 </span><span class="cov8" title="1">{
                subnetProperties = network.SubnetPropertiesFormat{
                        AddressPrefix: &amp;s.CIDRs[0],
                }
        }</span>

        <span class="cov8" title="1">if s.RouteTableName != "" </span><span class="cov8" title="1">{
                subnetProperties.RouteTable = &amp;network.RouteTable{
                        ID: to.StringPtr(azure.RouteTableID(s.SubscriptionID, s.ResourceGroup, s.RouteTableName)),
                }
        }</span>

        <span class="cov8" title="1">if s.NatGatewayName != "" </span><span class="cov8" title="1">{
                subnetProperties.NatGateway = &amp;network.SubResource{
                        ID: to.StringPtr(azure.NatGatewayID(s.SubscriptionID, s.ResourceGroup, s.NatGatewayName)),
                }
        }</span>

        <span class="cov8" title="1">if s.SecurityGroupName != "" </span><span class="cov8" title="1">{
                subnetProperties.NetworkSecurityGroup = &amp;network.SecurityGroup{
                        ID: to.StringPtr(azure.SecurityGroupID(s.SubscriptionID, s.ResourceGroup, s.SecurityGroupName)),
                }
        }</span>

        <span class="cov8" title="1">return network.Subnet{
                SubnetPropertiesFormat: &amp;subnetProperties,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file139" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package subnets

import (
        "context"

        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-08-01/network"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/converters"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/async"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

const serviceName = "subnets"

// SubnetScope defines the scope interface for a subnet service.
type SubnetScope interface {
        azure.Authorizer
        azure.AsyncStatusUpdater
        UpdateSubnetID(string, string)
        UpdateSubnetCIDRs(string, []string)
        IsVnetManaged() bool
        SubnetSpecs() []azure.ResourceSpecGetter
}

// Service provides operations on Azure resources.
type Service struct {
        Scope SubnetScope
        async.Reconciler
}

// New creates a new service.
func New(scope SubnetScope) *Service <span class="cov0" title="0">{
        Client := NewClient(scope)
        return &amp;Service{
                Scope:      scope,
                Reconciler: async.New(scope, Client, Client),
        }
}</span>

// Name returns the service name.
func (s *Service) Name() string <span class="cov0" title="0">{
        return serviceName
}</span>

// Reconcile gets/creates/updates a subnet.
func (s *Service) Reconcile(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "subnets.Service.Reconcile")
        defer done()

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        specs := s.Scope.SubnetSpecs()
        if len(specs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // We go through the list of SubnetSpecs to reconcile each one, independently of the result of the previous one.
        // If multiple errors occur, we return the most pressing one.
        //  Order of precedence (highest -&gt; lowest) is: error that is not an operationNotDoneError (i.e. error creating) -&gt; operationNotDoneError (i.e. creating in progress) -&gt; no error (i.e. created)
        <span class="cov8" title="1">var resultErr error
        for _, subnetSpec := range specs </span><span class="cov8" title="1">{
                result, err := s.CreateResource(ctx, subnetSpec, serviceName)
                if err != nil </span><span class="cov8" title="1">{
                        if !azure.IsOperationNotDoneError(err) || resultErr == nil </span><span class="cov8" title="1">{
                                resultErr = err
                        }</span>
                } else<span class="cov8" title="1"> {
                        subnet, ok := result.(network.Subnet)
                        if !ok </span><span class="cov8" title="1">{
                                return errors.Errorf("%T is not a network.Subnet", result)
                        }</span>
                        <span class="cov8" title="1">s.Scope.UpdateSubnetID(subnetSpec.ResourceName(), to.String(subnet.ID))
                        s.Scope.UpdateSubnetCIDRs(subnetSpec.ResourceName(), converters.GetSubnetAddresses(subnet))</span>
                }
        }

        <span class="cov8" title="1">if s.Scope.IsVnetManaged() </span><span class="cov8" title="1">{
                s.Scope.UpdatePutStatus(infrav1.SubnetsReadyCondition, serviceName, resultErr)
        }</span>

        <span class="cov8" title="1">return resultErr</span>
}

// Delete deletes the subnet with the provided name.
func (s *Service) Delete(ctx context.Context) error <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "subnets.Service.Delete")
        defer done()

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        if managed, err := s.IsManaged(ctx); err == nil &amp;&amp; !managed </span><span class="cov8" title="1">{
                log.Info("Skipping subnets deletion in custom vnet mode")
                return nil
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to check if subnets are managed")
        }</span>

        <span class="cov8" title="1">specs := s.Scope.SubnetSpecs()
        if len(specs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // We go through the list of SubnetSpecs to delete each one, independently of the result of the previous one.
        // If multiple errors occur, we return the most pressing one.
        //  Order of precedence (highest -&gt; lowest) is: error that is not an operationNotDoneError (i.e. error deleting) -&gt; operationNotDoneError (i.e. deleting in progress) -&gt; no error (i.e. deleted)
        <span class="cov8" title="1">var result error
        for _, subnetSpec := range specs </span><span class="cov8" title="1">{
                if err := s.DeleteResource(ctx, subnetSpec, serviceName); err != nil </span><span class="cov8" title="1">{
                        if !azure.IsOperationNotDoneError(err) || result == nil </span><span class="cov8" title="1">{
                                result = err
                        }</span>
                }
        }

        <span class="cov8" title="1">s.Scope.UpdateDeleteStatus(infrav1.SubnetsReadyCondition, serviceName, result)
        return result</span>
}

// IsManaged returns true if the route tables' lifecycles are managed.
func (s *Service) IsManaged(ctx context.Context) (bool, error) <span class="cov8" title="1">{
        _, _, done := tele.StartSpanWithLogger(ctx, "subnets.Service.IsManaged")
        defer done()

        return s.Scope.IsVnetManaged(), nil
}</span>
</pre>
		
		<pre class="file" id="file140" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tags

import (
        "context"

        "github.com/Azure/azure-sdk-for-go/services/resources/mgmt/2019-10-01/resources"
        "github.com/Azure/go-autorest/autorest"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// client wraps go-sdk.
type client interface {
        GetAtScope(context.Context, string) (resources.TagsResource, error)
        UpdateAtScope(context.Context, string, resources.TagsPatchResource) (resources.TagsResource, error)
}

// azureClient contains the Azure go-sdk Client.
type azureClient struct {
        tags resources.TagsClient
}

var _ client = (*azureClient)(nil)

// newClient creates a new tags client from subscription ID.
func newClient(auth azure.Authorizer) *azureClient <span class="cov0" title="0">{
        c := newTagsClient(auth.SubscriptionID(), auth.BaseURI(), auth.Authorizer())
        return &amp;azureClient{c}
}</span>

// newTagsClient creates a new tags client from subscription ID.
func newTagsClient(subscriptionID string, baseURI string, authorizer autorest.Authorizer) resources.TagsClient <span class="cov0" title="0">{
        tagsClient := resources.NewTagsClientWithBaseURI(baseURI, subscriptionID)
        azure.SetAutoRestClientDefaults(&amp;tagsClient.Client, authorizer)
        return tagsClient
}</span>

// GetAtScope sends the get at scope request.
func (ac *azureClient) GetAtScope(ctx context.Context, scope string) (resources.TagsResource, error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "tags.AzureClient.GetAtScope")
        defer done()

        return ac.tags.GetAtScope(ctx, scope)
}</span>

// UpdateAtScope this operation allows replacing, merging or selectively deleting tags on the specified resource or
// subscription.
func (ac *azureClient) UpdateAtScope(ctx context.Context, scope string, parameters resources.TagsPatchResource) (resources.TagsResource, error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "tags.AzureClient.UpdateAtScope")
        defer done()

        return ac.tags.UpdateAtScope(ctx, scope, parameters)
}</span>
</pre>
		
		<pre class="file" id="file141" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tags

import (
        "context"

        "github.com/Azure/azure-sdk-for-go/services/resources/mgmt/2019-10-01/resources"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/converters"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

const serviceName = "tags"

// TagScope defines the scope interface for a tags service.
type TagScope interface {
        azure.Authorizer
        ClusterName() string
        TagsSpecs() []azure.TagsSpec
        AnnotationJSON(string) (map[string]interface{}, error)
        UpdateAnnotationJSON(string, map[string]interface{}) error
}

// Service provides operations on Azure resources.
type Service struct {
        Scope TagScope
        client
}

// New creates a new service.
func New(scope TagScope) *Service <span class="cov0" title="0">{
        return &amp;Service{
                Scope:  scope,
                client: newClient(scope),
        }
}</span>

// Name returns the service name.
func (s *Service) Name() string <span class="cov0" title="0">{
        return serviceName
}</span>

// Reconcile ensures tags are correct.
func (s *Service) Reconcile(ctx context.Context) error <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "tags.Service.Reconcile")
        defer done()

        for _, tagsSpec := range s.Scope.TagsSpecs() </span><span class="cov8" title="1">{
                existingTags, err := s.client.GetAtScope(ctx, tagsSpec.Scope)
                if err != nil </span><span class="cov8" title="1">{
                        return errors.Wrap(err, "failed to get existing tags")
                }</span>
                <span class="cov8" title="1">tags := make(map[string]*string)
                if existingTags.Properties != nil &amp;&amp; existingTags.Properties.Tags != nil </span><span class="cov8" title="1">{
                        tags = existingTags.Properties.Tags
                }</span>

                <span class="cov8" title="1">if !s.isResourceManaged(tags) </span><span class="cov8" title="1">{
                        log.V(4).Info("Skipping tags reconcile for not managed resource")
                        continue</span>
                }

                <span class="cov8" title="1">lastAppliedTags, err := s.Scope.AnnotationJSON(tagsSpec.Annotation)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">changed, createdOrUpdated, deleted, newAnnotation := tagsChanged(lastAppliedTags, tagsSpec.Tags, tags)
                if changed </span><span class="cov8" title="1">{
                        log.V(2).Info("Updating tags")
                        if len(createdOrUpdated) &gt; 0 </span><span class="cov8" title="1">{
                                createdOrUpdatedTags := make(map[string]*string)
                                for k, v := range createdOrUpdated </span><span class="cov8" title="1">{
                                        createdOrUpdatedTags[k] = to.StringPtr(v)
                                }</span>

                                <span class="cov8" title="1">if _, err := s.client.UpdateAtScope(ctx, tagsSpec.Scope, resources.TagsPatchResource{Operation: "Merge", Properties: &amp;resources.Tags{Tags: createdOrUpdatedTags}}); err != nil </span><span class="cov8" title="1">{
                                        return errors.Wrap(err, "cannot update tags")
                                }</span>
                        }

                        <span class="cov8" title="1">if len(deleted) &gt; 0 </span><span class="cov8" title="1">{
                                deletedTags := make(map[string]*string)
                                for k, v := range deleted </span><span class="cov8" title="1">{
                                        deletedTags[k] = to.StringPtr(v)
                                }</span>

                                <span class="cov8" title="1">if _, err := s.client.UpdateAtScope(ctx, tagsSpec.Scope, resources.TagsPatchResource{Operation: "Delete", Properties: &amp;resources.Tags{Tags: deletedTags}}); err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "cannot update tags")
                                }</span>
                        }

                        // We also need to update the annotation if anything changed.
                        <span class="cov8" title="1">if err := s.Scope.UpdateAnnotationJSON(tagsSpec.Annotation, newAnnotation); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">log.V(2).Info("successfully updated tags")</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *Service) isResourceManaged(tags map[string]*string) bool <span class="cov8" title="1">{
        return converters.MapToTags(tags).HasOwned(s.Scope.ClusterName())
}</span>

// Delete is a no-op as the tags get deleted as part of VM deletion.
func (s *Service) Delete(ctx context.Context) error <span class="cov0" title="0">{
        _, _, done := tele.StartSpanWithLogger(ctx, "tags.Service.Delete")
        defer done()

        return nil
}</span>

// tagsChanged determines which tags to delete and which to add.
func tagsChanged(lastAppliedTags map[string]interface{}, desiredTags map[string]string, currentTags map[string]*string) (change bool, createOrUpdates map[string]string, deletes map[string]string, annotation map[string]interface{}) <span class="cov8" title="1">{
        // Bool tracking if we found any changed state.
        changed := false

        // Tracking for created/updated
        createdOrUpdated := map[string]string{}

        // Tracking for tags that were deleted.
        deleted := map[string]string{}

        // The new annotation that we need to set if anything is created/updated.
        newAnnotation := map[string]interface{}{}

        // Loop over lastAppliedTags, checking if entries are in desiredTags.
        // If an entry is present in lastAppliedTags but not in desiredTags, it has been deleted
        // since last time. We flag this in the deleted map.
        for t, v := range lastAppliedTags </span><span class="cov8" title="1">{
                _, ok := desiredTags[t]

                // Entry isn't in desiredTags, it has been deleted.
                if !ok </span><span class="cov8" title="1">{
                        // Cast v to a string here. This should be fine, tags are always
                        // strings.
                        deleted[t] = v.(string)
                        changed = true
                }</span>
        }

        // Loop over desiredTags, checking for entries in currentTags.
        //
        // If an entry is in desiredTags, but not currentTags, it has been created since
        // last time, or some external entity deleted it.
        //
        // If an entry is in both desiredTags and currentTags, we compare their values, if
        // the value in desiredTags differs from that in currentTags, the tag has been
        // updated since last time or some external entity modified it.
        <span class="cov8" title="1">for t, v := range desiredTags </span><span class="cov8" title="1">{
                av, ok := currentTags[t]

                // Entries in the desiredTags always need to be noted in the newAnnotation. We
                // know they're going to be created or updated.
                newAnnotation[t] = v

                // Entry isn't in desiredTags, it's new.
                if !ok </span><span class="cov8" title="1">{
                        createdOrUpdated[t] = v
                        newAnnotation[t] = v
                        changed = true
                        continue</span>
                }

                // Entry is in desiredTags, has the value changed?
                <span class="cov8" title="1">if v != *av </span><span class="cov8" title="1">{
                        createdOrUpdated[t] = v
                        changed = true
                }</span>

                // Entry existed in both desiredTags and desiredTags, and their values were
                // equal. Nothing to do.
        }

        // We made it through the loop, and everything that was in desiredTags, was also
        // in dst. Nothing changed.
        <span class="cov8" title="1">return changed, createdOrUpdated, deleted, newAnnotation</span>
}

// IsManaged returns always returns true as CAPZ does not support BYO tags.
func (s *Service) IsManaged(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>
</pre>
		
		<pre class="file" id="file142" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package virtualmachineimages

import (
        "context"
        "sync"
        "time"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-11-01/compute"
        "github.com/pkg/errors"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/cache/ttllru"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// Key contains the fields necessary to locate a VM image list resource.
type Key struct {
        location  string
        publisher string
        offer     string
        sku       string
}

// Cache stores VM image list resources.
type Cache struct {
        client Client
        data   map[Key]compute.ListVirtualMachineImageResource
}

// Cacher allows getting items from and adding them to a cache.
type Cacher interface {
        Get(key interface{}) (value interface{}, ok bool)
        Add(key interface{}, value interface{}) bool
}

var (
        _           Client = &amp;AzureClient{}
        doOnce      sync.Once
        clientCache Cacher
)

// newCache instantiates a cache.
func newCache(auth azure.Authorizer) *Cache <span class="cov8" title="1">{
        return &amp;Cache{
                client: NewClient(auth),
        }
}</span>

// GetCache either creates a new VM images cache or returns the existing one.
func GetCache(auth azure.Authorizer) (*Cache, error) <span class="cov8" title="1">{
        var err error
        doOnce.Do(func() </span><span class="cov8" title="1">{
                clientCache, err = ttllru.New(128, 1*time.Hour)
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed creating LRU cache for VM images")
        }</span>

        <span class="cov8" title="1">key := auth.HashKey()
        c, ok := clientCache.Get(key)
        if ok </span><span class="cov0" title="0">{
                return c.(*Cache), nil
        }</span>

        <span class="cov8" title="1">c = newCache(auth)
        _ = clientCache.Add(key, c)
        return c.(*Cache), nil</span>
}

// refresh fetches a VM image list resource from Azure and stores it in the cache.
func (c *Cache) refresh(ctx context.Context, key Key) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "virtualmachineimages.Cache.refresh")
        defer done()

        data, err := c.client.List(ctx, key.location, key.publisher, key.offer, key.sku)
        if err != nil </span><span class="cov8" title="1">{
                return errors.Wrap(err, "failed to refresh VM images cache")
        }</span>

        <span class="cov8" title="1">c.data[key] = data

        return nil</span>
}

// Get returns a VM image list resource in a location given a publisher, offer, and sku.
func (c *Cache) Get(ctx context.Context, location, publisher, offer, sku string) (compute.ListVirtualMachineImageResource, error) <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "virtualmachineimages.Cache.Get")
        defer done()

        if c.data == nil </span><span class="cov8" title="1">{
                c.data = make(map[Key]compute.ListVirtualMachineImageResource)
        }</span>

        <span class="cov8" title="1">key := Key{
                location:  location,
                publisher: publisher,
                offer:     offer,
                sku:       sku,
        }

        if _, ok := c.data[key]; !ok </span><span class="cov8" title="1">{
                log.Info("VM images cache miss", "location", key.location, "publisher", key.publisher, "offer", key.offer, "sku", key.sku)
                if err := c.refresh(ctx, key); err != nil </span><span class="cov8" title="1">{
                        return compute.ListVirtualMachineImageResource{}, err
                }</span>
        } else<span class="cov0" title="0"> {
                log.Info("VM images cache hit", "location", key.location, "publisher", key.publisher, "offer", key.offer, "sku", key.sku)
        }</span>

        <span class="cov8" title="1">return c.data[key], nil</span>
}
</pre>
		
		<pre class="file" id="file143" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package virtualmachineimages

import (
        "context"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-11-01/compute"
        "github.com/Azure/go-autorest/autorest"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// Client is an interface for listing VM images.
type Client interface {
        List(ctx context.Context, location, publisher, offer, sku string) (compute.ListVirtualMachineImageResource, error)
}

// AzureClient contains the Azure go-sdk Client.
type AzureClient struct {
        images compute.VirtualMachineImagesClient
}

var _ Client = (*AzureClient)(nil)

// NewClient creates a new VM images client from auth info.
func NewClient(auth azure.Authorizer) *AzureClient <span class="cov8" title="1">{
        return &amp;AzureClient{
                images: newVirtualMachineImagesClient(auth.SubscriptionID(), auth.BaseURI(), auth.Authorizer()),
        }
}</span>

// newVirtualMachineImagesClient creates a new VM images client from subscription ID, base URI and authorizer.
func newVirtualMachineImagesClient(subscriptionID, baseURI string, authorizer autorest.Authorizer) compute.VirtualMachineImagesClient <span class="cov8" title="1">{
        c := compute.NewVirtualMachineImagesClientWithBaseURI(baseURI, subscriptionID)
        azure.SetAutoRestClientDefaults(&amp;c.Client, authorizer)
        return c
}</span>

// List returns a VM image list resource.
func (ac *AzureClient) List(ctx context.Context, location, publisher, offer, sku string) (compute.ListVirtualMachineImageResource, error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "virtualmachineimages.AzureClient.List")
        defer done()

        // See https://docs.microsoft.com/en-us/odata/concepts/queryoptions-overview for how to use these query options.
        expand, orderby := "", ""
        var top *int32
        return ac.images.List(ctx, location, publisher, offer, sku, expand, top, orderby)
}</span>
</pre>
		
		<pre class="file" id="file144" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package virtualmachineimages

import (
        "context"
        "fmt"
        "sort"
        "strings"

        "github.com/blang/semver"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// Service provides operations on Azure VM Images.
type Service struct {
        Client
        azure.Authorizer
}

// New creates a new VM Images service.
func New(auth azure.Authorizer) *Service <span class="cov0" title="0">{
        return &amp;Service{
                Client:     NewClient(auth),
                Authorizer: auth,
        }
}</span>

// GetDefaultUbuntuImage returns the default image spec for Ubuntu.
func (s *Service) GetDefaultUbuntuImage(ctx context.Context, location, k8sVersion string) (*infrav1.Image, error) <span class="cov8" title="1">{
        v, err := semver.ParseTolerant(k8sVersion)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "unable to parse Kubernetes version \"%s\"", k8sVersion)
        }</span>

        <span class="cov8" title="1">osVersion := getUbuntuOSVersion(v.Major, v.Minor, v.Patch)
        publisher, offer := azure.DefaultImagePublisherID, azure.DefaultImageOfferID
        skuID, version, err := s.getSKUAndVersion(
                ctx, location, publisher, offer, k8sVersion, fmt.Sprintf("ubuntu-%s", osVersion))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to get default image")
        }</span>

        <span class="cov8" title="1">defaultImage := &amp;infrav1.Image{
                Marketplace: &amp;infrav1.AzureMarketplaceImage{
                        ImagePlan: infrav1.ImagePlan{
                                Publisher: publisher,
                                Offer:     offer,
                                SKU:       skuID,
                        },
                        Version: version,
                },
        }

        return defaultImage, nil</span>
}

// GetDefaultWindowsImage returns the default image spec for Windows.
func (s *Service) GetDefaultWindowsImage(ctx context.Context, location, k8sVersion, runtime, osAndVersion string) (*infrav1.Image, error) <span class="cov8" title="1">{
        v122 := semver.MustParse("1.22.0")
        v, err := semver.ParseTolerant(k8sVersion)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrapf(err, "unable to parse Kubernetes version \"%s\"", k8sVersion)
        }</span>

        // If containerd is specified we don't currently support less than 1.22
        <span class="cov8" title="1">if v.LE(v122) &amp;&amp; runtime == "containerd" </span><span class="cov8" title="1">{
                return nil, errors.New("containerd image only supported in 1.22+")
        }</span>

        <span class="cov8" title="1">if osAndVersion == "" </span><span class="cov8" title="1">{
                osAndVersion = azure.DefaultWindowsOsAndVersion
        }</span>

        // Starting with 1.22 we default to containerd for Windows unless the runtime flag is set.
        <span class="cov8" title="1">if v.GE(v122) &amp;&amp; runtime != "dockershim" &amp;&amp; !strings.HasSuffix(osAndVersion, "-containerd") </span><span class="cov8" title="1">{
                osAndVersion += "-containerd"
        }</span>

        <span class="cov8" title="1">publisher, offer := azure.DefaultImagePublisherID, azure.DefaultWindowsImageOfferID
        skuID, version, err := s.getSKUAndVersion(
                ctx, location, publisher, offer, k8sVersion, osAndVersion)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to get default image")
        }</span>

        <span class="cov8" title="1">defaultImage := &amp;infrav1.Image{
                Marketplace: &amp;infrav1.AzureMarketplaceImage{
                        ImagePlan: infrav1.ImagePlan{
                                Publisher: publisher,
                                Offer:     offer,
                                SKU:       skuID,
                        },
                        Version: version,
                },
        }

        return defaultImage, nil</span>
}

// getSKUAndVersion gets the SKU ID and version of the image to use for the provided version of Kubernetes.
// note: osAndVersion is expected to be in the format of {os}-{version} (ex: ubuntu-2004 or windows-2022)
func (s *Service) getSKUAndVersion(ctx context.Context, location, publisher, offer, k8sVersion, osAndVersion string) (skuID string, imageVersion string, err error) <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "virtualmachineimages.Service.getSKUAndVersion")
        defer done()

        log.Info("Getting VM image SKU and version", "location", location, "publisher", publisher, "offer", offer, "k8sVersion", k8sVersion, "osAndVersion", osAndVersion)

        v, err := semver.ParseTolerant(k8sVersion)
        if err != nil </span><span class="cov8" title="1">{
                return "", "", errors.Wrapf(err, "unable to parse Kubernetes version \"%s\" in spec, expected valid SemVer string", k8sVersion)
        }</span>

        // Old SKUs before 1.21.12, 1.22.9, or 1.23.6 are named like "k8s-1dot21dot2-ubuntu-2004".
        <span class="cov8" title="1">if k8sVersionInSKUName(v.Major, v.Minor, v.Patch) </span><span class="cov8" title="1">{
                return fmt.Sprintf("k8s-%ddot%ddot%d-%s", v.Major, v.Minor, v.Patch, osAndVersion), azure.LatestVersion, nil
        }</span>

        // New SKUs don't contain the Kubernetes version and are named like "ubuntu-2004-gen1".
        <span class="cov8" title="1">sku := fmt.Sprintf("%s-gen1", osAndVersion)

        imageCache, err := GetCache(s.Authorizer)
        imageCache.client = s.Client
        if err != nil </span><span class="cov0" title="0">{
                return "", "", errors.Wrap(err, "failed to get image cache")
        }</span>

        <span class="cov8" title="1">listVMImagesResource, err := imageCache.Get(ctx, location, publisher, offer, sku)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", errors.Wrapf(err, "unable to list VM images for publisher \"%s\" offer \"%s\" sku \"%s\"", publisher, offer, sku)
        }</span>

        <span class="cov8" title="1">vmImages := listVMImagesResource.Value
        if vmImages == nil || len(*vmImages) == 0 </span><span class="cov8" title="1">{
                return "", "", errors.Errorf("no VM images found for publisher \"%s\" offer \"%s\" sku \"%s\"", publisher, offer, sku)
        }</span>

        // Sort the VM image names descending, so more recent dates sort first.
        // (The date is encoded into the end of the name, for example "124.0.20220512").
        <span class="cov8" title="1">names := []string{}
        for _, vmImage := range *vmImages </span><span class="cov8" title="1">{
                names = append(names, *vmImage.Name)
        }</span>
        <span class="cov8" title="1">sort.Sort(sort.Reverse(sort.StringSlice(names)))

        // Pick the first (most recent) one whose k8s version matches.
        var version string
        id := fmt.Sprintf("%d%d.%d", v.Major, v.Minor, v.Patch)
        for _, name := range names </span><span class="cov8" title="1">{
                if strings.HasPrefix(name, id) </span><span class="cov8" title="1">{
                        version = name
                        break</span>
                }
        }
        <span class="cov8" title="1">if version == "" </span><span class="cov8" title="1">{
                return "", "", errors.Errorf("no VM image found for publisher \"%s\" offer \"%s\" sku \"%s\" with Kubernetes version \"%s\"", publisher, offer, sku, k8sVersion)
        }</span>

        <span class="cov8" title="1">log.Info("Found VM image SKU and version", "location", location, "publisher", publisher, "offer", offer, "sku", sku, "version", version)

        return sku, version, nil</span>
}

// getUbuntuOSVersion returns the default Ubuntu OS version for the given Kubernetes version.
func getUbuntuOSVersion(major, minor, patch uint64) string <span class="cov8" title="1">{
        // Default to Ubuntu 20.04 LTS, except for k8s versions which have only 18.04 reference images.
        osVersion := "2004"
        if (major == 1 &amp;&amp; minor == 21 &amp;&amp; patch &lt; 2) ||
                (major == 1 &amp;&amp; minor == 20 &amp;&amp; patch &lt; 8) ||
                (major == 1 &amp;&amp; minor == 19 &amp;&amp; patch &lt; 12) ||
                (major == 1 &amp;&amp; minor == 18 &amp;&amp; patch &lt; 20) ||
                (major == 1 &amp;&amp; minor &lt; 18) </span><span class="cov8" title="1">{
                osVersion = "1804"
        }</span>
        <span class="cov8" title="1">return osVersion</span>
}

// k8sVersionInSKUName returns true if the k8s version is in the SKU name (the older style of naming).
func k8sVersionInSKUName(major, minor, patch uint64) bool <span class="cov8" title="1">{
        return (major == 1 &amp;&amp; minor &lt; 21) ||
                (major == 1 &amp;&amp; minor == 21 &amp;&amp; patch &lt;= 12) ||
                (major == 1 &amp;&amp; minor == 22 &amp;&amp; patch &lt;= 9) ||
                (major == 1 &amp;&amp; minor == 23 &amp;&amp; patch &lt;= 6)
}</span>
</pre>
		
		<pre class="file" id="file145" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package virtualmachines

import (
        "context"
        "encoding/json"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-11-01/compute"
        "github.com/Azure/go-autorest/autorest"
        azureautorest "github.com/Azure/go-autorest/autorest/azure"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// AzureClient contains the Azure go-sdk Client.
type AzureClient struct {
        virtualmachines compute.VirtualMachinesClient
}

// NewClient creates a new VM client from subscription ID.
func NewClient(auth azure.Authorizer) *AzureClient <span class="cov0" title="0">{
        c := newVirtualMachinesClient(auth.SubscriptionID(), auth.BaseURI(), auth.Authorizer())
        return &amp;AzureClient{c}
}</span>

// newVirtualMachinesClient creates a new VM client from subscription ID.
func newVirtualMachinesClient(subscriptionID string, baseURI string, authorizer autorest.Authorizer) compute.VirtualMachinesClient <span class="cov0" title="0">{
        vmClient := compute.NewVirtualMachinesClientWithBaseURI(baseURI, subscriptionID)
        azure.SetAutoRestClientDefaults(&amp;vmClient.Client, authorizer)
        return vmClient
}</span>

// Get retrieves information about the model view or the instance view of a virtual machine.
func (ac *AzureClient) Get(ctx context.Context, spec azure.ResourceSpecGetter) (result interface{}, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "virtualmachines.AzureClient.Get")
        defer done()

        return ac.virtualmachines.Get(ctx, spec.ResourceGroupName(), spec.ResourceName(), "")
}</span>

// CreateOrUpdateAsync creates or updates a virtual machine asynchronously.
// It sends a PUT request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *AzureClient) CreateOrUpdateAsync(ctx context.Context, spec azure.ResourceSpecGetter, parameters interface{}) (result interface{}, future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "virtualmachines.AzureClient.CreateOrUpdate")
        defer done()

        vm, ok := parameters.(compute.VirtualMachine)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.Errorf("%T is not a compute.VirtualMachine", parameters)
        }</span>

        <span class="cov0" title="0">createFuture, err := ac.virtualmachines.CreateOrUpdate(ctx, spec.ResourceGroupName(), spec.ResourceName(), vm)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = createFuture.WaitForCompletionRef(ctx, ac.virtualmachines.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return nil, &amp;createFuture, err
        }</span>
        <span class="cov0" title="0">result, err = createFuture.Result(ac.virtualmachines)
        // if the operation completed, return a nil future
        return result, nil, err</span>
}

// DeleteAsync deletes a virtual machine asynchronously. DeleteAsync sends a DELETE
// request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *AzureClient) DeleteAsync(ctx context.Context, spec azure.ResourceSpecGetter) (future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "virtualmachines.AzureClient.Delete")
        defer done()

        forceDelete := to.BoolPtr(true)
        deleteFuture, err := ac.virtualmachines.Delete(ctx, spec.ResourceGroupName(), spec.ResourceName(), forceDelete)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = deleteFuture.WaitForCompletionRef(ctx, ac.virtualmachines.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return &amp;deleteFuture, err
        }</span>
        <span class="cov0" title="0">_, err = deleteFuture.Result(ac.virtualmachines)
        // if the operation completed, return a nil future.
        return nil, err</span>
}

// IsDone returns true if the long-running operation has completed.
func (ac *AzureClient) IsDone(ctx context.Context, future azureautorest.FutureAPI) (isDone bool, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "virtualmachines.AzureClient.IsDone")
        defer done()

        isDone, err = future.DoneWithContext(ctx, ac.virtualmachines)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "failed checking if the operation was complete")
        }</span>

        <span class="cov0" title="0">return isDone, nil</span>
}

// Result fetches the result of a long-running operation future.
func (ac *AzureClient) Result(ctx context.Context, future azureautorest.FutureAPI, futureType string) (result interface{}, err error) <span class="cov0" title="0">{
        _, _, done := tele.StartSpanWithLogger(ctx, "virtualmachines.AzureClient.Result")
        defer done()

        if future == nil </span><span class="cov0" title="0">{
                return nil, errors.Errorf("cannot get result from nil future")
        }</span>

        <span class="cov0" title="0">switch futureType </span>{
        case infrav1.PatchFuture:<span class="cov0" title="0">
                // Marshal and Unmarshal the future to put it into the correct future type so we can access the Result function.
                // Unfortunately the FutureAPI can't be casted directly to VirtualMachinesUpdateFuture because it is a azureautorest.Future, which doesn't implement the Result function. See PR #1686 for discussion on alternatives.
                // It was converted back to a generic azureautorest.Future from the CAPZ infrav1.Future type stored in Status: https://github.com/kubernetes-sigs/cluster-api-provider-azure/blob/main/azure/converters/futures.go#L49.
                var updateFuture *compute.VirtualMachinesUpdateFuture
                jsonData, err := future.MarshalJSON()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to marshal future")
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal(jsonData, &amp;updateFuture); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to unmarshal future data")
                }</span>
                <span class="cov0" title="0">return updateFuture.Result(ac.virtualmachines)</span>

        case infrav1.PutFuture:<span class="cov0" title="0">
                // Marshal and Unmarshal the future to put it into the correct future type so we can access the Result function.
                // Unfortunately the FutureAPI can't be casted directly to VirtualMachinesCreateOrUpdateFuture because it is a azureautorest.Future, which doesn't implement the Result function. See PR #1686 for discussion on alternatives.
                // It was converted back to a generic azureautorest.Future from the CAPZ infrav1.Future type stored in Status: https://github.com/kubernetes-sigs/cluster-api-provider-azure/blob/main/azure/converters/futures.go#L49.
                var createFuture *compute.VirtualMachinesCreateOrUpdateFuture
                jsonData, err := future.MarshalJSON()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to marshal future")
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal(jsonData, &amp;createFuture); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to unmarshal future data")
                }</span>
                <span class="cov0" title="0">return createFuture.Result(ac.virtualmachines)</span>

        case infrav1.DeleteFuture:<span class="cov0" title="0">
                // Delete does not return a result VM.
                return nil, nil</span>

        default:<span class="cov0" title="0">
                return nil, errors.Errorf("unknown future type %q", futureType)</span>
        }
}
</pre>
		
		<pre class="file" id="file146" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package virtualmachines

import (
        "encoding/base64"
        "fmt"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-11-01/compute"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/converters"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/resourceskus"
        "sigs.k8s.io/cluster-api-provider-azure/util/generators"
)

// VMSpec defines the specification for a Virtual Machine.
type VMSpec struct {
        Name                   string
        ResourceGroup          string
        Location               string
        ClusterName            string
        Role                   string
        NICIDs                 []string
        SSHKeyData             string
        Size                   string
        AvailabilitySetID      string
        Zone                   string
        Identity               infrav1.VMIdentity
        OSDisk                 infrav1.OSDisk
        DataDisks              []infrav1.DataDisk
        UserAssignedIdentities []infrav1.UserAssignedIdentity
        SpotVMOptions          *infrav1.SpotVMOptions
        SecurityProfile        *infrav1.SecurityProfile
        AdditionalTags         infrav1.Tags
        AdditionalCapabilities *infrav1.AdditionalCapabilities
        SKU                    resourceskus.SKU
        Image                  *infrav1.Image
        BootstrapData          string
        ProviderID             string
}

// ResourceName returns the name of the virtual machine.
func (s *VMSpec) ResourceName() string <span class="cov0" title="0">{
        return s.Name
}</span>

// ResourceGroupName returns the name of the virtual machine.
func (s *VMSpec) ResourceGroupName() string <span class="cov8" title="1">{
        return s.ResourceGroup
}</span>

// OwnerResourceName is a no-op for virtual machines.
func (s *VMSpec) OwnerResourceName() string <span class="cov0" title="0">{
        return ""
}</span>

// Parameters returns the parameters for the virtual machine.
func (s *VMSpec) Parameters(existing interface{}) (params interface{}, err error) <span class="cov8" title="1">{
        if existing != nil </span><span class="cov8" title="1">{
                if _, ok := existing.(compute.VirtualMachine); !ok </span><span class="cov8" title="1">{
                        return nil, errors.Errorf("%T is not a compute.VirtualMachine", existing)
                }</span>
                // vm already exists
                <span class="cov8" title="1">return nil, nil</span>
        }

        // VM got deleted outside of capz, do not recreate it as Machines are immutable.
        <span class="cov8" title="1">if s.ProviderID != "" </span><span class="cov8" title="1">{
                return nil, azure.VMDeletedError{ProviderID: s.ProviderID}
        }</span>

        <span class="cov8" title="1">storageProfile, err := s.generateStorageProfile()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">securityProfile, err := s.generateSecurityProfile()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">osProfile, err := s.generateOSProfile()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to generate OS Profile")
        }</span>

        <span class="cov8" title="1">priority, evictionPolicy, billingProfile, err := converters.GetSpotVMOptions(s.SpotVMOptions, s.OSDisk.DiffDiskSettings)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to get Spot VM options")
        }</span>

        <span class="cov8" title="1">identity, err := converters.VMIdentityToVMSDK(s.Identity, s.UserAssignedIdentities)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to generate VM identity")
        }</span>

        <span class="cov8" title="1">return compute.VirtualMachine{
                Plan:     converters.ImageToPlan(s.Image),
                Location: to.StringPtr(s.Location),
                Tags: converters.TagsToMap(infrav1.Build(infrav1.BuildParams{
                        ClusterName: s.ClusterName,
                        Lifecycle:   infrav1.ResourceLifecycleOwned,
                        Name:        to.StringPtr(s.Name),
                        Role:        to.StringPtr(s.Role),
                        Additional:  s.AdditionalTags,
                })),
                VirtualMachineProperties: &amp;compute.VirtualMachineProperties{
                        AdditionalCapabilities: s.generateAdditionalCapabilities(),
                        AvailabilitySet:        s.getAvailabilitySet(),
                        HardwareProfile: &amp;compute.HardwareProfile{
                                VMSize: compute.VirtualMachineSizeTypes(s.Size),
                        },
                        StorageProfile:  storageProfile,
                        SecurityProfile: securityProfile,
                        OsProfile:       osProfile,
                        NetworkProfile: &amp;compute.NetworkProfile{
                                NetworkInterfaces: s.generateNICRefs(),
                        },
                        Priority:       priority,
                        EvictionPolicy: evictionPolicy,
                        BillingProfile: billingProfile,
                        DiagnosticsProfile: &amp;compute.DiagnosticsProfile{
                                BootDiagnostics: &amp;compute.BootDiagnostics{
                                        Enabled: to.BoolPtr(true),
                                },
                        },
                },
                Identity: identity,
                Zones:    s.getZones(),
        }, nil</span>
}

// generateStorageProfile generates a pointer to a compute.StorageProfile which can utilized for VM creation.
func (s *VMSpec) generateStorageProfile() (*compute.StorageProfile, error) <span class="cov8" title="1">{
        storageProfile := &amp;compute.StorageProfile{
                OsDisk: &amp;compute.OSDisk{
                        Name:         to.StringPtr(azure.GenerateOSDiskName(s.Name)),
                        OsType:       compute.OperatingSystemTypes(s.OSDisk.OSType),
                        CreateOption: compute.DiskCreateOptionTypesFromImage,
                        DiskSizeGB:   s.OSDisk.DiskSizeGB,
                        Caching:      compute.CachingTypes(s.OSDisk.CachingType),
                },
        }

        // Checking if the requested VM size has at least 2 vCPUS
        vCPUCapability, err := s.SKU.HasCapabilityWithCapacity(resourceskus.VCPUs, resourceskus.MinimumVCPUS)
        if err != nil </span><span class="cov0" title="0">{
                return nil, azure.WithTerminalError(errors.Wrap(err, "failed to validate the vCPU capability"))
        }</span>
        <span class="cov8" title="1">if !vCPUCapability </span><span class="cov8" title="1">{
                return nil, azure.WithTerminalError(errors.New("vm size should be bigger or equal to at least 2 vCPUs"))
        }</span>

        // Checking if the requested VM size has at least 2 Gi of memory
        <span class="cov8" title="1">MemoryCapability, err := s.SKU.HasCapabilityWithCapacity(resourceskus.MemoryGB, resourceskus.MinimumMemory)
        if err != nil </span><span class="cov0" title="0">{
                return nil, azure.WithTerminalError(errors.Wrap(err, "failed to validate the memory capability"))
        }</span>

        <span class="cov8" title="1">if !MemoryCapability </span><span class="cov8" title="1">{
                return nil, azure.WithTerminalError(errors.New("vm memory should be bigger or equal to at least 2Gi"))
        }</span>
        // enable ephemeral OS
        <span class="cov8" title="1">if s.OSDisk.DiffDiskSettings != nil </span><span class="cov8" title="1">{
                if !s.SKU.HasCapability(resourceskus.EphemeralOSDisk) </span><span class="cov8" title="1">{
                        return nil, azure.WithTerminalError(fmt.Errorf("vm size %s does not support ephemeral os. select a different vm size or disable ephemeral os", s.Size))
                }</span>

                <span class="cov8" title="1">storageProfile.OsDisk.DiffDiskSettings = &amp;compute.DiffDiskSettings{
                        Option: compute.DiffDiskOptions(s.OSDisk.DiffDiskSettings.Option),
                }</span>
        }

        <span class="cov8" title="1">if s.OSDisk.ManagedDisk != nil </span><span class="cov8" title="1">{
                storageProfile.OsDisk.ManagedDisk = &amp;compute.ManagedDiskParameters{}
                if s.OSDisk.ManagedDisk.StorageAccountType != "" </span><span class="cov8" title="1">{
                        storageProfile.OsDisk.ManagedDisk.StorageAccountType = compute.StorageAccountTypes(s.OSDisk.ManagedDisk.StorageAccountType)
                }</span>
                <span class="cov8" title="1">if s.OSDisk.ManagedDisk.DiskEncryptionSet != nil </span><span class="cov8" title="1">{
                        storageProfile.OsDisk.ManagedDisk.DiskEncryptionSet = &amp;compute.DiskEncryptionSetParameters{ID: to.StringPtr(s.OSDisk.ManagedDisk.DiskEncryptionSet.ID)}
                }</span>
        }

        <span class="cov8" title="1">dataDisks := make([]compute.DataDisk, len(s.DataDisks))
        for i, disk := range s.DataDisks </span><span class="cov8" title="1">{
                dataDisks[i] = compute.DataDisk{
                        CreateOption: compute.DiskCreateOptionTypesEmpty,
                        DiskSizeGB:   to.Int32Ptr(disk.DiskSizeGB),
                        Lun:          disk.Lun,
                        Name:         to.StringPtr(azure.GenerateDataDiskName(s.Name, disk.NameSuffix)),
                        Caching:      compute.CachingTypes(disk.CachingType),
                }

                if disk.ManagedDisk != nil </span><span class="cov8" title="1">{
                        dataDisks[i].ManagedDisk = &amp;compute.ManagedDiskParameters{
                                StorageAccountType: compute.StorageAccountTypes(disk.ManagedDisk.StorageAccountType),
                        }

                        if disk.ManagedDisk.DiskEncryptionSet != nil </span><span class="cov8" title="1">{
                                dataDisks[i].ManagedDisk.DiskEncryptionSet = &amp;compute.DiskEncryptionSetParameters{ID: to.StringPtr(disk.ManagedDisk.DiskEncryptionSet.ID)}
                        }</span>

                        // check the support for ultra disks based on location and vm size
                        <span class="cov8" title="1">if disk.ManagedDisk.StorageAccountType == string(compute.StorageAccountTypesUltraSSDLRS) &amp;&amp; !s.SKU.HasLocationCapability(resourceskus.UltraSSDAvailable, s.Location, s.Zone) </span><span class="cov8" title="1">{
                                return nil, azure.WithTerminalError(fmt.Errorf("vm size %s does not support ultra disks in location %s. select a different vm size or disable ultra disks", s.Size, s.Location))
                        }</span>
                }
        }
        <span class="cov8" title="1">storageProfile.DataDisks = &amp;dataDisks

        imageRef, err := converters.ImageToSDK(s.Image)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">storageProfile.ImageReference = imageRef

        return storageProfile, nil</span>
}

func (s *VMSpec) generateOSProfile() (*compute.OSProfile, error) <span class="cov8" title="1">{
        sshKey, err := base64.StdEncoding.DecodeString(s.SSHKeyData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to decode ssh public key")
        }</span>

        <span class="cov8" title="1">osProfile := &amp;compute.OSProfile{
                ComputerName:  to.StringPtr(s.Name),
                AdminUsername: to.StringPtr(azure.DefaultUserName),
                CustomData:    to.StringPtr(s.BootstrapData),
        }

        switch s.OSDisk.OSType </span>{
        case string(compute.OperatingSystemTypesWindows):<span class="cov8" title="1">
                // Cloudbase-init is used to generate a password.
                // https://cloudbase-init.readthedocs.io/en/latest/plugins.html#setting-password-main
                //
                // We generate a random password here in case of failure
                // but the password on the VM will NOT be the same as created here.
                // Access is provided via SSH public key that is set during deployment
                // Azure also provides a way to reset user passwords in the case of need.
                osProfile.AdminPassword = to.StringPtr(generators.SudoRandomPassword(123))
                osProfile.WindowsConfiguration = &amp;compute.WindowsConfiguration{
                        EnableAutomaticUpdates: to.BoolPtr(false),
                }</span>
        default:<span class="cov8" title="1">
                osProfile.LinuxConfiguration = &amp;compute.LinuxConfiguration{
                        DisablePasswordAuthentication: to.BoolPtr(true),
                        SSH: &amp;compute.SSHConfiguration{
                                PublicKeys: &amp;[]compute.SSHPublicKey{
                                        {
                                                Path:    to.StringPtr(fmt.Sprintf("/home/%s/.ssh/authorized_keys", azure.DefaultUserName)),
                                                KeyData: to.StringPtr(string(sshKey)),
                                        },
                                },
                        },
                }</span>
        }

        <span class="cov8" title="1">return osProfile, nil</span>
}

func (s *VMSpec) generateSecurityProfile() (*compute.SecurityProfile, error) <span class="cov8" title="1">{
        if s.SecurityProfile == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">if !s.SKU.HasCapability(resourceskus.EncryptionAtHost) </span><span class="cov8" title="1">{
                return nil, azure.WithTerminalError(errors.Errorf("encryption at host is not supported for VM type %s", s.Size))
        }</span>

        <span class="cov8" title="1">return &amp;compute.SecurityProfile{
                EncryptionAtHost: s.SecurityProfile.EncryptionAtHost,
        }, nil</span>
}

func (s *VMSpec) generateNICRefs() *[]compute.NetworkInterfaceReference <span class="cov8" title="1">{
        nicRefs := make([]compute.NetworkInterfaceReference, len(s.NICIDs))
        for i, id := range s.NICIDs </span><span class="cov8" title="1">{
                primary := i == 0
                nicRefs[i] = compute.NetworkInterfaceReference{
                        ID: to.StringPtr(id),
                        NetworkInterfaceReferenceProperties: &amp;compute.NetworkInterfaceReferenceProperties{
                                Primary: to.BoolPtr(primary),
                        },
                }
        }</span>
        <span class="cov8" title="1">return &amp;nicRefs</span>
}

func (s *VMSpec) generateAdditionalCapabilities() *compute.AdditionalCapabilities <span class="cov8" title="1">{
        var capabilities *compute.AdditionalCapabilities

        // Provisionally detect whether there is any Data Disk defined which uses UltraSSDs.
        // If that's the case, enable the UltraSSD capability.
        for _, dataDisk := range s.DataDisks </span><span class="cov8" title="1">{
                if dataDisk.ManagedDisk != nil &amp;&amp; dataDisk.ManagedDisk.StorageAccountType == string(compute.StorageAccountTypesUltraSSDLRS) </span><span class="cov8" title="1">{
                        capabilities = &amp;compute.AdditionalCapabilities{
                                UltraSSDEnabled: to.BoolPtr(true),
                        }
                        break</span>
                }
        }

        // Set Additional Capabilities if any is present on the spec.
        <span class="cov8" title="1">if s.AdditionalCapabilities != nil </span><span class="cov8" title="1">{
                if capabilities == nil </span><span class="cov8" title="1">{
                        capabilities = &amp;compute.AdditionalCapabilities{}
                }</span>
                // Set UltraSSDEnabled if a specific value is set on the spec for it.
                <span class="cov8" title="1">if s.AdditionalCapabilities.UltraSSDEnabled != nil </span><span class="cov8" title="1">{
                        capabilities.UltraSSDEnabled = s.AdditionalCapabilities.UltraSSDEnabled
                }</span>
        }

        <span class="cov8" title="1">return capabilities</span>
}

func (s *VMSpec) getAvailabilitySet() *compute.SubResource <span class="cov8" title="1">{
        var as *compute.SubResource
        if s.AvailabilitySetID != "" </span><span class="cov8" title="1">{
                as = &amp;compute.SubResource{ID: &amp;s.AvailabilitySetID}
        }</span>
        <span class="cov8" title="1">return as</span>
}

func (s *VMSpec) getZones() *[]string <span class="cov8" title="1">{
        var zones *[]string
        if s.Zone != "" </span><span class="cov8" title="1">{
                zones = &amp;[]string{s.Zone}
        }</span>
        <span class="cov8" title="1">return zones</span>
}
</pre>
		
		<pre class="file" id="file147" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package virtualmachines

import (
        "context"
        "strings"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-11-01/compute"
        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-08-01/network"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        corev1 "k8s.io/api/core/v1"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/converters"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/async"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/networkinterfaces"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/publicips"
        azureutil "sigs.k8s.io/cluster-api-provider-azure/util/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

const serviceName = "virtualmachine"

// VMScope defines the scope interface for a virtual machines service.
type VMScope interface {
        azure.Authorizer
        azure.AsyncStatusUpdater
        VMSpec() azure.ResourceSpecGetter
        SetAnnotation(string, string)
        SetProviderID(string)
        SetAddresses([]corev1.NodeAddress)
        SetVMState(infrav1.ProvisioningState)
}

// Service provides operations on Azure resources.
type Service struct {
        Scope VMScope
        async.Reconciler
        interfacesGetter async.Getter
        publicIPsGetter  async.Getter
}

// New creates a new service.
func New(scope VMScope) *Service <span class="cov0" title="0">{
        Client := NewClient(scope)
        return &amp;Service{
                Scope:            scope,
                interfacesGetter: networkinterfaces.NewClient(scope),
                publicIPsGetter:  publicips.NewClient(scope),
                Reconciler:       async.New(scope, Client, Client),
        }
}</span>

// Name returns the service name.
func (s *Service) Name() string <span class="cov0" title="0">{
        return serviceName
}</span>

// Reconcile gets/creates/updates a virtual machine.
func (s *Service) Reconcile(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "virtualmachines.Service.Reconcile")
        defer done()

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        vmSpec := s.Scope.VMSpec()
        if vmSpec == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">result, err := s.CreateResource(ctx, vmSpec, serviceName)
        s.Scope.UpdatePutStatus(infrav1.VMRunningCondition, serviceName, err)
        // Set the DiskReady condition here since the disk gets created with the VM.
        s.Scope.UpdatePutStatus(infrav1.DisksReadyCondition, serviceName, err)
        if err == nil &amp;&amp; result != nil </span><span class="cov8" title="1">{
                vm, ok := result.(compute.VirtualMachine)
                if !ok </span><span class="cov0" title="0">{
                        return errors.Errorf("%T is not a compute.VirtualMachine", result)
                }</span>
                <span class="cov8" title="1">infraVM := converters.SDKToVM(vm)
                // Transform the VM resource representation to conform to the cloud-provider-azure representation
                providerID, err := azureutil.ConvertResourceGroupNameToLower(azure.ProviderIDPrefix + infraVM.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrapf(err, "failed to parse VM ID %s", infraVM.ID)
                }</span>
                <span class="cov8" title="1">s.Scope.SetProviderID(providerID)
                s.Scope.SetAnnotation("cluster-api-provider-azure", "true")

                // Discover addresses for NICs associated with the VM
                addresses, err := s.getAddresses(ctx, vm, vmSpec.ResourceGroupName())
                if err != nil </span><span class="cov8" title="1">{
                        return errors.Wrap(err, "failed to fetch VM addresses")
                }</span>
                <span class="cov8" title="1">s.Scope.SetAddresses(addresses)
                s.Scope.SetVMState(infraVM.State)</span>
        }
        <span class="cov8" title="1">return err</span>
}

// Delete deletes the virtual machine with the provided name.
func (s *Service) Delete(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "virtualmachines.Service.Delete")
        defer done()

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        vmSpec := s.Scope.VMSpec()
        if vmSpec == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">err := s.DeleteResource(ctx, vmSpec, serviceName)
        if err != nil </span><span class="cov8" title="1">{
                s.Scope.SetVMState(infrav1.Deleting)
        }</span> else<span class="cov8" title="1"> {
                s.Scope.SetVMState(infrav1.Deleted)
        }</span>
        <span class="cov8" title="1">s.Scope.UpdateDeleteStatus(infrav1.VMRunningCondition, serviceName, err)
        return err</span>
}

func (s *Service) getAddresses(ctx context.Context, vm compute.VirtualMachine, rgName string) ([]corev1.NodeAddress, error) <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "virtualmachines.Service.getAddresses")
        defer done()

        addresses := []corev1.NodeAddress{
                {
                        Type:    corev1.NodeInternalDNS,
                        Address: to.String(vm.Name),
                },
        }
        if vm.NetworkProfile.NetworkInterfaces == nil </span><span class="cov0" title="0">{
                return addresses, nil
        }</span>
        <span class="cov8" title="1">for _, nicRef := range *vm.NetworkProfile.NetworkInterfaces </span><span class="cov8" title="1">{
                // The full ID includes the name at the very end. Split the string and pull the last element
                // Ex: /subscriptions/$SUB/resourceGroups/$RG/providers/Microsoft.Network/networkInterfaces/$NICNAME
                // We'll check to see if ID is nil and bail early if we don't have it
                if nicRef.ID == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">nicName := getResourceNameByID(to.String(nicRef.ID))

                // Fetch nic and append its addresses
                existingNic, err := s.interfacesGetter.Get(ctx, &amp;networkinterfaces.NICSpec{
                        Name:          nicName,
                        ResourceGroup: rgName,
                })
                if err != nil </span><span class="cov8" title="1">{
                        return addresses, err
                }</span>

                <span class="cov8" title="1">nic, ok := existingNic.(network.Interface)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("%T is not a network.Interface", existingNic)
                }</span>

                <span class="cov8" title="1">if nic.IPConfigurations == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">for _, ipConfig := range *nic.IPConfigurations </span><span class="cov8" title="1">{
                        if ipConfig.PrivateIPAddress != nil </span><span class="cov8" title="1">{
                                addresses = append(addresses,
                                        corev1.NodeAddress{
                                                Type:    corev1.NodeInternalIP,
                                                Address: to.String(ipConfig.PrivateIPAddress),
                                        },
                                )
                        }</span>

                        <span class="cov8" title="1">if ipConfig.PublicIPAddress == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        // ID is the only field populated in PublicIPAddress sub-resource.
                        // Thus, we have to go fetch the publicIP with the name.
                        <span class="cov8" title="1">publicIPName := getResourceNameByID(to.String(ipConfig.PublicIPAddress.ID))
                        publicNodeAddress, err := s.getPublicIPAddress(ctx, publicIPName, rgName)
                        if err != nil </span><span class="cov8" title="1">{
                                return addresses, err
                        }</span>
                        <span class="cov8" title="1">addresses = append(addresses, publicNodeAddress)</span>
                }
        }

        <span class="cov8" title="1">return addresses, nil</span>
}

// getPublicIPAddress will fetch a public ip address resource by name and return a nodeaddresss representation.
func (s *Service) getPublicIPAddress(ctx context.Context, publicIPAddressName string, rgName string) (corev1.NodeAddress, error) <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "virtualmachines.Service.getPublicIPAddress")
        defer done()

        retAddress := corev1.NodeAddress{}
        result, err := s.publicIPsGetter.Get(ctx, &amp;publicips.PublicIPSpec{
                Name:          publicIPAddressName,
                ResourceGroup: rgName,
        })
        if err != nil </span><span class="cov8" title="1">{
                return retAddress, err
        }</span>

        <span class="cov8" title="1">publicIP, ok := result.(network.PublicIPAddress)
        if !ok </span><span class="cov0" title="0">{
                return retAddress, errors.Errorf("%T is not a network.PublicIPAddress", result)
        }</span>

        <span class="cov8" title="1">retAddress.Type = corev1.NodeExternalIP
        retAddress.Address = to.String(publicIP.IPAddress)

        return retAddress, nil</span>
}

// getResourceNameById takes a resource ID like
// `/subscriptions/$SUB/resourceGroups/$RG/providers/Microsoft.Network/networkInterfaces/$NICNAME`
// and parses out the string after the last slash.
func getResourceNameByID(resourceID string) string <span class="cov8" title="1">{
        explodedResourceID := strings.Split(resourceID, "/")
        resourceName := explodedResourceID[len(explodedResourceID)-1]
        return resourceName
}</span>

// IsManaged returns always returns true as CAPZ does not support BYO VM.
func (s *Service) IsManaged(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>
</pre>
		
		<pre class="file" id="file148" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package virtualnetworks

import (
        "context"
        "encoding/json"

        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-08-01/network"
        "github.com/Azure/go-autorest/autorest"
        azureautorest "github.com/Azure/go-autorest/autorest/azure"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// azureClient contains the Azure go-sdk Client.
type azureClient struct {
        virtualnetworks network.VirtualNetworksClient
}

// newClient creates a new VM client from subscription ID.
func newClient(auth azure.Authorizer) *azureClient <span class="cov0" title="0">{
        c := newVirtualNetworksClient(auth.SubscriptionID(), auth.BaseURI(), auth.Authorizer())
        return &amp;azureClient{
                virtualnetworks: c,
        }
}</span>

// newVirtualNetworksClient creates a new vnet client from subscription ID.
func newVirtualNetworksClient(subscriptionID string, baseURI string, authorizer autorest.Authorizer) network.VirtualNetworksClient <span class="cov0" title="0">{
        vnetsClient := network.NewVirtualNetworksClientWithBaseURI(baseURI, subscriptionID)
        azure.SetAutoRestClientDefaults(&amp;vnetsClient.Client, authorizer)
        return vnetsClient
}</span>

// Get gets the specified virtual network.
func (ac *azureClient) Get(ctx context.Context, spec azure.ResourceSpecGetter) (result interface{}, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "virtualnetworks.azureClient.Get")
        defer done()

        return ac.virtualnetworks.Get(ctx, spec.ResourceGroupName(), spec.ResourceName(), "")
}</span>

// CreateOrUpdateAsync creates or updates a virtual network in the specified resource group asynchronously.
// It sends a PUT request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *azureClient) CreateOrUpdateAsync(ctx context.Context, spec azure.ResourceSpecGetter, parameters interface{}) (result interface{}, future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "virtualnetworks.azureClient.CreateOrUpdateAsync")
        defer done()

        vn, ok := parameters.(network.VirtualNetwork)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.Errorf("%T is not a network.VirtualNetwork", parameters)
        }</span>

        <span class="cov0" title="0">createFuture, err := ac.virtualnetworks.CreateOrUpdate(ctx, spec.ResourceGroupName(), spec.ResourceName(), vn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = createFuture.WaitForCompletionRef(ctx, ac.virtualnetworks.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return nil, &amp;createFuture, err
        }</span>
        <span class="cov0" title="0">result, err = createFuture.Result(ac.virtualnetworks)
        // if the operation completed, return a nil future.
        return result, nil, err</span>
}

// DeleteAsync deletes a virtual network asynchronously. DeleteAsync sends a DELETE
// request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *azureClient) DeleteAsync(ctx context.Context, spec azure.ResourceSpecGetter) (future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "virtualnetworks.azureClient.DeleteAsync")
        defer done()

        deleteFuture, err := ac.virtualnetworks.Delete(ctx, spec.ResourceGroupName(), spec.ResourceName())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = deleteFuture.WaitForCompletionRef(ctx, ac.virtualnetworks.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return &amp;deleteFuture, err
        }</span>
        <span class="cov0" title="0">_, err = deleteFuture.Result(ac.virtualnetworks)
        // if the operation completed, return a nil future.
        return nil, err</span>
}

// IsDone returns true if the long-running operation has completed.
func (ac *azureClient) IsDone(ctx context.Context, future azureautorest.FutureAPI) (isDone bool, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "virtualnetworks.azureClient.IsDone")
        defer done()

        isDone, err = future.DoneWithContext(ctx, ac.virtualnetworks)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "failed checking if the operation was complete")
        }</span>

        <span class="cov0" title="0">return isDone, nil</span>
}

// Result fetches the result of a long-running operation future.
func (ac *azureClient) Result(ctx context.Context, future azureautorest.FutureAPI, futureType string) (result interface{}, err error) <span class="cov0" title="0">{
        _, _, done := tele.StartSpanWithLogger(ctx, "virtualnetworks.azureClient.Result")
        defer done()

        if future == nil </span><span class="cov0" title="0">{
                return nil, errors.Errorf("cannot get result from nil future")
        }</span>

        <span class="cov0" title="0">switch futureType </span>{
        case infrav1.PutFuture:<span class="cov0" title="0">
                // Marshal and Unmarshal the future to put it into the correct future type so we can access the Result function.
                // Unfortunately the FutureAPI can't be casted directly to VirtualNetworksCreateOrUpdateFuture because it is a azureautorest.Future, which doesn't implement the Result function. See PR #1686 for discussion on alternatives.
                // It was converted back to a generic azureautorest.Future from the CAPZ infrav1.Future type stored in Status: https://github.com/kubernetes-sigs/cluster-api-provider-azure/blob/main/azure/converters/futures.go#L49.
                var createFuture *network.VirtualNetworksCreateOrUpdateFuture
                jsonData, err := future.MarshalJSON()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to marshal future")
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal(jsonData, &amp;createFuture); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to unmarshal future data")
                }</span>
                <span class="cov0" title="0">return createFuture.Result(ac.virtualnetworks)</span>

        case infrav1.DeleteFuture:<span class="cov0" title="0">
                // Delete does not return a result vnet.
                return nil, nil</span>

        default:<span class="cov0" title="0">
                return nil, errors.Errorf("unknown future type %q", futureType)</span>
        }
}
</pre>
		
		<pre class="file" id="file149" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package virtualnetworks

import (
        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-08-01/network"
        "github.com/Azure/go-autorest/autorest/to"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure/converters"
)

// VNetSpec defines the specification for a Virtual Network.
type VNetSpec struct {
        ResourceGroup  string
        Name           string
        CIDRs          []string
        Location       string
        ClusterName    string
        AdditionalTags infrav1.Tags
}

// ResourceName returns the name of the vnet.
func (s *VNetSpec) ResourceName() string <span class="cov0" title="0">{
        return s.Name
}</span>

// ResourceGroupName returns the name of the resource group.
func (s *VNetSpec) ResourceGroupName() string <span class="cov0" title="0">{
        return s.ResourceGroup
}</span>

// OwnerResourceName is a no-op for vnets.
func (s *VNetSpec) OwnerResourceName() string <span class="cov0" title="0">{
        return ""
}</span>

// Parameters returns the parameters for the vnet.
func (s *VNetSpec) Parameters(existing interface{}) (interface{}, error) <span class="cov0" title="0">{
        if existing != nil </span><span class="cov0" title="0">{
                // vnet already exists, nothing to update.
                return nil, nil
        }</span>
        <span class="cov0" title="0">return network.VirtualNetwork{
                Tags: converters.TagsToMap(infrav1.Build(infrav1.BuildParams{
                        ClusterName: s.ClusterName,
                        Lifecycle:   infrav1.ResourceLifecycleOwned,
                        Name:        to.StringPtr(s.Name),
                        Role:        to.StringPtr(infrav1.CommonRole),
                        Additional:  s.AdditionalTags,
                })),
                Location: to.StringPtr(s.Location),
                VirtualNetworkPropertiesFormat: &amp;network.VirtualNetworkPropertiesFormat{
                        AddressSpace: &amp;network.AddressSpace{
                                AddressPrefixes: &amp;s.CIDRs,
                        },
                },
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file150" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package virtualnetworks

import (
        "context"

        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-08-01/network"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/converters"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/async"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

const serviceName = "virtualnetworks"

// VNetScope defines the scope interface for a virtual network service.
type VNetScope interface {
        azure.Authorizer
        azure.AsyncStatusUpdater
        Vnet() *infrav1.VnetSpec
        VNetSpec() azure.ResourceSpecGetter
        ClusterName() string
        IsVnetManaged() bool
        UpdateSubnetCIDRs(string, []string)
}

// Service provides operations on Azure resources.
type Service struct {
        Scope VNetScope
        async.Reconciler
        async.Getter
}

// New creates a new service.
func New(scope VNetScope) *Service <span class="cov0" title="0">{
        client := newClient(scope)
        return &amp;Service{
                Scope:      scope,
                Getter:     client,
                Reconciler: async.New(scope, client, client),
        }
}</span>

// Name returns the service name.
func (s *Service) Name() string <span class="cov0" title="0">{
        return serviceName
}</span>

// Reconcile creates and updates a virtual network.
func (s *Service) Reconcile(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "virtualnetworks.Service.Reconcile")
        defer done()

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        vnetSpec := s.Scope.VNetSpec()
        if vnetSpec == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">result, err := s.CreateResource(ctx, vnetSpec, serviceName)
        if err == nil &amp;&amp; result != nil </span><span class="cov8" title="1">{
                existingVnet, ok := result.(network.VirtualNetwork)
                if !ok </span><span class="cov0" title="0">{
                        return errors.Errorf("%T is not a network.VirtualNetwork", result)
                }</span>
                <span class="cov8" title="1">vnet := s.Scope.Vnet()
                vnet.ID = to.String(existingVnet.ID)
                vnet.Tags = converters.MapToTags(existingVnet.Tags)

                var prefixes []string
                if existingVnet.VirtualNetworkPropertiesFormat != nil &amp;&amp; existingVnet.VirtualNetworkPropertiesFormat.AddressSpace != nil </span><span class="cov8" title="1">{
                        prefixes = to.StringSlice(existingVnet.VirtualNetworkPropertiesFormat.AddressSpace.AddressPrefixes)
                }</span>
                <span class="cov8" title="1">vnet.CIDRBlocks = prefixes

                // Update the subnet CIDRs if they already exist.
                // This makes sure the subnet CIDRs are up to date and there are no validation errors when updating the VNet.
                // Subnets that are not part of this cluster spec are silently ignored.
                if existingVnet.Subnets != nil </span><span class="cov8" title="1">{
                        for _, subnet := range *existingVnet.Subnets </span><span class="cov8" title="1">{
                                s.Scope.UpdateSubnetCIDRs(to.String(subnet.Name), converters.GetSubnetAddresses(subnet))
                        }</span>
                }
        }

        <span class="cov8" title="1">if s.Scope.IsVnetManaged() </span><span class="cov8" title="1">{
                s.Scope.UpdatePutStatus(infrav1.VNetReadyCondition, serviceName, err)
        }</span>

        <span class="cov8" title="1">return err</span>
}

// Delete deletes the virtual network if it is managed by capz.
func (s *Service) Delete(ctx context.Context) error <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "virtualnetworks.Service.Delete")
        defer done()

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        vnetSpec := s.Scope.VNetSpec()
        if vnetSpec == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Check that the vnet is not BYO.
        <span class="cov8" title="1">managed, err := s.IsManaged(ctx)
        if err != nil </span><span class="cov0" title="0">{
                if azure.ResourceNotFound(err) </span><span class="cov0" title="0">{
                        // already deleted or doesn't exist, cleanup status and return.
                        s.Scope.DeleteLongRunningOperationState(vnetSpec.ResourceName(), serviceName)
                        s.Scope.UpdateDeleteStatus(infrav1.VNetReadyCondition, serviceName, nil)
                        return nil
                }</span>
                <span class="cov0" title="0">return errors.Wrap(err, "could not get VNet management state")</span>
        }
        <span class="cov8" title="1">if !managed </span><span class="cov8" title="1">{
                log.Info("Skipping VNet deletion in custom vnet mode")
                return nil
        }</span>

        <span class="cov8" title="1">err = s.DeleteResource(ctx, vnetSpec, serviceName)
        s.Scope.UpdateDeleteStatus(infrav1.VNetReadyCondition, serviceName, err)
        return err</span>
}

// IsManaged returns true if the virtual network has an owned tag with the cluster name as value,
// meaning that the vnet's lifecycle is managed.
func (s *Service) IsManaged(ctx context.Context) (bool, error) <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "virtualnetworks.Service.IsManaged")
        defer done()

        spec := s.Scope.VNetSpec()
        if spec == nil </span><span class="cov8" title="1">{
                return false, errors.New("cannot get vnet to check if it is managed: spec is nil")
        }</span>

        <span class="cov8" title="1">vnetIface, err := s.Get(ctx, spec)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">vnet, ok := vnetIface.(network.VirtualNetwork)
        if !ok </span><span class="cov0" title="0">{
                return false, errors.Errorf("%T is not a network.VirtualNetwork", vnetIface)
        }</span>
        <span class="cov8" title="1">tags := converters.MapToTags(vnet.Tags)
        return tags.HasOwned(s.Scope.ClusterName()), nil</span>
}
</pre>
		
		<pre class="file" id="file151" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package vmextensions

import (
        "context"
        "encoding/json"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-11-01/compute"
        "github.com/Azure/go-autorest/autorest"
        azureautorest "github.com/Azure/go-autorest/autorest/azure"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// azureClient contains the Azure go-sdk Client.
type azureClient struct {
        vmextensions compute.VirtualMachineExtensionsClient
}

// newClient creates a new VM client from subscription ID.
func newClient(auth azure.Authorizer) *azureClient <span class="cov0" title="0">{
        c := newVirtualMachineExtensionsClient(auth.SubscriptionID(), auth.BaseURI(), auth.Authorizer())
        return &amp;azureClient{c}
}</span>

// newVirtualMachineExtensionsClient creates a new vm extension client from subscription ID.
func newVirtualMachineExtensionsClient(subscriptionID string, baseURI string, authorizer autorest.Authorizer) compute.VirtualMachineExtensionsClient <span class="cov0" title="0">{
        vmextensionsClient := compute.NewVirtualMachineExtensionsClientWithBaseURI(baseURI, subscriptionID)
        azure.SetAutoRestClientDefaults(&amp;vmextensionsClient.Client, authorizer)
        return vmextensionsClient
}</span>

// Get the specified virtual machine extension.
func (ac *azureClient) Get(ctx context.Context, spec azure.ResourceSpecGetter) (result interface{}, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "vmextensions.AzureClient.Get")
        defer done()

        return ac.vmextensions.Get(ctx, spec.ResourceGroupName(), spec.OwnerResourceName(), spec.ResourceName(), "")
}</span>

// CreateOrUpdateAsync creates or updates a VM extension asynchronously.
// It sends a PUT request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *azureClient) CreateOrUpdateAsync(ctx context.Context, spec azure.ResourceSpecGetter, parameters interface{}) (result interface{}, future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "vmextensions.AzureClient.CreateOrUpdateAsync")
        defer done()

        vmextension, ok := parameters.(compute.VirtualMachineExtension)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.Errorf("%T is not a compute.VirtualMachineExtension", parameters)
        }</span>

        <span class="cov0" title="0">createFuture, err := ac.vmextensions.CreateOrUpdate(ctx, spec.ResourceGroupName(), spec.OwnerResourceName(), spec.ResourceName(), vmextension)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = createFuture.WaitForCompletionRef(ctx, ac.vmextensions.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return nil, &amp;createFuture, err
        }</span>
        <span class="cov0" title="0">result, err = createFuture.Result(ac.vmextensions)
        // if the operation completed, return a nil future.
        return result, nil, err</span>
}

// DeleteAsync deletes a VM extension asynchronously. DeleteAsync sends a DELETE
// request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *azureClient) DeleteAsync(ctx context.Context, spec azure.ResourceSpecGetter) (future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "vmextensions.AzureClient.DeleteAsync")
        defer done()

        deleteFuture, err := ac.vmextensions.Delete(ctx, spec.ResourceGroupName(), spec.OwnerResourceName(), spec.ResourceName())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = deleteFuture.WaitForCompletionRef(ctx, ac.vmextensions.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return &amp;deleteFuture, err
        }</span>
        <span class="cov0" title="0">_, err = deleteFuture.Result(ac.vmextensions)
        // if the operation completed, return a nil future.
        return nil, err</span>
}

// IsDone returns true if the long-running operation has completed.
func (ac *azureClient) IsDone(ctx context.Context, future azureautorest.FutureAPI) (isDone bool, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "virtualnetworks.azureClient.IsDone")
        defer done()

        isDone, err = future.DoneWithContext(ctx, ac.vmextensions)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "failed checking if the operation was complete")
        }</span>

        <span class="cov0" title="0">return isDone, nil</span>
}

// Result fetches the result of a long-running operation future.
func (ac *azureClient) Result(ctx context.Context, future azureautorest.FutureAPI, futureType string) (result interface{}, err error) <span class="cov0" title="0">{
        _, _, done := tele.StartSpanWithLogger(ctx, "vmextensions.azureClient.Result")
        defer done()

        if future == nil </span><span class="cov0" title="0">{
                return nil, errors.Errorf("cannot get result from nil future")
        }</span>

        <span class="cov0" title="0">switch futureType </span>{
        case infrav1.PutFuture:<span class="cov0" title="0">
                // Marshal and Unmarshal the future to put it into the correct future type so we can access the Result function.
                // Unfortunately the FutureAPI can't be casted directly to VirtualMachineExtensionsCreateOrUpdateFuture because it is a azureautorest.Future, which doesn't implement the Result function. See PR #1686 for discussion on alternatives.
                // It was converted back to a generic azureautorest.Future from the CAPZ infrav1.Future type stored in Status: https://github.com/kubernetes-sigs/cluster-api-provider-azure/blob/main/azure/converters/futures.go#L49.
                var createFuture *compute.VirtualMachineExtensionsCreateOrUpdateFuture
                jsonData, err := future.MarshalJSON()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to marshal future")
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal(jsonData, &amp;createFuture); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to unmarshal future data")
                }</span>
                <span class="cov0" title="0">return createFuture.Result(ac.vmextensions)</span>

        case infrav1.DeleteFuture:<span class="cov0" title="0">
                // Delete does not return a result vnet.
                return nil, nil</span>

        default:<span class="cov0" title="0">
                return nil, errors.Errorf("unknown future type %q", futureType)</span>
        }
}
</pre>
		
		<pre class="file" id="file152" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package vmextensions

import (
        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-11-01/compute"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
)

// VMExtensionSpec defines the specification for a VM or VMScaleSet extension.
type VMExtensionSpec struct {
        azure.ExtensionSpec
        ResourceGroup string
        Location      string
}

// ResourceName returns the name of the VM extension.
func (s *VMExtensionSpec) ResourceName() string <span class="cov0" title="0">{
        return s.Name
}</span>

// ResourceGroupName returns the name of the resource group.
func (s *VMExtensionSpec) ResourceGroupName() string <span class="cov0" title="0">{
        return s.ResourceGroup
}</span>

// OwnerResourceName returns the name of the VM that owns this VM extension.
func (s *VMExtensionSpec) OwnerResourceName() string <span class="cov0" title="0">{
        return s.VMName
}</span>

// Parameters returns the parameters for the VM extension.
func (s *VMExtensionSpec) Parameters(existing interface{}) (interface{}, error) <span class="cov0" title="0">{
        if existing != nil </span><span class="cov0" title="0">{
                _, ok := existing.(compute.VirtualMachineExtension)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("%T is not a compute.VirtualMachineExtension", existing)
                }</span>

                // VM extension already exists, nothing to update.
                <span class="cov0" title="0">return nil, nil</span>
        }

        <span class="cov0" title="0">return compute.VirtualMachineExtension{
                VirtualMachineExtensionProperties: &amp;compute.VirtualMachineExtensionProperties{
                        Publisher:          to.StringPtr(s.Publisher),
                        Type:               to.StringPtr(s.Name),
                        TypeHandlerVersion: to.StringPtr(s.Version),
                        Settings:           nil,
                        ProtectedSettings:  s.ProtectedSettings,
                },
                Location: to.StringPtr(s.Location),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file153" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package vmextensions

import (
        "context"

        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/async"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

const serviceName = "vmextensions"

// VMExtensionScope defines the scope interface for a vm extension service.
type VMExtensionScope interface {
        azure.Authorizer
        azure.AsyncStatusUpdater
        VMExtensionSpecs() []azure.ResourceSpecGetter
}

// Service provides operations on Azure resources.
type Service struct {
        Scope VMExtensionScope
        async.Reconciler
}

// New creates a new vm extension service.
func New(scope VMExtensionScope) *Service <span class="cov0" title="0">{
        client := newClient(scope)
        return &amp;Service{
                Scope:      scope,
                Reconciler: async.New(scope, client, client),
        }
}</span>

// Name returns the service name.
func (s *Service) Name() string <span class="cov0" title="0">{
        return serviceName
}</span>

// Reconcile creates or updates the VM extension.
func (s *Service) Reconcile(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "vmextensions.Service.Reconcile")
        defer done()

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        specs := s.Scope.VMExtensionSpecs()
        if len(specs) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // We go through the list of ExtensionSpecs to reconcile each one, independently of the result of the previous one.
        // If multiple errors occur, we return the most pressing one.
        //  Order of precedence (highest -&gt; lowest) is: error that is not an operationNotDoneError (i.e. error creating) -&gt; operationNotDoneError (i.e. creating in progress) -&gt; no error (i.e. created)
        <span class="cov8" title="1">var resultErr error
        for _, extensionSpec := range specs </span><span class="cov8" title="1">{
                _, err := s.CreateResource(ctx, extensionSpec, serviceName)
                if err != nil </span><span class="cov8" title="1">{
                        if !azure.IsOperationNotDoneError(err) || resultErr == nil </span><span class="cov8" title="1">{
                                resultErr = err
                        }</span>
                }
        }

        <span class="cov8" title="1">if azure.IsOperationNotDoneError(resultErr) </span><span class="cov8" title="1">{
                resultErr = errors.Wrapf(resultErr, "extension is still in provisioning state. This likely means that bootstrapping has not yet completed on the VM")
        }</span> else<span class="cov8" title="1"> if resultErr != nil </span><span class="cov8" title="1">{
                resultErr = errors.Wrapf(resultErr, "extension state failed. This likely means the Kubernetes node bootstrapping process failed or timed out. Check VM boot diagnostics logs to learn more")
        }</span>

        <span class="cov8" title="1">s.Scope.UpdatePutStatus(infrav1.BootstrapSucceededCondition, serviceName, resultErr)
        return resultErr</span>
}

// Delete is a no-op. VM Extensions will be deleted as part of VM deletion.
func (s *Service) Delete(_ context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// IsManaged returns always returns true as CAPZ does not support BYO VM extension.
func (s *Service) IsManaged(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>
</pre>
		
		<pre class="file" id="file154" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package vnetpeerings

import (
        "context"
        "encoding/json"

        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-08-01/network"
        "github.com/Azure/go-autorest/autorest"
        azureautorest "github.com/Azure/go-autorest/autorest/azure"
        "github.com/pkg/errors"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// AzureClient contains the Azure go-sdk Client.
type AzureClient struct {
        peerings network.VirtualNetworkPeeringsClient
}

// NewClient creates a new virtual network peerings client from subscription ID.
func NewClient(auth azure.Authorizer) *AzureClient <span class="cov0" title="0">{
        c := newPeeringsClient(auth.SubscriptionID(), auth.BaseURI(), auth.Authorizer())
        return &amp;AzureClient{c}
}</span>

// newPeeringsClient creates a new virtual network peerings client from subscription ID.
func newPeeringsClient(subscriptionID string, baseURI string, authorizer autorest.Authorizer) network.VirtualNetworkPeeringsClient <span class="cov0" title="0">{
        peeringsClient := network.NewVirtualNetworkPeeringsClientWithBaseURI(baseURI, subscriptionID)
        azure.SetAutoRestClientDefaults(&amp;peeringsClient.Client, authorizer)
        return peeringsClient
}</span>

// Get gets the specified virtual network peering by the peering name, virtual network, and resource group.
func (ac *AzureClient) Get(ctx context.Context, spec azure.ResourceSpecGetter) (result interface{}, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "vnetpeerings.AzureClient.Get")
        defer done()

        return ac.peerings.Get(ctx, spec.ResourceGroupName(), spec.OwnerResourceName(), spec.ResourceName())
}</span>

// CreateOrUpdateAsync creates or updates a virtual network peering asynchronously.
// It sends a PUT request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *AzureClient) CreateOrUpdateAsync(ctx context.Context, spec azure.ResourceSpecGetter, parameters interface{}) (result interface{}, future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "vnetpeerings.AzureClient.CreateOrUpdateAsync")
        defer done()

        peering, ok := parameters.(network.VirtualNetworkPeering)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.Errorf("%T is not a network.VirtualNetworkPeering", parameters)
        }</span>

        <span class="cov0" title="0">createFuture, err := ac.peerings.CreateOrUpdate(ctx, spec.ResourceGroupName(), spec.OwnerResourceName(), spec.ResourceName(), peering, network.SyncRemoteAddressSpaceTrue)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = createFuture.WaitForCompletionRef(ctx, ac.peerings.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return nil, &amp;createFuture, err
        }</span>

        <span class="cov0" title="0">result, err = createFuture.Result(ac.peerings)
        // if the operation completed, return a nil future
        return result, nil, err</span>
}

// DeleteAsync deletes a virtual network peering asynchronously. DeleteAsync sends a DELETE
// request to Azure and if accepted without error, the func will return a Future which can be used to track the ongoing
// progress of the operation.
func (ac *AzureClient) DeleteAsync(ctx context.Context, spec azure.ResourceSpecGetter) (future azureautorest.FutureAPI, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "vnetpeerings.AzureClient.Delete")
        defer done()

        deleteFuture, err := ac.peerings.Delete(ctx, spec.ResourceGroupName(), spec.OwnerResourceName(), spec.ResourceName())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureCallTimeout)
        defer cancel()

        err = deleteFuture.WaitForCompletionRef(ctx, ac.peerings.Client)
        if err != nil </span><span class="cov0" title="0">{
                // if an error occurs, return the future.
                // this means the long-running operation didn't finish in the specified timeout.
                return &amp;deleteFuture, err
        }</span>
        <span class="cov0" title="0">_, err = deleteFuture.Result(ac.peerings)
        // if the operation completed, return a nil future.
        return nil, err</span>
}

// IsDone returns true if the long-running operation has completed.
func (ac *AzureClient) IsDone(ctx context.Context, future azureautorest.FutureAPI) (isDone bool, err error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "vnetpeerings.AzureClient.IsDone")
        defer done()

        isDone, err = future.DoneWithContext(ctx, ac.peerings)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "failed checking if the operation was complete")
        }</span>

        <span class="cov0" title="0">return isDone, nil</span>
}

// Result fetches the result of a long-running operation future.
func (ac *AzureClient) Result(ctx context.Context, future azureautorest.FutureAPI, futureType string) (result interface{}, err error) <span class="cov0" title="0">{
        _, _, done := tele.StartSpanWithLogger(ctx, "vnetpeerings.AzureClient.Result")
        defer done()

        if future == nil </span><span class="cov0" title="0">{
                return nil, errors.Errorf("cannot get result from nil future")
        }</span>

        <span class="cov0" title="0">switch futureType </span>{
        case infrav1.PutFuture:<span class="cov0" title="0">
                // Marshal and Unmarshal the future to put it into the correct future type so we can access the Result function.
                // Unfortunately the FutureAPI can't be casted directly to VirtualNetworkPeeringsCreateOrUpdateFuture because it is a azureautorest.Future, which doesn't implement the Result function. See PR #1686 for discussion on alternatives.
                // It was converted back to a generic azureautorest.Future from the CAPZ infrav1.Future type stored in Status: https://github.com/kubernetes-sigs/cluster-api-provider-azure/blob/main/azure/converters/futures.go#L49.
                var createFuture *network.VirtualNetworkPeeringsCreateOrUpdateFuture
                jsonData, err := future.MarshalJSON()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to marshal future")
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal(jsonData, &amp;createFuture); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to unmarshal future data")
                }</span>
                <span class="cov0" title="0">return createFuture.Result(ac.peerings)</span>

        case infrav1.DeleteFuture:<span class="cov0" title="0">
                // Delete does not return a result virtual network peering
                return nil, nil</span>

        default:<span class="cov0" title="0">
                return nil, errors.Errorf("unknown future type %q", futureType)</span>
        }
}
</pre>
		
		<pre class="file" id="file155" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package vnetpeerings

import (
        "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2021-08-01/network"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
)

// VnetPeeringSpec defines the specification for a virtual network peering.
type VnetPeeringSpec struct {
        SourceResourceGroup string
        SourceVnetName      string
        RemoteResourceGroup string
        RemoteVnetName      string
        PeeringName         string
        SubscriptionID      string
}

// ResourceName returns the name of the virtual network peering.
func (s *VnetPeeringSpec) ResourceName() string <span class="cov0" title="0">{
        return s.PeeringName
}</span>

// ResourceGroupName returns the name of the resource group.
func (s *VnetPeeringSpec) ResourceGroupName() string <span class="cov0" title="0">{
        return s.SourceResourceGroup
}</span>

// OwnerResourceName is a no-op for virtual network peerings.
func (s *VnetPeeringSpec) OwnerResourceName() string <span class="cov0" title="0">{
        return s.SourceVnetName
}</span>

// Parameters returns the parameters for the virtual network peering.
func (s *VnetPeeringSpec) Parameters(existing interface{}) (params interface{}, err error) <span class="cov0" title="0">{
        if existing != nil </span><span class="cov0" title="0">{
                if _, ok := existing.(network.VirtualNetworkPeering); !ok </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("%T is not a network.VnetPeering", existing)
                }</span>
                // virtual network peering already exists
                <span class="cov0" title="0">return nil, nil</span>
        }
        <span class="cov0" title="0">vnetID := azure.VNetID(s.SubscriptionID, s.RemoteResourceGroup, s.RemoteVnetName)
        peeringProperties := network.VirtualNetworkPeeringPropertiesFormat{
                RemoteVirtualNetwork: &amp;network.SubResource{
                        ID: to.StringPtr(vnetID),
                },
        }
        return network.VirtualNetworkPeering{
                Name:                                  to.StringPtr(s.PeeringName),
                VirtualNetworkPeeringPropertiesFormat: &amp;peeringProperties,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file156" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package vnetpeerings

import (
        "context"

        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/async"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

const serviceName = "vnetpeerings"

// VnetPeeringScope defines the scope interface for a subnet service.
type VnetPeeringScope interface {
        azure.Authorizer
        azure.AsyncStatusUpdater
        VnetPeeringSpecs() []azure.ResourceSpecGetter
}

// Service provides operations on Azure resources.
type Service struct {
        Scope VnetPeeringScope
        async.Reconciler
}

// New creates a new service.
func New(scope VnetPeeringScope) *Service <span class="cov0" title="0">{
        Client := NewClient(scope)
        return &amp;Service{
                Scope:      scope,
                Reconciler: async.New(scope, Client, Client),
        }
}</span>

// Name returns the service name.
func (s *Service) Name() string <span class="cov0" title="0">{
        return serviceName
}</span>

// Reconcile gets/creates/updates a peering.
func (s *Service) Reconcile(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "vnetpeerings.Service.Reconcile")
        defer done()

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        specs := s.Scope.VnetPeeringSpecs()
        if len(specs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // We go through the list of VnetPeeringSpecs to reconcile each one, independently of the result of the previous one.
        // If multiple errors occur, we return the most pressing one.
        //  Order of precedence (highest -&gt; lowest) is: error that is not an operationNotDoneError (i.e. error creating) -&gt; operationNotDoneError (i.e. creating in progress) -&gt; no error (i.e. created)
        <span class="cov8" title="1">var result error
        for _, peeringSpec := range specs </span><span class="cov8" title="1">{
                if _, err := s.CreateResource(ctx, peeringSpec, serviceName); err != nil </span><span class="cov8" title="1">{
                        if !azure.IsOperationNotDoneError(err) || result == nil </span><span class="cov8" title="1">{
                                result = err
                        }</span>
                }
        }

        <span class="cov8" title="1">s.Scope.UpdatePutStatus(infrav1.VnetPeeringReadyCondition, serviceName, result)
        return result</span>
}

// Delete deletes the peering with the provided name.
func (s *Service) Delete(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "vnetpeerings.Service.Delete")
        defer done()

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultAzureServiceReconcileTimeout)
        defer cancel()

        specs := s.Scope.VnetPeeringSpecs()
        if len(specs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // We go through the list of VnetPeeringSpecs to delete each one, independently of the result of the previous one.
        // If multiple errors occur, we return the most pressing one.
        //  Order of precedence (highest -&gt; lowest) is: error that is not an operationNotDoneError (i.e. error deleting) -&gt; operationNotDoneError (i.e. deleting in progress) -&gt; no error (i.e. deleted)
        <span class="cov8" title="1">var result error
        for _, peeringSpec := range specs </span><span class="cov8" title="1">{
                if err := s.DeleteResource(ctx, peeringSpec, serviceName); err != nil </span><span class="cov8" title="1">{
                        if !azure.IsOperationNotDoneError(err) || result == nil </span><span class="cov8" title="1">{
                                result = err
                        }</span>
                }
        }
        <span class="cov8" title="1">s.Scope.UpdateDeleteStatus(infrav1.VnetPeeringReadyCondition, serviceName, result)
        return result</span>
}

// IsManaged returns always returns true as CAPZ does not support BYO VNet peering.
func (s *Service) IsManaged(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>
</pre>
		
		<pre class="file" id="file157" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package azure

import (
        "reflect"

        "github.com/google/go-cmp/cmp"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
)

// RoleAssignmentSpec defines the specification for a Role Assignment.
type RoleAssignmentSpec struct {
        MachineName  string
        Name         string
        ResourceType string
}

// ResourceType defines the type azure resource being reconciled.
// Eg. Virtual Machine, Virtual Machine Scale Sets.
type ResourceType string

const (

        // VirtualMachine ...
        VirtualMachine = "VirtualMachine"

        // VirtualMachineScaleSet ...
        VirtualMachineScaleSet = "VirtualMachineScaleSet"
)

// ScaleSetSpec defines the specification for a Scale Set.
type ScaleSetSpec struct {
        Name                         string
        Size                         string
        Capacity                     int64
        SSHKeyData                   string
        OSDisk                       infrav1.OSDisk
        DataDisks                    []infrav1.DataDisk
        SubnetName                   string
        VNetName                     string
        VNetResourceGroup            string
        PublicLBName                 string
        PublicLBAddressPoolName      string
        AcceleratedNetworking        *bool
        TerminateNotificationTimeout *int
        Identity                     infrav1.VMIdentity
        UserAssignedIdentities       []infrav1.UserAssignedIdentity
        SecurityProfile              *infrav1.SecurityProfile
        SpotVMOptions                *infrav1.SpotVMOptions
        AdditionalCapabilities       *infrav1.AdditionalCapabilities
        FailureDomains               []string
}

// TagsSpec defines the specification for a set of tags.
type TagsSpec struct {
        Scope string
        Tags  infrav1.Tags
        // Annotation is the key which stores the last applied tags as value in JSON format.
        // The last applied tags are used to find out which tags are being managed by CAPZ
        // and if any has to be deleted by comparing it with the new desired tags
        Annotation string
}

// ExtensionSpec defines the specification for a VM or VMSS extension.
type ExtensionSpec struct {
        Name              string
        VMName            string
        Publisher         string
        Version           string
        ProtectedSettings map[string]string
}

type (
        // VMSSVM defines a VM in a virtual machine scale set.
        VMSSVM struct {
                ID               string                    `json:"id,omitempty"`
                InstanceID       string                    `json:"instanceID,omitempty"`
                Image            infrav1.Image             `json:"image,omitempty"`
                Name             string                    `json:"name,omitempty"`
                AvailabilityZone string                    `json:"availabilityZone,omitempty"`
                State            infrav1.ProvisioningState `json:"vmState,omitempty"`
        }

        // VMSS defines a virtual machine scale set.
        VMSS struct {
                ID        string                    `json:"id,omitempty"`
                Name      string                    `json:"name,omitempty"`
                Sku       string                    `json:"sku,omitempty"`
                Capacity  int64                     `json:"capacity,omitempty"`
                Zones     []string                  `json:"zones,omitempty"`
                Image     infrav1.Image             `json:"image,omitempty"`
                State     infrav1.ProvisioningState `json:"vmState,omitempty"`
                Identity  infrav1.VMIdentity        `json:"identity,omitempty"`
                Tags      infrav1.Tags              `json:"tags,omitempty"`
                Instances []VMSSVM                  `json:"instances,omitempty"`
        }
)

// HasModelChanges returns true if the spec fields which will mutate the Azure VMSS model are different.
func (vmss VMSS) HasModelChanges(other VMSS) bool <span class="cov8" title="1">{
        equal := cmp.Equal(vmss.Image, other.Image) &amp;&amp;
                cmp.Equal(vmss.Identity, other.Identity) &amp;&amp;
                cmp.Equal(vmss.Zones, other.Zones) &amp;&amp;
                cmp.Equal(vmss.Tags, other.Tags) &amp;&amp;
                cmp.Equal(vmss.Sku, other.Sku)
        return !equal
}</span>

// InstancesByProviderID returns VMSSVMs by ID.
func (vmss VMSS) InstancesByProviderID() map[string]VMSSVM <span class="cov0" title="0">{
        instancesByProviderID := make(map[string]VMSSVM, len(vmss.Instances))
        for _, instance := range vmss.Instances </span><span class="cov0" title="0">{
                instancesByProviderID[instance.ProviderID()] = instance
        }</span>

        <span class="cov0" title="0">return instancesByProviderID</span>
}

// ProviderID returns the K8s provider ID for the VMSS instance.
func (vm VMSSVM) ProviderID() string <span class="cov0" title="0">{
        return ProviderIDPrefix + vm.ID
}</span>

// HasLatestModelAppliedToAll returns true if all VMSS instance have the latest model applied.
func (vmss VMSS) HasLatestModelAppliedToAll() bool <span class="cov0" title="0">{
        for _, instance := range vmss.Instances </span><span class="cov0" title="0">{
                if !vmss.HasLatestModelApplied(instance) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// HasEnoughLatestModelOrNotMixedModel returns true if VMSS instance have the latest model applied to all or equal to the capacity.
func (vmss VMSS) HasEnoughLatestModelOrNotMixedModel() bool <span class="cov0" title="0">{
        if vmss.HasLatestModelAppliedToAll() </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">counter := int64(0)
        for _, instance := range vmss.Instances </span><span class="cov0" title="0">{
                if vmss.HasLatestModelApplied(instance) </span><span class="cov0" title="0">{
                        counter++
                }</span>
        }

        <span class="cov0" title="0">return counter == vmss.Capacity</span>
}

// HasLatestModelApplied returns true if the VMSS instance matches the VMSS image reference.
func (vmss VMSS) HasLatestModelApplied(vm VMSSVM) bool <span class="cov0" title="0">{
        // if the images match, then the VM is of the same model
        return reflect.DeepEqual(vm.Image, vmss.Image)
}</span>
</pre>
		
		<pre class="file" id="file158" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "time"

        "github.com/pkg/errors"
        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/client-go/tools/record"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/scope"
        "sigs.k8s.io/cluster-api-provider-azure/pkg/coalescing"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        "sigs.k8s.io/cluster-api/util"
        "sigs.k8s.io/cluster-api/util/annotations"
        "sigs.k8s.io/cluster-api/util/conditions"
        "sigs.k8s.io/cluster-api/util/predicates"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
        "sigs.k8s.io/controller-runtime/pkg/source"
)

// AzureClusterReconciler reconciles an AzureCluster object.
type AzureClusterReconciler struct {
        client.Client
        Recorder                  record.EventRecorder
        ReconcileTimeout          time.Duration
        WatchFilterValue          string
        createAzureClusterService azureClusterServiceCreator
}

type azureClusterServiceCreator func(clusterScope *scope.ClusterScope) (*azureClusterService, error)

// NewAzureClusterReconciler returns a new AzureClusterReconciler instance.
func NewAzureClusterReconciler(client client.Client, recorder record.EventRecorder, reconcileTimeout time.Duration, watchFilterValue string) *AzureClusterReconciler <span class="cov8" title="1">{
        acr := &amp;AzureClusterReconciler{
                Client:           client,
                Recorder:         recorder,
                ReconcileTimeout: reconcileTimeout,
                WatchFilterValue: watchFilterValue,
        }

        acr.createAzureClusterService = newAzureClusterService

        return acr
}</span>

// SetupWithManager initializes this controller with a manager.
func (acr *AzureClusterReconciler) SetupWithManager(ctx context.Context, mgr ctrl.Manager, options Options) error <span class="cov8" title="1">{
        _, log, done := tele.StartSpanWithLogger(ctx,
                "controllers.AzureClusterReconciler.SetupWithManager",
                tele.KVP("controller", "AzureCluster"),
        )
        defer done()

        var r reconcile.Reconciler = acr
        if options.Cache != nil </span><span class="cov0" title="0">{
                r = coalescing.NewReconciler(acr, options.Cache, log)
        }</span>

        <span class="cov8" title="1">c, err := ctrl.NewControllerManagedBy(mgr).
                WithOptions(options.Options).
                For(&amp;infrav1.AzureCluster{}).
                WithEventFilter(predicates.ResourceNotPausedAndHasFilterLabel(log, acr.WatchFilterValue)).
                WithEventFilter(predicates.ResourceIsNotExternallyManaged(log)).
                Build(r)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "error creating controller")
        }</span>

        // Add a watch on clusterv1.Cluster object for unpause notifications.
        <span class="cov8" title="1">if err = c.Watch(
                &amp;source.Kind{Type: &amp;clusterv1.Cluster{}},
                handler.EnqueueRequestsFromMapFunc(util.ClusterToInfrastructureMapFunc(ctx, infrav1.GroupVersion.WithKind("AzureCluster"), mgr.GetClient(), &amp;infrav1.AzureCluster{})),
                predicates.ClusterUnpaused(log),
                predicates.ResourceNotPausedAndHasFilterLabel(log, acr.WatchFilterValue),
        ); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed adding a watch for ready clusters")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// +kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=azureclusters,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=azureclusters/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=cluster.x-k8s.io,resources=clusters;clusters/status,verbs=get;list;watch
// +kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=azuremachinetemplates;azuremachinetemplates/status,verbs=get;list;watch
// +kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=azureclusteridentities;azureclusteridentities/status,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups="",resources=namespaces,verbs=list;

// Reconcile idempotently gets, creates, and updates a cluster.
func (acr *AzureClusterReconciler) Reconcile(ctx context.Context, req ctrl.Request) (_ ctrl.Result, reterr error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultedLoopTimeout(acr.ReconcileTimeout))
        defer cancel()

        ctx, log, done := tele.StartSpanWithLogger(
                ctx,
                "controllers.AzureClusterReconciler.Reconcile",
                tele.KVP("namespace", req.Namespace),
                tele.KVP("name", req.Name),
                tele.KVP("kind", "AzureCluster"),
        )
        defer done()

        // Fetch the AzureCluster instance
        azureCluster := &amp;infrav1.AzureCluster{}
        err := acr.Get(ctx, req.NamespacedName, azureCluster)
        if err != nil </span><span class="cov8" title="1">{
                if apierrors.IsNotFound(err) </span><span class="cov8" title="1">{
                        acr.Recorder.Eventf(azureCluster, corev1.EventTypeNormal, "AzureClusterObjectNotFound", err.Error())
                        log.Info("object was not found")
                        return reconcile.Result{}, nil
                }</span>
                <span class="cov0" title="0">return reconcile.Result{}, err</span>
        }

        // Fetch the Cluster.
        <span class="cov0" title="0">cluster, err := util.GetOwnerCluster(ctx, acr.Client, azureCluster.ObjectMeta)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                acr.Recorder.Eventf(azureCluster, corev1.EventTypeNormal, "OwnerRefNotSet", "Cluster Controller has not yet set OwnerRef")
                log.Info("Cluster Controller has not yet set OwnerRef")
                return reconcile.Result{}, nil
        }</span>

        <span class="cov0" title="0">log = log.WithValues("cluster", cluster.Name)

        // Return early if the object or Cluster is paused.
        if annotations.IsPaused(cluster, azureCluster) </span><span class="cov0" title="0">{
                acr.Recorder.Eventf(azureCluster, corev1.EventTypeNormal, "ClusterPaused", "AzureCluster or linked Cluster is marked as paused. Won't reconcile")
                log.Info("AzureCluster or linked Cluster is marked as paused. Won't reconcile")
                return ctrl.Result{}, nil
        }</span>

        <span class="cov0" title="0">if azureCluster.Spec.IdentityRef != nil </span><span class="cov0" title="0">{
                err := EnsureClusterIdentity(ctx, acr.Client, azureCluster, azureCluster.Spec.IdentityRef, infrav1.ClusterFinalizer)
                if err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, err
                }</span>
        } else<span class="cov0" title="0"> {
                log.Info(fmt.Sprintf("WARNING, %s", deprecatedManagerCredsWarning))
                acr.Recorder.Eventf(azureCluster, corev1.EventTypeWarning, "AzureClusterIdentity", deprecatedManagerCredsWarning)
        }</span>

        // Create the scope.
        <span class="cov0" title="0">clusterScope, err := scope.NewClusterScope(ctx, scope.ClusterScopeParams{
                Client:       acr.Client,
                Cluster:      cluster,
                AzureCluster: azureCluster,
        })
        if err != nil </span><span class="cov0" title="0">{
                err = errors.Wrap(err, "failed to create scope")
                acr.Recorder.Eventf(azureCluster, corev1.EventTypeWarning, "CreateClusterScopeFailed", err.Error())
                return reconcile.Result{}, err
        }</span>

        // Always close the scope when exiting this function so we can persist any AzureMachine changes.
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := clusterScope.Close(ctx); err != nil &amp;&amp; reterr == nil </span><span class="cov0" title="0">{
                        reterr = err
                }</span>
        }()

        // Handle deleted clusters
        <span class="cov0" title="0">if !azureCluster.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                return acr.reconcileDelete(ctx, clusterScope)
        }</span>

        // Handle non-deleted clusters
        <span class="cov0" title="0">return acr.reconcileNormal(ctx, clusterScope)</span>
}

func (acr *AzureClusterReconciler) reconcileNormal(ctx context.Context, clusterScope *scope.ClusterScope) (reconcile.Result, error) <span class="cov0" title="0">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "controllers.AzureClusterReconciler.reconcileNormal")
        defer done()

        log.Info("Reconciling AzureCluster")
        azureCluster := clusterScope.AzureCluster

        // If the AzureCluster doesn't have our finalizer, add it.
        controllerutil.AddFinalizer(azureCluster, infrav1.ClusterFinalizer)
        // Register the finalizer immediately to avoid orphaning Azure resources on delete
        if err := clusterScope.PatchObject(ctx); err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov0" title="0">acs, err := acr.createAzureClusterService(clusterScope)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, errors.Wrap(err, "failed to create a new AzureClusterReconciler")
        }</span>

        <span class="cov0" title="0">if err := acs.Reconcile(ctx); err != nil </span><span class="cov0" title="0">{
                // Handle terminal &amp; transient errors
                var reconcileError azure.ReconcileError
                if errors.As(err, &amp;reconcileError) </span><span class="cov0" title="0">{
                        if reconcileError.IsTerminal() </span><span class="cov0" title="0">{
                                acr.Recorder.Eventf(clusterScope.AzureCluster, corev1.EventTypeWarning, "ReconcileErrror", errors.Wrapf(err, "failed to reconcile AzureCluster").Error())
                                log.Error(err, "failed to reconcile AzureCluster", "name", clusterScope.ClusterName())
                                conditions.MarkFalse(azureCluster, infrav1.NetworkInfrastructureReadyCondition, infrav1.FailedReason, clusterv1.ConditionSeverityError, "")
                                return reconcile.Result{}, nil
                        }</span>
                        <span class="cov0" title="0">if reconcileError.IsTransient() </span><span class="cov0" title="0">{
                                if azure.IsOperationNotDoneError(reconcileError) </span><span class="cov0" title="0">{
                                        log.V(2).Info(fmt.Sprintf("AzureCluster reconcile not done: %s", reconcileError.Error()))
                                }</span> else<span class="cov0" title="0"> {
                                        log.V(2).Info(fmt.Sprintf("transient failure to reconcile AzureCluster, retrying: %s", reconcileError.Error()))
                                }</span>
                                <span class="cov0" title="0">return reconcile.Result{RequeueAfter: reconcileError.RequeueAfter()}, nil</span>
                        }
                }

                <span class="cov0" title="0">wrappedErr := errors.Wrap(err, "failed to reconcile cluster services")
                acr.Recorder.Eventf(azureCluster, corev1.EventTypeWarning, "ClusterReconcilerNormalFailed", wrappedErr.Error())
                conditions.MarkFalse(azureCluster, infrav1.NetworkInfrastructureReadyCondition, infrav1.FailedReason, clusterv1.ConditionSeverityError, wrappedErr.Error())
                return reconcile.Result{}, wrappedErr</span>
        }

        // Set APIEndpoints so the Cluster API Cluster Controller can pull them
        <span class="cov0" title="0">if azureCluster.Spec.ControlPlaneEndpoint.Host == "" </span><span class="cov0" title="0">{
                azureCluster.Spec.ControlPlaneEndpoint.Host = clusterScope.APIServerHost()
        }</span>
        <span class="cov0" title="0">if azureCluster.Spec.ControlPlaneEndpoint.Port == 0 </span><span class="cov0" title="0">{
                azureCluster.Spec.ControlPlaneEndpoint.Port = clusterScope.APIServerPort()
        }</span>

        // No errors, so mark us ready so the Cluster API Cluster Controller can pull it
        <span class="cov0" title="0">azureCluster.Status.Ready = true
        conditions.MarkTrue(azureCluster, infrav1.NetworkInfrastructureReadyCondition)

        return reconcile.Result{}, nil</span>
}

func (acr *AzureClusterReconciler) reconcileDelete(ctx context.Context, clusterScope *scope.ClusterScope) (reconcile.Result, error) <span class="cov0" title="0">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "controllers.AzureClusterReconciler.reconcileDelete")
        defer done()

        log.Info("Reconciling AzureCluster delete")

        azureCluster := clusterScope.AzureCluster

        acs, err := acr.createAzureClusterService(clusterScope)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, errors.Wrap(err, "failed to create a new AzureClusterReconciler")
        }</span>

        <span class="cov0" title="0">if err := acs.Delete(ctx); err != nil </span><span class="cov0" title="0">{
                // Handle transient errors
                var reconcileError azure.ReconcileError
                if errors.As(err, &amp;reconcileError) </span><span class="cov0" title="0">{
                        if reconcileError.IsTransient() </span><span class="cov0" title="0">{
                                if azure.IsOperationNotDoneError(reconcileError) </span><span class="cov0" title="0">{
                                        log.V(2).Info(fmt.Sprintf("AzureCluster delete not done: %s", reconcileError.Error()))
                                }</span> else<span class="cov0" title="0"> {
                                        log.V(2).Info("transient failure to delete AzureCluster, retrying")
                                }</span>
                                <span class="cov0" title="0">return reconcile.Result{RequeueAfter: reconcileError.RequeueAfter()}, nil</span>
                        }
                }

                <span class="cov0" title="0">wrappedErr := errors.Wrapf(err, "error deleting AzureCluster %s/%s", azureCluster.Namespace, azureCluster.Name)
                acr.Recorder.Eventf(azureCluster, corev1.EventTypeWarning, "ClusterReconcilerDeleteFailed", wrappedErr.Error())
                conditions.MarkFalse(azureCluster, infrav1.NetworkInfrastructureReadyCondition, clusterv1.DeletionFailedReason, clusterv1.ConditionSeverityWarning, err.Error())
                return reconcile.Result{}, wrappedErr</span>
        }

        // Cluster is deleted so remove the finalizer.
        <span class="cov0" title="0">controllerutil.RemoveFinalizer(azureCluster, infrav1.ClusterFinalizer)

        if azureCluster.Spec.IdentityRef != nil </span><span class="cov0" title="0">{
                // Cluster is deleted so remove the identity finalizer.
                err := RemoveClusterIdentityFinalizer(ctx, acr.Client, azureCluster, azureCluster.Spec.IdentityRef, infrav1.ClusterFinalizer)
                if err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, err
                }</span>
        }

        <span class="cov0" title="0">return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file159" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"

        "github.com/pkg/errors"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/scope"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/bastionhosts"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/groups"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/loadbalancers"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/natgateways"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/privatedns"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/publicips"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/resourceskus"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/routetables"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/securitygroups"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/subnets"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/tags"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/virtualnetworks"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/vnetpeerings"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
)

// azureClusterService is the reconciler called by the AzureCluster controller.
type azureClusterService struct {
        scope *scope.ClusterScope
        // services is the list of services that are reconciled by this controller.
        // The order of the services is important as it determines the order in which the services are reconciled.
        services []azure.ServiceReconciler
        skuCache *resourceskus.Cache
}

// newAzureClusterService populates all the services based on input scope.
func newAzureClusterService(scope *scope.ClusterScope) (*azureClusterService, error) <span class="cov0" title="0">{
        skuCache, err := resourceskus.GetCache(scope, scope.Location())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed creating a NewCache")
        }</span>
        <span class="cov0" title="0">return &amp;azureClusterService{
                scope: scope,
                services: []azure.ServiceReconciler{
                        groups.New(scope),
                        virtualnetworks.New(scope),
                        securitygroups.New(scope),
                        routetables.New(scope),
                        publicips.New(scope),
                        natgateways.New(scope),
                        subnets.New(scope),
                        vnetpeerings.New(scope),
                        loadbalancers.New(scope),
                        privatedns.New(scope),
                        bastionhosts.New(scope),
                        tags.New(scope),
                },
                skuCache: skuCache,
        }, nil</span>
}

// Reconcile reconciles all the services in a predetermined order.
func (s *azureClusterService) Reconcile(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "controllers.azureClusterService.Reconcile")
        defer done()

        if err := s.setFailureDomainsForLocation(ctx); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to get availability zones")
        }</span>

        <span class="cov8" title="1">s.scope.SetDNSName()
        s.scope.SetControlPlaneSecurityRules()

        for _, service := range s.services </span><span class="cov8" title="1">{
                if err := service.Reconcile(ctx); err != nil </span><span class="cov8" title="1">{
                        return errors.Wrapf(err, "failed to reconcile AzureCluster service %s", service.Name())
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Delete reconciles all the services in a predetermined order.
func (s *azureClusterService) Delete(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "controllers.azureClusterService.Delete")
        defer done()

        groupSvc, err := s.getService(groups.ServiceName)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to get group service")
        }</span>

        <span class="cov8" title="1">managed, err := groupSvc.IsManaged(ctx)
        if err != nil </span><span class="cov8" title="1">{
                if azure.ResourceNotFound(err) </span><span class="cov0" title="0">{
                        // If the resource group is not found, there is nothing to delete, return early.
                        return nil
                }</span>
                <span class="cov8" title="1">return errors.Wrap(err, "failed to determine if the AzureCluster resource group is managed")</span>
        }
        <span class="cov8" title="1">if managed </span><span class="cov8" title="1">{
                // if the resource group is managed, we delete the entire resource group directly.
                if err := groupSvc.Delete(ctx); err != nil </span><span class="cov8" title="1">{
                        return errors.Wrap(err, "failed to delete resource group")
                }</span>
        } else<span class="cov8" title="1"> {
                // If the resource group is not managed we need to delete resources inside the group one by one.
                // services are deleted in reverse order from the order in which they are reconciled.
                for i := len(s.services) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                        if err := s.services[i].Delete(ctx); err != nil </span><span class="cov8" title="1">{
                                return errors.Wrapf(err, "failed to delete AzureCluster service %s", s.services[i].Name())
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func (s *azureClusterService) getService(name string) (azure.ServiceReconciler, error) <span class="cov8" title="1">{
        for _, service := range s.services </span><span class="cov8" title="1">{
                if service.Name() == name </span><span class="cov8" title="1">{
                        return service, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, errors.Errorf("service %s not found", name)</span>
}

// setFailureDomainsForLocation sets the AzureCluster Status failure domains based on which Azure Availability Zones are available in the cluster location.
// Note that this is not done in a webhook as it requires API calls to fetch the availability zones.
func (s *azureClusterService) setFailureDomainsForLocation(ctx context.Context) error <span class="cov8" title="1">{
        zones, err := s.skuCache.GetZones(ctx, s.scope.Location())
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to get zones for location %s", s.scope.Location())
        }</span>

        <span class="cov8" title="1">for _, zone := range zones </span><span class="cov0" title="0">{
                s.scope.SetFailureDomain(zone, clusterv1.FailureDomainSpec{
                        ControlPlane: true,
                })
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file160" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "time"

        aadpodv1 "github.com/Azure/aad-pod-identity/pkg/apis/aadpodidentity/v1"
        "github.com/pkg/errors"
        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/client-go/tools/record"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        infrav1exp "sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/feature"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/system"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        "sigs.k8s.io/cluster-api/util"
        "sigs.k8s.io/cluster-api/util/predicates"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
        "sigs.k8s.io/controller-runtime/pkg/source"
)

// AzureIdentityReconciler reconciles Azure identity objects.
type AzureIdentityReconciler struct {
        client.Client
        Recorder         record.EventRecorder
        ReconcileTimeout time.Duration
        WatchFilterValue string
}

// SetupWithManager initializes this controller with a manager.
func (r *AzureIdentityReconciler) SetupWithManager(ctx context.Context, mgr ctrl.Manager, options controller.Options) error <span class="cov0" title="0">{
        _, log, done := tele.StartSpanWithLogger(ctx,
                "controllers.AzureIdentityReconciler.SetupWithManager",
                tele.KVP("controller", "AzureIdentity"),
        )
        defer done()

        c, err := ctrl.NewControllerManagedBy(mgr).
                WithOptions(options).
                For(&amp;infrav1.AzureCluster{}).
                WithEventFilter(predicates.ResourceNotPausedAndHasFilterLabel(log, r.WatchFilterValue)).
                WithEventFilter(predicates.ResourceIsNotExternallyManaged(log)).
                Named("AzureIdentity").
                Build(r)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "error creating controller")
        }</span>

        // Add a watch on infrav1exp.AzureManagedControlPlane if aks is enabled.
        <span class="cov0" title="0">if feature.Gates.Enabled(feature.AKS) </span><span class="cov0" title="0">{
                if err = c.Watch(
                        &amp;source.Kind{Type: &amp;infrav1exp.AzureManagedControlPlane{}},
                        &amp;handler.EnqueueRequestForObject{},
                        predicates.ResourceNotPausedAndHasFilterLabel(log, r.WatchFilterValue),
                ); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed adding a watch for ready clusters")
                }</span>
        }

        // Add a watch on clusterv1.Cluster object for unpause notifications.
        <span class="cov0" title="0">if err = c.Watch(
                &amp;source.Kind{Type: &amp;clusterv1.Cluster{}},
                handler.EnqueueRequestsFromMapFunc(util.ClusterToInfrastructureMapFunc(ctx, infrav1.GroupVersion.WithKind("AzureCluster"), mgr.GetClient(), &amp;infrav1.AzureCluster{})),
                predicates.ClusterUnpaused(log),
                predicates.ResourceNotPausedAndHasFilterLabel(log, r.WatchFilterValue),
        ); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed adding a watch for ready clusters")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// +kubebuilder:rbac:groups=aadpodidentity.k8s.io,resources=azureidentities;azureidentities/status,verbs=get;list;watch
// +kubebuilder:rbac:groups=aadpodidentity.k8s.io,resources=azureidentitybindings;azureidentitybindings/status,verbs=get;list;watch
// +kubebuilder:rbac:groups="",resources=events,verbs=get;list;watch;create;update;patch
// +kubebuilder:rbac:groups="",resources=secrets;,verbs=get;list;watch

// Reconcile reconciles the Azure identity.
func (r *AzureIdentityReconciler) Reconcile(ctx context.Context, req ctrl.Request) (_ ctrl.Result, reterr error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultedLoopTimeout(r.ReconcileTimeout))
        defer cancel()

        ctx, log, done := tele.StartSpanWithLogger(ctx, "controllers.AzureIdentityReconciler.Reconcile",
                tele.KVP("namespace", req.Namespace),
                tele.KVP("name", req.Name),
                tele.KVP("kind", "AzureCluster"),
        )
        defer done()

        // identityOwner is the resource that created the identity. This could be either an AzureCluster or AzureManagedControlPlane (if AKS is enabled).
        // check for AzureCluster first and if it is not found, check for AzureManagedControlPlane.
        var identityOwner interface{}

        // Fetch the AzureCluster instance
        azureCluster := &amp;infrav1.AzureCluster{}
        identityOwner = azureCluster
        err := r.Get(ctx, req.NamespacedName, azureCluster)
        if err != nil &amp;&amp; apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                if feature.Gates.Enabled(feature.AKS) </span><span class="cov0" title="0">{
                        // Fetch the AzureManagedControlPlane instance
                        azureManagedControlPlane := &amp;infrav1exp.AzureManagedControlPlane{}
                        identityOwner = azureManagedControlPlane
                        err = r.Get(ctx, req.NamespacedName, azureManagedControlPlane)
                        if err != nil &amp;&amp; apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                                r.Recorder.Eventf(azureCluster, corev1.EventTypeNormal, "AzureClusterObjectNotFound",
                                        fmt.Sprintf("AzureCluster object %s/%s not found", req.Namespace, req.Name))
                                r.Recorder.Eventf(azureManagedControlPlane, corev1.EventTypeNormal, "AzureManagedControlPlaneObjectNotFound",
                                        fmt.Sprintf("AzureManagedControlPlane object %s/%s not found", req.Namespace, req.Name))
                                log.Info("object was not found")
                                return reconcile.Result{}, nil
                        }</span>
                } else<span class="cov0" title="0"> {
                        r.Recorder.Eventf(azureCluster, corev1.EventTypeNormal, "AzureClusterObjectNotFound", err.Error())
                        log.Info("object was not found")
                        return reconcile.Result{}, nil
                }</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>

        // get all the bindings
        <span class="cov0" title="0">var bindings aadpodv1.AzureIdentityBindingList
        if err := r.List(ctx, &amp;bindings, client.InNamespace(system.GetManagerNamespace())); err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">var bindingsToDelete []aadpodv1.AzureIdentityBinding
        for _, b := range bindings.Items </span><span class="cov0" title="0">{
                log = log.WithValues("azureidentitybinding", b.Name)

                binding := b
                clusterName := binding.ObjectMeta.Labels[clusterv1.ClusterLabelName]
                clusterNamespace := binding.ObjectMeta.Labels[infrav1.ClusterLabelNamespace]

                key := client.ObjectKey{Name: clusterName, Namespace: clusterNamespace}

                // only delete bindings when the identity owner type is not found.
                // we should not delete an identity when azureCluster is not found because it could have been created by AzureManagedControlPlane.
                switch identityOwner.(type) </span>{
                case infrav1.AzureCluster:<span class="cov0" title="0">
                        azCluster := &amp;infrav1.AzureCluster{}
                        if err := r.Get(ctx, key, azCluster); err != nil </span><span class="cov0" title="0">{
                                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                                        bindingsToDelete = append(bindingsToDelete, b)
                                        continue</span>
                                } else<span class="cov0" title="0"> {
                                        return ctrl.Result{}, errors.Wrap(err, "failed to get AzureCluster")
                                }</span>
                        }
                case infrav1exp.AzureManagedControlPlane:<span class="cov0" title="0">
                        azManagedControlPlane := &amp;infrav1exp.AzureManagedControlPlane{}
                        if err := r.Get(ctx, key, azManagedControlPlane); err != nil </span><span class="cov0" title="0">{
                                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                                        bindingsToDelete = append(bindingsToDelete, b)
                                        continue</span>
                                } else<span class="cov0" title="0"> {
                                        return ctrl.Result{}, errors.Wrap(err, "failed to get AzureManagedControlPlane")
                                }</span>
                        }
                }
        }

        // delete bindings and identites no longer used by a cluster
        <span class="cov0" title="0">for _, bindingToDelete := range bindingsToDelete </span><span class="cov0" title="0">{
                binding := bindingToDelete
                identityName := binding.Spec.AzureIdentity
                if err := r.Client.Delete(ctx, &amp;binding); err != nil </span><span class="cov0" title="0">{
                        r.Recorder.Eventf(azureCluster, corev1.EventTypeWarning, "Error reconciling AzureIdentity", err.Error())
                        log.Error(err, "failed to delete AzureIdentityBinding")
                        return ctrl.Result{}, err
                }</span>
                <span class="cov0" title="0">azureIdentity := &amp;aadpodv1.AzureIdentity{}
                if err := r.Client.Get(ctx, client.ObjectKey{Name: identityName, Namespace: system.GetManagerNamespace()}, azureIdentity); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to fetch AzureIdentity")
                        return ctrl.Result{}, err
                }</span>
                <span class="cov0" title="0">if err := r.Client.Delete(ctx, azureIdentity); err != nil </span><span class="cov0" title="0">{
                        r.Recorder.Eventf(azureCluster, corev1.EventTypeWarning, "Error reconciling AzureIdentity", err.Error())
                        log.Error(err, "failed to delete AzureIdentity")
                        return ctrl.Result{}, err
                }</span>
        }

        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file161" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "time"

        "github.com/go-logr/logr"
        "github.com/pkg/errors"
        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/tools/record"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure/scope"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/identities"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        "sigs.k8s.io/cluster-api/util"
        "sigs.k8s.io/cluster-api/util/annotations"
        "sigs.k8s.io/cluster-api/util/predicates"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller"
        "sigs.k8s.io/controller-runtime/pkg/event"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        "sigs.k8s.io/controller-runtime/pkg/predicate"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
        "sigs.k8s.io/controller-runtime/pkg/source"
)

// AzureJSONMachineReconciler reconciles Azure json secrets for AzureMachine objects.
type AzureJSONMachineReconciler struct {
        client.Client
        Recorder         record.EventRecorder
        ReconcileTimeout time.Duration
        WatchFilterValue string
}

// SetupWithManager initializes this controller with a manager.
func (r *AzureJSONMachineReconciler) SetupWithManager(ctx context.Context, mgr ctrl.Manager, options controller.Options) error <span class="cov0" title="0">{
        _, log, done := tele.StartSpanWithLogger(ctx,
                "controllers.AzureJSONMachineReconciler.SetupWithManager",
        )
        defer done()

        azureMachineMapper, err := util.ClusterToObjectsMapper(r.Client, &amp;infrav1.AzureMachineList{}, mgr.GetScheme())
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to create mapper for Cluster to AzureMachines")
        }</span>

        <span class="cov0" title="0">c, err := ctrl.NewControllerManagedBy(mgr).
                WithOptions(options).
                For(&amp;infrav1.AzureMachine{}).
                WithEventFilter(filterUnclonedMachinesPredicate{log: log}).
                WithEventFilter(predicates.ResourceNotPausedAndHasFilterLabel(log, r.WatchFilterValue)).
                Owns(&amp;corev1.Secret{}).
                Build(r)

        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to create controller")
        }</span>

        // Add a watch on Clusters to requeue when the infraRef is set. This is needed because the infraRef is not initially
        // set in Clusters created from a ClusterClass.
        <span class="cov0" title="0">if err := c.Watch(
                &amp;source.Kind{Type: &amp;clusterv1.Cluster{}},
                handler.EnqueueRequestsFromMapFunc(azureMachineMapper),
                predicates.ClusterUnpausedAndInfrastructureReady(log),
                predicates.ResourceNotPausedAndHasFilterLabel(log, r.WatchFilterValue),
        ); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed adding a watch for Clusters")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type filterUnclonedMachinesPredicate struct {
        log logr.Logger
        predicate.Funcs
}

func (f filterUnclonedMachinesPredicate) Create(e event.CreateEvent) bool <span class="cov0" title="0">{
        return f.Generic(event.GenericEvent(e))
}</span>

func (f filterUnclonedMachinesPredicate) Update(e event.UpdateEvent) bool <span class="cov0" title="0">{
        return f.Generic(event.GenericEvent{
                Object: e.ObjectNew,
        })
}</span>

// Generic implements a default GenericEvent filter.
func (f filterUnclonedMachinesPredicate) Generic(e event.GenericEvent) bool <span class="cov8" title="1">{
        if e.Object == nil </span><span class="cov0" title="0">{
                f.log.Error(nil, "Generic event has no old metadata", "event", e)
                return false
        }</span>

        // when watching machines, we only care about machines users created one-off
        // outside of machinedeployments/machinesets and using AzureMachineTemplates. if a machine is part of a machineset
        // or machinedeployment, we already created a secret for the template. All machines
        // in the machinedeployment will share that one secret.
        <span class="cov8" title="1">gvk := infrav1.GroupVersion.WithKind("AzureMachineTemplate")
        isClonedFromTemplate := e.Object.GetAnnotations()[clusterv1.TemplateClonedFromGroupKindAnnotation] == gvk.GroupKind().String()

        return !isClonedFromTemplate</span>
}

// Reconcile reconciles the Azure json for a specific machine not in a machine deployment.
func (r *AzureJSONMachineReconciler) Reconcile(ctx context.Context, req ctrl.Request) (_ ctrl.Result, reterr error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultedLoopTimeout(r.ReconcileTimeout))
        defer cancel()

        ctx, log, done := tele.StartSpanWithLogger(
                ctx,
                "controllers.AzureJSONMachineReconciler.Reconcile",
                tele.KVP("namespace", req.Namespace),
                tele.KVP("name", req.Name),
                tele.KVP("kind", "AzureMachine"),
        )
        defer done()

        // Fetch the AzureMachine instance
        azureMachine := &amp;infrav1.AzureMachine{}
        err := r.Get(ctx, req.NamespacedName, azureMachine)
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        log.Info("object was not found")
                        return reconcile.Result{}, nil
                }</span>
                <span class="cov0" title="0">return reconcile.Result{}, err</span>
        }

        // Fetch the Cluster.
        <span class="cov8" title="1">cluster, err := util.GetClusterFromMetadata(ctx, r.Client, azureMachine.ObjectMeta)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">if cluster == nil </span><span class="cov0" title="0">{
                log.Info("Cluster Controller has not yet set OwnerRef")
                return reconcile.Result{}, nil
        }</span>

        <span class="cov8" title="1">log = log.WithValues("cluster", cluster.Name)

        // Return early if the object or Cluster is paused.
        if annotations.IsPaused(cluster, azureMachine) </span><span class="cov0" title="0">{
                log.Info("AzureMachine or linked Cluster is marked as paused. Won't reconcile")
                return ctrl.Result{}, nil
        }</span>

        <span class="cov8" title="1">_, kind := infrav1.GroupVersion.WithKind("AzureCluster").ToAPIVersionAndKind()

        // only look at azure clusters
        if cluster.Spec.InfrastructureRef == nil </span><span class="cov8" title="1">{
                log.Info("infra ref is nil")
                return ctrl.Result{}, nil
        }</span>
        <span class="cov8" title="1">if cluster.Spec.InfrastructureRef.Kind != kind </span><span class="cov8" title="1">{
                log.WithValues("kind", cluster.Spec.InfrastructureRef.Kind).Info("infra ref was not an AzureCluster")
                return ctrl.Result{}, nil
        }</span>

        // fetch the corresponding azure cluster
        <span class="cov8" title="1">azureCluster := &amp;infrav1.AzureCluster{}
        azureClusterName := types.NamespacedName{
                Namespace: req.Namespace,
                Name:      cluster.Spec.InfrastructureRef.Name,
        }

        if err := r.Get(ctx, azureClusterName, azureCluster); err != nil </span><span class="cov8" title="1">{
                log.Error(err, "failed to fetch AzureCluster")
                return reconcile.Result{}, err
        }</span>

        // Create the scope.
        <span class="cov8" title="1">clusterScope, err := scope.NewClusterScope(ctx, scope.ClusterScopeParams{
                Client:       r.Client,
                Cluster:      cluster,
                AzureCluster: azureCluster,
        })
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, errors.Wrap(err, "failed to create scope")
        }</span>

        <span class="cov8" title="1">apiVersion, kind := infrav1.GroupVersion.WithKind("AzureMachine").ToAPIVersionAndKind()
        owner := metav1.OwnerReference{
                APIVersion: apiVersion,
                Kind:       kind,
                Name:       azureMachine.GetName(),
                UID:        azureMachine.GetUID(),
        }

        // Construct secret for this machine
        userAssignedIdentityIfExists := ""
        if len(azureMachine.Spec.UserAssignedIdentities) &gt; 0 </span><span class="cov0" title="0">{
                // TODO: remove this ClientID lookup code when the fixed cloud-provider-azure is default
                idsClient := identities.NewClient(clusterScope)
                userAssignedIdentityIfExists, err = idsClient.GetClientID(
                        ctx, azureMachine.Spec.UserAssignedIdentities[0].ProviderID)
                if err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, errors.Wrap(err, "failed to get user-assigned identity ClientID")
                }</span>
        }

        <span class="cov8" title="1">if azureMachine.Spec.Identity == infrav1.VMIdentityNone </span><span class="cov0" title="0">{
                log.Info(fmt.Sprintf("WARNING, %s", spIdentityWarning))
                r.Recorder.Eventf(azureMachine, corev1.EventTypeWarning, "VMIdentityNone", spIdentityWarning)
        }</span>

        <span class="cov8" title="1">newSecret, err := GetCloudProviderSecret(
                clusterScope,
                azureMachine.Namespace,
                azureMachine.Name,
                owner,
                azureMachine.Spec.Identity,
                userAssignedIdentityIfExists,
        )

        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, errors.Wrap(err, "failed to create cloud provider config")
        }</span>

        <span class="cov8" title="1">if err := reconcileAzureSecret(ctx, r.Client, owner, newSecret, clusterScope.ClusterName()); err != nil </span><span class="cov0" title="0">{
                r.Recorder.Eventf(azureMachine, corev1.EventTypeWarning, "Error reconciling cloud provider secret for AzureMachine", err.Error())
                return ctrl.Result{}, errors.Wrap(err, "failed to reconcile azure secret")
        }</span>

        <span class="cov8" title="1">return ctrl.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file162" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "time"

        "github.com/pkg/errors"
        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/tools/record"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure/scope"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/identities"
        infrav1exp "sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        "sigs.k8s.io/cluster-api/util"
        "sigs.k8s.io/cluster-api/util/predicates"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
        "sigs.k8s.io/controller-runtime/pkg/source"
)

// AzureJSONMachinePoolReconciler reconciles Azure json secrets for AzureMachinePool objects.
type AzureJSONMachinePoolReconciler struct {
        client.Client
        Recorder         record.EventRecorder
        ReconcileTimeout time.Duration
        WatchFilterValue string
}

// SetupWithManager initializes this controller with a manager.
func (r *AzureJSONMachinePoolReconciler) SetupWithManager(ctx context.Context, mgr ctrl.Manager, options controller.Options) error <span class="cov0" title="0">{
        _, log, done := tele.StartSpanWithLogger(ctx,
                "controllers.AzureJSONMachinePoolReconciler.SetupWithManager",
        )
        defer done()

        azureMachinePoolMapper, err := util.ClusterToObjectsMapper(r.Client, &amp;infrav1exp.AzureMachinePoolList{}, mgr.GetScheme())
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to create mapper for Cluster to AzureMachinePools")
        }</span>

        <span class="cov0" title="0">c, err := ctrl.NewControllerManagedBy(mgr).
                WithOptions(options).
                For(&amp;infrav1exp.AzureMachinePool{}).
                WithEventFilter(predicates.ResourceNotPausedAndHasFilterLabel(log, r.WatchFilterValue)).
                Owns(&amp;corev1.Secret{}).
                Build(r)

        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to create controller")
        }</span>

        // Add a watch on Clusters to requeue when the infraRef is set. This is needed because the infraRef is not initially
        // set in Clusters created from a ClusterClass.
        <span class="cov0" title="0">if err := c.Watch(
                &amp;source.Kind{Type: &amp;clusterv1.Cluster{}},
                handler.EnqueueRequestsFromMapFunc(azureMachinePoolMapper),
                predicates.ClusterUnpausedAndInfrastructureReady(log),
                predicates.ResourceNotPausedAndHasFilterLabel(log, r.WatchFilterValue),
        ); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed adding a watch for Clusters")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Reconcile reconciles the Azure json for AzureMachinePool objects.
func (r *AzureJSONMachinePoolReconciler) Reconcile(ctx context.Context, req ctrl.Request) (_ ctrl.Result, reterr error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultedLoopTimeout(r.ReconcileTimeout))
        defer cancel()

        ctx, log, done := tele.StartSpanWithLogger(
                ctx,
                "controllers.AzureJSONMachinePoolReconciler.Reconcile",
                tele.KVP("namespace", req.Namespace),
                tele.KVP("name", req.Name),
                tele.KVP("kind", "AzureMachinePool"),
        )
        defer done()

        log = log.WithValues("namespace", req.Namespace, "azureMachinePool", req.Name)

        // Fetch the AzureMachine instance
        azureMachinePool := &amp;infrav1exp.AzureMachinePool{}
        err := r.Get(ctx, req.NamespacedName, azureMachinePool)
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        log.Info("object was not found")
                        return reconcile.Result{}, nil
                }</span>
                <span class="cov0" title="0">return reconcile.Result{}, err</span>
        }

        // Fetch the CAPI MachinePool.
        <span class="cov8" title="1">machinePool, err := GetOwnerMachinePool(ctx, r.Client, azureMachinePool.ObjectMeta)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">if machinePool == nil </span><span class="cov0" title="0">{
                log.Info("MachinePool Controller has not yet set OwnerRef")
                return reconcile.Result{}, nil
        }</span>

        <span class="cov8" title="1">log = log.WithValues("machinePool", machinePool.Name)

        // Fetch the Cluster.
        cluster, err := util.GetClusterFromMetadata(ctx, r.Client, machinePool.ObjectMeta)
        if err != nil </span><span class="cov0" title="0">{
                log.Info("MachinePool is missing cluster label or cluster does not exist")
                return reconcile.Result{}, nil
        }</span>

        <span class="cov8" title="1">log = log.WithValues("cluster", cluster.Name)

        _, kind := infrav1.GroupVersion.WithKind("AzureCluster").ToAPIVersionAndKind()

        // only look at azure clusters
        if cluster.Spec.InfrastructureRef == nil </span><span class="cov8" title="1">{
                log.Info("infra ref is nil")
                return ctrl.Result{}, nil
        }</span>
        <span class="cov8" title="1">if cluster.Spec.InfrastructureRef.Kind != kind </span><span class="cov8" title="1">{
                log.WithValues("kind", cluster.Spec.InfrastructureRef.Kind).Info("infra ref was not an AzureCluster")
                return ctrl.Result{}, nil
        }</span>

        // fetch the corresponding azure cluster
        <span class="cov8" title="1">azureCluster := &amp;infrav1.AzureCluster{}
        azureClusterName := types.NamespacedName{
                Namespace: req.Namespace,
                Name:      cluster.Spec.InfrastructureRef.Name,
        }

        if err := r.Get(ctx, azureClusterName, azureCluster); err != nil </span><span class="cov8" title="1">{
                log.Error(err, "failed to fetch AzureCluster")
                return reconcile.Result{}, err
        }</span>

        // Create the scope.
        <span class="cov8" title="1">clusterScope, err := scope.NewClusterScope(ctx, scope.ClusterScopeParams{
                Client:       r.Client,
                Cluster:      cluster,
                AzureCluster: azureCluster,
        })
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, errors.Wrap(err, "failed to create scope")
        }</span>

        // Construct secret for this machine
        <span class="cov8" title="1">userAssignedIdentityIfExists := ""
        if len(azureMachinePool.Spec.UserAssignedIdentities) &gt; 0 </span><span class="cov0" title="0">{
                // TODO: remove this ClientID lookup code when the fixed cloud-provider-azure is default
                idsClient := identities.NewClient(clusterScope)
                userAssignedIdentityIfExists, err = idsClient.GetClientID(
                        ctx, azureMachinePool.Spec.UserAssignedIdentities[0].ProviderID)
                if err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, errors.Wrap(err, "failed to get user-assigned identity ClientID")
                }</span>
        }

        <span class="cov8" title="1">apiVersion, kind := infrav1.GroupVersion.WithKind("AzureMachinePool").ToAPIVersionAndKind()
        owner := metav1.OwnerReference{
                APIVersion: apiVersion,
                Kind:       kind,
                Name:       azureMachinePool.GetName(),
                UID:        azureMachinePool.GetUID(),
        }

        if azureMachinePool.Spec.Identity == infrav1.VMIdentityNone </span><span class="cov0" title="0">{
                log.Info(fmt.Sprintf("WARNING, %s", spIdentityWarning))
                r.Recorder.Eventf(azureMachinePool, corev1.EventTypeWarning, "VMIdentityNone", spIdentityWarning)
        }</span>

        <span class="cov8" title="1">newSecret, err := GetCloudProviderSecret(
                clusterScope,
                azureMachinePool.Namespace,
                azureMachinePool.Name,
                owner,
                azureMachinePool.Spec.Identity,
                userAssignedIdentityIfExists,
        )

        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, errors.Wrap(err, "failed to create cloud provider config")
        }</span>

        <span class="cov8" title="1">if err := reconcileAzureSecret(ctx, r.Client, owner, newSecret, clusterScope.ClusterName()); err != nil </span><span class="cov0" title="0">{
                r.Recorder.Eventf(azureMachinePool, corev1.EventTypeWarning, "Error reconciling cloud provider secret for AzureMachinePool", err.Error())
                return ctrl.Result{}, errors.Wrap(err, "failed to reconcile azure secret")
        }</span>

        <span class="cov8" title="1">return ctrl.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file163" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "time"

        "github.com/pkg/errors"
        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/tools/record"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure/scope"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/identities"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        "sigs.k8s.io/cluster-api/util"
        "sigs.k8s.io/cluster-api/util/annotations"
        "sigs.k8s.io/cluster-api/util/predicates"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
        "sigs.k8s.io/controller-runtime/pkg/source"
)

// AzureJSONTemplateReconciler reconciles Azure json secrets for AzureMachineTemplate objects.
type AzureJSONTemplateReconciler struct {
        client.Client
        Recorder         record.EventRecorder
        ReconcileTimeout time.Duration
        WatchFilterValue string
}

// SetupWithManager initializes this controller with a manager.
func (r *AzureJSONTemplateReconciler) SetupWithManager(ctx context.Context, mgr ctrl.Manager, options controller.Options) error <span class="cov0" title="0">{
        _, log, done := tele.StartSpanWithLogger(ctx,
                "controllers.AzureJSONTemplateReconciler.SetupWithManager",
        )
        defer done()

        azureMachineTemplateMapper, err := util.ClusterToObjectsMapper(r.Client, &amp;infrav1.AzureMachineTemplateList{}, mgr.GetScheme())
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to create mapper for Cluster to AzureMachineTemplates")
        }</span>

        <span class="cov0" title="0">c, err := ctrl.NewControllerManagedBy(mgr).
                WithOptions(options).
                For(&amp;infrav1.AzureMachineTemplate{}).
                WithEventFilter(predicates.ResourceNotPausedAndHasFilterLabel(log, r.WatchFilterValue)).
                Owns(&amp;corev1.Secret{}).
                Build(r)

        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to create controller")
        }</span>

        // Add a watch on Clusters to requeue when the infraRef is set. This is needed because the infraRef is not initially
        // set in Clusters created from a ClusterClass.
        <span class="cov0" title="0">if err := c.Watch(
                &amp;source.Kind{Type: &amp;clusterv1.Cluster{}},
                handler.EnqueueRequestsFromMapFunc(azureMachineTemplateMapper),
                predicates.ClusterUnpausedAndInfrastructureReady(log),
                predicates.ResourceNotPausedAndHasFilterLabel(log, r.WatchFilterValue),
        ); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed adding a watch for Clusters")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Reconcile reconciles Azure json secrets for Azure machine templates.
func (r *AzureJSONTemplateReconciler) Reconcile(ctx context.Context, req ctrl.Request) (_ ctrl.Result, reterr error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultedLoopTimeout(r.ReconcileTimeout))
        defer cancel()

        ctx, log, done := tele.StartSpanWithLogger(ctx, "controllers.AzureJSONTemplateReconciler.Reconcile",
                tele.KVP("namespace", req.Namespace),
                tele.KVP("name", req.Name),
                tele.KVP("kind", "AzureMachineTemplate"),
        )
        defer done()

        // Fetch the AzureMachineTemplate instance
        azureMachineTemplate := &amp;infrav1.AzureMachineTemplate{}
        err := r.Get(ctx, req.NamespacedName, azureMachineTemplate)
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        log.Info("object was not found")
                        return reconcile.Result{}, nil
                }</span>
                <span class="cov0" title="0">return reconcile.Result{}, err</span>
        }

        // Fetch the Cluster.
        <span class="cov8" title="1">cluster, err := util.GetOwnerCluster(ctx, r.Client, azureMachineTemplate.ObjectMeta)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov8" title="1">if cluster == nil </span><span class="cov0" title="0">{
                log.Info("Cluster Controller has not yet set OwnerRef")
                return reconcile.Result{}, nil
        }</span>

        <span class="cov8" title="1">log = log.WithValues("cluster", cluster.Name)

        // Return early if the object or Cluster is paused.
        if annotations.IsPaused(cluster, azureMachineTemplate) </span><span class="cov0" title="0">{
                log.Info("AzureMachineTemplate or linked Cluster is marked as paused. Won't reconcile")
                return ctrl.Result{}, nil
        }</span>

        // only look at azure clusters
        <span class="cov8" title="1">if cluster.Spec.InfrastructureRef == nil </span><span class="cov8" title="1">{
                log.Info("infra ref is nil")
                return ctrl.Result{}, nil
        }</span>
        <span class="cov8" title="1">if cluster.Spec.InfrastructureRef.Kind != "AzureCluster" </span><span class="cov8" title="1">{
                log.WithValues("kind", cluster.Spec.InfrastructureRef.Kind).Info("infra ref was not an AzureCluster")
                return ctrl.Result{}, nil
        }</span>

        // fetch the corresponding azure cluster
        <span class="cov8" title="1">azureCluster := &amp;infrav1.AzureCluster{}
        azureClusterName := types.NamespacedName{
                Namespace: req.Namespace,
                Name:      cluster.Spec.InfrastructureRef.Name,
        }

        if err := r.Get(ctx, azureClusterName, azureCluster); err != nil </span><span class="cov8" title="1">{
                log.Error(err, "failed to fetch AzureCluster")
                return reconcile.Result{}, err
        }</span>

        // Create the scope.
        <span class="cov8" title="1">clusterScope, err := scope.NewClusterScope(ctx, scope.ClusterScopeParams{
                Client:       r.Client,
                Cluster:      cluster,
                AzureCluster: azureCluster,
        })
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, errors.Wrap(err, "failed to create scope")
        }</span>

        <span class="cov8" title="1">apiVersion, kind := infrav1.GroupVersion.WithKind("AzureMachineTemplate").ToAPIVersionAndKind()
        owner := metav1.OwnerReference{
                APIVersion: apiVersion,
                Kind:       kind,
                Name:       azureMachineTemplate.GetName(),
                UID:        azureMachineTemplate.GetUID(),
        }

        // Construct secret for this machine template
        userAssignedIdentityIfExists := ""
        if len(azureMachineTemplate.Spec.Template.Spec.UserAssignedIdentities) &gt; 0 </span><span class="cov0" title="0">{
                // TODO: remove this ClientID lookup code when the fixed cloud-provider-azure is default
                idsClient := identities.NewClient(clusterScope)
                userAssignedIdentityIfExists, err = idsClient.GetClientID(
                        ctx, azureMachineTemplate.Spec.Template.Spec.UserAssignedIdentities[0].ProviderID)
                if err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, errors.Wrap(err, "failed to get user-assigned identity ClientID")
                }</span>
        }

        <span class="cov8" title="1">if azureMachineTemplate.Spec.Template.Spec.Identity == infrav1.VMIdentityNone </span><span class="cov0" title="0">{
                log.Info(fmt.Sprintf("WARNING, %s", spIdentityWarning))
                r.Recorder.Eventf(azureMachineTemplate, corev1.EventTypeWarning, "VMIdentityNone", spIdentityWarning)
        }</span>

        <span class="cov8" title="1">newSecret, err := GetCloudProviderSecret(
                clusterScope,
                azureMachineTemplate.Namespace,
                azureMachineTemplate.Name,
                owner,
                azureMachineTemplate.Spec.Template.Spec.Identity,
                userAssignedIdentityIfExists,
        )

        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, errors.Wrap(err, "failed to create cloud provider config")
        }</span>

        <span class="cov8" title="1">if err := reconcileAzureSecret(ctx, r.Client, owner, newSecret, clusterScope.ClusterName()); err != nil </span><span class="cov0" title="0">{
                r.Recorder.Eventf(azureMachineTemplate, corev1.EventTypeWarning, "Error reconciling cloud provider secret for AzureMachineTemplate", err.Error())
                return ctrl.Result{}, errors.Wrap(err, "failed to reconcile azure secret")
        }</span>

        <span class="cov8" title="1">return ctrl.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file164" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "time"

        "github.com/pkg/errors"
        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/client-go/tools/record"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/scope"
        "sigs.k8s.io/cluster-api-provider-azure/pkg/coalescing"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        capierrors "sigs.k8s.io/cluster-api/errors"
        "sigs.k8s.io/cluster-api/util"
        "sigs.k8s.io/cluster-api/util/annotations"
        "sigs.k8s.io/cluster-api/util/conditions"
        "sigs.k8s.io/cluster-api/util/predicates"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
        "sigs.k8s.io/controller-runtime/pkg/source"
)

// AzureMachineReconciler reconciles an AzureMachine object.
type AzureMachineReconciler struct {
        client.Client
        Recorder                  record.EventRecorder
        ReconcileTimeout          time.Duration
        WatchFilterValue          string
        createAzureMachineService azureMachineServiceCreator
}

type azureMachineServiceCreator func(machineScope *scope.MachineScope) (*azureMachineService, error)

// NewAzureMachineReconciler returns a new AzureMachineReconciler instance.
func NewAzureMachineReconciler(client client.Client, recorder record.EventRecorder, reconcileTimeout time.Duration, watchFilterValue string) *AzureMachineReconciler <span class="cov8" title="1">{
        amr := &amp;AzureMachineReconciler{
                Client:           client,
                Recorder:         recorder,
                ReconcileTimeout: reconcileTimeout,
                WatchFilterValue: watchFilterValue,
        }

        amr.createAzureMachineService = newAzureMachineService

        return amr
}</span>

// SetupWithManager initializes this controller with a manager.
func (amr *AzureMachineReconciler) SetupWithManager(ctx context.Context, mgr ctrl.Manager, options Options) error <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx,
                "controllers.AzureMachineReconciler.SetupWithManager",
                tele.KVP("controller", "AzureMachine"),
        )
        defer done()

        var r reconcile.Reconciler = amr
        if options.Cache != nil </span><span class="cov0" title="0">{
                r = coalescing.NewReconciler(amr, options.Cache, log)
        }</span>

        // create mapper to transform incoming AzureClusters into AzureMachine requests
        <span class="cov8" title="1">azureClusterToAzureMachinesMapper, err := AzureClusterToAzureMachinesMapper(ctx, amr.Client, &amp;infrav1.AzureMachineList{}, mgr.GetScheme(), log)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to create AzureCluster to AzureMachines mapper")
        }</span>

        <span class="cov8" title="1">c, err := ctrl.NewControllerManagedBy(mgr).
                WithOptions(options.Options).
                For(&amp;infrav1.AzureMachine{}).
                WithEventFilter(predicates.ResourceNotPausedAndHasFilterLabel(log, amr.WatchFilterValue)).
                // watch for changes in CAPI Machine resources
                Watches(
                        &amp;source.Kind{Type: &amp;clusterv1.Machine{}},
                        handler.EnqueueRequestsFromMapFunc(util.MachineToInfrastructureMapFunc(infrav1.GroupVersion.WithKind("AzureMachine"))),
                ).
                // watch for changes in AzureCluster
                Watches(
                        &amp;source.Kind{Type: &amp;infrav1.AzureCluster{}},
                        handler.EnqueueRequestsFromMapFunc(azureClusterToAzureMachinesMapper),
                ).
                Build(r)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "error creating controller")
        }</span>

        <span class="cov8" title="1">azureMachineMapper, err := util.ClusterToObjectsMapper(amr.Client, &amp;infrav1.AzureMachineList{}, mgr.GetScheme())
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to create mapper for Cluster to AzureMachines")
        }</span>

        // Add a watch on clusterv1.Cluster object for unpause &amp; ready notifications.
        <span class="cov8" title="1">if err := c.Watch(
                &amp;source.Kind{Type: &amp;clusterv1.Cluster{}},
                handler.EnqueueRequestsFromMapFunc(azureMachineMapper),
                predicates.ClusterUnpausedAndInfrastructureReady(log),
                predicates.ResourceNotPausedAndHasFilterLabel(log, amr.WatchFilterValue),
        ); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed adding a watch for ready clusters")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// +kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=azuremachines,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=azuremachines/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=cluster.x-k8s.io,resources=machines;machines/status,verbs=get;list;watch
// +kubebuilder:rbac:groups="",resources=events,verbs=get;list;watch;create;update;patch
// +kubebuilder:rbac:groups="",resources=secrets;,verbs=get;list;watch

// Reconcile idempotently gets, creates, and updates a machine.
func (amr *AzureMachineReconciler) Reconcile(ctx context.Context, req ctrl.Request) (_ ctrl.Result, reterr error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultedLoopTimeout(amr.ReconcileTimeout))
        defer cancel()

        ctx, log, done := tele.StartSpanWithLogger(
                ctx,
                "controllers.AzureMachineReconciler.Reconcile",
                tele.KVP("namespace", req.Namespace),
                tele.KVP("name", req.Name),
                tele.KVP("kind", "AzureMachine"),
        )
        defer done()

        // Fetch the AzureMachine VM.
        azureMachine := &amp;infrav1.AzureMachine{}
        err := amr.Get(ctx, req.NamespacedName, azureMachine)
        if err != nil </span><span class="cov8" title="1">{
                if apierrors.IsNotFound(err) </span><span class="cov8" title="1">{
                        return reconcile.Result{}, nil
                }</span>
                <span class="cov0" title="0">return reconcile.Result{}, err</span>
        }

        // Fetch the Machine.
        <span class="cov0" title="0">machine, err := util.GetOwnerMachine(ctx, amr.Client, azureMachine.ObjectMeta)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov0" title="0">if machine == nil </span><span class="cov0" title="0">{
                amr.Recorder.Eventf(azureMachine, corev1.EventTypeNormal, "Machine controller dependency not yet met", "Machine Controller has not yet set OwnerRef")
                log.Info("Machine Controller has not yet set OwnerRef")
                return reconcile.Result{}, nil
        }</span>

        <span class="cov0" title="0">log = log.WithValues("machine", machine.Name)

        // Fetch the Cluster.
        cluster, err := util.GetClusterFromMetadata(ctx, amr.Client, machine.ObjectMeta)
        if err != nil </span><span class="cov0" title="0">{
                amr.Recorder.Eventf(azureMachine, corev1.EventTypeNormal, "Unable to get cluster from metadata", "Machine is missing cluster label or cluster does not exist")
                log.Info("Machine is missing cluster label or cluster does not exist")
                return reconcile.Result{}, nil
        }</span>

        <span class="cov0" title="0">log = log.WithValues("cluster", cluster.Name)

        // Return early if the object or Cluster is paused.
        if annotations.IsPaused(cluster, azureMachine) </span><span class="cov0" title="0">{
                log.Info("AzureMachine or linked Cluster is marked as paused. Won't reconcile")
                return ctrl.Result{}, nil
        }</span>

        <span class="cov0" title="0">log = log.WithValues("AzureCluster", cluster.Spec.InfrastructureRef.Name)
        azureClusterName := client.ObjectKey{
                Namespace: azureMachine.Namespace,
                Name:      cluster.Spec.InfrastructureRef.Name,
        }
        azureCluster := &amp;infrav1.AzureCluster{}
        if err := amr.Client.Get(ctx, azureClusterName, azureCluster); err != nil </span><span class="cov0" title="0">{
                amr.Recorder.Eventf(azureMachine, corev1.EventTypeNormal, "AzureCluster unavailable", "AzureCluster is not available yet")
                log.Info("AzureCluster is not available yet")
                return reconcile.Result{}, nil
        }</span>

        // Create the cluster scope
        <span class="cov0" title="0">clusterScope, err := scope.NewClusterScope(ctx, scope.ClusterScopeParams{
                Client:       amr.Client,
                Cluster:      cluster,
                AzureCluster: azureCluster,
        })
        if err != nil </span><span class="cov0" title="0">{
                amr.Recorder.Eventf(azureCluster, corev1.EventTypeWarning, "Error creating the cluster scope", err.Error())
                return reconcile.Result{}, err
        }</span>

        // Create the machine scope
        <span class="cov0" title="0">machineScope, err := scope.NewMachineScope(scope.MachineScopeParams{
                Client:       amr.Client,
                Machine:      machine,
                AzureMachine: azureMachine,
                ClusterScope: clusterScope,
        })
        if err != nil </span><span class="cov0" title="0">{
                amr.Recorder.Eventf(azureMachine, corev1.EventTypeWarning, "Error creating the machine scope", err.Error())
                return reconcile.Result{}, errors.Wrap(err, "failed to create scope")
        }</span>

        // Always close the scope when exiting this function so we can persist any AzureMachine changes.
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := machineScope.Close(ctx); err != nil &amp;&amp; reterr == nil </span><span class="cov0" title="0">{
                        reterr = err
                }</span>
        }()

        // Handle deleted machines
        <span class="cov0" title="0">if !azureMachine.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                return amr.reconcileDelete(ctx, machineScope, clusterScope)
        }</span>

        // Handle non-deleted machines
        <span class="cov0" title="0">return amr.reconcileNormal(ctx, machineScope, clusterScope)</span>
}

func (amr *AzureMachineReconciler) reconcileNormal(ctx context.Context, machineScope *scope.MachineScope, clusterScope *scope.ClusterScope) (reconcile.Result, error) <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "controllers.AzureMachineReconciler.reconcileNormal")
        defer done()

        log.Info("Reconciling AzureMachine")
        // If the AzureMachine is in an error state, return early.
        if machineScope.AzureMachine.Status.FailureReason != nil || machineScope.AzureMachine.Status.FailureMessage != nil </span><span class="cov0" title="0">{
                log.Info("Error state detected, skipping reconciliation")
                return reconcile.Result{}, nil
        }</span>

        // If the AzureMachine doesn't have our finalizer, add it.
        <span class="cov8" title="1">controllerutil.AddFinalizer(machineScope.AzureMachine, infrav1.MachineFinalizer)
        // Register the finalizer immediately to avoid orphaning Azure resources on delete
        if err := machineScope.PatchObject(ctx); err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>

        // Make sure the Cluster Infrastructure is ready.
        <span class="cov8" title="1">if !clusterScope.Cluster.Status.InfrastructureReady </span><span class="cov8" title="1">{
                log.Info("Cluster infrastructure is not ready yet")
                conditions.MarkFalse(machineScope.AzureMachine, infrav1.VMRunningCondition, infrav1.WaitingForClusterInfrastructureReason, clusterv1.ConditionSeverityInfo, "")
                return reconcile.Result{}, nil
        }</span>

        // Make sure bootstrap data is available and populated.
        <span class="cov8" title="1">if machineScope.Machine.Spec.Bootstrap.DataSecretName == nil </span><span class="cov8" title="1">{
                log.Info("Bootstrap data secret reference is not yet available")
                conditions.MarkFalse(machineScope.AzureMachine, infrav1.VMRunningCondition, infrav1.WaitingForBootstrapDataReason, clusterv1.ConditionSeverityInfo, "")
                return reconcile.Result{}, nil
        }</span>

        <span class="cov0" title="0">var reconcileError azure.ReconcileError

        // Initialize the cache to be used by the AzureMachine services.
        err := machineScope.InitMachineCache(ctx)
        if err != nil </span><span class="cov0" title="0">{
                if errors.As(err, &amp;reconcileError) &amp;&amp; reconcileError.IsTerminal() </span><span class="cov0" title="0">{
                        amr.Recorder.Eventf(machineScope.AzureMachine, corev1.EventTypeWarning, "SKUNotFound", errors.Wrap(err, "failed to initialize machine cache").Error())
                        log.Error(err, "Failed to initialize machine cache")
                        machineScope.SetFailureReason(capierrors.InvalidConfigurationMachineError)
                        machineScope.SetFailureMessage(err)
                        machineScope.SetNotReady()
                        return reconcile.Result{}, nil
                }</span>
                <span class="cov0" title="0">return reconcile.Result{}, errors.Wrap(err, "failed to init machine scope cache")</span>
        }

        <span class="cov0" title="0">ams, err := amr.createAzureMachineService(machineScope)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, errors.Wrap(err, "failed to create azure machine service")
        }</span>

        <span class="cov0" title="0">if err := ams.Reconcile(ctx); err != nil </span><span class="cov0" title="0">{
                // This means that a VM was created and managed by this controller, but is not present anymore.
                // In this case, we mark it as failed and leave it to MHC for remediation
                if errors.As(err, &amp;azure.VMDeletedError{}) </span><span class="cov0" title="0">{
                        amr.Recorder.Eventf(machineScope.AzureMachine, corev1.EventTypeWarning, "VMDeleted", errors.Wrap(err, "failed to reconcile AzureMachine").Error())
                        machineScope.SetFailureReason(capierrors.UpdateMachineError)
                        machineScope.SetFailureMessage(err)
                        machineScope.SetNotReady()
                        machineScope.SetVMState(infrav1.Deleted)
                        return reconcile.Result{}, errors.Wrap(err, "failed to reconcile AzureMachine")
                }</span>

                // Handle transient and terminal errors
                <span class="cov0" title="0">if errors.As(err, &amp;reconcileError) </span><span class="cov0" title="0">{
                        if reconcileError.IsTerminal() </span><span class="cov0" title="0">{
                                amr.Recorder.Eventf(machineScope.AzureMachine, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "failed to reconcile AzureMachine").Error())
                                log.Error(err, "failed to reconcile AzureMachine", "name", machineScope.Name())
                                machineScope.SetFailureReason(capierrors.CreateMachineError)
                                machineScope.SetFailureMessage(err)
                                machineScope.SetNotReady()
                                machineScope.SetVMState(infrav1.Failed)
                                return reconcile.Result{}, nil
                        }</span>

                        <span class="cov0" title="0">if reconcileError.IsTransient() </span><span class="cov0" title="0">{
                                if azure.IsOperationNotDoneError(reconcileError) </span><span class="cov0" title="0">{
                                        log.V(2).Info(fmt.Sprintf("AzureMachine reconcile not done: %s", reconcileError.Error()))
                                }</span> else<span class="cov0" title="0"> {
                                        log.V(2).Info(fmt.Sprintf("transient failure to reconcile AzureMachine, retrying: %s", reconcileError.Error()))
                                }</span>
                                <span class="cov0" title="0">return reconcile.Result{RequeueAfter: reconcileError.RequeueAfter()}, nil</span>
                        }
                }
                <span class="cov0" title="0">amr.Recorder.Eventf(machineScope.AzureMachine, corev1.EventTypeWarning, "ReconcileError", errors.Wrapf(err, "failed to reconcile AzureMachine").Error())
                return reconcile.Result{}, errors.Wrap(err, "failed to reconcile AzureMachine")</span>
        }

        <span class="cov0" title="0">machineScope.SetReady()

        return reconcile.Result{}, nil</span>
}

func (amr *AzureMachineReconciler) reconcileDelete(ctx context.Context, machineScope *scope.MachineScope, clusterScope *scope.ClusterScope) (reconcile.Result, error) <span class="cov0" title="0">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "controllers.AzureMachineReconciler.reconcileDelete")
        defer done()

        log.Info("Handling deleted AzureMachine")
        conditions.MarkFalse(machineScope.AzureMachine, infrav1.VMRunningCondition, clusterv1.DeletingReason, clusterv1.ConditionSeverityInfo, "")
        if err := machineScope.PatchObject(ctx); err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov0" title="0">if ShouldDeleteIndividualResources(ctx, clusterScope) </span><span class="cov0" title="0">{
                log.Info("Deleting AzureMachine")
                ams, err := amr.createAzureMachineService(machineScope)
                if err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, errors.Wrap(err, "failed to create azure machine service")
                }</span>

                <span class="cov0" title="0">if err := ams.Delete(ctx); err != nil </span><span class="cov0" title="0">{
                        // Handle transient errors
                        var reconcileError azure.ReconcileError
                        if errors.As(err, &amp;reconcileError) </span><span class="cov0" title="0">{
                                if reconcileError.IsTransient() </span><span class="cov0" title="0">{
                                        if azure.IsOperationNotDoneError(reconcileError) </span><span class="cov0" title="0">{
                                                log.V(2).Info(fmt.Sprintf("AzureMachine delete not done: %s", reconcileError.Error()))
                                        }</span> else<span class="cov0" title="0"> {
                                                log.V(2).Info("transient failure to delete AzureMachine, retrying")
                                        }</span>
                                        <span class="cov0" title="0">return reconcile.Result{RequeueAfter: reconcileError.RequeueAfter()}, nil</span>
                                }
                        }

                        <span class="cov0" title="0">amr.Recorder.Eventf(machineScope.AzureMachine, corev1.EventTypeWarning, "Error deleting AzureMachine", errors.Wrapf(err, "error deleting AzureMachine %s/%s", machineScope.Namespace(), machineScope.Name()).Error())
                        return reconcile.Result{}, errors.Wrapf(err, "error deleting AzureMachine %s/%s", machineScope.Namespace(), machineScope.Name())</span>
                }
        } else<span class="cov0" title="0"> {
                log.Info("Skipping AzureMachine Deletion; will delete whole resource group.")
        }</span>

        // we're done deleting this AzureMachine so remove the finalizer.
        <span class="cov0" title="0">log.Info("Removing finalizer from AzureMachine")
        controllerutil.RemoveFinalizer(machineScope.AzureMachine, infrav1.MachineFinalizer)

        return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file165" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"

        "github.com/pkg/errors"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/scope"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/availabilitysets"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/disks"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/inboundnatrules"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/networkinterfaces"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/publicips"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/resourceskus"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/roleassignments"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/tags"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/virtualmachines"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/vmextensions"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// azureMachineService is the group of services called by the AzureMachine controller.
type azureMachineService struct {
        scope *scope.MachineScope
        // services is the list of services to be reconciled.
        // The order of the services is important as it determines the order in which the services are reconciled.
        services []azure.ServiceReconciler
        skuCache *resourceskus.Cache
}

// newAzureMachineService populates all the services based on input scope.
func newAzureMachineService(machineScope *scope.MachineScope) (*azureMachineService, error) <span class="cov0" title="0">{
        cache, err := resourceskus.GetCache(machineScope, machineScope.Location())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed creating a NewCache")
        }</span>

        <span class="cov0" title="0">return &amp;azureMachineService{
                scope: machineScope,
                services: []azure.ServiceReconciler{
                        publicips.New(machineScope),
                        inboundnatrules.New(machineScope),
                        networkinterfaces.New(machineScope, cache),
                        availabilitysets.New(machineScope, cache),
                        disks.New(machineScope),
                        virtualmachines.New(machineScope),
                        roleassignments.New(machineScope),
                        vmextensions.New(machineScope),
                        tags.New(machineScope),
                },
                skuCache: cache,
        }, nil</span>
}

// Reconcile reconciles all the services in a predetermined order.
func (s *azureMachineService) Reconcile(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "controllers.azureMachineService.Reconcile")
        defer done()

        if err := s.scope.SetSubnetName(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed defaulting subnet name")
        }</span>

        <span class="cov8" title="1">for _, service := range s.services </span><span class="cov8" title="1">{
                if err := service.Reconcile(ctx); err != nil </span><span class="cov8" title="1">{
                        return errors.Wrapf(err, "failed to reconcile AzureMachine service %s", service.Name())
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Delete deletes all the services in a predetermined order.
func (s *azureMachineService) Delete(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "controllers.azureMachineService.Delete")
        defer done()

        // Delete services in reverse order of creation.
        for i := len(s.services) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if err := s.services[i].Delete(ctx); err != nil </span><span class="cov8" title="1">{
                        return errors.Wrapf(err, "failed to delete AzureMachine service %s", s.services[i].Name())
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file166" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "encoding/json"
        "fmt"

        "github.com/go-logr/logr"
        "github.com/pkg/errors"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/equality"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/types"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/scope"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/groups"
        infrav1exp "sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/pkg/coalescing"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        expv1 "sigs.k8s.io/cluster-api/exp/api/v1beta1"
        "sigs.k8s.io/cluster-api/util"
        "sigs.k8s.io/cluster-api/util/conditions"
        "sigs.k8s.io/cluster-api/util/patch"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/client/apiutil"
        "sigs.k8s.io/controller-runtime/pkg/controller"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/handler"
)

const (
        spIdentityWarning = "You are using Service Principal authentication for Cloud Provider Azure which is less secure than Managed Identity. " +
                "Your Service Principal credentials will be written to a file on the disk of each VM in order to be accessible by Cloud Provider. " +
                "To learn more, see https://capz.sigs.k8s.io/topics/identities-use-cases.html#azure-host-identity "
        deprecatedManagerCredsWarning = "You're using deprecated functionality: " +
                "Using Azure credentials from the manager environment is deprecated and will be removed in future releases. " +
                "Please specify an AzureClusterIdentity for the AzureCluster instead, see: https://capz.sigs.k8s.io/topics/multitenancy.html "
)

type (
        // Options are controller options extended.
        Options struct {
                controller.Options
                Cache *coalescing.ReconcileCache
        }
)

// AzureClusterToAzureMachinesMapper creates a mapping handler to transform AzureClusters into AzureMachines. The transform
// requires AzureCluster to map to the owning Cluster, then from the Cluster, collect the Machines belonging to the cluster,
// then finally projecting the infrastructure reference to the AzureMachine.
func AzureClusterToAzureMachinesMapper(ctx context.Context, c client.Client, obj runtime.Object, scheme *runtime.Scheme, log logr.Logger) (handler.MapFunc, error) <span class="cov8" title="1">{
        gvk, err := apiutil.GVKForObject(obj, scheme)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to find GVK for AzureMachine")
        }</span>

        <span class="cov8" title="1">return func(o client.Object) []ctrl.Request </span><span class="cov8" title="1">{
                ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultMappingTimeout)
                defer cancel()

                azCluster, ok := o.(*infrav1.AzureCluster)
                if !ok </span><span class="cov0" title="0">{
                        log.Error(errors.Errorf("expected an AzureCluster, got %T instead", o), "failed to map AzureCluster")
                        return nil
                }</span>

                <span class="cov8" title="1">log = log.WithValues("AzureCluster", azCluster.Name, "Namespace", azCluster.Namespace)

                // Don't handle deleted AzureClusters
                if !azCluster.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                        log.V(4).Info("AzureCluster has a deletion timestamp, skipping mapping.")
                        return nil
                }</span>

                <span class="cov8" title="1">clusterName, ok := GetOwnerClusterName(azCluster.ObjectMeta)
                if !ok </span><span class="cov0" title="0">{
                        log.Info("unable to get the owner cluster")
                        return nil
                }</span>

                <span class="cov8" title="1">machineList := &amp;clusterv1.MachineList{}
                machineList.SetGroupVersionKind(gvk)
                // list all of the requested objects within the cluster namespace with the cluster name label
                if err := c.List(ctx, machineList, client.InNamespace(azCluster.Namespace), client.MatchingLabels{clusterv1.ClusterLabelName: clusterName}); err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">mapFunc := util.MachineToInfrastructureMapFunc(gvk)
                var results []ctrl.Request
                for _, machine := range machineList.Items </span><span class="cov8" title="1">{
                        m := machine
                        azureMachines := mapFunc(&amp;m)
                        results = append(results, azureMachines...)
                }</span>

                <span class="cov8" title="1">return results</span>
        }, nil
}

// GetOwnerClusterName returns the name of the owning Cluster by finding a clusterv1.Cluster in the ownership references.
func GetOwnerClusterName(obj metav1.ObjectMeta) (string, bool) <span class="cov8" title="1">{
        for _, ref := range obj.OwnerReferences </span><span class="cov8" title="1">{
                if ref.Kind != "Cluster" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">gv, err := schema.ParseGroupVersion(ref.APIVersion)
                if err != nil </span><span class="cov0" title="0">{
                        return "", false
                }</span>
                <span class="cov8" title="1">if gv.Group == clusterv1.GroupVersion.Group </span><span class="cov8" title="1">{
                        return ref.Name, true
                }</span>
        }
        <span class="cov0" title="0">return "", false</span>
}

// GetObjectsToRequestsByNamespaceAndClusterName returns the slice of ctrl.Requests consisting the list items contained in the unstructured list.
func GetObjectsToRequestsByNamespaceAndClusterName(ctx context.Context, c client.Client, clusterKey client.ObjectKey, list *unstructured.UnstructuredList) []ctrl.Request <span class="cov0" title="0">{
        // list all of the requested objects within the cluster namespace with the cluster name label
        if err := c.List(ctx, list, client.InNamespace(clusterKey.Namespace), client.MatchingLabels{clusterv1.ClusterLabelName: clusterKey.Name}); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">results := make([]ctrl.Request, len(list.Items))
        for i, obj := range list.Items </span><span class="cov0" title="0">{
                results[i] = ctrl.Request{
                        NamespacedName: client.ObjectKey{Namespace: obj.GetNamespace(), Name: obj.GetName()},
                }
        }</span>
        <span class="cov0" title="0">return results</span>
}

// referSameObject returns true if a and b point to the same object.
func referSameObject(a, b metav1.OwnerReference) bool <span class="cov0" title="0">{
        aGV, err := schema.ParseGroupVersion(a.APIVersion)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">bGV, err := schema.ParseGroupVersion(b.APIVersion)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return aGV.Group == bGV.Group &amp;&amp; a.Kind == b.Kind &amp;&amp; a.Name == b.Name</span>
}

// GetCloudProviderSecret returns the required azure json secret for the provided parameters.
func GetCloudProviderSecret(d azure.ClusterScoper, namespace, name string, owner metav1.OwnerReference, identityType infrav1.VMIdentity, userIdentityID string) (*corev1.Secret, error) <span class="cov8" title="1">{
        secret := &amp;corev1.Secret{
                ObjectMeta: metav1.ObjectMeta{
                        Namespace: namespace,
                        Name:      fmt.Sprintf("%s-azure-json", name),
                        Labels: map[string]string{
                                d.ClusterName(): string(infrav1.ResourceLifecycleOwned),
                        },
                        OwnerReferences: []metav1.OwnerReference{owner},
                },
        }

        var controlPlaneConfig, workerNodeConfig *CloudProviderConfig

        switch identityType </span>{
        case infrav1.VMIdentitySystemAssigned:<span class="cov8" title="1">
                controlPlaneConfig, workerNodeConfig = systemAssignedIdentityCloudProviderConfig(d)</span>
        case infrav1.VMIdentityUserAssigned:<span class="cov8" title="1">
                if len(userIdentityID) &lt; 1 </span><span class="cov0" title="0">{
                        return nil, errors.New("expected a non-empty userIdentityID")
                }</span>
                <span class="cov8" title="1">controlPlaneConfig, workerNodeConfig = userAssignedIdentityCloudProviderConfig(d, userIdentityID)</span>
        case infrav1.VMIdentityNone:<span class="cov8" title="1">
                controlPlaneConfig, workerNodeConfig = newCloudProviderConfig(d)</span>
        }

        <span class="cov8" title="1">controlPlaneData, err := json.MarshalIndent(controlPlaneConfig, "", "    ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed control plane json marshal")
        }</span>
        <span class="cov8" title="1">workerNodeData, err := json.MarshalIndent(workerNodeConfig, "", "    ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed worker node json marshal")
        }</span>

        <span class="cov8" title="1">secret.Data = map[string][]byte{
                "control-plane-azure.json": controlPlaneData,
                "worker-node-azure.json":   workerNodeData,
                // added for backwards compatibility
                "azure.json": controlPlaneData,
        }

        return secret, nil</span>
}

func systemAssignedIdentityCloudProviderConfig(d azure.ClusterScoper) (cpConfig *CloudProviderConfig, wkConfig *CloudProviderConfig) <span class="cov8" title="1">{
        controlPlaneConfig, workerConfig := newCloudProviderConfig(d)
        controlPlaneConfig.AadClientID = ""
        controlPlaneConfig.AadClientSecret = ""
        controlPlaneConfig.UseManagedIdentityExtension = true
        workerConfig.AadClientID = ""
        workerConfig.AadClientSecret = ""
        workerConfig.UseManagedIdentityExtension = true
        return controlPlaneConfig, workerConfig
}</span>

func userAssignedIdentityCloudProviderConfig(d azure.ClusterScoper, identityID string) (cpConfig *CloudProviderConfig, wkConfig *CloudProviderConfig) <span class="cov8" title="1">{
        controlPlaneConfig, workerConfig := newCloudProviderConfig(d)
        controlPlaneConfig.AadClientID = ""
        controlPlaneConfig.AadClientSecret = ""
        controlPlaneConfig.UseManagedIdentityExtension = true
        controlPlaneConfig.UserAssignedIdentityID = identityID
        workerConfig.AadClientID = ""
        workerConfig.AadClientSecret = ""
        workerConfig.UseManagedIdentityExtension = true
        workerConfig.UserAssignedIdentityID = identityID
        return controlPlaneConfig, workerConfig
}</span>

func newCloudProviderConfig(d azure.ClusterScoper) (controlPlaneConfig *CloudProviderConfig, workerConfig *CloudProviderConfig) <span class="cov8" title="1">{
        subnet := getOneNodeSubnet(d)
        return (&amp;CloudProviderConfig{
                        Cloud:                        d.CloudEnvironment(),
                        AadClientID:                  d.ClientID(),
                        AadClientSecret:              d.ClientSecret(),
                        TenantID:                     d.TenantID(),
                        SubscriptionID:               d.SubscriptionID(),
                        ResourceGroup:                d.ResourceGroup(),
                        SecurityGroupName:            subnet.SecurityGroup.Name,
                        SecurityGroupResourceGroup:   d.Vnet().ResourceGroup,
                        Location:                     d.Location(),
                        VMType:                       "vmss",
                        VnetName:                     d.Vnet().Name,
                        VnetResourceGroup:            d.Vnet().ResourceGroup,
                        SubnetName:                   subnet.Name,
                        RouteTableName:               subnet.RouteTable.Name,
                        LoadBalancerSku:              "Standard",
                        MaximumLoadBalancerRuleCount: 250,
                        UseManagedIdentityExtension:  false,
                        UseInstanceMetadata:          true,
                }).overrideFromSpec(d),
                (&amp;CloudProviderConfig{
                        Cloud:                        d.CloudEnvironment(),
                        AadClientID:                  d.ClientID(),
                        AadClientSecret:              d.ClientSecret(),
                        TenantID:                     d.TenantID(),
                        SubscriptionID:               d.SubscriptionID(),
                        ResourceGroup:                d.ResourceGroup(),
                        SecurityGroupName:            subnet.SecurityGroup.Name,
                        SecurityGroupResourceGroup:   d.Vnet().ResourceGroup,
                        Location:                     d.Location(),
                        VMType:                       "vmss",
                        VnetName:                     d.Vnet().Name,
                        VnetResourceGroup:            d.Vnet().ResourceGroup,
                        SubnetName:                   subnet.Name,
                        RouteTableName:               subnet.RouteTable.Name,
                        LoadBalancerSku:              "Standard",
                        MaximumLoadBalancerRuleCount: 250,
                        UseManagedIdentityExtension:  false,
                        UseInstanceMetadata:          true,
                }).overrideFromSpec(d)
}</span>

// getOneNodeSubnet returns one of the subnets for the node role.
func getOneNodeSubnet(d azure.ClusterScoper) infrav1.SubnetSpec <span class="cov8" title="1">{
        for _, subnet := range d.Subnets() </span><span class="cov8" title="1">{
                if subnet.Role == infrav1.SubnetNode </span><span class="cov8" title="1">{
                        return subnet
                }</span>
        }
        <span class="cov0" title="0">return infrav1.SubnetSpec{}</span>
}

// CloudProviderConfig is an abbreviated version of the same struct in k/k.
type CloudProviderConfig struct {
        Cloud                        string `json:"cloud"`
        TenantID                     string `json:"tenantId"`
        SubscriptionID               string `json:"subscriptionId"`
        AadClientID                  string `json:"aadClientId,omitempty"`
        AadClientSecret              string `json:"aadClientSecret,omitempty"`
        ResourceGroup                string `json:"resourceGroup"`
        SecurityGroupName            string `json:"securityGroupName"`
        SecurityGroupResourceGroup   string `json:"securityGroupResourceGroup"`
        Location                     string `json:"location"`
        VMType                       string `json:"vmType"`
        VnetName                     string `json:"vnetName"`
        VnetResourceGroup            string `json:"vnetResourceGroup"`
        SubnetName                   string `json:"subnetName"`
        RouteTableName               string `json:"routeTableName"`
        LoadBalancerSku              string `json:"loadBalancerSku"`
        MaximumLoadBalancerRuleCount int    `json:"maximumLoadBalancerRuleCount"`
        UseManagedIdentityExtension  bool   `json:"useManagedIdentityExtension"`
        UseInstanceMetadata          bool   `json:"useInstanceMetadata"`
        UserAssignedIdentityID       string `json:"userAssignedIdentityID,omitempty"`
        CloudProviderRateLimitConfig
        BackOffConfig
}

// overrideFromSpec overrides cloud provider config with the values provided in cluster spec.
func (cpc *CloudProviderConfig) overrideFromSpec(d azure.ClusterScoper) *CloudProviderConfig <span class="cov8" title="1">{
        if d.CloudProviderConfigOverrides() == nil </span><span class="cov8" title="1">{
                return cpc
        }</span>

        <span class="cov8" title="1">for _, rateLimit := range d.CloudProviderConfigOverrides().RateLimits </span><span class="cov8" title="1">{
                switch rateLimit.Name </span>{
                case infrav1.DefaultRateLimit:<span class="cov8" title="1">
                        cpc.RateLimitConfig = *toCloudProviderRateLimitConfig(rateLimit.Config)</span>
                case infrav1.RouteRateLimit:<span class="cov0" title="0">
                        cpc.RouteRateLimit = toCloudProviderRateLimitConfig(rateLimit.Config)</span>
                case infrav1.SubnetsRateLimit:<span class="cov0" title="0">
                        cpc.SubnetsRateLimit = toCloudProviderRateLimitConfig(rateLimit.Config)</span>
                case infrav1.InterfaceRateLimit:<span class="cov0" title="0">
                        cpc.InterfaceRateLimit = toCloudProviderRateLimitConfig(rateLimit.Config)</span>
                case infrav1.RouteTableRateLimit:<span class="cov0" title="0">
                        cpc.RouteTableRateLimit = toCloudProviderRateLimitConfig(rateLimit.Config)</span>
                case infrav1.LoadBalancerRateLimit:<span class="cov8" title="1">
                        cpc.LoadBalancerRateLimit = toCloudProviderRateLimitConfig(rateLimit.Config)</span>
                case infrav1.PublicIPAddressRateLimit:<span class="cov0" title="0">
                        cpc.PublicIPAddressRateLimit = toCloudProviderRateLimitConfig(rateLimit.Config)</span>
                case infrav1.SecurityGroupRateLimit:<span class="cov0" title="0">
                        cpc.SecurityGroupRateLimit = toCloudProviderRateLimitConfig(rateLimit.Config)</span>
                case infrav1.VirtualMachineRateLimit:<span class="cov0" title="0">
                        cpc.VirtualMachineRateLimit = toCloudProviderRateLimitConfig(rateLimit.Config)</span>
                case infrav1.StorageAccountRateLimit:<span class="cov0" title="0">
                        cpc.StorageAccountRateLimit = toCloudProviderRateLimitConfig(rateLimit.Config)</span>
                case infrav1.DiskRateLimit:<span class="cov0" title="0">
                        cpc.DiskRateLimit = toCloudProviderRateLimitConfig(rateLimit.Config)</span>
                case infrav1.SnapshotRateLimit:<span class="cov0" title="0">
                        cpc.SnapshotRateLimit = toCloudProviderRateLimitConfig(rateLimit.Config)</span>
                case infrav1.VirtualMachineScaleSetRateLimit:<span class="cov0" title="0">
                        cpc.VirtualMachineScaleSetRateLimit = toCloudProviderRateLimitConfig(rateLimit.Config)</span>
                case infrav1.VirtualMachineSizesRateLimit:<span class="cov0" title="0">
                        cpc.VirtualMachineSizeRateLimit = toCloudProviderRateLimitConfig(rateLimit.Config)</span>
                case infrav1.AvailabilitySetRateLimit:<span class="cov0" title="0">
                        cpc.AvailabilitySetRateLimit = toCloudProviderRateLimitConfig(rateLimit.Config)</span>
                }
        }

        <span class="cov8" title="1">cpc.BackOffConfig = toCloudProviderBackOffConfig(d.CloudProviderConfigOverrides().BackOffs)
        return cpc</span>
}

// toCloudProviderRateLimitConfig returns converts infrav1.RateLimitConfig to RateLimitConfig that is required with the cloud provider.
func toCloudProviderRateLimitConfig(source infrav1.RateLimitConfig) *RateLimitConfig <span class="cov8" title="1">{
        rateLimitConfig := RateLimitConfig{}
        rateLimitConfig.CloudProviderRateLimit = source.CloudProviderRateLimit
        if source.CloudProviderRateLimitQPS != nil </span><span class="cov8" title="1">{
                rateLimitConfig.CloudProviderRateLimitQPS = float32(source.CloudProviderRateLimitQPS.AsApproximateFloat64())
        }</span>
        <span class="cov8" title="1">rateLimitConfig.CloudProviderRateLimitBucket = source.CloudProviderRateLimitBucket
        if source.CloudProviderRateLimitQPSWrite != nil </span><span class="cov0" title="0">{
                rateLimitConfig.CloudProviderRateLimitQPSWrite = float32(source.CloudProviderRateLimitQPSWrite.AsApproximateFloat64())
        }</span>
        <span class="cov8" title="1">rateLimitConfig.CloudProviderRateLimitBucketWrite = source.CloudProviderRateLimitBucketWrite
        return &amp;rateLimitConfig</span>
}

// CloudProviderRateLimitConfig represents the rate limiting configurations in azure cloud provider config.
// See: https://kubernetes-sigs.github.io/cloud-provider-azure/install/configs/#per-client-rate-limiting.
// This is a copy of the struct used in cloud-provider-azure: https://github.com/kubernetes-sigs/cloud-provider-azure/blob/d585c2031925b39c925624302f22f8856e29e352/pkg/provider/azure_ratelimit.go#L25
type CloudProviderRateLimitConfig struct {
        RateLimitConfig

        RouteRateLimit                  *RateLimitConfig `json:"routeRateLimit,omitempty"`
        SubnetsRateLimit                *RateLimitConfig `json:"subnetsRateLimit,omitempty"`
        InterfaceRateLimit              *RateLimitConfig `json:"interfaceRateLimit,omitempty"`
        RouteTableRateLimit             *RateLimitConfig `json:"routeTableRateLimit,omitempty"`
        LoadBalancerRateLimit           *RateLimitConfig `json:"loadBalancerRateLimit,omitempty"`
        PublicIPAddressRateLimit        *RateLimitConfig `json:"publicIPAddressRateLimit,omitempty"`
        SecurityGroupRateLimit          *RateLimitConfig `json:"securityGroupRateLimit,omitempty"`
        VirtualMachineRateLimit         *RateLimitConfig `json:"virtualMachineRateLimit,omitempty"`
        StorageAccountRateLimit         *RateLimitConfig `json:"storageAccountRateLimit,omitempty"`
        DiskRateLimit                   *RateLimitConfig `json:"diskRateLimit,omitempty"`
        SnapshotRateLimit               *RateLimitConfig `json:"snapshotRateLimit,omitempty"`
        VirtualMachineScaleSetRateLimit *RateLimitConfig `json:"virtualMachineScaleSetRateLimit,omitempty"`
        VirtualMachineSizeRateLimit     *RateLimitConfig `json:"virtualMachineSizesRateLimit,omitempty"`
        AvailabilitySetRateLimit        *RateLimitConfig `json:"availabilitySetRateLimit,omitempty"`
}

// RateLimitConfig indicates the rate limit config options.
// This is a copy of the struct used in cloud-provider-azure: https://github.com/kubernetes-sigs/cloud-provider-azure/blob/d585c2031925b39c925624302f22f8856e29e352/pkg/azureclients/azure_client_config.go#L48
type RateLimitConfig struct {
        CloudProviderRateLimit            bool    `json:"cloudProviderRateLimit,omitempty"`
        CloudProviderRateLimitQPS         float32 `json:"cloudProviderRateLimitQPS,omitempty"`
        CloudProviderRateLimitBucket      int     `json:"cloudProviderRateLimitBucket,omitempty"`
        CloudProviderRateLimitQPSWrite    float32 `json:"cloudProviderRateLimitQPSWrite,omitempty"`
        CloudProviderRateLimitBucketWrite int     `json:"cloudProviderRateLimitBucketWrite,omitempty"`
}

// BackOffConfig indicates the back-off config options.
// This is a copy of the struct used in cloud-provider-azure: https://github.com/kubernetes-sigs/cloud-provider-azure/blob/d585c2031925b39c925624302f22f8856e29e352/pkg/azureclients/azure_client_config.go#L48
type BackOffConfig struct {
        CloudProviderBackoff         bool    `json:"cloudProviderBackoff,omitempty"`
        CloudProviderBackoffRetries  int     `json:"cloudProviderBackoffRetries,omitempty"`
        CloudProviderBackoffExponent float64 `json:"cloudProviderBackoffExponent,omitempty"`
        CloudProviderBackoffDuration int     `json:"cloudProviderBackoffDuration,omitempty"`
        CloudProviderBackoffJitter   float64 `json:"cloudProviderBackoffJitter,omitempty"`
}

// toCloudProviderBackOffConfig returns converts infrav1.BackOffConfig to BackOffConfig that is required with the cloud provider.
func toCloudProviderBackOffConfig(source infrav1.BackOffConfig) BackOffConfig <span class="cov8" title="1">{
        backOffConfig := BackOffConfig{}
        backOffConfig.CloudProviderBackoff = source.CloudProviderBackoff
        if source.CloudProviderBackoffExponent != nil </span><span class="cov8" title="1">{
                backOffConfig.CloudProviderBackoffExponent = source.CloudProviderBackoffExponent.AsApproximateFloat64()
        }</span>
        <span class="cov8" title="1">backOffConfig.CloudProviderBackoffRetries = source.CloudProviderBackoffRetries
        if source.CloudProviderBackoffJitter != nil </span><span class="cov8" title="1">{
                backOffConfig.CloudProviderBackoffJitter = source.CloudProviderBackoffJitter.AsApproximateFloat64()
        }</span>
        <span class="cov8" title="1">backOffConfig.CloudProviderBackoffDuration = source.CloudProviderBackoffDuration
        return backOffConfig</span>
}

func reconcileAzureSecret(ctx context.Context, kubeclient client.Client, owner metav1.OwnerReference, newSecret *corev1.Secret, clusterName string) error <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "controllers.reconcileAzureSecret")
        defer done()

        // Fetch previous secret, if it exists
        key := types.NamespacedName{
                Namespace: newSecret.Namespace,
                Name:      newSecret.Name,
        }
        old := &amp;corev1.Secret{}
        err := kubeclient.Get(ctx, key, old)
        if err != nil &amp;&amp; !apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to fetch existing azure json")
        }</span>

        // Create if it wasn't found
        <span class="cov8" title="1">if apierrors.IsNotFound(err) </span><span class="cov8" title="1">{
                if err := kubeclient.Create(ctx, newSecret); err != nil &amp;&amp; !apierrors.IsAlreadyExists(err) </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to create cluster azure json")
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">tag, exists := old.Labels[clusterName]

        if !exists || tag != string(infrav1.ResourceLifecycleOwned) </span><span class="cov8" title="1">{
                log.V(2).Info("returning early from json reconcile, user provided secret already exists")
                return nil
        }</span>

        // Otherwise, check ownership and data freshness. Update as necessary
        <span class="cov8" title="1">hasOwner := false
        for _, ownerRef := range old.OwnerReferences </span><span class="cov0" title="0">{
                if referSameObject(ownerRef, owner) </span><span class="cov0" title="0">{
                        hasOwner = true
                        break</span>
                }
        }

        <span class="cov8" title="1">hasData := equality.Semantic.DeepEqual(old.Data, newSecret.Data)
        if hasData &amp;&amp; hasOwner </span><span class="cov0" title="0">{
                // no update required
                log.V(2).Info("returning early from json reconcile, no update needed")
                return nil
        }</span>

        <span class="cov8" title="1">if !hasOwner </span><span class="cov8" title="1">{
                old.OwnerReferences = append(old.OwnerReferences, owner)
        }</span>

        <span class="cov8" title="1">if !hasData </span><span class="cov8" title="1">{
                old.Data = newSecret.Data
        }</span>

        <span class="cov8" title="1">log.V(2).Info("updating azure json")
        if err := kubeclient.Update(ctx, old); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to update cluster azure json when diff was required")
        }</span>

        <span class="cov8" title="1">log.V(2).Info("done updating azure json")

        return nil</span>
}

// GetOwnerMachinePool returns the MachinePool object owning the current resource.
func GetOwnerMachinePool(ctx context.Context, c client.Client, obj metav1.ObjectMeta) (*expv1.MachinePool, error) <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "controllers.GetOwnerMachinePool")
        defer done()

        for _, ref := range obj.OwnerReferences </span><span class="cov8" title="1">{
                if ref.Kind != "MachinePool" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">gv, err := schema.ParseGroupVersion(ref.APIVersion)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.WithStack(err)
                }</span>

                <span class="cov8" title="1">if gv.Group == expv1.GroupVersion.Group </span><span class="cov8" title="1">{
                        return GetMachinePoolByName(ctx, c, obj.Namespace, ref.Name)
                }</span>
        }
        <span class="cov0" title="0">return nil, nil</span>
}

// GetOwnerAzureMachinePool returns the AzureMachinePool object owning the current resource.
func GetOwnerAzureMachinePool(ctx context.Context, c client.Client, obj metav1.ObjectMeta) (*infrav1exp.AzureMachinePool, error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "controllers.GetOwnerAzureMachinePool")
        defer done()

        for _, ref := range obj.OwnerReferences </span><span class="cov0" title="0">{
                if ref.Kind != "AzureMachinePool" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">gv, err := schema.ParseGroupVersion(ref.APIVersion)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.WithStack(err)
                }</span>

                <span class="cov0" title="0">if gv.Group == infrav1exp.GroupVersion.Group </span><span class="cov0" title="0">{
                        return GetAzureMachinePoolByName(ctx, c, obj.Namespace, ref.Name)
                }</span>
        }
        <span class="cov0" title="0">return nil, nil</span>
}

// GetMachinePoolByName finds and return a MachinePool object using the specified params.
func GetMachinePoolByName(ctx context.Context, c client.Client, namespace, name string) (*expv1.MachinePool, error) <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "controllers.GetMachinePoolByName")
        defer done()

        m := &amp;expv1.MachinePool{}
        key := client.ObjectKey{Name: name, Namespace: namespace}
        if err := c.Get(ctx, key, m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return m, nil</span>
}

// GetAzureMachinePoolByName finds and return an AzureMachinePool object using the specified params.
func GetAzureMachinePoolByName(ctx context.Context, c client.Client, namespace, name string) (*infrav1exp.AzureMachinePool, error) <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "controllers.GetAzureMachinePoolByName")
        defer done()

        m := &amp;infrav1exp.AzureMachinePool{}
        key := client.ObjectKey{Name: name, Namespace: namespace}
        if err := c.Get(ctx, key, m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

// ShouldDeleteIndividualResources returns false if the resource group is managed and the whole cluster is being deleted
// meaning that we can rely on a single resource group delete operation as opposed to deleting every individual VM resource.
func ShouldDeleteIndividualResources(ctx context.Context, clusterScope *scope.ClusterScope) bool <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "controllers.ShouldDeleteIndividualResources")
        defer done()

        if clusterScope.Cluster.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">grpSvc := groups.New(clusterScope)
        managed, err := grpSvc.IsManaged(ctx)
        // Since this is a best effort attempt to speed up delete, we don't fail the delete if we can't get the RG status.
        // Instead, take the long way and delete all resources one by one.
        return err != nil || !managed</span>
}

// GetClusterIdentityFromRef returns the AzureClusterIdentity referenced by the AzureCluster.
func GetClusterIdentityFromRef(ctx context.Context, c client.Client, azureClusterNamespace string, ref *corev1.ObjectReference) (*infrav1.AzureClusterIdentity, error) <span class="cov0" title="0">{
        identity := &amp;infrav1.AzureClusterIdentity{}
        if ref != nil </span><span class="cov0" title="0">{
                namespace := ref.Namespace
                if namespace == "" </span><span class="cov0" title="0">{
                        namespace = azureClusterNamespace
                }</span>
                <span class="cov0" title="0">key := client.ObjectKey{Name: ref.Name, Namespace: namespace}
                if err := c.Get(ctx, key, identity); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return identity, nil</span>
        }
        <span class="cov0" title="0">return nil, nil</span>
}

func clusterIdentityFinalizer(prefix, clusterNamespace, clusterName string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s/%s-%s", prefix, clusterNamespace, clusterName)
}</span>

// EnsureClusterIdentity ensures that the identity ref is allowed in the namespace and sets a finalizer.
func EnsureClusterIdentity(ctx context.Context, c client.Client, object conditions.Setter, identityRef *corev1.ObjectReference, finalizerPrefix string) error <span class="cov0" title="0">{
        name := object.GetName()
        namespace := object.GetNamespace()
        identity, err := GetClusterIdentityFromRef(ctx, c, namespace, identityRef)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !scope.IsClusterNamespaceAllowed(ctx, c, identity.Spec.AllowedNamespaces, namespace) </span><span class="cov0" title="0">{
                conditions.MarkFalse(object, infrav1.NetworkInfrastructureReadyCondition, infrav1.NamespaceNotAllowedByIdentity, clusterv1.ConditionSeverityError, "")
                return errors.New("AzureClusterIdentity list of allowed namespaces doesn't include current cluster namespace")
        }</span>
        <span class="cov0" title="0">identityHelper, err := patch.NewHelper(identity, c)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to init patch helper")
        }</span>
        // If the AzureClusterIdentity doesn't have our finalizer, add it.
        <span class="cov0" title="0">controllerutil.AddFinalizer(identity, clusterIdentityFinalizer(finalizerPrefix, namespace, name))
        // Register the finalizer immediately to avoid orphaning Azure resources on delete.
        return identityHelper.Patch(ctx, identity)</span>
}

// RemoveClusterIdentityFinalizer removes the finalizer on an AzureClusterIdentity.
func RemoveClusterIdentityFinalizer(ctx context.Context, c client.Client, object client.Object, identityRef *corev1.ObjectReference, finalizerPrefix string) error <span class="cov0" title="0">{
        name := object.GetName()
        namespace := object.GetNamespace()
        identity, err := GetClusterIdentityFromRef(ctx, c, namespace, identityRef)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">identityHelper, err := patch.NewHelper(identity, c)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to init patch helper")
        }</span>
        <span class="cov0" title="0">controllerutil.RemoveFinalizer(identity, clusterIdentityFinalizer(finalizerPrefix, namespace, name))
        err = identityHelper.Patch(ctx, identity)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to patch AzureClusterIdentity")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file167" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha3

import (
        convert "k8s.io/apimachinery/pkg/conversion"
        infrav1alpha3 "sigs.k8s.io/cluster-api-provider-azure/api/v1alpha3"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        infrav1exp "sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1"
        utilconversion "sigs.k8s.io/cluster-api/util/conversion"
        "sigs.k8s.io/controller-runtime/pkg/conversion"
)

// ConvertTo converts this AzureMachinePool to the Hub version (v1beta1).
func (src *AzureMachinePool) ConvertTo(dstRaw conversion.Hub) error <span class="cov8" title="1">{
        dst := dstRaw.(*infrav1exp.AzureMachinePool)
        if err := Convert_v1alpha3_AzureMachinePool_To_v1beta1_AzureMachinePool(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Manually restore data.
        <span class="cov8" title="1">restored := &amp;infrav1exp.AzureMachinePool{}
        if ok, err := utilconversion.UnmarshalData(src, restored); err != nil || !ok </span><span class="cov8" title="1">{
                return err
        }</span>

        // Handle special case for conversion of ManagedDisk to pointer.
        <span class="cov8" title="1">if restored.Spec.Template.OSDisk.ManagedDisk == nil &amp;&amp; dst.Spec.Template.OSDisk.ManagedDisk != nil </span><span class="cov8" title="1">{
                if *dst.Spec.Template.OSDisk.ManagedDisk == (infrav1.ManagedDiskParameters{}) </span><span class="cov8" title="1">{
                        // restore nil value if nothing has changed since conversion
                        dst.Spec.Template.OSDisk.ManagedDisk = nil
                }</span>
        }

        <span class="cov8" title="1">dst.Spec.Template.SubnetName = restored.Spec.Template.SubnetName

        dst.Spec.Strategy.Type = restored.Spec.Strategy.Type
        if restored.Spec.Strategy.RollingUpdate != nil </span><span class="cov8" title="1">{
                if dst.Spec.Strategy.RollingUpdate == nil </span><span class="cov8" title="1">{
                        dst.Spec.Strategy.RollingUpdate = &amp;infrav1exp.MachineRollingUpdateDeployment{}
                }</span>

                <span class="cov8" title="1">dst.Spec.Strategy.RollingUpdate.DeletePolicy = restored.Spec.Strategy.RollingUpdate.DeletePolicy</span>
        }

        <span class="cov8" title="1">if restored.Spec.NodeDrainTimeout != nil </span><span class="cov8" title="1">{
                dst.Spec.NodeDrainTimeout = restored.Spec.NodeDrainTimeout
        }</span>

        <span class="cov8" title="1">if restored.Status.Image != nil </span><span class="cov8" title="1">{
                dst.Status.Image = restored.Status.Image
        }</span>

        <span class="cov8" title="1">if restored.Spec.Template.Image != nil &amp;&amp; restored.Spec.Template.Image.SharedGallery != nil </span><span class="cov8" title="1">{
                dst.Spec.Template.Image.SharedGallery.Offer = restored.Spec.Template.Image.SharedGallery.Offer
                dst.Spec.Template.Image.SharedGallery.Publisher = restored.Spec.Template.Image.SharedGallery.Publisher
                dst.Spec.Template.Image.SharedGallery.SKU = restored.Spec.Template.Image.SharedGallery.SKU
        }</span>

        <span class="cov8" title="1">if dst.Spec.Template.Image != nil &amp;&amp; restored.Spec.Template.Image.ComputeGallery != nil </span><span class="cov8" title="1">{
                dst.Spec.Template.Image.ComputeGallery = restored.Spec.Template.Image.ComputeGallery
        }</span>

        <span class="cov8" title="1">if len(dst.Annotations) == 0 </span><span class="cov8" title="1">{
                dst.Annotations = nil
        }</span>

        <span class="cov8" title="1">for i, r := range restored.Status.LongRunningOperationStates </span><span class="cov8" title="1">{
                if r.Name == dst.Status.LongRunningOperationStates[i].Name </span><span class="cov8" title="1">{
                        dst.Status.LongRunningOperationStates[i].ServiceName = r.ServiceName
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureMachinePool) ConvertFrom(srcRaw conversion.Hub) error <span class="cov8" title="1">{
        src := srcRaw.(*infrav1exp.AzureMachinePool)
        if err := Convert_v1beta1_AzureMachinePool_To_v1alpha3_AzureMachinePool(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Preserve Hub data on down-conversion.
        <span class="cov8" title="1">return utilconversion.MarshalData(src, dst)</span>
}

// Convert_v1beta1_AzureMachinePoolMachineTemplate_To_v1alpha3_AzureMachinePoolMachineTemplate converts an Azure Machine Pool Machine Template from v1beta1 to v1alpha3.
func Convert_v1beta1_AzureMachinePoolMachineTemplate_To_v1alpha3_AzureMachinePoolMachineTemplate(in *infrav1exp.AzureMachinePoolMachineTemplate, out *AzureMachinePoolMachineTemplate, s convert.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureMachinePoolMachineTemplate_To_v1alpha3_AzureMachinePoolMachineTemplate(in, out, s)
}</span>

// Convert_v1beta1_AzureMachinePoolSpec_To_v1alpha3_AzureMachinePoolSpec converts an Azure Machine Pool Spec from v1beta1 to v1alpha3.
func Convert_v1beta1_AzureMachinePoolSpec_To_v1alpha3_AzureMachinePoolSpec(in *infrav1exp.AzureMachinePoolSpec, out *AzureMachinePoolSpec, s convert.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureMachinePoolSpec_To_v1alpha3_AzureMachinePoolSpec(in, out, s)
}</span>

// Convert_v1beta1_AzureMachinePoolStatus_To_v1alpha3_AzureMachinePoolStatus converts an Azure Machine Pool Status from v1beta1 to v1alpha3.
func Convert_v1beta1_AzureMachinePoolStatus_To_v1alpha3_AzureMachinePoolStatus(in *infrav1exp.AzureMachinePoolStatus, out *AzureMachinePoolStatus, s convert.Scope) error <span class="cov8" title="1">{
        if len(in.LongRunningOperationStates) &gt; 0 </span><span class="cov8" title="1">{
                if out.LongRunningOperationState == nil </span><span class="cov8" title="1">{
                        out.LongRunningOperationState = &amp;infrav1alpha3.Future{}
                }</span>
                <span class="cov8" title="1">if err := infrav1alpha3.Convert_v1beta1_Future_To_v1alpha3_Future(&amp;in.LongRunningOperationStates[0], out.LongRunningOperationState, s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return autoConvert_v1beta1_AzureMachinePoolStatus_To_v1alpha3_AzureMachinePoolStatus(in, out, s)</span>
}

// Convert_v1alpha3_AzureMachinePoolStatus_To_v1beta1_AzureMachinePoolStatus converts an Azure Machine Pool Status from v1alpha3 to v1beta1.
func Convert_v1alpha3_AzureMachinePoolStatus_To_v1beta1_AzureMachinePoolStatus(in *AzureMachinePoolStatus, out *infrav1exp.AzureMachinePoolStatus, s convert.Scope) error <span class="cov8" title="1">{
        if in.LongRunningOperationState != nil </span><span class="cov8" title="1">{
                f := infrav1.Future{}
                if err := infrav1alpha3.Convert_v1alpha3_Future_To_v1beta1_Future(in.LongRunningOperationState, &amp;f, s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">out.LongRunningOperationStates = []infrav1.Future{f}</span>
        }
        <span class="cov8" title="1">return autoConvert_v1alpha3_AzureMachinePoolStatus_To_v1beta1_AzureMachinePoolStatus(in, out, s)</span>
}

// ConvertTo converts this AzureMachinePoolList to the Hub version (v1beta1).
func (src *AzureMachinePoolList) ConvertTo(dstRaw conversion.Hub) error <span class="cov0" title="0">{
        dst := dstRaw.(*infrav1exp.AzureMachinePoolList)
        return Convert_v1alpha3_AzureMachinePoolList_To_v1beta1_AzureMachinePoolList(src, dst, nil)
}</span>

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureMachinePoolList) ConvertFrom(srcRaw conversion.Hub) error <span class="cov0" title="0">{
        src := srcRaw.(*infrav1exp.AzureMachinePoolList)
        return Convert_v1beta1_AzureMachinePoolList_To_v1alpha3_AzureMachinePoolList(src, dst, nil)
}</span>
</pre>
		
		<pre class="file" id="file168" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha3

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        infrav1alpha3 "sigs.k8s.io/cluster-api-provider-azure/api/v1alpha3"
        clusterv1alpha3 "sigs.k8s.io/cluster-api/api/v1alpha3"
        "sigs.k8s.io/cluster-api/errors"
)

type (
        // AzureMachinePoolMachineTemplate defines the template for an AzureMachinePool machine.
        AzureMachinePoolMachineTemplate struct {
                // VMSize is the size of the Virtual Machine to build.
                // See https://docs.microsoft.com/en-us/rest/api/compute/virtualmachines/createorupdate#virtualmachinesizetypes
                VMSize string `json:"vmSize"`

                // Image is used to provide details of an image to use during Virtual Machine creation.
                // If image details are omitted the image will default the Azure Marketplace "capi" offer,
                // which is based on Ubuntu.
                // +kubebuilder:validation:nullable
                // +optional
                Image *infrav1alpha3.Image `json:"image,omitempty"`

                // OSDisk contains the operating system disk information for a Virtual Machine
                OSDisk infrav1alpha3.OSDisk `json:"osDisk"`

                // DataDisks specifies the list of data disks to be created for a Virtual Machine
                // +optional
                DataDisks []infrav1alpha3.DataDisk `json:"dataDisks,omitempty"`

                // SSHPublicKey is the SSH public key string base64 encoded to add to a Virtual Machine
                SSHPublicKey string `json:"sshPublicKey"`

                // AcceleratedNetworking enables or disables Azure accelerated networking. If omitted, it will be set based on
                // whether the requested VMSize supports accelerated networking.
                // If AcceleratedNetworking is set to true with a VMSize that does not support it, Azure will return an error.
                // +optional
                AcceleratedNetworking *bool `json:"acceleratedNetworking,omitempty"`

                // TerminateNotificationTimeout enables or disables VMSS scheduled events termination notification with specified timeout
                // allowed values are between 5 and 15 (mins)
                // +optional
                TerminateNotificationTimeout *int `json:"terminateNotificationTimeout,omitempty"`

                // SecurityProfile specifies the Security profile settings for a virtual machine.
                // +optional
                SecurityProfile *infrav1alpha3.SecurityProfile `json:"securityProfile,omitempty"`

                // SpotVMOptions allows the ability to specify the Machine should use a Spot VM
                // +optional
                SpotVMOptions *infrav1alpha3.SpotVMOptions `json:"spotVMOptions,omitempty"`
        }

        // AzureMachinePoolSpec defines the desired state of AzureMachinePool.
        AzureMachinePoolSpec struct {
                // Location is the Azure region location e.g. westus2
                Location string `json:"location"`

                // Template contains the details used to build a replica virtual machine within the Machine Pool.
                Template AzureMachinePoolMachineTemplate `json:"template"`

                // AdditionalTags is an optional set of tags to add to an instance, in addition to the ones added by default by the
                // Azure provider. If both the AzureCluster and the AzureMachine specify the same tag name with different values, the
                // AzureMachine's value takes precedence.
                // +optional
                AdditionalTags infrav1alpha3.Tags `json:"additionalTags,omitempty"`

                // ProviderID is the identification ID of the Virtual Machine Scale Set
                // +optional
                ProviderID string `json:"providerID,omitempty"`

                // ProviderIDList are the identification IDs of machine instances provided by the provider.
                // This field must match the provider IDs as seen on the node objects corresponding to a machine pool's machine instances.
                // +optional
                ProviderIDList []string `json:"providerIDList,omitempty"`

                // Identity is the type of identity used for the Virtual Machine Scale Set.
                // The type 'SystemAssigned' is an implicitly created identity.
                // The generated identity will be assigned a Subscription contributor role.
                // The type 'UserAssigned' is a standalone Azure resource provided by the user
                // and assigned to the VM
                // +kubebuilder:default=None
                // +optional
                Identity infrav1alpha3.VMIdentity `json:"identity,omitempty"`

                // UserAssignedIdentities is a list of standalone Azure identities provided by the user
                // The lifecycle of a user-assigned identity is managed separately from the lifecycle of
                // the AzureMachinePool.
                // See https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/how-to-manage-ua-identity-cli
                // +optional
                UserAssignedIdentities []infrav1alpha3.UserAssignedIdentity `json:"userAssignedIdentities,omitempty"`

                // RoleAssignmentName is the name of the role assignment to create for a system assigned identity. It can be any valid GUID.
                // If not specified, a random GUID will be generated.
                // +optional
                RoleAssignmentName string `json:"roleAssignmentName,omitempty"`
        }

        // AzureMachinePoolStatus defines the observed state of AzureMachinePool.
        AzureMachinePoolStatus struct {
                // Ready is true when the provider resource is ready.
                // +optional
                Ready bool `json:"ready"`

                // Replicas is the most recently observed number of replicas.
                // +optional
                Replicas int32 `json:"replicas"`

                // Instances is the VM instance status for each VM in the VMSS
                // +optional
                Instances []*AzureMachinePoolInstanceStatus `json:"instances,omitempty"`

                // Version is the Kubernetes version for the current VMSS model
                // +optional
                Version string `json:"version"`

                // ProvisioningState is the provisioning state of the Azure virtual machine.
                // +optional
                ProvisioningState *infrav1alpha3.VMState `json:"provisioningState,omitempty"`

                // FailureReason will be set in the event that there is a terminal problem
                // reconciling the MachinePool and will contain a succinct value suitable
                // for machine interpretation.
                //
                // This field should not be set for transitive errors that a controller
                // faces that are expected to be fixed automatically over
                // time (like service outages), but instead indicate that something is
                // fundamentally wrong with the MachinePool's spec or the configuration of
                // the controller, and that manual intervention is required. Examples
                // of terminal errors would be invalid combinations of settings in the
                // spec, values that are unsupported by the controller, or the
                // responsible controller itself being critically misconfigured.
                //
                // Any transient errors that occur during the reconciliation of MachinePools
                // can be added as events to the MachinePool object and/or logged in the
                // controller's output.
                // +optional
                FailureReason *errors.MachineStatusError `json:"failureReason,omitempty"`

                // FailureMessage will be set in the event that there is a terminal problem
                // reconciling the MachinePool and will contain a more verbose string suitable
                // for logging and human consumption.
                //
                // This field should not be set for transitive errors that a controller
                // faces that are expected to be fixed automatically over
                // time (like service outages), but instead indicate that something is
                // fundamentally wrong with the MachinePool's spec or the configuration of
                // the controller, and that manual intervention is required. Examples
                // of terminal errors would be invalid combinations of settings in the
                // spec, values that are unsupported by the controller, or the
                // responsible controller itself being critically misconfigured.
                //
                // Any transient errors that occur during the reconciliation of MachinePools
                // can be added as events to the MachinePool object and/or logged in the
                // controller's output.
                // +optional
                FailureMessage *string `json:"failureMessage,omitempty"`

                // Conditions defines current service state of the AzureMachinePool.
                // +optional
                Conditions clusterv1alpha3.Conditions `json:"conditions,omitempty"`

                // LongRunningOperationState saves the state for an Azure long running operations so it can be continued on the
                // next reconciliation loop.
                // +optional
                LongRunningOperationState *infrav1alpha3.Future `json:"longRunningOperationState,omitempty"`
        }

        // AzureMachinePoolInstanceStatus provides status information for each instance in the VMSS.
        AzureMachinePoolInstanceStatus struct {
                // Version defines the Kubernetes version for the VM Instance
                // +optional
                Version string `json:"version"`

                // ProvisioningState is the provisioning state of the Azure virtual machine instance.
                // +optional
                ProvisioningState *infrav1alpha3.VMState `json:"provisioningState"`

                // ProviderID is the provider identification of the VMSS Instance
                // +optional
                ProviderID string `json:"providerID"`

                // InstanceID is the identification of the Machine Instance within the VMSS
                // +optional
                InstanceID string `json:"instanceID"`

                // InstanceName is the name of the Machine Instance within the VMSS
                // +optional
                InstanceName string `json:"instanceName"`

                // LatestModelApplied indicates the instance is running the most up-to-date VMSS model. A VMSS model describes
                // the image version the VM is running. If the instance is not running the latest model, it means the instance
                // may not be running the version of Kubernetes the Machine Pool has specified and needs to be updated.
                LatestModelApplied bool `json:"latestModelApplied"`
        }

        // +kubebuilder:object:root=true
        // +kubebuilder:subresource:status
        // +kubebuilder:resource:path=azuremachinepools,scope=Namespaced,categories=cluster-api,shortName=amp
        // +kubebuilder:printcolumn:name="Replicas",type="string",JSONPath=".status.replicas",description="AzureMachinePool replicas count"
        // +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.ready",description="AzureMachinePool replicas count"
        // +kubebuilder:printcolumn:name="State",type="string",JSONPath=".status.provisioningState",description="Azure VMSS provisioning state"
        // +kubebuilder:printcolumn:name="Cluster",type="string",priority=1,JSONPath=".metadata.labels.cluster\\.x-k8s\\.io/cluster-name",description="Cluster to which this AzureMachinePool belongs"
        // +kubebuilder:printcolumn:name="MachinePool",type="string",priority=1,JSONPath=".metadata.ownerReferences[?(@.kind==\"MachinePool\")].name",description="MachinePool object to which this AzureMachinePool belongs"
        // +kubebuilder:printcolumn:name="VMSS ID",type="string",priority=1,JSONPath=".spec.providerID",description="Azure VMSS ID"
        // +kubebuilder:printcolumn:name="VM Size",type="string",priority=1,JSONPath=".spec.template.vmSize",description="Azure VM Size"

        // AzureMachinePool is the Schema for the azuremachinepools API.
        AzureMachinePool struct {
                metav1.TypeMeta   `json:",inline"`
                metav1.ObjectMeta `json:"metadata,omitempty"`

                Spec   AzureMachinePoolSpec   `json:"spec,omitempty"`
                Status AzureMachinePoolStatus `json:"status,omitempty"`
        }

        // +kubebuilder:object:root=true

        // AzureMachinePoolList contains a list of AzureMachinePools.
        AzureMachinePoolList struct {
                metav1.TypeMeta `json:",inline"`
                metav1.ListMeta `json:"metadata,omitempty"`
                Items           []AzureMachinePool `json:"items"`
        }
)

// GetConditions returns the list of conditions for an AzureMachinePool API object.
func (amp *AzureMachinePool) GetConditions() clusterv1alpha3.Conditions <span class="cov0" title="0">{
        return amp.Status.Conditions
}</span>

// SetConditions will set the given conditions on an AzureMachinePool object.
func (amp *AzureMachinePool) SetConditions(conditions clusterv1alpha3.Conditions) <span class="cov0" title="0">{
        amp.Status.Conditions = conditions
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;AzureMachinePool{}, &amp;AzureMachinePoolList{})
}</span>
</pre>
		
		<pre class="file" id="file169" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha3

import (
        infrav1exp "sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1"
        utilconversion "sigs.k8s.io/cluster-api/util/conversion"
        "sigs.k8s.io/controller-runtime/pkg/conversion"
)

// ConvertTo converts this AzureManagedCluster to the Hub version (v1beta1).
func (src *AzureManagedCluster) ConvertTo(dstRaw conversion.Hub) error <span class="cov8" title="1">{
        dst := dstRaw.(*infrav1exp.AzureManagedCluster)
        if err := Convert_v1alpha3_AzureManagedCluster_To_v1beta1_AzureManagedCluster(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Manually restore data.
        <span class="cov8" title="1">restored := &amp;infrav1exp.AzureManagedCluster{}
        if ok, err := utilconversion.UnmarshalData(src, restored); err != nil || !ok </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureManagedCluster) ConvertFrom(srcRaw conversion.Hub) error <span class="cov8" title="1">{
        src := srcRaw.(*infrav1exp.AzureManagedCluster)

        if err := Convert_v1beta1_AzureManagedCluster_To_v1alpha3_AzureManagedCluster(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Preserve Hub data on down-conversion.
        <span class="cov8" title="1">return utilconversion.MarshalData(src, dst)</span>
}

// ConvertTo converts this AzureManagedClusterList to the Hub version (v1beta1).
func (src *AzureManagedClusterList) ConvertTo(dstRaw conversion.Hub) error <span class="cov0" title="0">{
        dst := dstRaw.(*infrav1exp.AzureManagedClusterList)
        return Convert_v1alpha3_AzureManagedClusterList_To_v1beta1_AzureManagedClusterList(src, dst, nil)
}</span>

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureManagedClusterList) ConvertFrom(srcRaw conversion.Hub) error <span class="cov0" title="0">{
        src := srcRaw.(*infrav1exp.AzureManagedClusterList)
        return Convert_v1beta1_AzureManagedClusterList_To_v1alpha3_AzureManagedClusterList(src, dst, nil)
}</span>
</pre>
		
		<pre class="file" id="file170" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha3

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1alpha3 "sigs.k8s.io/cluster-api/api/v1alpha3"
)

// AzureManagedClusterSpec defines the desired state of AzureManagedCluster.
type AzureManagedClusterSpec struct {
        // ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
        // +optional
        ControlPlaneEndpoint clusterv1alpha3.APIEndpoint `json:"controlPlaneEndpoint"`
}

// AzureManagedClusterStatus defines the observed state of AzureManagedCluster.
type AzureManagedClusterStatus struct {
        // Ready is true when the provider resource is ready.
        // +optional
        Ready bool `json:"ready,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:path=azuremanagedclusters,scope=Namespaced,categories=cluster-api,shortName=amc
// +kubebuilder:subresource:status

// AzureManagedCluster is the Schema for the azuremanagedclusters API.
type AzureManagedCluster struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   AzureManagedClusterSpec   `json:"spec,omitempty"`
        Status AzureManagedClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AzureManagedClusterList contains a list of AzureManagedClusters.
type AzureManagedClusterList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []AzureManagedCluster `json:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;AzureManagedCluster{}, &amp;AzureManagedClusterList{})
}</span>
</pre>
		
		<pre class="file" id="file171" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha3

import (
        apiconversion "k8s.io/apimachinery/pkg/conversion"
        infrav1exp "sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1"
        utilconversion "sigs.k8s.io/cluster-api/util/conversion"
        "sigs.k8s.io/controller-runtime/pkg/conversion"
)

// ConvertTo converts this AzureManagedControlPlane to the Hub version (v1beta1).
func (src *AzureManagedControlPlane) ConvertTo(dstRaw conversion.Hub) error <span class="cov8" title="1">{
        dst := dstRaw.(*infrav1exp.AzureManagedControlPlane)
        if err := Convert_v1alpha3_AzureManagedControlPlane_To_v1beta1_AzureManagedControlPlane(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Manually restore data.
        <span class="cov8" title="1">restored := &amp;infrav1exp.AzureManagedControlPlane{}
        if ok, err := utilconversion.UnmarshalData(src, restored); err != nil || !ok </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">dst.Spec.IdentityRef = restored.Spec.IdentityRef
        dst.Spec.SKU = restored.Spec.SKU
        dst.Spec.LoadBalancerProfile = restored.Spec.LoadBalancerProfile
        dst.Spec.APIServerAccessProfile = restored.Spec.APIServerAccessProfile
        dst.Spec.AddonProfiles = restored.Spec.AddonProfiles

        dst.Status.LongRunningOperationStates = restored.Status.LongRunningOperationStates
        dst.Status.Conditions = restored.Status.Conditions

        return nil</span>
}

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureManagedControlPlane) ConvertFrom(srcRaw conversion.Hub) error <span class="cov8" title="1">{
        src := srcRaw.(*infrav1exp.AzureManagedControlPlane)

        if err := Convert_v1beta1_AzureManagedControlPlane_To_v1alpha3_AzureManagedControlPlane(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Preserve Hub data on down-conversion.
        <span class="cov8" title="1">return utilconversion.MarshalData(src, dst)</span>
}

// Convert_v1beta1_AzureManagedControlPlaneSpec_To_v1alpha3_AzureManagedControlPlaneSpec is an autogenerated conversion function.
func Convert_v1beta1_AzureManagedControlPlaneSpec_To_v1alpha3_AzureManagedControlPlaneSpec(in *infrav1exp.AzureManagedControlPlaneSpec, out *AzureManagedControlPlaneSpec, s apiconversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureManagedControlPlaneSpec_To_v1alpha3_AzureManagedControlPlaneSpec(in, out, s)
}</span>

// Convert_v1beta1_AzureManagedControlPlaneStatus_To_v1alpha3_AzureManagedControlPlaneStatus is an autogenerated conversion function.
func Convert_v1beta1_AzureManagedControlPlaneStatus_To_v1alpha3_AzureManagedControlPlaneStatus(in *infrav1exp.AzureManagedControlPlaneStatus, out *AzureManagedControlPlaneStatus, s apiconversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureManagedControlPlaneStatus_To_v1alpha3_AzureManagedControlPlaneStatus(in, out, s)
}</span>

// ConvertTo converts this AzureManagedControlPlane to the Hub version (v1beta1).
func (src *AzureManagedControlPlaneList) ConvertTo(dstRaw conversion.Hub) error <span class="cov0" title="0">{
        dst := dstRaw.(*infrav1exp.AzureManagedControlPlaneList)
        return Convert_v1alpha3_AzureManagedControlPlaneList_To_v1beta1_AzureManagedControlPlaneList(src, dst, nil)
}</span>

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureManagedControlPlaneList) ConvertFrom(srcRaw conversion.Hub) error <span class="cov0" title="0">{
        src := srcRaw.(*infrav1exp.AzureManagedControlPlaneList)
        return Convert_v1beta1_AzureManagedControlPlaneList_To_v1alpha3_AzureManagedControlPlaneList(src, dst, nil)
}</span>
</pre>
		
		<pre class="file" id="file172" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha3

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        infrav1alpha3 "sigs.k8s.io/cluster-api-provider-azure/api/v1alpha3"
        clusterv1alpha3 "sigs.k8s.io/cluster-api/api/v1alpha3"
)

// AzureManagedControlPlaneSpec defines the desired state of AzureManagedControlPlane.
type AzureManagedControlPlaneSpec struct {
        // Version defines the desired Kubernetes version.
        // +kubebuilder:validation:MinLength:=2
        Version string `json:"version"`

        // ResourceGroupName is the name of the Azure resource group for this AKS Cluster.
        ResourceGroupName string `json:"resourceGroupName"`

        // NodeResourceGroupName is the name of the resource group
        // containing cluster IaaS resources. Will be populated to default
        // in webhook.
        NodeResourceGroupName string `json:"nodeResourceGroupName"`

        // VirtualNetwork describes the vnet for the AKS cluster. Will be created if it does not exist.
        VirtualNetwork ManagedControlPlaneVirtualNetwork `json:"virtualNetwork,omitempty"`

        // SubscriotionID is the GUID of the Azure subscription to hold this cluster.
        SubscriptionID string `json:"subscriptionID,omitempty"`

        // Location is a string matching one of the canonical Azure region names. Examples: "westus2", "eastus".
        Location string `json:"location"`

        // ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
        // +optional
        ControlPlaneEndpoint clusterv1alpha3.APIEndpoint `json:"controlPlaneEndpoint"`

        // AdditionalTags is an optional set of tags to add to Azure resources managed by the Azure provider, in addition to the
        // ones added by default.
        // +optional
        AdditionalTags infrav1alpha3.Tags `json:"additionalTags,omitempty"`

        // NetworkPlugin used for building Kubernetes network.
        // +kubebuilder:validation:Enum=azure;kubenet
        // +optional
        NetworkPlugin *string `json:"networkPlugin,omitempty"`

        // NetworkPolicy used for building Kubernetes network.
        // +kubebuilder:validation:Enum=azure;calico
        // +optional
        NetworkPolicy *string `json:"networkPolicy,omitempty"`

        // SSHPublicKey is a string literal containing an ssh public key base64 encoded.
        SSHPublicKey string `json:"sshPublicKey"`

        // DNSServiceIP is an IP address assigned to the Kubernetes DNS service.
        // It must be within the Kubernetes service address range specified in serviceCidr.
        // +optional
        DNSServiceIP *string `json:"dnsServiceIP,omitempty"`

        // LoadBalancerSKU is the SKU of the loadBalancer to be provisioned.
        // +kubebuilder:validation:Enum=Basic;Standard
        // +optional
        LoadBalancerSKU *string `json:"loadBalancerSKU,omitempty"`

        // AadProfile is Azure Active Directory configuration to integrate with AKS for aad authentication.
        // +optional
        AADProfile *AADProfile `json:"aadProfile,omitempty"`
}

// AADProfile - AAD integration managed by AKS.
type AADProfile struct {
        // Managed - Whether to enable managed AAD.
        // +kubebuilder:validation:Required
        Managed bool `json:"managed"`

        // AdminGroupObjectIDs - AAD group object IDs that will have admin role of the cluster.
        // +kubebuilder:validation:Required
        AdminGroupObjectIDs []string `json:"adminGroupObjectIDs"`
}

// ManagedControlPlaneVirtualNetwork describes a virtual network required to provision AKS clusters.
type ManagedControlPlaneVirtualNetwork struct {
        Name      string                    `json:"name"`
        CIDRBlock string                    `json:"cidrBlock"`
        Subnet    ManagedControlPlaneSubnet `json:"subnet,omitempty"`
}

// ManagedControlPlaneSubnet describes a subnet for an AKS cluster.
type ManagedControlPlaneSubnet struct {
        Name      string `json:"name"`
        CIDRBlock string `json:"cidrBlock"`
}

// AzureManagedControlPlaneStatus defines the observed state of AzureManagedControlPlane.
type AzureManagedControlPlaneStatus struct {
        // Ready is true when the provider resource is ready.
        // +optional
        Ready bool `json:"ready,omitempty"`

        // Initialized is true when the the control plane is available for initial contact.
        // This may occur before the control plane is fully ready.
        // In the AzureManagedControlPlane implementation, these are identical.
        // +optional
        Initialized bool `json:"initialized,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:path=azuremanagedcontrolplanes,scope=Namespaced,categories=cluster-api,shortName=amcp
// +kubebuilder:subresource:status

// AzureManagedControlPlane is the Schema for the azuremanagedcontrolplanes API.
type AzureManagedControlPlane struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   AzureManagedControlPlaneSpec   `json:"spec,omitempty"`
        Status AzureManagedControlPlaneStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AzureManagedControlPlaneList contains a list of AzureManagedControlPlanes.
type AzureManagedControlPlaneList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []AzureManagedControlPlane `json:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;AzureManagedControlPlane{}, &amp;AzureManagedControlPlaneList{})
}</span>
</pre>
		
		<pre class="file" id="file173" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha3

import (
        apiconversion "k8s.io/apimachinery/pkg/conversion"
        infrav1exp "sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1"
        utilconversion "sigs.k8s.io/cluster-api/util/conversion"
        "sigs.k8s.io/controller-runtime/pkg/conversion"
)

// ConvertTo converts this AzureManagedMachinePool to the Hub version (v1beta1).
func (src *AzureManagedMachinePool) ConvertTo(dstRaw conversion.Hub) error <span class="cov8" title="1">{
        dst := dstRaw.(*infrav1exp.AzureManagedMachinePool)
        if err := Convert_v1alpha3_AzureManagedMachinePool_To_v1beta1_AzureManagedMachinePool(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Manually restore data.
        <span class="cov8" title="1">restored := &amp;infrav1exp.AzureManagedMachinePool{}
        if ok, err := utilconversion.UnmarshalData(src, restored); err != nil || !ok </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">dst.Spec.Name = restored.Spec.Name
        dst.Spec.Scaling = restored.Spec.Scaling
        dst.Spec.Taints = restored.Spec.Taints
        dst.Spec.AvailabilityZones = restored.Spec.AvailabilityZones
        dst.Spec.MaxPods = restored.Spec.MaxPods
        dst.Spec.OsDiskType = restored.Spec.OsDiskType
        dst.Spec.OSType = restored.Spec.OSType
        dst.Spec.NodeLabels = restored.Spec.NodeLabels
        dst.Spec.EnableUltraSSD = restored.Spec.EnableUltraSSD
        dst.Spec.EnableNodePublicIP = restored.Spec.EnableNodePublicIP

        dst.Status.LongRunningOperationStates = restored.Status.LongRunningOperationStates
        dst.Status.Conditions = restored.Status.Conditions

        return nil</span>
}

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureManagedMachinePool) ConvertFrom(srcRaw conversion.Hub) error <span class="cov8" title="1">{
        src := srcRaw.(*infrav1exp.AzureManagedMachinePool)
        if err := Convert_v1beta1_AzureManagedMachinePool_To_v1alpha3_AzureManagedMachinePool(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Preserve Hub data on down-conversion.
        <span class="cov8" title="1">return utilconversion.MarshalData(src, dst)</span>
}

// Convert_v1beta1_AzureManagedMachinePoolSpec_To_v1alpha3_AzureManagedMachinePoolSpec is an autogenerated conversion function.
func Convert_v1beta1_AzureManagedMachinePoolSpec_To_v1alpha3_AzureManagedMachinePoolSpec(in *infrav1exp.AzureManagedMachinePoolSpec, out *AzureManagedMachinePoolSpec, s apiconversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureManagedMachinePoolSpec_To_v1alpha3_AzureManagedMachinePoolSpec(in, out, s)
}</span>

// Convert_v1beta1_AzureManagedMachinePoolStatus_To_v1alpha3_AzureManagedMachinePoolStatus is an autogenerated conversion function.
func Convert_v1beta1_AzureManagedMachinePoolStatus_To_v1alpha3_AzureManagedMachinePoolStatus(in *infrav1exp.AzureManagedMachinePoolStatus, out *AzureManagedMachinePoolStatus, s apiconversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureManagedMachinePoolStatus_To_v1alpha3_AzureManagedMachinePoolStatus(in, out, s)
}</span>

// ConvertTo converts this AzureManagedMachinePoolList to the Hub version (v1beta1).
func (src *AzureManagedMachinePoolList) ConvertTo(dstRaw conversion.Hub) error <span class="cov0" title="0">{
        dst := dstRaw.(*infrav1exp.AzureManagedMachinePoolList)
        return Convert_v1alpha3_AzureManagedMachinePoolList_To_v1beta1_AzureManagedMachinePoolList(src, dst, nil)
}</span>

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureManagedMachinePoolList) ConvertFrom(srcRaw conversion.Hub) error <span class="cov0" title="0">{
        src := srcRaw.(*infrav1exp.AzureManagedMachinePoolList)
        return Convert_v1beta1_AzureManagedMachinePoolList_To_v1alpha3_AzureManagedMachinePoolList(src, dst, nil)
}</span>
</pre>
		
		<pre class="file" id="file174" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha3

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        capierrors "sigs.k8s.io/cluster-api/errors"
)

// AzureManagedMachinePoolSpec defines the desired state of AzureManagedMachinePool.
type AzureManagedMachinePoolSpec struct {
        // Mode - represents mode of an agent pool. Possible values include: System, User.
        // +kubebuilder:validation:Enum=System;User
        Mode string `json:"mode"`

        // SKU is the size of the VMs in the node pool.
        SKU string `json:"sku"`

        // OSDiskSizeGB is the disk size for every machine in this agent pool.
        // If you specify 0, it will apply the default osDisk size according to the vmSize specified.
        OSDiskSizeGB *int32 `json:"osDiskSizeGB,omitempty"`

        // ProviderIDList is the unique identifier as specified by the cloud provider.
        // +optional
        ProviderIDList []string `json:"providerIDList,omitempty"`
}

// AzureManagedMachinePoolStatus defines the observed state of AzureManagedMachinePool.
type AzureManagedMachinePoolStatus struct {
        // Ready is true when the provider resource is ready.
        // +optional
        Ready bool `json:"ready"`

        // Replicas is the most recently observed number of replicas.
        // +optional
        Replicas int32 `json:"replicas"`

        // Any transient errors that occur during the reconciliation of Machines
        // can be added as events to the Machine object and/or logged in the
        // controller's output.
        // +optional
        ErrorReason *capierrors.MachineStatusError `json:"errorReason,omitempty"`

        // Any transient errors that occur during the reconciliation of Machines
        // can be added as events to the Machine object and/or logged in the
        // controller's output.
        // +optional
        ErrorMessage *string `json:"errorMessage,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:path=azuremanagedmachinepools,scope=Namespaced,categories=cluster-api,shortName=ammp
// +kubebuilder:subresource:status

// AzureManagedMachinePool is the Schema for the azuremanagedmachinepools API.
type AzureManagedMachinePool struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   AzureManagedMachinePoolSpec   `json:"spec,omitempty"`
        Status AzureManagedMachinePoolStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AzureManagedMachinePoolList contains a list of AzureManagedMachinePools.
type AzureManagedMachinePoolList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []AzureManagedMachinePool `json:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;AzureManagedMachinePool{}, &amp;AzureManagedMachinePoolList{})
}</span>
</pre>
		
		<pre class="file" id="file175" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha3

import (
        conversion "k8s.io/apimachinery/pkg/conversion"
        infrav1alpha3 "sigs.k8s.io/cluster-api-provider-azure/api/v1alpha3"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        clusterv1alpha3 "sigs.k8s.io/cluster-api/api/v1alpha3"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
)

// Convert_v1alpha3_OSDisk_To_v1beta1_OSDisk is a conversion function.
func Convert_v1alpha3_OSDisk_To_v1beta1_OSDisk(in *infrav1alpha3.OSDisk, out *infrav1.OSDisk, s conversion.Scope) error <span class="cov8" title="1">{
        return infrav1alpha3.Convert_v1alpha3_OSDisk_To_v1beta1_OSDisk(in, out, s)
}</span>

// Convert_v1beta1_OSDisk_To_v1alpha3_OSDisk is a conversion function.
func Convert_v1beta1_OSDisk_To_v1alpha3_OSDisk(in *infrav1.OSDisk, out *infrav1alpha3.OSDisk, s conversion.Scope) error <span class="cov8" title="1">{
        return infrav1alpha3.Convert_v1beta1_OSDisk_To_v1alpha3_OSDisk(in, out, s)
}</span>

// Convert_v1alpha3_Image_To_v1beta1_Image is a conversion function.
func Convert_v1alpha3_Image_To_v1beta1_Image(in *infrav1alpha3.Image, out *infrav1.Image, s conversion.Scope) error <span class="cov8" title="1">{
        return infrav1alpha3.Convert_v1alpha3_Image_To_v1beta1_Image(in, out, s)
}</span>

// Convert_v1beta1_Image_To_v1alpha3_Image is a conversion function.
func Convert_v1beta1_Image_To_v1alpha3_Image(in *infrav1.Image, out *infrav1alpha3.Image, s conversion.Scope) error <span class="cov8" title="1">{
        return infrav1alpha3.Convert_v1beta1_Image_To_v1alpha3_Image(in, out, s)
}</span>

// Convert_v1alpha3_APIEndpoint_To_v1beta1_APIEndpoint is an autogenerated conversion function.
func Convert_v1alpha3_APIEndpoint_To_v1beta1_APIEndpoint(in *clusterv1alpha3.APIEndpoint, out *clusterv1.APIEndpoint, s conversion.Scope) error <span class="cov8" title="1">{
        return clusterv1alpha3.Convert_v1alpha3_APIEndpoint_To_v1beta1_APIEndpoint(in, out, s)
}</span>

// Convert_v1beta1_APIEndpoint_To_v1alpha3_APIEndpoint is an autogenerated conversion function.
func Convert_v1beta1_APIEndpoint_To_v1alpha3_APIEndpoint(in *clusterv1.APIEndpoint, out *clusterv1alpha3.APIEndpoint, s conversion.Scope) error <span class="cov8" title="1">{
        return clusterv1alpha3.Convert_v1beta1_APIEndpoint_To_v1alpha3_APIEndpoint(in, out, s)
}</span>
</pre>
		
		<pre class="file" id="file176" style="display: none">//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by conversion-gen-v0.23.1. DO NOT EDIT.

package v1alpha3

import (
        unsafe "unsafe"

        conversion "k8s.io/apimachinery/pkg/conversion"
        runtime "k8s.io/apimachinery/pkg/runtime"
        clusterapiproviderazureapiv1alpha3 "sigs.k8s.io/cluster-api-provider-azure/api/v1alpha3"
        clusterapiproviderazureapiv1beta1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        v1beta1 "sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1"
        apiv1alpha3 "sigs.k8s.io/cluster-api/api/v1alpha3"
        apiv1beta1 "sigs.k8s.io/cluster-api/api/v1beta1"
        errors "sigs.k8s.io/cluster-api/errors"
)

func init() <span class="cov8" title="1">{
        localSchemeBuilder.Register(RegisterConversions)
}</span>

// RegisterConversions adds conversion functions to the given scheme.
// Public to allow building arbitrary schemes.
func RegisterConversions(s *runtime.Scheme) error <span class="cov0" title="0">{
        if err := s.AddGeneratedConversionFunc((*AADProfile)(nil), (*v1beta1.AADProfile)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AADProfile_To_v1beta1_AADProfile(a.(*AADProfile), b.(*v1beta1.AADProfile), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AADProfile)(nil), (*AADProfile)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AADProfile_To_v1alpha3_AADProfile(a.(*v1beta1.AADProfile), b.(*AADProfile), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureMachinePool)(nil), (*v1beta1.AzureMachinePool)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureMachinePool_To_v1beta1_AzureMachinePool(a.(*AzureMachinePool), b.(*v1beta1.AzureMachinePool), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureMachinePool)(nil), (*AzureMachinePool)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachinePool_To_v1alpha3_AzureMachinePool(a.(*v1beta1.AzureMachinePool), b.(*AzureMachinePool), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureMachinePoolInstanceStatus)(nil), (*v1beta1.AzureMachinePoolInstanceStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureMachinePoolInstanceStatus_To_v1beta1_AzureMachinePoolInstanceStatus(a.(*AzureMachinePoolInstanceStatus), b.(*v1beta1.AzureMachinePoolInstanceStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureMachinePoolInstanceStatus)(nil), (*AzureMachinePoolInstanceStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachinePoolInstanceStatus_To_v1alpha3_AzureMachinePoolInstanceStatus(a.(*v1beta1.AzureMachinePoolInstanceStatus), b.(*AzureMachinePoolInstanceStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureMachinePoolList)(nil), (*v1beta1.AzureMachinePoolList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureMachinePoolList_To_v1beta1_AzureMachinePoolList(a.(*AzureMachinePoolList), b.(*v1beta1.AzureMachinePoolList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureMachinePoolList)(nil), (*AzureMachinePoolList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachinePoolList_To_v1alpha3_AzureMachinePoolList(a.(*v1beta1.AzureMachinePoolList), b.(*AzureMachinePoolList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureMachinePoolMachineTemplate)(nil), (*v1beta1.AzureMachinePoolMachineTemplate)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureMachinePoolMachineTemplate_To_v1beta1_AzureMachinePoolMachineTemplate(a.(*AzureMachinePoolMachineTemplate), b.(*v1beta1.AzureMachinePoolMachineTemplate), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureMachinePoolSpec)(nil), (*v1beta1.AzureMachinePoolSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureMachinePoolSpec_To_v1beta1_AzureMachinePoolSpec(a.(*AzureMachinePoolSpec), b.(*v1beta1.AzureMachinePoolSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureManagedCluster)(nil), (*v1beta1.AzureManagedCluster)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureManagedCluster_To_v1beta1_AzureManagedCluster(a.(*AzureManagedCluster), b.(*v1beta1.AzureManagedCluster), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureManagedCluster)(nil), (*AzureManagedCluster)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureManagedCluster_To_v1alpha3_AzureManagedCluster(a.(*v1beta1.AzureManagedCluster), b.(*AzureManagedCluster), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureManagedClusterList)(nil), (*v1beta1.AzureManagedClusterList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureManagedClusterList_To_v1beta1_AzureManagedClusterList(a.(*AzureManagedClusterList), b.(*v1beta1.AzureManagedClusterList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureManagedClusterList)(nil), (*AzureManagedClusterList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureManagedClusterList_To_v1alpha3_AzureManagedClusterList(a.(*v1beta1.AzureManagedClusterList), b.(*AzureManagedClusterList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureManagedClusterSpec)(nil), (*v1beta1.AzureManagedClusterSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureManagedClusterSpec_To_v1beta1_AzureManagedClusterSpec(a.(*AzureManagedClusterSpec), b.(*v1beta1.AzureManagedClusterSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureManagedClusterSpec)(nil), (*AzureManagedClusterSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureManagedClusterSpec_To_v1alpha3_AzureManagedClusterSpec(a.(*v1beta1.AzureManagedClusterSpec), b.(*AzureManagedClusterSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureManagedClusterStatus)(nil), (*v1beta1.AzureManagedClusterStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureManagedClusterStatus_To_v1beta1_AzureManagedClusterStatus(a.(*AzureManagedClusterStatus), b.(*v1beta1.AzureManagedClusterStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureManagedClusterStatus)(nil), (*AzureManagedClusterStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureManagedClusterStatus_To_v1alpha3_AzureManagedClusterStatus(a.(*v1beta1.AzureManagedClusterStatus), b.(*AzureManagedClusterStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureManagedControlPlane)(nil), (*v1beta1.AzureManagedControlPlane)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureManagedControlPlane_To_v1beta1_AzureManagedControlPlane(a.(*AzureManagedControlPlane), b.(*v1beta1.AzureManagedControlPlane), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureManagedControlPlane)(nil), (*AzureManagedControlPlane)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureManagedControlPlane_To_v1alpha3_AzureManagedControlPlane(a.(*v1beta1.AzureManagedControlPlane), b.(*AzureManagedControlPlane), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureManagedControlPlaneList)(nil), (*v1beta1.AzureManagedControlPlaneList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureManagedControlPlaneList_To_v1beta1_AzureManagedControlPlaneList(a.(*AzureManagedControlPlaneList), b.(*v1beta1.AzureManagedControlPlaneList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureManagedControlPlaneList)(nil), (*AzureManagedControlPlaneList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureManagedControlPlaneList_To_v1alpha3_AzureManagedControlPlaneList(a.(*v1beta1.AzureManagedControlPlaneList), b.(*AzureManagedControlPlaneList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureManagedControlPlaneSpec)(nil), (*v1beta1.AzureManagedControlPlaneSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureManagedControlPlaneSpec_To_v1beta1_AzureManagedControlPlaneSpec(a.(*AzureManagedControlPlaneSpec), b.(*v1beta1.AzureManagedControlPlaneSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureManagedControlPlaneStatus)(nil), (*v1beta1.AzureManagedControlPlaneStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureManagedControlPlaneStatus_To_v1beta1_AzureManagedControlPlaneStatus(a.(*AzureManagedControlPlaneStatus), b.(*v1beta1.AzureManagedControlPlaneStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureManagedMachinePool)(nil), (*v1beta1.AzureManagedMachinePool)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureManagedMachinePool_To_v1beta1_AzureManagedMachinePool(a.(*AzureManagedMachinePool), b.(*v1beta1.AzureManagedMachinePool), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureManagedMachinePool)(nil), (*AzureManagedMachinePool)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureManagedMachinePool_To_v1alpha3_AzureManagedMachinePool(a.(*v1beta1.AzureManagedMachinePool), b.(*AzureManagedMachinePool), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureManagedMachinePoolList)(nil), (*v1beta1.AzureManagedMachinePoolList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureManagedMachinePoolList_To_v1beta1_AzureManagedMachinePoolList(a.(*AzureManagedMachinePoolList), b.(*v1beta1.AzureManagedMachinePoolList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureManagedMachinePoolList)(nil), (*AzureManagedMachinePoolList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureManagedMachinePoolList_To_v1alpha3_AzureManagedMachinePoolList(a.(*v1beta1.AzureManagedMachinePoolList), b.(*AzureManagedMachinePoolList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureManagedMachinePoolSpec)(nil), (*v1beta1.AzureManagedMachinePoolSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureManagedMachinePoolSpec_To_v1beta1_AzureManagedMachinePoolSpec(a.(*AzureManagedMachinePoolSpec), b.(*v1beta1.AzureManagedMachinePoolSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureManagedMachinePoolStatus)(nil), (*v1beta1.AzureManagedMachinePoolStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureManagedMachinePoolStatus_To_v1beta1_AzureManagedMachinePoolStatus(a.(*AzureManagedMachinePoolStatus), b.(*v1beta1.AzureManagedMachinePoolStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*ManagedControlPlaneSubnet)(nil), (*v1beta1.ManagedControlPlaneSubnet)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_ManagedControlPlaneSubnet_To_v1beta1_ManagedControlPlaneSubnet(a.(*ManagedControlPlaneSubnet), b.(*v1beta1.ManagedControlPlaneSubnet), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.ManagedControlPlaneSubnet)(nil), (*ManagedControlPlaneSubnet)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_ManagedControlPlaneSubnet_To_v1alpha3_ManagedControlPlaneSubnet(a.(*v1beta1.ManagedControlPlaneSubnet), b.(*ManagedControlPlaneSubnet), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*ManagedControlPlaneVirtualNetwork)(nil), (*v1beta1.ManagedControlPlaneVirtualNetwork)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_ManagedControlPlaneVirtualNetwork_To_v1beta1_ManagedControlPlaneVirtualNetwork(a.(*ManagedControlPlaneVirtualNetwork), b.(*v1beta1.ManagedControlPlaneVirtualNetwork), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.ManagedControlPlaneVirtualNetwork)(nil), (*ManagedControlPlaneVirtualNetwork)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_ManagedControlPlaneVirtualNetwork_To_v1alpha3_ManagedControlPlaneVirtualNetwork(a.(*v1beta1.ManagedControlPlaneVirtualNetwork), b.(*ManagedControlPlaneVirtualNetwork), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*apiv1alpha3.APIEndpoint)(nil), (*apiv1beta1.APIEndpoint)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_APIEndpoint_To_v1beta1_APIEndpoint(a.(*apiv1alpha3.APIEndpoint), b.(*apiv1beta1.APIEndpoint), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*AzureMachinePoolStatus)(nil), (*v1beta1.AzureMachinePoolStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_AzureMachinePoolStatus_To_v1beta1_AzureMachinePoolStatus(a.(*AzureMachinePoolStatus), b.(*v1beta1.AzureMachinePoolStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*clusterapiproviderazureapiv1alpha3.Image)(nil), (*clusterapiproviderazureapiv1beta1.Image)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_Image_To_v1beta1_Image(a.(*clusterapiproviderazureapiv1alpha3.Image), b.(*clusterapiproviderazureapiv1beta1.Image), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*clusterapiproviderazureapiv1alpha3.OSDisk)(nil), (*clusterapiproviderazureapiv1beta1.OSDisk)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha3_OSDisk_To_v1beta1_OSDisk(a.(*clusterapiproviderazureapiv1alpha3.OSDisk), b.(*clusterapiproviderazureapiv1beta1.OSDisk), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*apiv1beta1.APIEndpoint)(nil), (*apiv1alpha3.APIEndpoint)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_APIEndpoint_To_v1alpha3_APIEndpoint(a.(*apiv1beta1.APIEndpoint), b.(*apiv1alpha3.APIEndpoint), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.AzureMachinePoolMachineTemplate)(nil), (*AzureMachinePoolMachineTemplate)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachinePoolMachineTemplate_To_v1alpha3_AzureMachinePoolMachineTemplate(a.(*v1beta1.AzureMachinePoolMachineTemplate), b.(*AzureMachinePoolMachineTemplate), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.AzureMachinePoolSpec)(nil), (*AzureMachinePoolSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachinePoolSpec_To_v1alpha3_AzureMachinePoolSpec(a.(*v1beta1.AzureMachinePoolSpec), b.(*AzureMachinePoolSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.AzureMachinePoolStatus)(nil), (*AzureMachinePoolStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachinePoolStatus_To_v1alpha3_AzureMachinePoolStatus(a.(*v1beta1.AzureMachinePoolStatus), b.(*AzureMachinePoolStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.AzureManagedControlPlaneSpec)(nil), (*AzureManagedControlPlaneSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureManagedControlPlaneSpec_To_v1alpha3_AzureManagedControlPlaneSpec(a.(*v1beta1.AzureManagedControlPlaneSpec), b.(*AzureManagedControlPlaneSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.AzureManagedControlPlaneStatus)(nil), (*AzureManagedControlPlaneStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureManagedControlPlaneStatus_To_v1alpha3_AzureManagedControlPlaneStatus(a.(*v1beta1.AzureManagedControlPlaneStatus), b.(*AzureManagedControlPlaneStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.AzureManagedMachinePoolSpec)(nil), (*AzureManagedMachinePoolSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureManagedMachinePoolSpec_To_v1alpha3_AzureManagedMachinePoolSpec(a.(*v1beta1.AzureManagedMachinePoolSpec), b.(*AzureManagedMachinePoolSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.AzureManagedMachinePoolStatus)(nil), (*AzureManagedMachinePoolStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureManagedMachinePoolStatus_To_v1alpha3_AzureManagedMachinePoolStatus(a.(*v1beta1.AzureManagedMachinePoolStatus), b.(*AzureManagedMachinePoolStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*clusterapiproviderazureapiv1beta1.Image)(nil), (*clusterapiproviderazureapiv1alpha3.Image)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_Image_To_v1alpha3_Image(a.(*clusterapiproviderazureapiv1beta1.Image), b.(*clusterapiproviderazureapiv1alpha3.Image), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*clusterapiproviderazureapiv1beta1.OSDisk)(nil), (*clusterapiproviderazureapiv1alpha3.OSDisk)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_OSDisk_To_v1alpha3_OSDisk(a.(*clusterapiproviderazureapiv1beta1.OSDisk), b.(*clusterapiproviderazureapiv1alpha3.OSDisk), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func autoConvert_v1alpha3_AADProfile_To_v1beta1_AADProfile(in *AADProfile, out *v1beta1.AADProfile, s conversion.Scope) error <span class="cov0" title="0">{
        out.Managed = in.Managed
        out.AdminGroupObjectIDs = *(*[]string)(unsafe.Pointer(&amp;in.AdminGroupObjectIDs))
        return nil
}</span>

// Convert_v1alpha3_AADProfile_To_v1beta1_AADProfile is an autogenerated conversion function.
func Convert_v1alpha3_AADProfile_To_v1beta1_AADProfile(in *AADProfile, out *v1beta1.AADProfile, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha3_AADProfile_To_v1beta1_AADProfile(in, out, s)
}</span>

func autoConvert_v1beta1_AADProfile_To_v1alpha3_AADProfile(in *v1beta1.AADProfile, out *AADProfile, s conversion.Scope) error <span class="cov0" title="0">{
        out.Managed = in.Managed
        out.AdminGroupObjectIDs = *(*[]string)(unsafe.Pointer(&amp;in.AdminGroupObjectIDs))
        return nil
}</span>

// Convert_v1beta1_AADProfile_To_v1alpha3_AADProfile is an autogenerated conversion function.
func Convert_v1beta1_AADProfile_To_v1alpha3_AADProfile(in *v1beta1.AADProfile, out *AADProfile, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_AADProfile_To_v1alpha3_AADProfile(in, out, s)
}</span>

func autoConvert_v1alpha3_AzureMachinePool_To_v1beta1_AzureMachinePool(in *AzureMachinePool, out *v1beta1.AzureMachinePool, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1alpha3_AzureMachinePoolSpec_To_v1beta1_AzureMachinePoolSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1alpha3_AzureMachinePoolStatus_To_v1beta1_AzureMachinePoolStatus(&amp;in.Status, &amp;out.Status, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha3_AzureMachinePool_To_v1beta1_AzureMachinePool is an autogenerated conversion function.
func Convert_v1alpha3_AzureMachinePool_To_v1beta1_AzureMachinePool(in *AzureMachinePool, out *v1beta1.AzureMachinePool, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha3_AzureMachinePool_To_v1beta1_AzureMachinePool(in, out, s)
}</span>

func autoConvert_v1beta1_AzureMachinePool_To_v1alpha3_AzureMachinePool(in *v1beta1.AzureMachinePool, out *AzureMachinePool, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1beta1_AzureMachinePoolSpec_To_v1alpha3_AzureMachinePoolSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1beta1_AzureMachinePoolStatus_To_v1alpha3_AzureMachinePoolStatus(&amp;in.Status, &amp;out.Status, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1beta1_AzureMachinePool_To_v1alpha3_AzureMachinePool is an autogenerated conversion function.
func Convert_v1beta1_AzureMachinePool_To_v1alpha3_AzureMachinePool(in *v1beta1.AzureMachinePool, out *AzureMachinePool, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureMachinePool_To_v1alpha3_AzureMachinePool(in, out, s)
}</span>

func autoConvert_v1alpha3_AzureMachinePoolInstanceStatus_To_v1beta1_AzureMachinePoolInstanceStatus(in *AzureMachinePoolInstanceStatus, out *v1beta1.AzureMachinePoolInstanceStatus, s conversion.Scope) error <span class="cov0" title="0">{
        out.Version = in.Version
        out.ProvisioningState = (*clusterapiproviderazureapiv1beta1.ProvisioningState)(unsafe.Pointer(in.ProvisioningState))
        out.ProviderID = in.ProviderID
        out.InstanceID = in.InstanceID
        out.InstanceName = in.InstanceName
        out.LatestModelApplied = in.LatestModelApplied
        return nil
}</span>

// Convert_v1alpha3_AzureMachinePoolInstanceStatus_To_v1beta1_AzureMachinePoolInstanceStatus is an autogenerated conversion function.
func Convert_v1alpha3_AzureMachinePoolInstanceStatus_To_v1beta1_AzureMachinePoolInstanceStatus(in *AzureMachinePoolInstanceStatus, out *v1beta1.AzureMachinePoolInstanceStatus, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha3_AzureMachinePoolInstanceStatus_To_v1beta1_AzureMachinePoolInstanceStatus(in, out, s)
}</span>

func autoConvert_v1beta1_AzureMachinePoolInstanceStatus_To_v1alpha3_AzureMachinePoolInstanceStatus(in *v1beta1.AzureMachinePoolInstanceStatus, out *AzureMachinePoolInstanceStatus, s conversion.Scope) error <span class="cov0" title="0">{
        out.Version = in.Version
        out.ProvisioningState = (*clusterapiproviderazureapiv1alpha3.VMState)(unsafe.Pointer(in.ProvisioningState))
        out.ProviderID = in.ProviderID
        out.InstanceID = in.InstanceID
        out.InstanceName = in.InstanceName
        out.LatestModelApplied = in.LatestModelApplied
        return nil
}</span>

// Convert_v1beta1_AzureMachinePoolInstanceStatus_To_v1alpha3_AzureMachinePoolInstanceStatus is an autogenerated conversion function.
func Convert_v1beta1_AzureMachinePoolInstanceStatus_To_v1alpha3_AzureMachinePoolInstanceStatus(in *v1beta1.AzureMachinePoolInstanceStatus, out *AzureMachinePoolInstanceStatus, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_AzureMachinePoolInstanceStatus_To_v1alpha3_AzureMachinePoolInstanceStatus(in, out, s)
}</span>

func autoConvert_v1alpha3_AzureMachinePoolList_To_v1beta1_AzureMachinePoolList(in *AzureMachinePoolList, out *v1beta1.AzureMachinePoolList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]v1beta1.AzureMachinePool, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1alpha3_AzureMachinePool_To_v1beta1_AzureMachinePool(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1alpha3_AzureMachinePoolList_To_v1beta1_AzureMachinePoolList is an autogenerated conversion function.
func Convert_v1alpha3_AzureMachinePoolList_To_v1beta1_AzureMachinePoolList(in *AzureMachinePoolList, out *v1beta1.AzureMachinePoolList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha3_AzureMachinePoolList_To_v1beta1_AzureMachinePoolList(in, out, s)
}</span>

func autoConvert_v1beta1_AzureMachinePoolList_To_v1alpha3_AzureMachinePoolList(in *v1beta1.AzureMachinePoolList, out *AzureMachinePoolList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureMachinePool, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1beta1_AzureMachinePool_To_v1alpha3_AzureMachinePool(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1beta1_AzureMachinePoolList_To_v1alpha3_AzureMachinePoolList is an autogenerated conversion function.
func Convert_v1beta1_AzureMachinePoolList_To_v1alpha3_AzureMachinePoolList(in *v1beta1.AzureMachinePoolList, out *AzureMachinePoolList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_AzureMachinePoolList_To_v1alpha3_AzureMachinePoolList(in, out, s)
}</span>

func autoConvert_v1alpha3_AzureMachinePoolMachineTemplate_To_v1beta1_AzureMachinePoolMachineTemplate(in *AzureMachinePoolMachineTemplate, out *v1beta1.AzureMachinePoolMachineTemplate, s conversion.Scope) error <span class="cov8" title="1">{
        out.VMSize = in.VMSize
        if in.Image != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Image, &amp;out.Image
                *out = new(clusterapiproviderazureapiv1beta1.Image)
                if err := Convert_v1alpha3_Image_To_v1beta1_Image(*in, *out, s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                out.Image = nil
        }</span>
        <span class="cov8" title="1">if err := Convert_v1alpha3_OSDisk_To_v1beta1_OSDisk(&amp;in.OSDisk, &amp;out.OSDisk, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">out.DataDisks = *(*[]clusterapiproviderazureapiv1beta1.DataDisk)(unsafe.Pointer(&amp;in.DataDisks))
        out.SSHPublicKey = in.SSHPublicKey
        out.AcceleratedNetworking = (*bool)(unsafe.Pointer(in.AcceleratedNetworking))
        out.TerminateNotificationTimeout = (*int)(unsafe.Pointer(in.TerminateNotificationTimeout))
        out.SecurityProfile = (*clusterapiproviderazureapiv1beta1.SecurityProfile)(unsafe.Pointer(in.SecurityProfile))
        out.SpotVMOptions = (*clusterapiproviderazureapiv1beta1.SpotVMOptions)(unsafe.Pointer(in.SpotVMOptions))
        return nil</span>
}

// Convert_v1alpha3_AzureMachinePoolMachineTemplate_To_v1beta1_AzureMachinePoolMachineTemplate is an autogenerated conversion function.
func Convert_v1alpha3_AzureMachinePoolMachineTemplate_To_v1beta1_AzureMachinePoolMachineTemplate(in *AzureMachinePoolMachineTemplate, out *v1beta1.AzureMachinePoolMachineTemplate, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha3_AzureMachinePoolMachineTemplate_To_v1beta1_AzureMachinePoolMachineTemplate(in, out, s)
}</span>

func autoConvert_v1beta1_AzureMachinePoolMachineTemplate_To_v1alpha3_AzureMachinePoolMachineTemplate(in *v1beta1.AzureMachinePoolMachineTemplate, out *AzureMachinePoolMachineTemplate, s conversion.Scope) error <span class="cov8" title="1">{
        out.VMSize = in.VMSize
        if in.Image != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Image, &amp;out.Image
                *out = new(clusterapiproviderazureapiv1alpha3.Image)
                if err := Convert_v1beta1_Image_To_v1alpha3_Image(*in, *out, s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                out.Image = nil
        }</span>
        <span class="cov8" title="1">if err := Convert_v1beta1_OSDisk_To_v1alpha3_OSDisk(&amp;in.OSDisk, &amp;out.OSDisk, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">out.DataDisks = *(*[]clusterapiproviderazureapiv1alpha3.DataDisk)(unsafe.Pointer(&amp;in.DataDisks))
        out.SSHPublicKey = in.SSHPublicKey
        out.AcceleratedNetworking = (*bool)(unsafe.Pointer(in.AcceleratedNetworking))
        out.TerminateNotificationTimeout = (*int)(unsafe.Pointer(in.TerminateNotificationTimeout))
        out.SecurityProfile = (*clusterapiproviderazureapiv1alpha3.SecurityProfile)(unsafe.Pointer(in.SecurityProfile))
        out.SpotVMOptions = (*clusterapiproviderazureapiv1alpha3.SpotVMOptions)(unsafe.Pointer(in.SpotVMOptions))
        // WARNING: in.SubnetName requires manual conversion: does not exist in peer-type
        return nil</span>
}

func autoConvert_v1alpha3_AzureMachinePoolSpec_To_v1beta1_AzureMachinePoolSpec(in *AzureMachinePoolSpec, out *v1beta1.AzureMachinePoolSpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.Location = in.Location
        if err := Convert_v1alpha3_AzureMachinePoolMachineTemplate_To_v1beta1_AzureMachinePoolMachineTemplate(&amp;in.Template, &amp;out.Template, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">out.AdditionalTags = *(*clusterapiproviderazureapiv1beta1.Tags)(unsafe.Pointer(&amp;in.AdditionalTags))
        out.ProviderID = in.ProviderID
        out.ProviderIDList = *(*[]string)(unsafe.Pointer(&amp;in.ProviderIDList))
        out.Identity = clusterapiproviderazureapiv1beta1.VMIdentity(in.Identity)
        out.UserAssignedIdentities = *(*[]clusterapiproviderazureapiv1beta1.UserAssignedIdentity)(unsafe.Pointer(&amp;in.UserAssignedIdentities))
        out.RoleAssignmentName = in.RoleAssignmentName
        return nil</span>
}

// Convert_v1alpha3_AzureMachinePoolSpec_To_v1beta1_AzureMachinePoolSpec is an autogenerated conversion function.
func Convert_v1alpha3_AzureMachinePoolSpec_To_v1beta1_AzureMachinePoolSpec(in *AzureMachinePoolSpec, out *v1beta1.AzureMachinePoolSpec, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha3_AzureMachinePoolSpec_To_v1beta1_AzureMachinePoolSpec(in, out, s)
}</span>

func autoConvert_v1beta1_AzureMachinePoolSpec_To_v1alpha3_AzureMachinePoolSpec(in *v1beta1.AzureMachinePoolSpec, out *AzureMachinePoolSpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.Location = in.Location
        if err := Convert_v1beta1_AzureMachinePoolMachineTemplate_To_v1alpha3_AzureMachinePoolMachineTemplate(&amp;in.Template, &amp;out.Template, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">out.AdditionalTags = *(*clusterapiproviderazureapiv1alpha3.Tags)(unsafe.Pointer(&amp;in.AdditionalTags))
        out.ProviderID = in.ProviderID
        out.ProviderIDList = *(*[]string)(unsafe.Pointer(&amp;in.ProviderIDList))
        out.Identity = clusterapiproviderazureapiv1alpha3.VMIdentity(in.Identity)
        out.UserAssignedIdentities = *(*[]clusterapiproviderazureapiv1alpha3.UserAssignedIdentity)(unsafe.Pointer(&amp;in.UserAssignedIdentities))
        out.RoleAssignmentName = in.RoleAssignmentName
        // WARNING: in.Strategy requires manual conversion: does not exist in peer-type
        // WARNING: in.NodeDrainTimeout requires manual conversion: does not exist in peer-type
        return nil</span>
}

func autoConvert_v1alpha3_AzureMachinePoolStatus_To_v1beta1_AzureMachinePoolStatus(in *AzureMachinePoolStatus, out *v1beta1.AzureMachinePoolStatus, s conversion.Scope) error <span class="cov8" title="1">{
        out.Ready = in.Ready
        out.Replicas = in.Replicas
        out.Instances = *(*[]*v1beta1.AzureMachinePoolInstanceStatus)(unsafe.Pointer(&amp;in.Instances))
        out.Version = in.Version
        out.ProvisioningState = (*clusterapiproviderazureapiv1beta1.ProvisioningState)(unsafe.Pointer(in.ProvisioningState))
        out.FailureReason = (*errors.MachineStatusError)(unsafe.Pointer(in.FailureReason))
        out.FailureMessage = (*string)(unsafe.Pointer(in.FailureMessage))
        out.Conditions = *(*apiv1beta1.Conditions)(unsafe.Pointer(&amp;in.Conditions))
        // WARNING: in.LongRunningOperationState requires manual conversion: does not exist in peer-type
        return nil
}</span>

func autoConvert_v1beta1_AzureMachinePoolStatus_To_v1alpha3_AzureMachinePoolStatus(in *v1beta1.AzureMachinePoolStatus, out *AzureMachinePoolStatus, s conversion.Scope) error <span class="cov8" title="1">{
        out.Ready = in.Ready
        out.Replicas = in.Replicas
        out.Instances = *(*[]*AzureMachinePoolInstanceStatus)(unsafe.Pointer(&amp;in.Instances))
        // WARNING: in.Image requires manual conversion: does not exist in peer-type
        out.Version = in.Version
        out.ProvisioningState = (*clusterapiproviderazureapiv1alpha3.VMState)(unsafe.Pointer(in.ProvisioningState))
        out.FailureReason = (*errors.MachineStatusError)(unsafe.Pointer(in.FailureReason))
        out.FailureMessage = (*string)(unsafe.Pointer(in.FailureMessage))
        out.Conditions = *(*apiv1alpha3.Conditions)(unsafe.Pointer(&amp;in.Conditions))
        // WARNING: in.LongRunningOperationStates requires manual conversion: does not exist in peer-type
        return nil
}</span>

func autoConvert_v1alpha3_AzureManagedCluster_To_v1beta1_AzureManagedCluster(in *AzureManagedCluster, out *v1beta1.AzureManagedCluster, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1alpha3_AzureManagedClusterSpec_To_v1beta1_AzureManagedClusterSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1alpha3_AzureManagedClusterStatus_To_v1beta1_AzureManagedClusterStatus(&amp;in.Status, &amp;out.Status, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha3_AzureManagedCluster_To_v1beta1_AzureManagedCluster is an autogenerated conversion function.
func Convert_v1alpha3_AzureManagedCluster_To_v1beta1_AzureManagedCluster(in *AzureManagedCluster, out *v1beta1.AzureManagedCluster, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha3_AzureManagedCluster_To_v1beta1_AzureManagedCluster(in, out, s)
}</span>

func autoConvert_v1beta1_AzureManagedCluster_To_v1alpha3_AzureManagedCluster(in *v1beta1.AzureManagedCluster, out *AzureManagedCluster, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1beta1_AzureManagedClusterSpec_To_v1alpha3_AzureManagedClusterSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1beta1_AzureManagedClusterStatus_To_v1alpha3_AzureManagedClusterStatus(&amp;in.Status, &amp;out.Status, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1beta1_AzureManagedCluster_To_v1alpha3_AzureManagedCluster is an autogenerated conversion function.
func Convert_v1beta1_AzureManagedCluster_To_v1alpha3_AzureManagedCluster(in *v1beta1.AzureManagedCluster, out *AzureManagedCluster, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureManagedCluster_To_v1alpha3_AzureManagedCluster(in, out, s)
}</span>

func autoConvert_v1alpha3_AzureManagedClusterList_To_v1beta1_AzureManagedClusterList(in *AzureManagedClusterList, out *v1beta1.AzureManagedClusterList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]v1beta1.AzureManagedCluster, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1alpha3_AzureManagedCluster_To_v1beta1_AzureManagedCluster(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1alpha3_AzureManagedClusterList_To_v1beta1_AzureManagedClusterList is an autogenerated conversion function.
func Convert_v1alpha3_AzureManagedClusterList_To_v1beta1_AzureManagedClusterList(in *AzureManagedClusterList, out *v1beta1.AzureManagedClusterList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha3_AzureManagedClusterList_To_v1beta1_AzureManagedClusterList(in, out, s)
}</span>

func autoConvert_v1beta1_AzureManagedClusterList_To_v1alpha3_AzureManagedClusterList(in *v1beta1.AzureManagedClusterList, out *AzureManagedClusterList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureManagedCluster, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1beta1_AzureManagedCluster_To_v1alpha3_AzureManagedCluster(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1beta1_AzureManagedClusterList_To_v1alpha3_AzureManagedClusterList is an autogenerated conversion function.
func Convert_v1beta1_AzureManagedClusterList_To_v1alpha3_AzureManagedClusterList(in *v1beta1.AzureManagedClusterList, out *AzureManagedClusterList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_AzureManagedClusterList_To_v1alpha3_AzureManagedClusterList(in, out, s)
}</span>

func autoConvert_v1alpha3_AzureManagedClusterSpec_To_v1beta1_AzureManagedClusterSpec(in *AzureManagedClusterSpec, out *v1beta1.AzureManagedClusterSpec, s conversion.Scope) error <span class="cov8" title="1">{
        if err := Convert_v1alpha3_APIEndpoint_To_v1beta1_APIEndpoint(&amp;in.ControlPlaneEndpoint, &amp;out.ControlPlaneEndpoint, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha3_AzureManagedClusterSpec_To_v1beta1_AzureManagedClusterSpec is an autogenerated conversion function.
func Convert_v1alpha3_AzureManagedClusterSpec_To_v1beta1_AzureManagedClusterSpec(in *AzureManagedClusterSpec, out *v1beta1.AzureManagedClusterSpec, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha3_AzureManagedClusterSpec_To_v1beta1_AzureManagedClusterSpec(in, out, s)
}</span>

func autoConvert_v1beta1_AzureManagedClusterSpec_To_v1alpha3_AzureManagedClusterSpec(in *v1beta1.AzureManagedClusterSpec, out *AzureManagedClusterSpec, s conversion.Scope) error <span class="cov8" title="1">{
        if err := Convert_v1beta1_APIEndpoint_To_v1alpha3_APIEndpoint(&amp;in.ControlPlaneEndpoint, &amp;out.ControlPlaneEndpoint, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1beta1_AzureManagedClusterSpec_To_v1alpha3_AzureManagedClusterSpec is an autogenerated conversion function.
func Convert_v1beta1_AzureManagedClusterSpec_To_v1alpha3_AzureManagedClusterSpec(in *v1beta1.AzureManagedClusterSpec, out *AzureManagedClusterSpec, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureManagedClusterSpec_To_v1alpha3_AzureManagedClusterSpec(in, out, s)
}</span>

func autoConvert_v1alpha3_AzureManagedClusterStatus_To_v1beta1_AzureManagedClusterStatus(in *AzureManagedClusterStatus, out *v1beta1.AzureManagedClusterStatus, s conversion.Scope) error <span class="cov8" title="1">{
        out.Ready = in.Ready
        return nil
}</span>

// Convert_v1alpha3_AzureManagedClusterStatus_To_v1beta1_AzureManagedClusterStatus is an autogenerated conversion function.
func Convert_v1alpha3_AzureManagedClusterStatus_To_v1beta1_AzureManagedClusterStatus(in *AzureManagedClusterStatus, out *v1beta1.AzureManagedClusterStatus, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha3_AzureManagedClusterStatus_To_v1beta1_AzureManagedClusterStatus(in, out, s)
}</span>

func autoConvert_v1beta1_AzureManagedClusterStatus_To_v1alpha3_AzureManagedClusterStatus(in *v1beta1.AzureManagedClusterStatus, out *AzureManagedClusterStatus, s conversion.Scope) error <span class="cov8" title="1">{
        out.Ready = in.Ready
        return nil
}</span>

// Convert_v1beta1_AzureManagedClusterStatus_To_v1alpha3_AzureManagedClusterStatus is an autogenerated conversion function.
func Convert_v1beta1_AzureManagedClusterStatus_To_v1alpha3_AzureManagedClusterStatus(in *v1beta1.AzureManagedClusterStatus, out *AzureManagedClusterStatus, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureManagedClusterStatus_To_v1alpha3_AzureManagedClusterStatus(in, out, s)
}</span>

func autoConvert_v1alpha3_AzureManagedControlPlane_To_v1beta1_AzureManagedControlPlane(in *AzureManagedControlPlane, out *v1beta1.AzureManagedControlPlane, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1alpha3_AzureManagedControlPlaneSpec_To_v1beta1_AzureManagedControlPlaneSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1alpha3_AzureManagedControlPlaneStatus_To_v1beta1_AzureManagedControlPlaneStatus(&amp;in.Status, &amp;out.Status, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha3_AzureManagedControlPlane_To_v1beta1_AzureManagedControlPlane is an autogenerated conversion function.
func Convert_v1alpha3_AzureManagedControlPlane_To_v1beta1_AzureManagedControlPlane(in *AzureManagedControlPlane, out *v1beta1.AzureManagedControlPlane, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha3_AzureManagedControlPlane_To_v1beta1_AzureManagedControlPlane(in, out, s)
}</span>

func autoConvert_v1beta1_AzureManagedControlPlane_To_v1alpha3_AzureManagedControlPlane(in *v1beta1.AzureManagedControlPlane, out *AzureManagedControlPlane, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1beta1_AzureManagedControlPlaneSpec_To_v1alpha3_AzureManagedControlPlaneSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1beta1_AzureManagedControlPlaneStatus_To_v1alpha3_AzureManagedControlPlaneStatus(&amp;in.Status, &amp;out.Status, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1beta1_AzureManagedControlPlane_To_v1alpha3_AzureManagedControlPlane is an autogenerated conversion function.
func Convert_v1beta1_AzureManagedControlPlane_To_v1alpha3_AzureManagedControlPlane(in *v1beta1.AzureManagedControlPlane, out *AzureManagedControlPlane, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureManagedControlPlane_To_v1alpha3_AzureManagedControlPlane(in, out, s)
}</span>

func autoConvert_v1alpha3_AzureManagedControlPlaneList_To_v1beta1_AzureManagedControlPlaneList(in *AzureManagedControlPlaneList, out *v1beta1.AzureManagedControlPlaneList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]v1beta1.AzureManagedControlPlane, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1alpha3_AzureManagedControlPlane_To_v1beta1_AzureManagedControlPlane(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1alpha3_AzureManagedControlPlaneList_To_v1beta1_AzureManagedControlPlaneList is an autogenerated conversion function.
func Convert_v1alpha3_AzureManagedControlPlaneList_To_v1beta1_AzureManagedControlPlaneList(in *AzureManagedControlPlaneList, out *v1beta1.AzureManagedControlPlaneList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha3_AzureManagedControlPlaneList_To_v1beta1_AzureManagedControlPlaneList(in, out, s)
}</span>

func autoConvert_v1beta1_AzureManagedControlPlaneList_To_v1alpha3_AzureManagedControlPlaneList(in *v1beta1.AzureManagedControlPlaneList, out *AzureManagedControlPlaneList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureManagedControlPlane, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1beta1_AzureManagedControlPlane_To_v1alpha3_AzureManagedControlPlane(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1beta1_AzureManagedControlPlaneList_To_v1alpha3_AzureManagedControlPlaneList is an autogenerated conversion function.
func Convert_v1beta1_AzureManagedControlPlaneList_To_v1alpha3_AzureManagedControlPlaneList(in *v1beta1.AzureManagedControlPlaneList, out *AzureManagedControlPlaneList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_AzureManagedControlPlaneList_To_v1alpha3_AzureManagedControlPlaneList(in, out, s)
}</span>

func autoConvert_v1alpha3_AzureManagedControlPlaneSpec_To_v1beta1_AzureManagedControlPlaneSpec(in *AzureManagedControlPlaneSpec, out *v1beta1.AzureManagedControlPlaneSpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.Version = in.Version
        out.ResourceGroupName = in.ResourceGroupName
        out.NodeResourceGroupName = in.NodeResourceGroupName
        if err := Convert_v1alpha3_ManagedControlPlaneVirtualNetwork_To_v1beta1_ManagedControlPlaneVirtualNetwork(&amp;in.VirtualNetwork, &amp;out.VirtualNetwork, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">out.SubscriptionID = in.SubscriptionID
        out.Location = in.Location
        if err := Convert_v1alpha3_APIEndpoint_To_v1beta1_APIEndpoint(&amp;in.ControlPlaneEndpoint, &amp;out.ControlPlaneEndpoint, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">out.AdditionalTags = *(*clusterapiproviderazureapiv1beta1.Tags)(unsafe.Pointer(&amp;in.AdditionalTags))
        out.NetworkPlugin = (*string)(unsafe.Pointer(in.NetworkPlugin))
        out.NetworkPolicy = (*string)(unsafe.Pointer(in.NetworkPolicy))
        out.SSHPublicKey = in.SSHPublicKey
        out.DNSServiceIP = (*string)(unsafe.Pointer(in.DNSServiceIP))
        out.LoadBalancerSKU = (*string)(unsafe.Pointer(in.LoadBalancerSKU))
        out.AADProfile = (*v1beta1.AADProfile)(unsafe.Pointer(in.AADProfile))
        return nil</span>
}

// Convert_v1alpha3_AzureManagedControlPlaneSpec_To_v1beta1_AzureManagedControlPlaneSpec is an autogenerated conversion function.
func Convert_v1alpha3_AzureManagedControlPlaneSpec_To_v1beta1_AzureManagedControlPlaneSpec(in *AzureManagedControlPlaneSpec, out *v1beta1.AzureManagedControlPlaneSpec, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha3_AzureManagedControlPlaneSpec_To_v1beta1_AzureManagedControlPlaneSpec(in, out, s)
}</span>

func autoConvert_v1beta1_AzureManagedControlPlaneSpec_To_v1alpha3_AzureManagedControlPlaneSpec(in *v1beta1.AzureManagedControlPlaneSpec, out *AzureManagedControlPlaneSpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.Version = in.Version
        out.ResourceGroupName = in.ResourceGroupName
        out.NodeResourceGroupName = in.NodeResourceGroupName
        if err := Convert_v1beta1_ManagedControlPlaneVirtualNetwork_To_v1alpha3_ManagedControlPlaneVirtualNetwork(&amp;in.VirtualNetwork, &amp;out.VirtualNetwork, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">out.SubscriptionID = in.SubscriptionID
        out.Location = in.Location
        if err := Convert_v1beta1_APIEndpoint_To_v1alpha3_APIEndpoint(&amp;in.ControlPlaneEndpoint, &amp;out.ControlPlaneEndpoint, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">out.AdditionalTags = *(*clusterapiproviderazureapiv1alpha3.Tags)(unsafe.Pointer(&amp;in.AdditionalTags))
        out.NetworkPlugin = (*string)(unsafe.Pointer(in.NetworkPlugin))
        out.NetworkPolicy = (*string)(unsafe.Pointer(in.NetworkPolicy))
        out.SSHPublicKey = in.SSHPublicKey
        out.DNSServiceIP = (*string)(unsafe.Pointer(in.DNSServiceIP))
        out.LoadBalancerSKU = (*string)(unsafe.Pointer(in.LoadBalancerSKU))
        // WARNING: in.IdentityRef requires manual conversion: does not exist in peer-type
        out.AADProfile = (*AADProfile)(unsafe.Pointer(in.AADProfile))
        // WARNING: in.AddonProfiles requires manual conversion: does not exist in peer-type
        // WARNING: in.SKU requires manual conversion: does not exist in peer-type
        // WARNING: in.LoadBalancerProfile requires manual conversion: does not exist in peer-type
        // WARNING: in.APIServerAccessProfile requires manual conversion: does not exist in peer-type
        return nil</span>
}

func autoConvert_v1alpha3_AzureManagedControlPlaneStatus_To_v1beta1_AzureManagedControlPlaneStatus(in *AzureManagedControlPlaneStatus, out *v1beta1.AzureManagedControlPlaneStatus, s conversion.Scope) error <span class="cov8" title="1">{
        out.Ready = in.Ready
        out.Initialized = in.Initialized
        return nil
}</span>

// Convert_v1alpha3_AzureManagedControlPlaneStatus_To_v1beta1_AzureManagedControlPlaneStatus is an autogenerated conversion function.
func Convert_v1alpha3_AzureManagedControlPlaneStatus_To_v1beta1_AzureManagedControlPlaneStatus(in *AzureManagedControlPlaneStatus, out *v1beta1.AzureManagedControlPlaneStatus, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha3_AzureManagedControlPlaneStatus_To_v1beta1_AzureManagedControlPlaneStatus(in, out, s)
}</span>

func autoConvert_v1beta1_AzureManagedControlPlaneStatus_To_v1alpha3_AzureManagedControlPlaneStatus(in *v1beta1.AzureManagedControlPlaneStatus, out *AzureManagedControlPlaneStatus, s conversion.Scope) error <span class="cov8" title="1">{
        out.Ready = in.Ready
        out.Initialized = in.Initialized
        // WARNING: in.Conditions requires manual conversion: does not exist in peer-type
        // WARNING: in.LongRunningOperationStates requires manual conversion: does not exist in peer-type
        return nil
}</span>

func autoConvert_v1alpha3_AzureManagedMachinePool_To_v1beta1_AzureManagedMachinePool(in *AzureManagedMachinePool, out *v1beta1.AzureManagedMachinePool, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1alpha3_AzureManagedMachinePoolSpec_To_v1beta1_AzureManagedMachinePoolSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1alpha3_AzureManagedMachinePoolStatus_To_v1beta1_AzureManagedMachinePoolStatus(&amp;in.Status, &amp;out.Status, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha3_AzureManagedMachinePool_To_v1beta1_AzureManagedMachinePool is an autogenerated conversion function.
func Convert_v1alpha3_AzureManagedMachinePool_To_v1beta1_AzureManagedMachinePool(in *AzureManagedMachinePool, out *v1beta1.AzureManagedMachinePool, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha3_AzureManagedMachinePool_To_v1beta1_AzureManagedMachinePool(in, out, s)
}</span>

func autoConvert_v1beta1_AzureManagedMachinePool_To_v1alpha3_AzureManagedMachinePool(in *v1beta1.AzureManagedMachinePool, out *AzureManagedMachinePool, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1beta1_AzureManagedMachinePoolSpec_To_v1alpha3_AzureManagedMachinePoolSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1beta1_AzureManagedMachinePoolStatus_To_v1alpha3_AzureManagedMachinePoolStatus(&amp;in.Status, &amp;out.Status, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1beta1_AzureManagedMachinePool_To_v1alpha3_AzureManagedMachinePool is an autogenerated conversion function.
func Convert_v1beta1_AzureManagedMachinePool_To_v1alpha3_AzureManagedMachinePool(in *v1beta1.AzureManagedMachinePool, out *AzureManagedMachinePool, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureManagedMachinePool_To_v1alpha3_AzureManagedMachinePool(in, out, s)
}</span>

func autoConvert_v1alpha3_AzureManagedMachinePoolList_To_v1beta1_AzureManagedMachinePoolList(in *AzureManagedMachinePoolList, out *v1beta1.AzureManagedMachinePoolList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]v1beta1.AzureManagedMachinePool, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1alpha3_AzureManagedMachinePool_To_v1beta1_AzureManagedMachinePool(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1alpha3_AzureManagedMachinePoolList_To_v1beta1_AzureManagedMachinePoolList is an autogenerated conversion function.
func Convert_v1alpha3_AzureManagedMachinePoolList_To_v1beta1_AzureManagedMachinePoolList(in *AzureManagedMachinePoolList, out *v1beta1.AzureManagedMachinePoolList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha3_AzureManagedMachinePoolList_To_v1beta1_AzureManagedMachinePoolList(in, out, s)
}</span>

func autoConvert_v1beta1_AzureManagedMachinePoolList_To_v1alpha3_AzureManagedMachinePoolList(in *v1beta1.AzureManagedMachinePoolList, out *AzureManagedMachinePoolList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureManagedMachinePool, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1beta1_AzureManagedMachinePool_To_v1alpha3_AzureManagedMachinePool(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1beta1_AzureManagedMachinePoolList_To_v1alpha3_AzureManagedMachinePoolList is an autogenerated conversion function.
func Convert_v1beta1_AzureManagedMachinePoolList_To_v1alpha3_AzureManagedMachinePoolList(in *v1beta1.AzureManagedMachinePoolList, out *AzureManagedMachinePoolList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_AzureManagedMachinePoolList_To_v1alpha3_AzureManagedMachinePoolList(in, out, s)
}</span>

func autoConvert_v1alpha3_AzureManagedMachinePoolSpec_To_v1beta1_AzureManagedMachinePoolSpec(in *AzureManagedMachinePoolSpec, out *v1beta1.AzureManagedMachinePoolSpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.Mode = in.Mode
        out.SKU = in.SKU
        out.OSDiskSizeGB = (*int32)(unsafe.Pointer(in.OSDiskSizeGB))
        out.ProviderIDList = *(*[]string)(unsafe.Pointer(&amp;in.ProviderIDList))
        return nil
}</span>

// Convert_v1alpha3_AzureManagedMachinePoolSpec_To_v1beta1_AzureManagedMachinePoolSpec is an autogenerated conversion function.
func Convert_v1alpha3_AzureManagedMachinePoolSpec_To_v1beta1_AzureManagedMachinePoolSpec(in *AzureManagedMachinePoolSpec, out *v1beta1.AzureManagedMachinePoolSpec, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha3_AzureManagedMachinePoolSpec_To_v1beta1_AzureManagedMachinePoolSpec(in, out, s)
}</span>

func autoConvert_v1beta1_AzureManagedMachinePoolSpec_To_v1alpha3_AzureManagedMachinePoolSpec(in *v1beta1.AzureManagedMachinePoolSpec, out *AzureManagedMachinePoolSpec, s conversion.Scope) error <span class="cov8" title="1">{
        // WARNING: in.Name requires manual conversion: does not exist in peer-type
        out.Mode = in.Mode
        out.SKU = in.SKU
        out.OSDiskSizeGB = (*int32)(unsafe.Pointer(in.OSDiskSizeGB))
        // WARNING: in.AvailabilityZones requires manual conversion: does not exist in peer-type
        // WARNING: in.NodeLabels requires manual conversion: does not exist in peer-type
        // WARNING: in.Taints requires manual conversion: does not exist in peer-type
        out.ProviderIDList = *(*[]string)(unsafe.Pointer(&amp;in.ProviderIDList))
        // WARNING: in.Scaling requires manual conversion: does not exist in peer-type
        // WARNING: in.MaxPods requires manual conversion: does not exist in peer-type
        // WARNING: in.OsDiskType requires manual conversion: does not exist in peer-type
        // WARNING: in.EnableUltraSSD requires manual conversion: does not exist in peer-type
        // WARNING: in.OSType requires manual conversion: does not exist in peer-type
        // WARNING: in.EnableNodePublicIP requires manual conversion: does not exist in peer-type
        return nil
}</span>

func autoConvert_v1alpha3_AzureManagedMachinePoolStatus_To_v1beta1_AzureManagedMachinePoolStatus(in *AzureManagedMachinePoolStatus, out *v1beta1.AzureManagedMachinePoolStatus, s conversion.Scope) error <span class="cov8" title="1">{
        out.Ready = in.Ready
        out.Replicas = in.Replicas
        out.ErrorReason = (*errors.MachineStatusError)(unsafe.Pointer(in.ErrorReason))
        out.ErrorMessage = (*string)(unsafe.Pointer(in.ErrorMessage))
        return nil
}</span>

// Convert_v1alpha3_AzureManagedMachinePoolStatus_To_v1beta1_AzureManagedMachinePoolStatus is an autogenerated conversion function.
func Convert_v1alpha3_AzureManagedMachinePoolStatus_To_v1beta1_AzureManagedMachinePoolStatus(in *AzureManagedMachinePoolStatus, out *v1beta1.AzureManagedMachinePoolStatus, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha3_AzureManagedMachinePoolStatus_To_v1beta1_AzureManagedMachinePoolStatus(in, out, s)
}</span>

func autoConvert_v1beta1_AzureManagedMachinePoolStatus_To_v1alpha3_AzureManagedMachinePoolStatus(in *v1beta1.AzureManagedMachinePoolStatus, out *AzureManagedMachinePoolStatus, s conversion.Scope) error <span class="cov8" title="1">{
        out.Ready = in.Ready
        out.Replicas = in.Replicas
        out.ErrorReason = (*errors.MachineStatusError)(unsafe.Pointer(in.ErrorReason))
        out.ErrorMessage = (*string)(unsafe.Pointer(in.ErrorMessage))
        // WARNING: in.Conditions requires manual conversion: does not exist in peer-type
        // WARNING: in.LongRunningOperationStates requires manual conversion: does not exist in peer-type
        return nil
}</span>

func autoConvert_v1alpha3_ManagedControlPlaneSubnet_To_v1beta1_ManagedControlPlaneSubnet(in *ManagedControlPlaneSubnet, out *v1beta1.ManagedControlPlaneSubnet, s conversion.Scope) error <span class="cov8" title="1">{
        out.Name = in.Name
        out.CIDRBlock = in.CIDRBlock
        return nil
}</span>

// Convert_v1alpha3_ManagedControlPlaneSubnet_To_v1beta1_ManagedControlPlaneSubnet is an autogenerated conversion function.
func Convert_v1alpha3_ManagedControlPlaneSubnet_To_v1beta1_ManagedControlPlaneSubnet(in *ManagedControlPlaneSubnet, out *v1beta1.ManagedControlPlaneSubnet, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha3_ManagedControlPlaneSubnet_To_v1beta1_ManagedControlPlaneSubnet(in, out, s)
}</span>

func autoConvert_v1beta1_ManagedControlPlaneSubnet_To_v1alpha3_ManagedControlPlaneSubnet(in *v1beta1.ManagedControlPlaneSubnet, out *ManagedControlPlaneSubnet, s conversion.Scope) error <span class="cov8" title="1">{
        out.Name = in.Name
        out.CIDRBlock = in.CIDRBlock
        return nil
}</span>

// Convert_v1beta1_ManagedControlPlaneSubnet_To_v1alpha3_ManagedControlPlaneSubnet is an autogenerated conversion function.
func Convert_v1beta1_ManagedControlPlaneSubnet_To_v1alpha3_ManagedControlPlaneSubnet(in *v1beta1.ManagedControlPlaneSubnet, out *ManagedControlPlaneSubnet, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_ManagedControlPlaneSubnet_To_v1alpha3_ManagedControlPlaneSubnet(in, out, s)
}</span>

func autoConvert_v1alpha3_ManagedControlPlaneVirtualNetwork_To_v1beta1_ManagedControlPlaneVirtualNetwork(in *ManagedControlPlaneVirtualNetwork, out *v1beta1.ManagedControlPlaneVirtualNetwork, s conversion.Scope) error <span class="cov8" title="1">{
        out.Name = in.Name
        out.CIDRBlock = in.CIDRBlock
        if err := Convert_v1alpha3_ManagedControlPlaneSubnet_To_v1beta1_ManagedControlPlaneSubnet(&amp;in.Subnet, &amp;out.Subnet, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha3_ManagedControlPlaneVirtualNetwork_To_v1beta1_ManagedControlPlaneVirtualNetwork is an autogenerated conversion function.
func Convert_v1alpha3_ManagedControlPlaneVirtualNetwork_To_v1beta1_ManagedControlPlaneVirtualNetwork(in *ManagedControlPlaneVirtualNetwork, out *v1beta1.ManagedControlPlaneVirtualNetwork, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha3_ManagedControlPlaneVirtualNetwork_To_v1beta1_ManagedControlPlaneVirtualNetwork(in, out, s)
}</span>

func autoConvert_v1beta1_ManagedControlPlaneVirtualNetwork_To_v1alpha3_ManagedControlPlaneVirtualNetwork(in *v1beta1.ManagedControlPlaneVirtualNetwork, out *ManagedControlPlaneVirtualNetwork, s conversion.Scope) error <span class="cov8" title="1">{
        out.Name = in.Name
        out.CIDRBlock = in.CIDRBlock
        if err := Convert_v1beta1_ManagedControlPlaneSubnet_To_v1alpha3_ManagedControlPlaneSubnet(&amp;in.Subnet, &amp;out.Subnet, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1beta1_ManagedControlPlaneVirtualNetwork_To_v1alpha3_ManagedControlPlaneVirtualNetwork is an autogenerated conversion function.
func Convert_v1beta1_ManagedControlPlaneVirtualNetwork_To_v1alpha3_ManagedControlPlaneVirtualNetwork(in *v1beta1.ManagedControlPlaneVirtualNetwork, out *ManagedControlPlaneVirtualNetwork, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_ManagedControlPlaneVirtualNetwork_To_v1alpha3_ManagedControlPlaneVirtualNetwork(in, out, s)
}</span>
</pre>
		
		<pre class="file" id="file177" style="display: none">//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha3

import (
        runtime "k8s.io/apimachinery/pkg/runtime"
        apiv1alpha3 "sigs.k8s.io/cluster-api-provider-azure/api/v1alpha3"
        cluster_apiapiv1alpha3 "sigs.k8s.io/cluster-api/api/v1alpha3"
        "sigs.k8s.io/cluster-api/errors"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AADProfile) DeepCopyInto(out *AADProfile) <span class="cov0" title="0">{
        *out = *in
        if in.AdminGroupObjectIDs != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AdminGroupObjectIDs, &amp;out.AdminGroupObjectIDs
                *out = make([]string, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AADProfile.
func (in *AADProfile) DeepCopy() *AADProfile <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AADProfile)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachinePool) DeepCopyInto(out *AzureMachinePool) <span class="cov8" title="1">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
        in.Status.DeepCopyInto(&amp;out.Status)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachinePool.
func (in *AzureMachinePool) DeepCopy() *AzureMachinePool <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">out := new(AzureMachinePool)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureMachinePool) DeepCopyObject() runtime.Object <span class="cov8" title="1">{
        if c := in.DeepCopy(); c != nil </span><span class="cov8" title="1">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachinePoolInstanceStatus) DeepCopyInto(out *AzureMachinePoolInstanceStatus) <span class="cov0" title="0">{
        *out = *in
        if in.ProvisioningState != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ProvisioningState, &amp;out.ProvisioningState
                *out = new(apiv1alpha3.VMState)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachinePoolInstanceStatus.
func (in *AzureMachinePoolInstanceStatus) DeepCopy() *AzureMachinePoolInstanceStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachinePoolInstanceStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachinePoolList) DeepCopyInto(out *AzureMachinePoolList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureMachinePool, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachinePoolList.
func (in *AzureMachinePoolList) DeepCopy() *AzureMachinePoolList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachinePoolList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureMachinePoolList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachinePoolMachineTemplate) DeepCopyInto(out *AzureMachinePoolMachineTemplate) <span class="cov8" title="1">{
        *out = *in
        if in.Image != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Image, &amp;out.Image
                *out = new(apiv1alpha3.Image)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov8" title="1">in.OSDisk.DeepCopyInto(&amp;out.OSDisk)
        if in.DataDisks != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.DataDisks, &amp;out.DataDisks
                *out = make([]apiv1alpha3.DataDisk, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov8" title="1">if in.AcceleratedNetworking != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AcceleratedNetworking, &amp;out.AcceleratedNetworking
                *out = new(bool)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.TerminateNotificationTimeout != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.TerminateNotificationTimeout, &amp;out.TerminateNotificationTimeout
                *out = new(int)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.SecurityProfile != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.SecurityProfile, &amp;out.SecurityProfile
                *out = new(apiv1alpha3.SecurityProfile)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov8" title="1">if in.SpotVMOptions != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.SpotVMOptions, &amp;out.SpotVMOptions
                *out = new(apiv1alpha3.SpotVMOptions)
                (*in).DeepCopyInto(*out)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachinePoolMachineTemplate.
func (in *AzureMachinePoolMachineTemplate) DeepCopy() *AzureMachinePoolMachineTemplate <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachinePoolMachineTemplate)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachinePoolSpec) DeepCopyInto(out *AzureMachinePoolSpec) <span class="cov8" title="1">{
        *out = *in
        in.Template.DeepCopyInto(&amp;out.Template)
        if in.AdditionalTags != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AdditionalTags, &amp;out.AdditionalTags
                *out = make(apiv1alpha3.Tags, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
        <span class="cov8" title="1">if in.ProviderIDList != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ProviderIDList, &amp;out.ProviderIDList
                *out = make([]string, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov8" title="1">if in.UserAssignedIdentities != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.UserAssignedIdentities, &amp;out.UserAssignedIdentities
                *out = make([]apiv1alpha3.UserAssignedIdentity, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachinePoolSpec.
func (in *AzureMachinePoolSpec) DeepCopy() *AzureMachinePoolSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachinePoolSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachinePoolStatus) DeepCopyInto(out *AzureMachinePoolStatus) <span class="cov8" title="1">{
        *out = *in
        if in.Instances != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Instances, &amp;out.Instances
                *out = make([]*AzureMachinePoolInstanceStatus, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if (*in)[i] != nil </span><span class="cov0" title="0">{
                                in, out := &amp;(*in)[i], &amp;(*out)[i]
                                *out = new(AzureMachinePoolInstanceStatus)
                                (*in).DeepCopyInto(*out)
                        }</span>
                }
        }
        <span class="cov8" title="1">if in.ProvisioningState != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ProvisioningState, &amp;out.ProvisioningState
                *out = new(apiv1alpha3.VMState)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.FailureReason != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.FailureReason, &amp;out.FailureReason
                *out = new(errors.MachineStatusError)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.FailureMessage != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.FailureMessage, &amp;out.FailureMessage
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.Conditions != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make(cluster_apiapiv1alpha3.Conditions, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov8" title="1">if in.LongRunningOperationState != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.LongRunningOperationState, &amp;out.LongRunningOperationState
                *out = new(apiv1alpha3.Future)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachinePoolStatus.
func (in *AzureMachinePoolStatus) DeepCopy() *AzureMachinePoolStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachinePoolStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedCluster) DeepCopyInto(out *AzureManagedCluster) <span class="cov8" title="1">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        out.Spec = in.Spec
        out.Status = in.Status
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedCluster.
func (in *AzureManagedCluster) DeepCopy() *AzureManagedCluster <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">out := new(AzureManagedCluster)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureManagedCluster) DeepCopyObject() runtime.Object <span class="cov8" title="1">{
        if c := in.DeepCopy(); c != nil </span><span class="cov8" title="1">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedClusterList) DeepCopyInto(out *AzureManagedClusterList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureManagedCluster, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedClusterList.
func (in *AzureManagedClusterList) DeepCopy() *AzureManagedClusterList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureManagedClusterList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureManagedClusterList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedClusterSpec) DeepCopyInto(out *AzureManagedClusterSpec) <span class="cov0" title="0">{
        *out = *in
        out.ControlPlaneEndpoint = in.ControlPlaneEndpoint
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedClusterSpec.
func (in *AzureManagedClusterSpec) DeepCopy() *AzureManagedClusterSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureManagedClusterSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedClusterStatus) DeepCopyInto(out *AzureManagedClusterStatus) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedClusterStatus.
func (in *AzureManagedClusterStatus) DeepCopy() *AzureManagedClusterStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureManagedClusterStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedControlPlane) DeepCopyInto(out *AzureManagedControlPlane) <span class="cov8" title="1">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
        out.Status = in.Status
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedControlPlane.
func (in *AzureManagedControlPlane) DeepCopy() *AzureManagedControlPlane <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">out := new(AzureManagedControlPlane)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureManagedControlPlane) DeepCopyObject() runtime.Object <span class="cov8" title="1">{
        if c := in.DeepCopy(); c != nil </span><span class="cov8" title="1">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedControlPlaneList) DeepCopyInto(out *AzureManagedControlPlaneList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureManagedControlPlane, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedControlPlaneList.
func (in *AzureManagedControlPlaneList) DeepCopy() *AzureManagedControlPlaneList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureManagedControlPlaneList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureManagedControlPlaneList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedControlPlaneSpec) DeepCopyInto(out *AzureManagedControlPlaneSpec) <span class="cov8" title="1">{
        *out = *in
        out.VirtualNetwork = in.VirtualNetwork
        out.ControlPlaneEndpoint = in.ControlPlaneEndpoint
        if in.AdditionalTags != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AdditionalTags, &amp;out.AdditionalTags
                *out = make(apiv1alpha3.Tags, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
        <span class="cov8" title="1">if in.NetworkPlugin != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.NetworkPlugin, &amp;out.NetworkPlugin
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.NetworkPolicy != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.NetworkPolicy, &amp;out.NetworkPolicy
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.DNSServiceIP != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.DNSServiceIP, &amp;out.DNSServiceIP
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.LoadBalancerSKU != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.LoadBalancerSKU, &amp;out.LoadBalancerSKU
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.AADProfile != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AADProfile, &amp;out.AADProfile
                *out = new(AADProfile)
                (*in).DeepCopyInto(*out)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedControlPlaneSpec.
func (in *AzureManagedControlPlaneSpec) DeepCopy() *AzureManagedControlPlaneSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureManagedControlPlaneSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedControlPlaneStatus) DeepCopyInto(out *AzureManagedControlPlaneStatus) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedControlPlaneStatus.
func (in *AzureManagedControlPlaneStatus) DeepCopy() *AzureManagedControlPlaneStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureManagedControlPlaneStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedMachinePool) DeepCopyInto(out *AzureManagedMachinePool) <span class="cov8" title="1">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
        in.Status.DeepCopyInto(&amp;out.Status)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedMachinePool.
func (in *AzureManagedMachinePool) DeepCopy() *AzureManagedMachinePool <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">out := new(AzureManagedMachinePool)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureManagedMachinePool) DeepCopyObject() runtime.Object <span class="cov8" title="1">{
        if c := in.DeepCopy(); c != nil </span><span class="cov8" title="1">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedMachinePoolList) DeepCopyInto(out *AzureManagedMachinePoolList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureManagedMachinePool, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedMachinePoolList.
func (in *AzureManagedMachinePoolList) DeepCopy() *AzureManagedMachinePoolList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureManagedMachinePoolList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureManagedMachinePoolList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedMachinePoolSpec) DeepCopyInto(out *AzureManagedMachinePoolSpec) <span class="cov8" title="1">{
        *out = *in
        if in.OSDiskSizeGB != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.OSDiskSizeGB, &amp;out.OSDiskSizeGB
                *out = new(int32)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.ProviderIDList != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ProviderIDList, &amp;out.ProviderIDList
                *out = make([]string, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedMachinePoolSpec.
func (in *AzureManagedMachinePoolSpec) DeepCopy() *AzureManagedMachinePoolSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureManagedMachinePoolSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedMachinePoolStatus) DeepCopyInto(out *AzureManagedMachinePoolStatus) <span class="cov8" title="1">{
        *out = *in
        if in.ErrorReason != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ErrorReason, &amp;out.ErrorReason
                *out = new(errors.MachineStatusError)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.ErrorMessage != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ErrorMessage, &amp;out.ErrorMessage
                *out = new(string)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedMachinePoolStatus.
func (in *AzureManagedMachinePoolStatus) DeepCopy() *AzureManagedMachinePoolStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureManagedMachinePoolStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ManagedControlPlaneSubnet) DeepCopyInto(out *ManagedControlPlaneSubnet) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ManagedControlPlaneSubnet.
func (in *ManagedControlPlaneSubnet) DeepCopy() *ManagedControlPlaneSubnet <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(ManagedControlPlaneSubnet)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ManagedControlPlaneVirtualNetwork) DeepCopyInto(out *ManagedControlPlaneVirtualNetwork) <span class="cov0" title="0">{
        *out = *in
        out.Subnet = in.Subnet
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ManagedControlPlaneVirtualNetwork.
func (in *ManagedControlPlaneVirtualNetwork) DeepCopy() *ManagedControlPlaneVirtualNetwork <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(ManagedControlPlaneVirtualNetwork)
        in.DeepCopyInto(out)
        return out</span>
}
</pre>
		
		<pre class="file" id="file178" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha4

import (
        infrav1exp "sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1"
        utilconversion "sigs.k8s.io/cluster-api/util/conversion"
        "sigs.k8s.io/controller-runtime/pkg/conversion"
)

// ConvertTo converts this AzureMachinePool to the Hub version (v1beta1).
func (src *AzureMachinePool) ConvertTo(dstRaw conversion.Hub) error <span class="cov8" title="1">{
        dst := dstRaw.(*infrav1exp.AzureMachinePool)
        if err := Convert_v1alpha4_AzureMachinePool_To_v1beta1_AzureMachinePool(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Manually restore data.
        <span class="cov8" title="1">restored := &amp;infrav1exp.AzureMachinePool{}
        if ok, err := utilconversion.UnmarshalData(src, restored); err != nil || !ok </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if restored.Spec.Template.Image != nil &amp;&amp; restored.Spec.Template.Image.ComputeGallery != nil </span><span class="cov8" title="1">{
                dst.Spec.Template.Image.ComputeGallery = restored.Spec.Template.Image.ComputeGallery
        }</span>

        <span class="cov8" title="1">if restored.Status.Image != nil &amp;&amp; restored.Status.Image.ComputeGallery != nil </span><span class="cov8" title="1">{
                dst.Status.Image.ComputeGallery = restored.Status.Image.ComputeGallery
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureMachinePool) ConvertFrom(srcRaw conversion.Hub) error <span class="cov8" title="1">{
        src := srcRaw.(*infrav1exp.AzureMachinePool)
        if err := Convert_v1beta1_AzureMachinePool_To_v1alpha4_AzureMachinePool(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Preserve Hub data on down-conversion.
        <span class="cov8" title="1">return utilconversion.MarshalData(src, dst)</span>
}

// ConvertTo converts this AzureMachinePool to the Hub version (v1beta1).
func (src *AzureMachinePoolList) ConvertTo(dstRaw conversion.Hub) error <span class="cov0" title="0">{
        dst := dstRaw.(*infrav1exp.AzureMachinePoolList)
        return Convert_v1alpha4_AzureMachinePoolList_To_v1beta1_AzureMachinePoolList(src, dst, nil)
}</span>

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureMachinePoolList) ConvertFrom(srcRaw conversion.Hub) error <span class="cov0" title="0">{
        src := srcRaw.(*infrav1exp.AzureMachinePoolList)
        return Convert_v1beta1_AzureMachinePoolList_To_v1alpha4_AzureMachinePoolList(src, dst, nil)
}</span>
</pre>
		
		<pre class="file" id="file179" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha4

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/util/intstr"
        infrav1alpha4 "sigs.k8s.io/cluster-api-provider-azure/api/v1alpha4"
        clusterv1alpha4 "sigs.k8s.io/cluster-api/api/v1alpha4"
        "sigs.k8s.io/cluster-api/errors"
)

const (
        // MachinePoolNameLabel indicates the AzureMachinePool name the AzureMachinePoolMachine belongs.
        MachinePoolNameLabel = "azuremachinepool.infrastructure.cluster.x-k8s.io/machine-pool"

        // RollingUpdateAzureMachinePoolDeploymentStrategyType replaces AzureMachinePoolMachines with older models with
        // AzureMachinePoolMachines based on the latest model.
        // i.e. gradually scale down the old AzureMachinePoolMachines and scale up the new ones.
        RollingUpdateAzureMachinePoolDeploymentStrategyType AzureMachinePoolDeploymentStrategyType = "RollingUpdate"

        // OldestDeletePolicyType will delete machines with the oldest creation date first.
        OldestDeletePolicyType AzureMachinePoolDeletePolicyType = "Oldest"
        // NewestDeletePolicyType will delete machines with the newest creation date first.
        NewestDeletePolicyType AzureMachinePoolDeletePolicyType = "Newest"
        // RandomDeletePolicyType will delete machines in random order.
        RandomDeletePolicyType AzureMachinePoolDeletePolicyType = "Random"
)

type (
        // AzureMachinePoolMachineTemplate defines the template for an AzureMachine.
        AzureMachinePoolMachineTemplate struct {
                // VMSize is the size of the Virtual Machine to build.
                // See https://docs.microsoft.com/en-us/rest/api/compute/virtualmachines/createorupdate#virtualmachinesizetypes
                VMSize string `json:"vmSize"`

                // Image is used to provide details of an image to use during VM creation.
                // If image details are omitted the image will default the Azure Marketplace "capi" offer,
                // which is based on Ubuntu.
                // +kubebuilder:validation:nullable
                // +optional
                Image *infrav1alpha4.Image `json:"image,omitempty"`

                // OSDisk contains the operating system disk information for a Virtual Machine
                OSDisk infrav1alpha4.OSDisk `json:"osDisk"`

                // DataDisks specifies the list of data disks to be created for a Virtual Machine
                // +optional
                DataDisks []infrav1alpha4.DataDisk `json:"dataDisks,omitempty"`

                // SSHPublicKey is the SSH public key string base64 encoded to add to a Virtual Machine
                SSHPublicKey string `json:"sshPublicKey"`

                // AcceleratedNetworking enables or disables Azure accelerated networking. If omitted, it will be set based on
                // whether the requested VMSize supports accelerated networking.
                // If AcceleratedNetworking is set to true with a VMSize that does not support it, Azure will return an error.
                // +optional
                AcceleratedNetworking *bool `json:"acceleratedNetworking,omitempty"`

                // TerminateNotificationTimeout enables or disables VMSS scheduled events termination notification with specified timeout
                // allowed values are between 5 and 15 (mins)
                // +optional
                TerminateNotificationTimeout *int `json:"terminateNotificationTimeout,omitempty"`

                // SecurityProfile specifies the Security profile settings for a virtual machine.
                // +optional
                SecurityProfile *infrav1alpha4.SecurityProfile `json:"securityProfile,omitempty"`

                // SpotVMOptions allows the ability to specify the Machine should use a Spot VM
                // +optional
                SpotVMOptions *infrav1alpha4.SpotVMOptions `json:"spotVMOptions,omitempty"`

                // SubnetName selects the Subnet where the VMSS will be placed
                // +optional
                SubnetName string `json:"subnetName,omitempty"`
        }

        // AzureMachinePoolSpec defines the desired state of AzureMachinePool.
        AzureMachinePoolSpec struct {
                // Location is the Azure region location e.g. westus2
                Location string `json:"location"`

                // Template contains the details used to build a replica virtual machine within the Machine Pool
                Template AzureMachinePoolMachineTemplate `json:"template"`

                // AdditionalTags is an optional set of tags to add to an instance, in addition to the ones added by default by the
                // Azure provider. If both the AzureCluster and the AzureMachine specify the same tag name with different values, the
                // AzureMachine's value takes precedence.
                // +optional
                AdditionalTags infrav1alpha4.Tags `json:"additionalTags,omitempty"`

                // ProviderID is the identification ID of the Virtual Machine Scale Set
                // +optional
                ProviderID string `json:"providerID,omitempty"`

                // ProviderIDList are the identification IDs of machine instances provided by the provider.
                // This field must match the provider IDs as seen on the node objects corresponding to a machine pool's machine instances.
                // +optional
                ProviderIDList []string `json:"providerIDList,omitempty"`

                // Identity is the type of identity used for the Virtual Machine Scale Set.
                // The type 'SystemAssigned' is an implicitly created identity.
                // The generated identity will be assigned a Subscription contributor role.
                // The type 'UserAssigned' is a standalone Azure resource provided by the user
                // and assigned to the VM
                // +kubebuilder:default=None
                // +optional
                Identity infrav1alpha4.VMIdentity `json:"identity,omitempty"`

                // UserAssignedIdentities is a list of standalone Azure identities provided by the user
                // The lifecycle of a user-assigned identity is managed separately from the lifecycle of
                // the AzureMachinePool.
                // See https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/how-to-manage-ua-identity-cli
                // +optional
                UserAssignedIdentities []infrav1alpha4.UserAssignedIdentity `json:"userAssignedIdentities,omitempty"`

                // RoleAssignmentName is the name of the role assignment to create for a system assigned identity. It can be any valid GUID.
                // If not specified, a random GUID will be generated.
                // +optional
                RoleAssignmentName string `json:"roleAssignmentName,omitempty"`

                // The deployment strategy to use to replace existing AzureMachinePoolMachines with new ones.
                // +optional
                // +kubebuilder:default={type: "RollingUpdate", rollingUpdate: {maxSurge: 1, maxUnavailable: 0, deletePolicy: Oldest}}
                Strategy AzureMachinePoolDeploymentStrategy `json:"strategy,omitempty"`

                // NodeDrainTimeout is the total amount of time that the controller will spend on draining a node.
                // The default value is 0, meaning that the node can be drained without any time limitations.
                // NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
                // +optional
                NodeDrainTimeout *metav1.Duration `json:"nodeDrainTimeout,omitempty"`
        }

        // AzureMachinePoolDeploymentStrategyType is the type of deployment strategy employed to rollout a new version of
        // the AzureMachinePool.
        AzureMachinePoolDeploymentStrategyType string

        // AzureMachinePoolDeploymentStrategy describes how to replace existing machines with new ones.
        AzureMachinePoolDeploymentStrategy struct {
                // Type of deployment. Currently the only supported strategy is RollingUpdate
                // +optional
                // +kubebuilder:validation:Enum=RollingUpdate
                // +optional
                // +kubebuilder:default=RollingUpdate
                Type AzureMachinePoolDeploymentStrategyType `json:"type,omitempty"`

                // Rolling update config params. Present only if
                // MachineDeploymentStrategyType = RollingUpdate.
                // +optional
                RollingUpdate *MachineRollingUpdateDeployment `json:"rollingUpdate,omitempty"`
        }

        // AzureMachinePoolDeletePolicyType is the type of DeletePolicy employed to select machines to be deleted during an
        // upgrade.
        AzureMachinePoolDeletePolicyType string

        // MachineRollingUpdateDeployment is used to control the desired behavior of rolling update.
        MachineRollingUpdateDeployment struct {
                // The maximum number of machines that can be unavailable during the update.
                // Value can be an absolute number (ex: 5) or a percentage of desired
                // machines (ex: 10%).
                // Absolute number is calculated from percentage by rounding down.
                // This can not be 0 if MaxSurge is 0.
                // Defaults to 0.
                // Example: when this is set to 30%, the old MachineSet can be scaled
                // down to 70% of desired machines immediately when the rolling update
                // starts. Once new machines are ready, old MachineSet can be scaled
                // down further, followed by scaling up the new MachineSet, ensuring
                // that the total number of machines available at all times
                // during the update is at least 70% of desired machines.
                // +optional
                // +kubebuilder:default:=0
                MaxUnavailable *intstr.IntOrString `json:"maxUnavailable,omitempty"`

                // The maximum number of machines that can be scheduled above the
                // desired number of machines.
                // Value can be an absolute number (ex: 5) or a percentage of
                // desired machines (ex: 10%).
                // This can not be 0 if MaxUnavailable is 0.
                // Absolute number is calculated from percentage by rounding up.
                // Defaults to 1.
                // Example: when this is set to 30%, the new MachineSet can be scaled
                // up immediately when the rolling update starts, such that the total
                // number of old and new machines do not exceed 130% of desired
                // machines. Once old machines have been killed, new MachineSet can
                // be scaled up further, ensuring that total number of machines running
                // at any time during the update is at most 130% of desired machines.
                // +optional
                // +kubebuilder:default:=1
                MaxSurge *intstr.IntOrString `json:"maxSurge,omitempty"`

                // DeletePolicy defines the policy used by the MachineDeployment to identify nodes to delete when downscaling.
                // Valid values are "Random, "Newest", "Oldest"
                // When no value is supplied, the default is Oldest
                // +optional
                // +kubebuilder:validation:Enum=Random;Newest;Oldest
                // +kubebuilder:default:=Oldest
                DeletePolicy AzureMachinePoolDeletePolicyType `json:"deletePolicy,omitempty"`
        }

        // AzureMachinePoolStatus defines the observed state of AzureMachinePool.
        AzureMachinePoolStatus struct {
                // Ready is true when the provider resource is ready.
                // +optional
                Ready bool `json:"ready"`

                // Replicas is the most recently observed number of replicas.
                // +optional
                Replicas int32 `json:"replicas"`

                // Instances is the VM instance status for each VM in the VMSS
                // +optional
                Instances []*AzureMachinePoolInstanceStatus `json:"instances,omitempty"`

                // Image is the current image used in the AzureMachinePool. When the spec image is nil, this image is populated
                // with the details of the defaulted Azure Marketplace "capi" offer.
                // +optional
                Image *infrav1alpha4.Image `json:"image,omitempty"`

                // Version is the Kubernetes version for the current VMSS model
                // +optional
                Version string `json:"version"`

                // ProvisioningState is the provisioning state of the Azure virtual machine.
                // +optional
                ProvisioningState *infrav1alpha4.ProvisioningState `json:"provisioningState,omitempty"`

                // FailureReason will be set in the event that there is a terminal problem
                // reconciling the MachinePool and will contain a succinct value suitable
                // for machine interpretation.
                //
                // This field should not be set for transitive errors that a controller
                // faces that are expected to be fixed automatically over
                // time (like service outages), but instead indicate that something is
                // fundamentally wrong with the MachinePool's spec or the configuration of
                // the controller, and that manual intervention is required. Examples
                // of terminal errors would be invalid combinations of settings in the
                // spec, values that are unsupported by the controller, or the
                // responsible controller itself being critically misconfigured.
                //
                // Any transient errors that occur during the reconciliation of MachinePools
                // can be added as events to the MachinePool object and/or logged in the
                // controller's output.
                // +optional
                FailureReason *errors.MachineStatusError `json:"failureReason,omitempty"`

                // FailureMessage will be set in the event that there is a terminal problem
                // reconciling the MachinePool and will contain a more verbose string suitable
                // for logging and human consumption.
                //
                // This field should not be set for transitive errors that a controller
                // faces that are expected to be fixed automatically over
                // time (like service outages), but instead indicate that something is
                // fundamentally wrong with the MachinePool's spec or the configuration of
                // the controller, and that manual intervention is required. Examples
                // of terminal errors would be invalid combinations of settings in the
                // spec, values that are unsupported by the controller, or the
                // responsible controller itself being critically misconfigured.
                //
                // Any transient errors that occur during the reconciliation of MachinePools
                // can be added as events to the MachinePool object and/or logged in the
                // controller's output.
                // +optional
                FailureMessage *string `json:"failureMessage,omitempty"`

                // Conditions defines current service state of the AzureMachinePool.
                // +optional
                Conditions clusterv1alpha4.Conditions `json:"conditions,omitempty"`

                // LongRunningOperationStates saves the state for Azure long-running operations so they can be continued on the
                // next reconciliation loop.
                // +optional
                LongRunningOperationStates infrav1alpha4.Futures `json:"longRunningOperationStates,omitempty"`
        }

        // AzureMachinePoolInstanceStatus provides status information for each instance in the VMSS.
        AzureMachinePoolInstanceStatus struct {
                // Version defines the Kubernetes version for the VM Instance
                // +optional
                Version string `json:"version"`

                // ProvisioningState is the provisioning state of the Azure virtual machine instance.
                // +optional
                ProvisioningState *infrav1alpha4.ProvisioningState `json:"provisioningState"`

                // ProviderID is the provider identification of the VMSS Instance
                // +optional
                ProviderID string `json:"providerID"`

                // InstanceID is the identification of the Machine Instance within the VMSS
                // +optional
                InstanceID string `json:"instanceID"`

                // InstanceName is the name of the Machine Instance within the VMSS
                // +optional
                InstanceName string `json:"instanceName"`

                // LatestModelApplied indicates the instance is running the most up-to-date VMSS model. A VMSS model describes
                // the image version the VM is running. If the instance is not running the latest model, it means the instance
                // may not be running the version of Kubernetes the Machine Pool has specified and needs to be updated.
                LatestModelApplied bool `json:"latestModelApplied"`
        }

        // +kubebuilder:object:root=true
        // +kubebuilder:subresource:status
        // +kubebuilder:resource:path=azuremachinepools,scope=Namespaced,categories=cluster-api,shortName=amp
        // +kubebuilder:printcolumn:name="Replicas",type="string",JSONPath=".status.replicas",description="AzureMachinePool replicas count"
        // +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.ready",description="AzureMachinePool replicas count"
        // +kubebuilder:printcolumn:name="State",type="string",JSONPath=".status.provisioningState",description="Azure VMSS provisioning state"
        // +kubebuilder:printcolumn:name="Cluster",type="string",priority=1,JSONPath=".metadata.labels.cluster\\.x-k8s\\.io/cluster-name",description="Cluster to which this AzureMachinePool belongs"
        // +kubebuilder:printcolumn:name="MachinePool",type="string",priority=1,JSONPath=".metadata.ownerReferences[?(@.kind==\"MachinePool\")].name",description="MachinePool object to which this AzureMachinePool belongs"
        // +kubebuilder:printcolumn:name="VMSS ID",type="string",priority=1,JSONPath=".spec.providerID",description="Azure VMSS ID"
        // +kubebuilder:printcolumn:name="VM Size",type="string",priority=1,JSONPath=".spec.template.vmSize",description="Azure VM Size"

        // AzureMachinePool is the Schema for the azuremachinepools API.
        AzureMachinePool struct {
                metav1.TypeMeta   `json:",inline"`
                metav1.ObjectMeta `json:"metadata,omitempty"`

                Spec   AzureMachinePoolSpec   `json:"spec,omitempty"`
                Status AzureMachinePoolStatus `json:"status,omitempty"`
        }

        // +kubebuilder:object:root=true

        // AzureMachinePoolList contains a list of AzureMachinePools.
        AzureMachinePoolList struct {
                metav1.TypeMeta `json:",inline"`
                metav1.ListMeta `json:"metadata,omitempty"`
                Items           []AzureMachinePool `json:"items"`
        }
)

// GetConditions returns the list of conditions for an AzureMachinePool API object.
func (amp *AzureMachinePool) GetConditions() clusterv1alpha4.Conditions <span class="cov0" title="0">{
        return amp.Status.Conditions
}</span>

// SetConditions will set the given conditions on an AzureMachinePool object.
func (amp *AzureMachinePool) SetConditions(conditions clusterv1alpha4.Conditions) <span class="cov0" title="0">{
        amp.Status.Conditions = conditions
}</span>

// GetFutures returns the list of long running operation states for an AzureMachinePool API object.
func (amp *AzureMachinePool) GetFutures() infrav1alpha4.Futures <span class="cov0" title="0">{
        return amp.Status.LongRunningOperationStates
}</span>

// SetFutures will set the given long running operation states on an AzureMachinePool object.
func (amp *AzureMachinePool) SetFutures(futures infrav1alpha4.Futures) <span class="cov0" title="0">{
        amp.Status.LongRunningOperationStates = futures
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;AzureMachinePool{}, &amp;AzureMachinePoolList{})
}</span>
</pre>
		
		<pre class="file" id="file180" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha4

import (
        infrav1exp "sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1"
        "sigs.k8s.io/controller-runtime/pkg/conversion"
)

// ConvertTo converts this AzureMachinePoolMachine to the Hub version (v1beta1).
func (src *AzureMachinePoolMachine) ConvertTo(dstRaw conversion.Hub) error <span class="cov8" title="1">{
        dst := dstRaw.(*infrav1exp.AzureMachinePoolMachine)
        return Convert_v1alpha4_AzureMachinePoolMachine_To_v1beta1_AzureMachinePoolMachine(src, dst, nil)
}</span>

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureMachinePoolMachine) ConvertFrom(srcRaw conversion.Hub) error <span class="cov8" title="1">{
        src := srcRaw.(*infrav1exp.AzureMachinePoolMachine)
        return Convert_v1beta1_AzureMachinePoolMachine_To_v1alpha4_AzureMachinePoolMachine(src, dst, nil)
}</span>

// ConvertTo converts this AzureMachinePoolMachineList to the Hub version (v1beta1).
func (src *AzureMachinePoolMachineList) ConvertTo(dstRaw conversion.Hub) error <span class="cov0" title="0">{
        dst := dstRaw.(*infrav1exp.AzureMachinePoolMachineList)
        return Convert_v1alpha4_AzureMachinePoolMachineList_To_v1beta1_AzureMachinePoolMachineList(src, dst, nil)
}</span>

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureMachinePoolMachineList) ConvertFrom(srcRaw conversion.Hub) error <span class="cov0" title="0">{
        src := srcRaw.(*infrav1exp.AzureMachinePoolMachineList)
        return Convert_v1beta1_AzureMachinePoolMachineList_To_v1alpha4_AzureMachinePoolMachineList(src, dst, nil)
}</span>
</pre>
		
		<pre class="file" id="file181" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha4

import (
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        infrav1alpha4 "sigs.k8s.io/cluster-api-provider-azure/api/v1alpha4"
        clusterv1alpha4 "sigs.k8s.io/cluster-api/api/v1alpha4"
        "sigs.k8s.io/cluster-api/errors"
)

const (
        // AzureMachinePoolMachineFinalizer is used to ensure deletion of dependencies (nodes, infra).
        AzureMachinePoolMachineFinalizer = "azuremachinepoolmachine.infrastructure.cluster.x-k8s.io"
)

type (

        // AzureMachinePoolMachineSpec defines the desired state of AzureMachinePoolMachine.
        AzureMachinePoolMachineSpec struct {
                // ProviderID is the identification ID of the Virtual Machine Scale Set
                ProviderID string `json:"providerID"`

                // InstanceID is the identification of the Machine Instance within the VMSS
                InstanceID string `json:"instanceID"`
        }

        // AzureMachinePoolMachineStatus defines the observed state of AzureMachinePoolMachine.
        AzureMachinePoolMachineStatus struct {
                // NodeRef will point to the corresponding Node if it exists.
                // +optional
                NodeRef *corev1.ObjectReference `json:"nodeRef,omitempty"`

                // Version defines the Kubernetes version for the VM Instance
                // +optional
                Version string `json:"version"`

                // ProvisioningState is the provisioning state of the Azure virtual machine instance.
                // +optional
                ProvisioningState *infrav1alpha4.ProvisioningState `json:"provisioningState"`

                // InstanceName is the name of the Machine Instance within the VMSS
                // +optional
                InstanceName string `json:"instanceName"`

                // FailureReason will be set in the event that there is a terminal problem
                // reconciling the MachinePool machine and will contain a succinct value suitable
                // for machine interpretation.
                //
                // Any transient errors that occur during the reconciliation of MachinePools
                // can be added as events to the MachinePool object and/or logged in the
                // controller's output.
                // +optional
                FailureReason *errors.MachineStatusError `json:"failureReason,omitempty"`

                // FailureMessage will be set in the event that there is a terminal problem
                // reconciling the MachinePool and will contain a more verbose string suitable
                // for logging and human consumption.
                //
                // Any transient errors that occur during the reconciliation of MachinePools
                // can be added as events to the MachinePool object and/or logged in the
                // controller's output.
                // +optional
                FailureMessage *string `json:"failureMessage,omitempty"`

                // Conditions defines current service state of the AzureMachinePool.
                // +optional
                Conditions clusterv1alpha4.Conditions `json:"conditions,omitempty"`

                // LongRunningOperationStates saves the state for Azure long running operations so they can be continued on the
                // next reconciliation loop.
                // +optional
                LongRunningOperationStates infrav1alpha4.Futures `json:"longRunningOperationStates,omitempty"`

                // LatestModelApplied indicates the instance is running the most up-to-date VMSS model. A VMSS model describes
                // the image version the VM is running. If the instance is not running the latest model, it means the instance
                // may not be running the version of Kubernetes the Machine Pool has specified and needs to be updated.
                LatestModelApplied bool `json:"latestModelApplied"`

                // Ready is true when the provider resource is ready.
                // +optional
                Ready bool `json:"ready"`
        }

        // +kubebuilder:object:root=true
        // +kubebuilder:subresource:status
        // +kubebuilder:resource:path=azuremachinepoolmachines,scope=Namespaced,categories=cluster-api,shortName=ampm
        // +kubebuilder:printcolumn:name="Version",type="string",JSONPath=".status.version",description="Kubernetes version"
        // +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.ready",description="Flag indicating infrastructure is successfully provisioned"
        // +kubebuilder:printcolumn:name="State",type="string",JSONPath=".status.provisioningState",description="Azure VMSS VM provisioning state"
        // +kubebuilder:printcolumn:name="Cluster",type="string",priority=1,JSONPath=".metadata.labels.cluster\\.x-k8s\\.io/cluster-name",description="Cluster to which this AzureMachinePoolMachine belongs"
        // +kubebuilder:printcolumn:name="VMSS VM ID",type="string",priority=1,JSONPath=".spec.providerID",description="Azure VMSS VM ID"

        // AzureMachinePoolMachine is the Schema for the azuremachinepoolmachines API.
        AzureMachinePoolMachine struct {
                metav1.TypeMeta   `json:",inline"`
                metav1.ObjectMeta `json:"metadata,omitempty"`

                Spec   AzureMachinePoolMachineSpec   `json:"spec,omitempty"`
                Status AzureMachinePoolMachineStatus `json:"status,omitempty"`
        }

        // +kubebuilder:object:root=true

        // AzureMachinePoolMachineList contains a list of AzureMachinePoolMachines.
        AzureMachinePoolMachineList struct {
                metav1.TypeMeta `json:",inline"`
                metav1.ListMeta `json:"metadata,omitempty"`
                Items           []AzureMachinePoolMachine `json:"items"`
        }
)

// GetConditions returns the list of conditions for an AzureMachinePool API object.
func (ampm *AzureMachinePoolMachine) GetConditions() clusterv1alpha4.Conditions <span class="cov0" title="0">{
        return ampm.Status.Conditions
}</span>

// SetConditions will set the given conditions on an AzureMachinePool object.
func (ampm *AzureMachinePoolMachine) SetConditions(conditions clusterv1alpha4.Conditions) <span class="cov0" title="0">{
        ampm.Status.Conditions = conditions
}</span>

// GetFutures returns the list of long running operation states for an AzureMachinePoolMachine API object.
func (ampm *AzureMachinePoolMachine) GetFutures() infrav1alpha4.Futures <span class="cov0" title="0">{
        return ampm.Status.LongRunningOperationStates
}</span>

// SetFutures will set the given long running operation states on an AzureMachinePoolMachine object.
func (ampm *AzureMachinePoolMachine) SetFutures(futures infrav1alpha4.Futures) <span class="cov0" title="0">{
        ampm.Status.LongRunningOperationStates = futures
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;AzureMachinePoolMachine{}, &amp;AzureMachinePoolMachineList{})
}</span>
</pre>
		
		<pre class="file" id="file182" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha4

import (
        infrav1exp "sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1"
        "sigs.k8s.io/controller-runtime/pkg/conversion"
)

// ConvertTo converts this AzureManagedCluster to the Hub version (v1beta1).
func (src *AzureManagedCluster) ConvertTo(dstRaw conversion.Hub) error <span class="cov8" title="1">{
        dst := dstRaw.(*infrav1exp.AzureManagedCluster)
        return Convert_v1alpha4_AzureManagedCluster_To_v1beta1_AzureManagedCluster(src, dst, nil)
}</span>

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureManagedCluster) ConvertFrom(srcRaw conversion.Hub) error <span class="cov8" title="1">{
        src := srcRaw.(*infrav1exp.AzureManagedCluster)
        return Convert_v1beta1_AzureManagedCluster_To_v1alpha4_AzureManagedCluster(src, dst, nil)
}</span>

// ConvertTo converts this AzureManagedClusterList to the Hub version (v1beta1).
func (src *AzureManagedClusterList) ConvertTo(dstRaw conversion.Hub) error <span class="cov0" title="0">{
        dst := dstRaw.(*infrav1exp.AzureManagedClusterList)
        return Convert_v1alpha4_AzureManagedClusterList_To_v1beta1_AzureManagedClusterList(src, dst, nil)
}</span>

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureManagedClusterList) ConvertFrom(srcRaw conversion.Hub) error <span class="cov0" title="0">{
        src := srcRaw.(*infrav1exp.AzureManagedClusterList)
        return Convert_v1beta1_AzureManagedClusterList_To_v1alpha4_AzureManagedClusterList(src, dst, nil)
}</span>
</pre>
		
		<pre class="file" id="file183" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha4

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1alpha4 "sigs.k8s.io/cluster-api/api/v1alpha4"
)

// AzureManagedClusterSpec defines the desired state of AzureManagedCluster.
type AzureManagedClusterSpec struct {
        // ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
        // +optional
        ControlPlaneEndpoint clusterv1alpha4.APIEndpoint `json:"controlPlaneEndpoint"`
}

// AzureManagedClusterStatus defines the observed state of AzureManagedCluster.
type AzureManagedClusterStatus struct {
        // Ready is true when the provider resource is ready.
        // +optional
        Ready bool `json:"ready,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:path=azuremanagedclusters,scope=Namespaced,categories=cluster-api,shortName=amc
// +kubebuilder:subresource:status

// AzureManagedCluster is the Schema for the azuremanagedclusters API.
type AzureManagedCluster struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   AzureManagedClusterSpec   `json:"spec,omitempty"`
        Status AzureManagedClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AzureManagedClusterList contains a list of AzureManagedClusters.
type AzureManagedClusterList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []AzureManagedCluster `json:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;AzureManagedCluster{}, &amp;AzureManagedClusterList{})
}</span>
</pre>
		
		<pre class="file" id="file184" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha4

import (
        apiconversion "k8s.io/apimachinery/pkg/conversion"
        infrav1exp "sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1"
        utilconversion "sigs.k8s.io/cluster-api/util/conversion"
        "sigs.k8s.io/controller-runtime/pkg/conversion"
)

// ConvertTo converts this AzureManagedControlPlane to the Hub version (v1beta1).
func (src *AzureManagedControlPlane) ConvertTo(dstRaw conversion.Hub) error <span class="cov8" title="1">{
        dst := dstRaw.(*infrav1exp.AzureManagedControlPlane)
        if err := Convert_v1alpha4_AzureManagedControlPlane_To_v1beta1_AzureManagedControlPlane(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Manually restore data.
        <span class="cov8" title="1">restored := &amp;infrav1exp.AzureManagedControlPlane{}
        if ok, err := utilconversion.UnmarshalData(src, restored); err != nil || !ok </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">dst.Spec.AddonProfiles = restored.Spec.AddonProfiles
        dst.Status.Conditions = restored.Status.Conditions

        return nil</span>
}

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureManagedControlPlane) ConvertFrom(srcRaw conversion.Hub) error <span class="cov8" title="1">{
        src := srcRaw.(*infrav1exp.AzureManagedControlPlane)
        if err := Convert_v1beta1_AzureManagedControlPlane_To_v1alpha4_AzureManagedControlPlane(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Preserve Hub data on down-conversion.
        <span class="cov8" title="1">return utilconversion.MarshalData(src, dst)</span>
}

// Convert_v1beta1_AzureManagedControlPlaneSpec_To_v1alpha4_AzureManagedControlPlaneSpec is an autogenerated conversion function.
func Convert_v1beta1_AzureManagedControlPlaneSpec_To_v1alpha4_AzureManagedControlPlaneSpec(in *infrav1exp.AzureManagedControlPlaneSpec, out *AzureManagedControlPlaneSpec, s apiconversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureManagedControlPlaneSpec_To_v1alpha4_AzureManagedControlPlaneSpec(in, out, s)
}</span>

// Convert_v1beta1_AzureManagedControlPlaneStatus_To_v1alpha4_AzureManagedControlPlaneStatus is an autogenerated conversion function.
func Convert_v1beta1_AzureManagedControlPlaneStatus_To_v1alpha4_AzureManagedControlPlaneStatus(in *infrav1exp.AzureManagedControlPlaneStatus, out *AzureManagedControlPlaneStatus, s apiconversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureManagedControlPlaneStatus_To_v1alpha4_AzureManagedControlPlaneStatus(in, out, s)
}</span>

// ConvertTo converts this AzureManagedControlPlaneList to the Hub version (v1beta1).
func (src *AzureManagedControlPlaneList) ConvertTo(dstRaw conversion.Hub) error <span class="cov0" title="0">{
        dst := dstRaw.(*infrav1exp.AzureManagedControlPlaneList)
        return Convert_v1alpha4_AzureManagedControlPlaneList_To_v1beta1_AzureManagedControlPlaneList(src, dst, nil)
}</span>

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureManagedControlPlaneList) ConvertFrom(srcRaw conversion.Hub) error <span class="cov0" title="0">{
        src := srcRaw.(*infrav1exp.AzureManagedControlPlaneList)
        return Convert_v1beta1_AzureManagedControlPlaneList_To_v1alpha4_AzureManagedControlPlaneList(src, dst, nil)
}</span>
</pre>
		
		<pre class="file" id="file185" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha4

import (
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        infrav1alpha4 "sigs.k8s.io/cluster-api-provider-azure/api/v1alpha4"
        clusterv1alpha4 "sigs.k8s.io/cluster-api/api/v1alpha4"
)

const (
        // PrivateDNSZoneModeSystem represents mode System for azuremanagedcontrolplane.
        PrivateDNSZoneModeSystem string = "System"

        // PrivateDNSZoneModeNone represents mode None for azuremanagedcontrolplane.
        PrivateDNSZoneModeNone string = "None"
)

// AzureManagedControlPlaneSpec defines the desired state of AzureManagedControlPlane.
type AzureManagedControlPlaneSpec struct {
        // Version defines the desired Kubernetes version.
        // +kubebuilder:validation:MinLength:=2
        Version string `json:"version"`

        // ResourceGroupName is the name of the Azure resource group for this AKS Cluster.
        ResourceGroupName string `json:"resourceGroupName"`

        // NodeResourceGroupName is the name of the resource group
        // containing cluster IaaS resources. Will be populated to default
        // in webhook.
        // +optional
        NodeResourceGroupName string `json:"nodeResourceGroupName,omitempty"`

        // VirtualNetwork describes the vnet for the AKS cluster. Will be created if it does not exist.
        VirtualNetwork ManagedControlPlaneVirtualNetwork `json:"virtualNetwork,omitempty"`

        // SubscriptionID is the GUID of the Azure subscription to hold this cluster.
        SubscriptionID string `json:"subscriptionID,omitempty"`

        // Location is a string matching one of the canonical Azure region names. Examples: "westus2", "eastus".
        Location string `json:"location"`

        // ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
        // +optional
        ControlPlaneEndpoint clusterv1alpha4.APIEndpoint `json:"controlPlaneEndpoint"`

        // AdditionalTags is an optional set of tags to add to Azure resources managed by the Azure provider, in addition to the
        // ones added by default.
        // +optional
        AdditionalTags infrav1alpha4.Tags `json:"additionalTags,omitempty"`

        // NetworkPlugin used for building Kubernetes network.
        // +kubebuilder:validation:Enum=azure;kubenet
        // +optional
        NetworkPlugin *string `json:"networkPlugin,omitempty"`

        // NetworkPolicy used for building Kubernetes network.
        // +kubebuilder:validation:Enum=azure;calico
        // +optional
        NetworkPolicy *string `json:"networkPolicy,omitempty"`

        // SSHPublicKey is a string literal containing an ssh public key base64 encoded.
        SSHPublicKey string `json:"sshPublicKey"`

        // DNSServiceIP is an IP address assigned to the Kubernetes DNS service.
        // It must be within the Kubernetes service address range specified in serviceCidr.
        // +optional
        DNSServiceIP *string `json:"dnsServiceIP,omitempty"`

        // LoadBalancerSKU is the SKU of the loadBalancer to be provisioned.
        // +kubebuilder:validation:Enum=Basic;Standard
        // +optional
        LoadBalancerSKU *string `json:"loadBalancerSKU,omitempty"`

        // IdentityRef is a reference to a AzureClusterIdentity to be used when reconciling this cluster
        // +optional
        IdentityRef *corev1.ObjectReference `json:"identityRef,omitempty"`

        // AadProfile is Azure Active Directory configuration to integrate with AKS for aad authentication.
        // +optional
        AADProfile *AADProfile `json:"aadProfile,omitempty"`

        // SKU is the SKU of the AKS to be provisioned.
        // +optional
        SKU *SKU `json:"sku,omitempty"`

        // LoadBalancerProfile is the profile of the cluster load balancer.
        // +optional
        LoadBalancerProfile *LoadBalancerProfile `json:"loadBalancerProfile,omitempty"`

        // APIServerAccessProfile is the access profile for AKS API server.
        // +optional
        APIServerAccessProfile *APIServerAccessProfile `json:"apiServerAccessProfile,omitempty"`
}

// AADProfile - AAD integration managed by AKS.
type AADProfile struct {
        // Managed - Whether to enable managed AAD.
        // +kubebuilder:validation:Required
        Managed bool `json:"managed"`

        // AdminGroupObjectIDs - AAD group object IDs that will have admin role of the cluster.
        // +kubebuilder:validation:Required
        AdminGroupObjectIDs []string `json:"adminGroupObjectIDs"`
}

// SKU - AKS SKU.
type SKU struct {
        // Tier - Tier of a managed cluster SKU.
        // +kubebuilder:validation:Enum=Free;Paid
        Tier string `json:"tier"`
}

// LoadBalancerProfile - Profile of the cluster load balancer.
type LoadBalancerProfile struct {
        // Load balancer profile must specify at most one of ManagedOutboundIPs, OutboundIPPrefixes and OutboundIPs.
        // By default the AKS cluster automatically creates a public IP in the AKS-managed infrastructure resource group and assigns it to the load balancer outbound pool.
        // Alternatively, you can assign your own custom public IP or public IP prefix at cluster creation time.
        // See https://docs.microsoft.com/en-us/azure/aks/load-balancer-standard#provide-your-own-outbound-public-ips-or-prefixes

        // ManagedOutboundIPs - Desired managed outbound IPs for the cluster load balancer.
        // +optional
        ManagedOutboundIPs *int32 `json:"managedOutboundIPs,omitempty"`

        // OutboundIPPrefixes - Desired outbound IP Prefix resources for the cluster load balancer.
        // +optional
        OutboundIPPrefixes []string `json:"outboundIPPrefixes,omitempty"`

        // OutboundIPs - Desired outbound IP resources for the cluster load balancer.
        // +optional
        OutboundIPs []string `json:"outboundIPs,omitempty"`

        // AllocatedOutboundPorts - Desired number of allocated SNAT ports per VM. Allowed values must be in the range of 0 to 64000 (inclusive). The default value is 0 which results in Azure dynamically allocating ports.
        // +optional
        AllocatedOutboundPorts *int32 `json:"allocatedOutboundPorts,omitempty"`

        // IdleTimeoutInMinutes - Desired outbound flow idle timeout in minutes. Allowed values must be in the range of 4 to 120 (inclusive). The default value is 30 minutes.
        // +optional
        IdleTimeoutInMinutes *int32 `json:"idleTimeoutInMinutes,omitempty"`
}

// APIServerAccessProfile - access profile for AKS API server.
type APIServerAccessProfile struct {
        // AuthorizedIPRanges - Authorized IP Ranges to kubernetes API server.
        // +optional
        AuthorizedIPRanges []string `json:"authorizedIPRanges,omitempty"`
        // EnablePrivateCluster - Whether to create the cluster as a private cluster or not.
        // +optional
        EnablePrivateCluster *bool `json:"enablePrivateCluster,omitempty"`
        // PrivateDNSZone - Private dns zone mode for private cluster.
        // +kubebuilder:validation:Enum=System;None
        // +optional
        PrivateDNSZone *string `json:"privateDNSZone,omitempty"`
        // EnablePrivateClusterPublicFQDN - Whether to create additional public FQDN for private cluster or not.
        // +optional
        EnablePrivateClusterPublicFQDN *bool `json:"enablePrivateClusterPublicFQDN,omitempty"`
}

// ManagedControlPlaneVirtualNetwork describes a virtual network required to provision AKS clusters.
type ManagedControlPlaneVirtualNetwork struct {
        Name      string                    `json:"name"`
        CIDRBlock string                    `json:"cidrBlock"`
        Subnet    ManagedControlPlaneSubnet `json:"subnet,omitempty"`
}

// ManagedControlPlaneSubnet describes a subnet for an AKS cluster.
type ManagedControlPlaneSubnet struct {
        Name      string `json:"name"`
        CIDRBlock string `json:"cidrBlock"`
}

// AzureManagedControlPlaneStatus defines the observed state of AzureManagedControlPlane.
type AzureManagedControlPlaneStatus struct {
        // Ready is true when the provider resource is ready.
        // +optional
        Ready bool `json:"ready,omitempty"`

        // Initialized is true when the the control plane is available for initial contact.
        // This may occur before the control plane is fully ready.
        // In the AzureManagedControlPlane implementation, these are identical.
        // +optional
        Initialized bool `json:"initialized,omitempty"`

        // LongRunningOperationStates saves the states for Azure long-running operations so they can be continued on the
        // next reconciliation loop.
        // +optional
        LongRunningOperationStates infrav1alpha4.Futures `json:"longRunningOperationStates,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:path=azuremanagedcontrolplanes,scope=Namespaced,categories=cluster-api,shortName=amcp
// +kubebuilder:subresource:status

// AzureManagedControlPlane is the Schema for the azuremanagedcontrolplanes API.
type AzureManagedControlPlane struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   AzureManagedControlPlaneSpec   `json:"spec,omitempty"`
        Status AzureManagedControlPlaneStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AzureManagedControlPlaneList contains a list of AzureManagedControlPlane.
type AzureManagedControlPlaneList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []AzureManagedControlPlane `json:"items"`
}

// GetFutures returns the list of long running operation states for an AzureManagedControlPlane API object.
func (m *AzureManagedControlPlane) GetFutures() infrav1alpha4.Futures <span class="cov0" title="0">{
        return m.Status.LongRunningOperationStates
}</span>

// SetFutures will set the given long running operation states on an AzureManagedControlPlane object.
func (m *AzureManagedControlPlane) SetFutures(futures infrav1alpha4.Futures) <span class="cov0" title="0">{
        m.Status.LongRunningOperationStates = futures
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;AzureManagedControlPlane{}, &amp;AzureManagedControlPlaneList{})
}</span>
</pre>
		
		<pre class="file" id="file186" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha4

import (
        apiconversion "k8s.io/apimachinery/pkg/conversion"
        infrav1exp "sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1"
        utilconversion "sigs.k8s.io/cluster-api/util/conversion"
        "sigs.k8s.io/controller-runtime/pkg/conversion"
)

// ConvertTo converts this AzureManagedMachinePool to the Hub version (v1beta1).
func (src *AzureManagedMachinePool) ConvertTo(dstRaw conversion.Hub) error <span class="cov8" title="1">{
        dst := dstRaw.(*infrav1exp.AzureManagedMachinePool)
        if err := Convert_v1alpha4_AzureManagedMachinePool_To_v1beta1_AzureManagedMachinePool(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Manually restore data.
        <span class="cov8" title="1">restored := &amp;infrav1exp.AzureManagedMachinePool{}
        if ok, err := utilconversion.UnmarshalData(src, restored); err != nil || !ok </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">dst.Spec.Scaling = restored.Spec.Scaling
        dst.Spec.Name = restored.Spec.Name
        dst.Spec.Taints = restored.Spec.Taints
        dst.Spec.AvailabilityZones = restored.Spec.AvailabilityZones
        dst.Spec.MaxPods = restored.Spec.MaxPods
        dst.Spec.OsDiskType = restored.Spec.OsDiskType
        dst.Spec.OSType = restored.Spec.OSType
        dst.Spec.NodeLabels = restored.Spec.NodeLabels
        dst.Spec.EnableUltraSSD = restored.Spec.EnableUltraSSD
        dst.Spec.EnableNodePublicIP = restored.Spec.EnableNodePublicIP

        dst.Status.LongRunningOperationStates = restored.Status.LongRunningOperationStates
        dst.Status.Conditions = restored.Status.Conditions

        return nil</span>
}

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureManagedMachinePool) ConvertFrom(srcRaw conversion.Hub) error <span class="cov8" title="1">{
        src := srcRaw.(*infrav1exp.AzureManagedMachinePool)
        if err := Convert_v1beta1_AzureManagedMachinePool_To_v1alpha4_AzureManagedMachinePool(src, dst, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Preserve Hub data on down-conversion.
        <span class="cov8" title="1">return utilconversion.MarshalData(src, dst)</span>
}

// Convert_v1beta1_AzureManagedMachinePoolSpec_To_v1alpha4_AzureManagedMachinePoolSpec is an autogenerated conversion function.
func Convert_v1beta1_AzureManagedMachinePoolSpec_To_v1alpha4_AzureManagedMachinePoolSpec(in *infrav1exp.AzureManagedMachinePoolSpec, out *AzureManagedMachinePoolSpec, s apiconversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureManagedMachinePoolSpec_To_v1alpha4_AzureManagedMachinePoolSpec(in, out, s)
}</span>

// Convert_v1beta1_AzureManagedMachinePoolStatus_To_v1alpha4_AzureManagedMachinePoolStatus is an autogenerated conversion function.
func Convert_v1beta1_AzureManagedMachinePoolStatus_To_v1alpha4_AzureManagedMachinePoolStatus(in *infrav1exp.AzureManagedMachinePoolStatus, out *AzureManagedMachinePoolStatus, s apiconversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureManagedMachinePoolStatus_To_v1alpha4_AzureManagedMachinePoolStatus(in, out, s)
}</span>

// ConvertTo converts this AzureManagedMachinePoolList to the Hub version (v1beta1).
func (src *AzureManagedMachinePoolList) ConvertTo(dstRaw conversion.Hub) error <span class="cov0" title="0">{
        dst := dstRaw.(*infrav1exp.AzureManagedMachinePoolList)
        return Convert_v1alpha4_AzureManagedMachinePoolList_To_v1beta1_AzureManagedMachinePoolList(src, dst, nil)
}</span>

// ConvertFrom converts from the Hub version (v1beta1) to this version.
func (dst *AzureManagedMachinePoolList) ConvertFrom(srcRaw conversion.Hub) error <span class="cov0" title="0">{
        src := srcRaw.(*infrav1exp.AzureManagedMachinePoolList)
        return Convert_v1beta1_AzureManagedMachinePoolList_To_v1alpha4_AzureManagedMachinePoolList(src, dst, nil)
}</span>
</pre>
		
		<pre class="file" id="file187" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha4

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        capierrors "sigs.k8s.io/cluster-api/errors"
)

const (
        // LabelAgentPoolMode represents mode of an agent pool. Possible values include: System, User.
        LabelAgentPoolMode = "azuremanagedmachinepool.infrastructure.cluster.x-k8s.io/agentpoolmode"

        // NodePoolModeSystem represents mode system for azuremachinepool.
        NodePoolModeSystem NodePoolMode = "System"

        // NodePoolModeUser represents mode user for azuremachinepool.
        NodePoolModeUser NodePoolMode = "User"
)

// NodePoolMode enumerates the values for agent pool mode.
type NodePoolMode string

// AzureManagedMachinePoolSpec defines the desired state of AzureManagedMachinePool.
type AzureManagedMachinePoolSpec struct {

        // Name - name of the agent pool. If not specified, CAPZ uses the name of the CR as the agent pool name.
        // +optional
        Name *string `json:"name,omitempty"`

        // Mode - represents mode of an agent pool. Possible values include: System, User.
        // +kubebuilder:validation:Enum=System;User
        Mode string `json:"mode"`

        // SKU is the size of the VMs in the node pool.
        SKU string `json:"sku"`

        // OSDiskSizeGB is the disk size for every machine in this agent pool.
        // If you specify 0, it will apply the default osDisk size according to the vmSize specified.
        OSDiskSizeGB *int32 `json:"osDiskSizeGB,omitempty"`

        // ProviderIDList is the unique identifier as specified by the cloud provider.
        // +optional
        ProviderIDList []string `json:"providerIDList,omitempty"`
}

// AzureManagedMachinePoolStatus defines the observed state of AzureManagedMachinePool.
type AzureManagedMachinePoolStatus struct {
        // Ready is true when the provider resource is ready.
        // +optional
        Ready bool `json:"ready"`

        // Replicas is the most recently observed number of replicas.
        // +optional
        Replicas int32 `json:"replicas"`

        // Any transient errors that occur during the reconciliation of Machines
        // can be added as events to the Machine object and/or logged in the
        // controller's output.
        // +optional
        ErrorReason *capierrors.MachineStatusError `json:"errorReason,omitempty"`

        // Any transient errors that occur during the reconciliation of Machines
        // can be added as events to the Machine object and/or logged in the
        // controller's output.
        // +optional
        ErrorMessage *string `json:"errorMessage,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:path=azuremanagedmachinepools,scope=Namespaced,categories=cluster-api,shortName=ammp
// +kubebuilder:subresource:status

// AzureManagedMachinePool is the Schema for the azuremanagedmachinepools API.
type AzureManagedMachinePool struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   AzureManagedMachinePoolSpec   `json:"spec,omitempty"`
        Status AzureManagedMachinePoolStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AzureManagedMachinePoolList contains a list of AzureManagedMachinePools.
type AzureManagedMachinePoolList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []AzureManagedMachinePool `json:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;AzureManagedMachinePool{}, &amp;AzureManagedMachinePoolList{})
}</span>
</pre>
		
		<pre class="file" id="file188" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha4

import (
        "k8s.io/apimachinery/pkg/conversion"
        infrav1alpha4 "sigs.k8s.io/cluster-api-provider-azure/api/v1alpha4"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        clusterv1alpha4 "sigs.k8s.io/cluster-api/api/v1alpha4"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
)

// Convert_v1alpha4_OSDisk_To_v1beta1_OSDisk is a conversion function.
func Convert_v1alpha4_OSDisk_To_v1beta1_OSDisk(in *infrav1alpha4.OSDisk, out *infrav1.OSDisk, s conversion.Scope) error <span class="cov8" title="1">{
        return infrav1alpha4.Convert_v1alpha4_OSDisk_To_v1beta1_OSDisk(in, out, s)
}</span>

// Convert_v1beta1_OSDisk_To_v1alpha4_OSDisk is a conversion function.
func Convert_v1beta1_OSDisk_To_v1alpha4_OSDisk(in *infrav1.OSDisk, out *infrav1alpha4.OSDisk, s conversion.Scope) error <span class="cov8" title="1">{
        return infrav1alpha4.Convert_v1beta1_OSDisk_To_v1alpha4_OSDisk(in, out, s)
}</span>

// Convert_v1alpha4_Image_To_v1beta1_Image is a conversion function.
func Convert_v1alpha4_Image_To_v1beta1_Image(in *infrav1alpha4.Image, out *infrav1.Image, s conversion.Scope) error <span class="cov8" title="1">{
        return infrav1alpha4.Convert_v1alpha4_Image_To_v1beta1_Image(in, out, s)
}</span>

// Convert_v1beta1_Image_To_v1alpha4_Image is a conversion function.
func Convert_v1beta1_Image_To_v1alpha4_Image(in *infrav1.Image, out *infrav1alpha4.Image, s conversion.Scope) error <span class="cov8" title="1">{
        return infrav1alpha4.Convert_v1beta1_Image_To_v1alpha4_Image(in, out, s)
}</span>

// Convert_v1alpha4_APIEndpoint_To_v1beta1_APIEndpoint is an autogenerated conversion function.
func Convert_v1alpha4_APIEndpoint_To_v1beta1_APIEndpoint(in *clusterv1alpha4.APIEndpoint, out *clusterv1.APIEndpoint, s conversion.Scope) error <span class="cov8" title="1">{
        return clusterv1alpha4.Convert_v1alpha4_APIEndpoint_To_v1beta1_APIEndpoint(in, out, s)
}</span>

// Convert_v1beta1_APIEndpoint_To_v1alpha4_APIEndpoint is an autogenerated conversion function.
func Convert_v1beta1_APIEndpoint_To_v1alpha4_APIEndpoint(in *clusterv1.APIEndpoint, out *clusterv1alpha4.APIEndpoint, s conversion.Scope) error <span class="cov8" title="1">{
        return clusterv1alpha4.Convert_v1beta1_APIEndpoint_To_v1alpha4_APIEndpoint(in, out, s)
}</span>
</pre>
		
		<pre class="file" id="file189" style="display: none">//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by conversion-gen-v0.23.1. DO NOT EDIT.

package v1alpha4

import (
        unsafe "unsafe"

        v1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        conversion "k8s.io/apimachinery/pkg/conversion"
        runtime "k8s.io/apimachinery/pkg/runtime"
        intstr "k8s.io/apimachinery/pkg/util/intstr"
        clusterapiproviderazureapiv1alpha4 "sigs.k8s.io/cluster-api-provider-azure/api/v1alpha4"
        clusterapiproviderazureapiv1beta1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        v1beta1 "sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1"
        apiv1alpha4 "sigs.k8s.io/cluster-api/api/v1alpha4"
        apiv1beta1 "sigs.k8s.io/cluster-api/api/v1beta1"
        errors "sigs.k8s.io/cluster-api/errors"
)

func init() <span class="cov8" title="1">{
        localSchemeBuilder.Register(RegisterConversions)
}</span>

// RegisterConversions adds conversion functions to the given scheme.
// Public to allow building arbitrary schemes.
func RegisterConversions(s *runtime.Scheme) error <span class="cov0" title="0">{
        if err := s.AddGeneratedConversionFunc((*AADProfile)(nil), (*v1beta1.AADProfile)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AADProfile_To_v1beta1_AADProfile(a.(*AADProfile), b.(*v1beta1.AADProfile), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AADProfile)(nil), (*AADProfile)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AADProfile_To_v1alpha4_AADProfile(a.(*v1beta1.AADProfile), b.(*AADProfile), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*APIServerAccessProfile)(nil), (*v1beta1.APIServerAccessProfile)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_APIServerAccessProfile_To_v1beta1_APIServerAccessProfile(a.(*APIServerAccessProfile), b.(*v1beta1.APIServerAccessProfile), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.APIServerAccessProfile)(nil), (*APIServerAccessProfile)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_APIServerAccessProfile_To_v1alpha4_APIServerAccessProfile(a.(*v1beta1.APIServerAccessProfile), b.(*APIServerAccessProfile), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureMachinePool)(nil), (*v1beta1.AzureMachinePool)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureMachinePool_To_v1beta1_AzureMachinePool(a.(*AzureMachinePool), b.(*v1beta1.AzureMachinePool), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureMachinePool)(nil), (*AzureMachinePool)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachinePool_To_v1alpha4_AzureMachinePool(a.(*v1beta1.AzureMachinePool), b.(*AzureMachinePool), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureMachinePoolDeploymentStrategy)(nil), (*v1beta1.AzureMachinePoolDeploymentStrategy)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureMachinePoolDeploymentStrategy_To_v1beta1_AzureMachinePoolDeploymentStrategy(a.(*AzureMachinePoolDeploymentStrategy), b.(*v1beta1.AzureMachinePoolDeploymentStrategy), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureMachinePoolDeploymentStrategy)(nil), (*AzureMachinePoolDeploymentStrategy)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachinePoolDeploymentStrategy_To_v1alpha4_AzureMachinePoolDeploymentStrategy(a.(*v1beta1.AzureMachinePoolDeploymentStrategy), b.(*AzureMachinePoolDeploymentStrategy), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureMachinePoolInstanceStatus)(nil), (*v1beta1.AzureMachinePoolInstanceStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureMachinePoolInstanceStatus_To_v1beta1_AzureMachinePoolInstanceStatus(a.(*AzureMachinePoolInstanceStatus), b.(*v1beta1.AzureMachinePoolInstanceStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureMachinePoolInstanceStatus)(nil), (*AzureMachinePoolInstanceStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachinePoolInstanceStatus_To_v1alpha4_AzureMachinePoolInstanceStatus(a.(*v1beta1.AzureMachinePoolInstanceStatus), b.(*AzureMachinePoolInstanceStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureMachinePoolList)(nil), (*v1beta1.AzureMachinePoolList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureMachinePoolList_To_v1beta1_AzureMachinePoolList(a.(*AzureMachinePoolList), b.(*v1beta1.AzureMachinePoolList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureMachinePoolList)(nil), (*AzureMachinePoolList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachinePoolList_To_v1alpha4_AzureMachinePoolList(a.(*v1beta1.AzureMachinePoolList), b.(*AzureMachinePoolList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureMachinePoolMachine)(nil), (*v1beta1.AzureMachinePoolMachine)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureMachinePoolMachine_To_v1beta1_AzureMachinePoolMachine(a.(*AzureMachinePoolMachine), b.(*v1beta1.AzureMachinePoolMachine), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureMachinePoolMachine)(nil), (*AzureMachinePoolMachine)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachinePoolMachine_To_v1alpha4_AzureMachinePoolMachine(a.(*v1beta1.AzureMachinePoolMachine), b.(*AzureMachinePoolMachine), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureMachinePoolMachineList)(nil), (*v1beta1.AzureMachinePoolMachineList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureMachinePoolMachineList_To_v1beta1_AzureMachinePoolMachineList(a.(*AzureMachinePoolMachineList), b.(*v1beta1.AzureMachinePoolMachineList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureMachinePoolMachineList)(nil), (*AzureMachinePoolMachineList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachinePoolMachineList_To_v1alpha4_AzureMachinePoolMachineList(a.(*v1beta1.AzureMachinePoolMachineList), b.(*AzureMachinePoolMachineList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureMachinePoolMachineSpec)(nil), (*v1beta1.AzureMachinePoolMachineSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureMachinePoolMachineSpec_To_v1beta1_AzureMachinePoolMachineSpec(a.(*AzureMachinePoolMachineSpec), b.(*v1beta1.AzureMachinePoolMachineSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureMachinePoolMachineSpec)(nil), (*AzureMachinePoolMachineSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachinePoolMachineSpec_To_v1alpha4_AzureMachinePoolMachineSpec(a.(*v1beta1.AzureMachinePoolMachineSpec), b.(*AzureMachinePoolMachineSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureMachinePoolMachineStatus)(nil), (*v1beta1.AzureMachinePoolMachineStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureMachinePoolMachineStatus_To_v1beta1_AzureMachinePoolMachineStatus(a.(*AzureMachinePoolMachineStatus), b.(*v1beta1.AzureMachinePoolMachineStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureMachinePoolMachineStatus)(nil), (*AzureMachinePoolMachineStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachinePoolMachineStatus_To_v1alpha4_AzureMachinePoolMachineStatus(a.(*v1beta1.AzureMachinePoolMachineStatus), b.(*AzureMachinePoolMachineStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureMachinePoolMachineTemplate)(nil), (*v1beta1.AzureMachinePoolMachineTemplate)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureMachinePoolMachineTemplate_To_v1beta1_AzureMachinePoolMachineTemplate(a.(*AzureMachinePoolMachineTemplate), b.(*v1beta1.AzureMachinePoolMachineTemplate), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureMachinePoolMachineTemplate)(nil), (*AzureMachinePoolMachineTemplate)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachinePoolMachineTemplate_To_v1alpha4_AzureMachinePoolMachineTemplate(a.(*v1beta1.AzureMachinePoolMachineTemplate), b.(*AzureMachinePoolMachineTemplate), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureMachinePoolSpec)(nil), (*v1beta1.AzureMachinePoolSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureMachinePoolSpec_To_v1beta1_AzureMachinePoolSpec(a.(*AzureMachinePoolSpec), b.(*v1beta1.AzureMachinePoolSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureMachinePoolSpec)(nil), (*AzureMachinePoolSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachinePoolSpec_To_v1alpha4_AzureMachinePoolSpec(a.(*v1beta1.AzureMachinePoolSpec), b.(*AzureMachinePoolSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureMachinePoolStatus)(nil), (*v1beta1.AzureMachinePoolStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureMachinePoolStatus_To_v1beta1_AzureMachinePoolStatus(a.(*AzureMachinePoolStatus), b.(*v1beta1.AzureMachinePoolStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureMachinePoolStatus)(nil), (*AzureMachinePoolStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureMachinePoolStatus_To_v1alpha4_AzureMachinePoolStatus(a.(*v1beta1.AzureMachinePoolStatus), b.(*AzureMachinePoolStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureManagedCluster)(nil), (*v1beta1.AzureManagedCluster)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureManagedCluster_To_v1beta1_AzureManagedCluster(a.(*AzureManagedCluster), b.(*v1beta1.AzureManagedCluster), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureManagedCluster)(nil), (*AzureManagedCluster)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureManagedCluster_To_v1alpha4_AzureManagedCluster(a.(*v1beta1.AzureManagedCluster), b.(*AzureManagedCluster), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureManagedClusterList)(nil), (*v1beta1.AzureManagedClusterList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureManagedClusterList_To_v1beta1_AzureManagedClusterList(a.(*AzureManagedClusterList), b.(*v1beta1.AzureManagedClusterList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureManagedClusterList)(nil), (*AzureManagedClusterList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureManagedClusterList_To_v1alpha4_AzureManagedClusterList(a.(*v1beta1.AzureManagedClusterList), b.(*AzureManagedClusterList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureManagedClusterSpec)(nil), (*v1beta1.AzureManagedClusterSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureManagedClusterSpec_To_v1beta1_AzureManagedClusterSpec(a.(*AzureManagedClusterSpec), b.(*v1beta1.AzureManagedClusterSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureManagedClusterSpec)(nil), (*AzureManagedClusterSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureManagedClusterSpec_To_v1alpha4_AzureManagedClusterSpec(a.(*v1beta1.AzureManagedClusterSpec), b.(*AzureManagedClusterSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureManagedClusterStatus)(nil), (*v1beta1.AzureManagedClusterStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureManagedClusterStatus_To_v1beta1_AzureManagedClusterStatus(a.(*AzureManagedClusterStatus), b.(*v1beta1.AzureManagedClusterStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureManagedClusterStatus)(nil), (*AzureManagedClusterStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureManagedClusterStatus_To_v1alpha4_AzureManagedClusterStatus(a.(*v1beta1.AzureManagedClusterStatus), b.(*AzureManagedClusterStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureManagedControlPlane)(nil), (*v1beta1.AzureManagedControlPlane)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureManagedControlPlane_To_v1beta1_AzureManagedControlPlane(a.(*AzureManagedControlPlane), b.(*v1beta1.AzureManagedControlPlane), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureManagedControlPlane)(nil), (*AzureManagedControlPlane)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureManagedControlPlane_To_v1alpha4_AzureManagedControlPlane(a.(*v1beta1.AzureManagedControlPlane), b.(*AzureManagedControlPlane), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureManagedControlPlaneList)(nil), (*v1beta1.AzureManagedControlPlaneList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureManagedControlPlaneList_To_v1beta1_AzureManagedControlPlaneList(a.(*AzureManagedControlPlaneList), b.(*v1beta1.AzureManagedControlPlaneList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureManagedControlPlaneList)(nil), (*AzureManagedControlPlaneList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureManagedControlPlaneList_To_v1alpha4_AzureManagedControlPlaneList(a.(*v1beta1.AzureManagedControlPlaneList), b.(*AzureManagedControlPlaneList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureManagedControlPlaneSpec)(nil), (*v1beta1.AzureManagedControlPlaneSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureManagedControlPlaneSpec_To_v1beta1_AzureManagedControlPlaneSpec(a.(*AzureManagedControlPlaneSpec), b.(*v1beta1.AzureManagedControlPlaneSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureManagedControlPlaneStatus)(nil), (*v1beta1.AzureManagedControlPlaneStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureManagedControlPlaneStatus_To_v1beta1_AzureManagedControlPlaneStatus(a.(*AzureManagedControlPlaneStatus), b.(*v1beta1.AzureManagedControlPlaneStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureManagedMachinePool)(nil), (*v1beta1.AzureManagedMachinePool)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureManagedMachinePool_To_v1beta1_AzureManagedMachinePool(a.(*AzureManagedMachinePool), b.(*v1beta1.AzureManagedMachinePool), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureManagedMachinePool)(nil), (*AzureManagedMachinePool)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureManagedMachinePool_To_v1alpha4_AzureManagedMachinePool(a.(*v1beta1.AzureManagedMachinePool), b.(*AzureManagedMachinePool), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureManagedMachinePoolList)(nil), (*v1beta1.AzureManagedMachinePoolList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureManagedMachinePoolList_To_v1beta1_AzureManagedMachinePoolList(a.(*AzureManagedMachinePoolList), b.(*v1beta1.AzureManagedMachinePoolList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.AzureManagedMachinePoolList)(nil), (*AzureManagedMachinePoolList)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureManagedMachinePoolList_To_v1alpha4_AzureManagedMachinePoolList(a.(*v1beta1.AzureManagedMachinePoolList), b.(*AzureManagedMachinePoolList), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureManagedMachinePoolSpec)(nil), (*v1beta1.AzureManagedMachinePoolSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureManagedMachinePoolSpec_To_v1beta1_AzureManagedMachinePoolSpec(a.(*AzureManagedMachinePoolSpec), b.(*v1beta1.AzureManagedMachinePoolSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*AzureManagedMachinePoolStatus)(nil), (*v1beta1.AzureManagedMachinePoolStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_AzureManagedMachinePoolStatus_To_v1beta1_AzureManagedMachinePoolStatus(a.(*AzureManagedMachinePoolStatus), b.(*v1beta1.AzureManagedMachinePoolStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*LoadBalancerProfile)(nil), (*v1beta1.LoadBalancerProfile)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_LoadBalancerProfile_To_v1beta1_LoadBalancerProfile(a.(*LoadBalancerProfile), b.(*v1beta1.LoadBalancerProfile), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.LoadBalancerProfile)(nil), (*LoadBalancerProfile)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_LoadBalancerProfile_To_v1alpha4_LoadBalancerProfile(a.(*v1beta1.LoadBalancerProfile), b.(*LoadBalancerProfile), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*MachineRollingUpdateDeployment)(nil), (*v1beta1.MachineRollingUpdateDeployment)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_MachineRollingUpdateDeployment_To_v1beta1_MachineRollingUpdateDeployment(a.(*MachineRollingUpdateDeployment), b.(*v1beta1.MachineRollingUpdateDeployment), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.MachineRollingUpdateDeployment)(nil), (*MachineRollingUpdateDeployment)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_MachineRollingUpdateDeployment_To_v1alpha4_MachineRollingUpdateDeployment(a.(*v1beta1.MachineRollingUpdateDeployment), b.(*MachineRollingUpdateDeployment), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*ManagedControlPlaneSubnet)(nil), (*v1beta1.ManagedControlPlaneSubnet)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_ManagedControlPlaneSubnet_To_v1beta1_ManagedControlPlaneSubnet(a.(*ManagedControlPlaneSubnet), b.(*v1beta1.ManagedControlPlaneSubnet), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.ManagedControlPlaneSubnet)(nil), (*ManagedControlPlaneSubnet)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_ManagedControlPlaneSubnet_To_v1alpha4_ManagedControlPlaneSubnet(a.(*v1beta1.ManagedControlPlaneSubnet), b.(*ManagedControlPlaneSubnet), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*ManagedControlPlaneVirtualNetwork)(nil), (*v1beta1.ManagedControlPlaneVirtualNetwork)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_ManagedControlPlaneVirtualNetwork_To_v1beta1_ManagedControlPlaneVirtualNetwork(a.(*ManagedControlPlaneVirtualNetwork), b.(*v1beta1.ManagedControlPlaneVirtualNetwork), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.ManagedControlPlaneVirtualNetwork)(nil), (*ManagedControlPlaneVirtualNetwork)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_ManagedControlPlaneVirtualNetwork_To_v1alpha4_ManagedControlPlaneVirtualNetwork(a.(*v1beta1.ManagedControlPlaneVirtualNetwork), b.(*ManagedControlPlaneVirtualNetwork), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*SKU)(nil), (*v1beta1.SKU)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_SKU_To_v1beta1_SKU(a.(*SKU), b.(*v1beta1.SKU), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddGeneratedConversionFunc((*v1beta1.SKU)(nil), (*SKU)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_SKU_To_v1alpha4_SKU(a.(*v1beta1.SKU), b.(*SKU), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*apiv1alpha4.APIEndpoint)(nil), (*apiv1beta1.APIEndpoint)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_APIEndpoint_To_v1beta1_APIEndpoint(a.(*apiv1alpha4.APIEndpoint), b.(*apiv1beta1.APIEndpoint), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*clusterapiproviderazureapiv1alpha4.Image)(nil), (*clusterapiproviderazureapiv1beta1.Image)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_Image_To_v1beta1_Image(a.(*clusterapiproviderazureapiv1alpha4.Image), b.(*clusterapiproviderazureapiv1beta1.Image), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*clusterapiproviderazureapiv1alpha4.OSDisk)(nil), (*clusterapiproviderazureapiv1beta1.OSDisk)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1alpha4_OSDisk_To_v1beta1_OSDisk(a.(*clusterapiproviderazureapiv1alpha4.OSDisk), b.(*clusterapiproviderazureapiv1beta1.OSDisk), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*apiv1beta1.APIEndpoint)(nil), (*apiv1alpha4.APIEndpoint)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_APIEndpoint_To_v1alpha4_APIEndpoint(a.(*apiv1beta1.APIEndpoint), b.(*apiv1alpha4.APIEndpoint), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.AzureManagedControlPlaneSpec)(nil), (*AzureManagedControlPlaneSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureManagedControlPlaneSpec_To_v1alpha4_AzureManagedControlPlaneSpec(a.(*v1beta1.AzureManagedControlPlaneSpec), b.(*AzureManagedControlPlaneSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.AzureManagedControlPlaneStatus)(nil), (*AzureManagedControlPlaneStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureManagedControlPlaneStatus_To_v1alpha4_AzureManagedControlPlaneStatus(a.(*v1beta1.AzureManagedControlPlaneStatus), b.(*AzureManagedControlPlaneStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.AzureManagedMachinePoolSpec)(nil), (*AzureManagedMachinePoolSpec)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureManagedMachinePoolSpec_To_v1alpha4_AzureManagedMachinePoolSpec(a.(*v1beta1.AzureManagedMachinePoolSpec), b.(*AzureManagedMachinePoolSpec), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*v1beta1.AzureManagedMachinePoolStatus)(nil), (*AzureManagedMachinePoolStatus)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_AzureManagedMachinePoolStatus_To_v1alpha4_AzureManagedMachinePoolStatus(a.(*v1beta1.AzureManagedMachinePoolStatus), b.(*AzureManagedMachinePoolStatus), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*clusterapiproviderazureapiv1beta1.Image)(nil), (*clusterapiproviderazureapiv1alpha4.Image)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_Image_To_v1alpha4_Image(a.(*clusterapiproviderazureapiv1beta1.Image), b.(*clusterapiproviderazureapiv1alpha4.Image), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := s.AddConversionFunc((*clusterapiproviderazureapiv1beta1.OSDisk)(nil), (*clusterapiproviderazureapiv1alpha4.OSDisk)(nil), func(a, b interface{}, scope conversion.Scope) error </span><span class="cov0" title="0">{
                return Convert_v1beta1_OSDisk_To_v1alpha4_OSDisk(a.(*clusterapiproviderazureapiv1beta1.OSDisk), b.(*clusterapiproviderazureapiv1alpha4.OSDisk), scope)
        }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func autoConvert_v1alpha4_AADProfile_To_v1beta1_AADProfile(in *AADProfile, out *v1beta1.AADProfile, s conversion.Scope) error <span class="cov0" title="0">{
        out.Managed = in.Managed
        out.AdminGroupObjectIDs = *(*[]string)(unsafe.Pointer(&amp;in.AdminGroupObjectIDs))
        return nil
}</span>

// Convert_v1alpha4_AADProfile_To_v1beta1_AADProfile is an autogenerated conversion function.
func Convert_v1alpha4_AADProfile_To_v1beta1_AADProfile(in *AADProfile, out *v1beta1.AADProfile, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_AADProfile_To_v1beta1_AADProfile(in, out, s)
}</span>

func autoConvert_v1beta1_AADProfile_To_v1alpha4_AADProfile(in *v1beta1.AADProfile, out *AADProfile, s conversion.Scope) error <span class="cov0" title="0">{
        out.Managed = in.Managed
        out.AdminGroupObjectIDs = *(*[]string)(unsafe.Pointer(&amp;in.AdminGroupObjectIDs))
        return nil
}</span>

// Convert_v1beta1_AADProfile_To_v1alpha4_AADProfile is an autogenerated conversion function.
func Convert_v1beta1_AADProfile_To_v1alpha4_AADProfile(in *v1beta1.AADProfile, out *AADProfile, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_AADProfile_To_v1alpha4_AADProfile(in, out, s)
}</span>

func autoConvert_v1alpha4_APIServerAccessProfile_To_v1beta1_APIServerAccessProfile(in *APIServerAccessProfile, out *v1beta1.APIServerAccessProfile, s conversion.Scope) error <span class="cov0" title="0">{
        out.AuthorizedIPRanges = *(*[]string)(unsafe.Pointer(&amp;in.AuthorizedIPRanges))
        out.EnablePrivateCluster = (*bool)(unsafe.Pointer(in.EnablePrivateCluster))
        out.PrivateDNSZone = (*string)(unsafe.Pointer(in.PrivateDNSZone))
        out.EnablePrivateClusterPublicFQDN = (*bool)(unsafe.Pointer(in.EnablePrivateClusterPublicFQDN))
        return nil
}</span>

// Convert_v1alpha4_APIServerAccessProfile_To_v1beta1_APIServerAccessProfile is an autogenerated conversion function.
func Convert_v1alpha4_APIServerAccessProfile_To_v1beta1_APIServerAccessProfile(in *APIServerAccessProfile, out *v1beta1.APIServerAccessProfile, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_APIServerAccessProfile_To_v1beta1_APIServerAccessProfile(in, out, s)
}</span>

func autoConvert_v1beta1_APIServerAccessProfile_To_v1alpha4_APIServerAccessProfile(in *v1beta1.APIServerAccessProfile, out *APIServerAccessProfile, s conversion.Scope) error <span class="cov0" title="0">{
        out.AuthorizedIPRanges = *(*[]string)(unsafe.Pointer(&amp;in.AuthorizedIPRanges))
        out.EnablePrivateCluster = (*bool)(unsafe.Pointer(in.EnablePrivateCluster))
        out.PrivateDNSZone = (*string)(unsafe.Pointer(in.PrivateDNSZone))
        out.EnablePrivateClusterPublicFQDN = (*bool)(unsafe.Pointer(in.EnablePrivateClusterPublicFQDN))
        return nil
}</span>

// Convert_v1beta1_APIServerAccessProfile_To_v1alpha4_APIServerAccessProfile is an autogenerated conversion function.
func Convert_v1beta1_APIServerAccessProfile_To_v1alpha4_APIServerAccessProfile(in *v1beta1.APIServerAccessProfile, out *APIServerAccessProfile, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_APIServerAccessProfile_To_v1alpha4_APIServerAccessProfile(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureMachinePool_To_v1beta1_AzureMachinePool(in *AzureMachinePool, out *v1beta1.AzureMachinePool, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1alpha4_AzureMachinePoolSpec_To_v1beta1_AzureMachinePoolSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1alpha4_AzureMachinePoolStatus_To_v1beta1_AzureMachinePoolStatus(&amp;in.Status, &amp;out.Status, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha4_AzureMachinePool_To_v1beta1_AzureMachinePool is an autogenerated conversion function.
func Convert_v1alpha4_AzureMachinePool_To_v1beta1_AzureMachinePool(in *AzureMachinePool, out *v1beta1.AzureMachinePool, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_AzureMachinePool_To_v1beta1_AzureMachinePool(in, out, s)
}</span>

func autoConvert_v1beta1_AzureMachinePool_To_v1alpha4_AzureMachinePool(in *v1beta1.AzureMachinePool, out *AzureMachinePool, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1beta1_AzureMachinePoolSpec_To_v1alpha4_AzureMachinePoolSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1beta1_AzureMachinePoolStatus_To_v1alpha4_AzureMachinePoolStatus(&amp;in.Status, &amp;out.Status, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1beta1_AzureMachinePool_To_v1alpha4_AzureMachinePool is an autogenerated conversion function.
func Convert_v1beta1_AzureMachinePool_To_v1alpha4_AzureMachinePool(in *v1beta1.AzureMachinePool, out *AzureMachinePool, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureMachinePool_To_v1alpha4_AzureMachinePool(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureMachinePoolDeploymentStrategy_To_v1beta1_AzureMachinePoolDeploymentStrategy(in *AzureMachinePoolDeploymentStrategy, out *v1beta1.AzureMachinePoolDeploymentStrategy, s conversion.Scope) error <span class="cov8" title="1">{
        out.Type = v1beta1.AzureMachinePoolDeploymentStrategyType(in.Type)
        out.RollingUpdate = (*v1beta1.MachineRollingUpdateDeployment)(unsafe.Pointer(in.RollingUpdate))
        return nil
}</span>

// Convert_v1alpha4_AzureMachinePoolDeploymentStrategy_To_v1beta1_AzureMachinePoolDeploymentStrategy is an autogenerated conversion function.
func Convert_v1alpha4_AzureMachinePoolDeploymentStrategy_To_v1beta1_AzureMachinePoolDeploymentStrategy(in *AzureMachinePoolDeploymentStrategy, out *v1beta1.AzureMachinePoolDeploymentStrategy, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_AzureMachinePoolDeploymentStrategy_To_v1beta1_AzureMachinePoolDeploymentStrategy(in, out, s)
}</span>

func autoConvert_v1beta1_AzureMachinePoolDeploymentStrategy_To_v1alpha4_AzureMachinePoolDeploymentStrategy(in *v1beta1.AzureMachinePoolDeploymentStrategy, out *AzureMachinePoolDeploymentStrategy, s conversion.Scope) error <span class="cov8" title="1">{
        out.Type = AzureMachinePoolDeploymentStrategyType(in.Type)
        out.RollingUpdate = (*MachineRollingUpdateDeployment)(unsafe.Pointer(in.RollingUpdate))
        return nil
}</span>

// Convert_v1beta1_AzureMachinePoolDeploymentStrategy_To_v1alpha4_AzureMachinePoolDeploymentStrategy is an autogenerated conversion function.
func Convert_v1beta1_AzureMachinePoolDeploymentStrategy_To_v1alpha4_AzureMachinePoolDeploymentStrategy(in *v1beta1.AzureMachinePoolDeploymentStrategy, out *AzureMachinePoolDeploymentStrategy, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureMachinePoolDeploymentStrategy_To_v1alpha4_AzureMachinePoolDeploymentStrategy(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureMachinePoolInstanceStatus_To_v1beta1_AzureMachinePoolInstanceStatus(in *AzureMachinePoolInstanceStatus, out *v1beta1.AzureMachinePoolInstanceStatus, s conversion.Scope) error <span class="cov0" title="0">{
        out.Version = in.Version
        out.ProvisioningState = (*clusterapiproviderazureapiv1beta1.ProvisioningState)(unsafe.Pointer(in.ProvisioningState))
        out.ProviderID = in.ProviderID
        out.InstanceID = in.InstanceID
        out.InstanceName = in.InstanceName
        out.LatestModelApplied = in.LatestModelApplied
        return nil
}</span>

// Convert_v1alpha4_AzureMachinePoolInstanceStatus_To_v1beta1_AzureMachinePoolInstanceStatus is an autogenerated conversion function.
func Convert_v1alpha4_AzureMachinePoolInstanceStatus_To_v1beta1_AzureMachinePoolInstanceStatus(in *AzureMachinePoolInstanceStatus, out *v1beta1.AzureMachinePoolInstanceStatus, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_AzureMachinePoolInstanceStatus_To_v1beta1_AzureMachinePoolInstanceStatus(in, out, s)
}</span>

func autoConvert_v1beta1_AzureMachinePoolInstanceStatus_To_v1alpha4_AzureMachinePoolInstanceStatus(in *v1beta1.AzureMachinePoolInstanceStatus, out *AzureMachinePoolInstanceStatus, s conversion.Scope) error <span class="cov0" title="0">{
        out.Version = in.Version
        out.ProvisioningState = (*clusterapiproviderazureapiv1alpha4.ProvisioningState)(unsafe.Pointer(in.ProvisioningState))
        out.ProviderID = in.ProviderID
        out.InstanceID = in.InstanceID
        out.InstanceName = in.InstanceName
        out.LatestModelApplied = in.LatestModelApplied
        return nil
}</span>

// Convert_v1beta1_AzureMachinePoolInstanceStatus_To_v1alpha4_AzureMachinePoolInstanceStatus is an autogenerated conversion function.
func Convert_v1beta1_AzureMachinePoolInstanceStatus_To_v1alpha4_AzureMachinePoolInstanceStatus(in *v1beta1.AzureMachinePoolInstanceStatus, out *AzureMachinePoolInstanceStatus, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_AzureMachinePoolInstanceStatus_To_v1alpha4_AzureMachinePoolInstanceStatus(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureMachinePoolList_To_v1beta1_AzureMachinePoolList(in *AzureMachinePoolList, out *v1beta1.AzureMachinePoolList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]v1beta1.AzureMachinePool, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1alpha4_AzureMachinePool_To_v1beta1_AzureMachinePool(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1alpha4_AzureMachinePoolList_To_v1beta1_AzureMachinePoolList is an autogenerated conversion function.
func Convert_v1alpha4_AzureMachinePoolList_To_v1beta1_AzureMachinePoolList(in *AzureMachinePoolList, out *v1beta1.AzureMachinePoolList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_AzureMachinePoolList_To_v1beta1_AzureMachinePoolList(in, out, s)
}</span>

func autoConvert_v1beta1_AzureMachinePoolList_To_v1alpha4_AzureMachinePoolList(in *v1beta1.AzureMachinePoolList, out *AzureMachinePoolList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureMachinePool, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1beta1_AzureMachinePool_To_v1alpha4_AzureMachinePool(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1beta1_AzureMachinePoolList_To_v1alpha4_AzureMachinePoolList is an autogenerated conversion function.
func Convert_v1beta1_AzureMachinePoolList_To_v1alpha4_AzureMachinePoolList(in *v1beta1.AzureMachinePoolList, out *AzureMachinePoolList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_AzureMachinePoolList_To_v1alpha4_AzureMachinePoolList(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureMachinePoolMachine_To_v1beta1_AzureMachinePoolMachine(in *AzureMachinePoolMachine, out *v1beta1.AzureMachinePoolMachine, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1alpha4_AzureMachinePoolMachineSpec_To_v1beta1_AzureMachinePoolMachineSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1alpha4_AzureMachinePoolMachineStatus_To_v1beta1_AzureMachinePoolMachineStatus(&amp;in.Status, &amp;out.Status, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha4_AzureMachinePoolMachine_To_v1beta1_AzureMachinePoolMachine is an autogenerated conversion function.
func Convert_v1alpha4_AzureMachinePoolMachine_To_v1beta1_AzureMachinePoolMachine(in *AzureMachinePoolMachine, out *v1beta1.AzureMachinePoolMachine, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_AzureMachinePoolMachine_To_v1beta1_AzureMachinePoolMachine(in, out, s)
}</span>

func autoConvert_v1beta1_AzureMachinePoolMachine_To_v1alpha4_AzureMachinePoolMachine(in *v1beta1.AzureMachinePoolMachine, out *AzureMachinePoolMachine, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1beta1_AzureMachinePoolMachineSpec_To_v1alpha4_AzureMachinePoolMachineSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1beta1_AzureMachinePoolMachineStatus_To_v1alpha4_AzureMachinePoolMachineStatus(&amp;in.Status, &amp;out.Status, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1beta1_AzureMachinePoolMachine_To_v1alpha4_AzureMachinePoolMachine is an autogenerated conversion function.
func Convert_v1beta1_AzureMachinePoolMachine_To_v1alpha4_AzureMachinePoolMachine(in *v1beta1.AzureMachinePoolMachine, out *AzureMachinePoolMachine, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureMachinePoolMachine_To_v1alpha4_AzureMachinePoolMachine(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureMachinePoolMachineList_To_v1beta1_AzureMachinePoolMachineList(in *AzureMachinePoolMachineList, out *v1beta1.AzureMachinePoolMachineList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        out.Items = *(*[]v1beta1.AzureMachinePoolMachine)(unsafe.Pointer(&amp;in.Items))
        return nil
}</span>

// Convert_v1alpha4_AzureMachinePoolMachineList_To_v1beta1_AzureMachinePoolMachineList is an autogenerated conversion function.
func Convert_v1alpha4_AzureMachinePoolMachineList_To_v1beta1_AzureMachinePoolMachineList(in *AzureMachinePoolMachineList, out *v1beta1.AzureMachinePoolMachineList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_AzureMachinePoolMachineList_To_v1beta1_AzureMachinePoolMachineList(in, out, s)
}</span>

func autoConvert_v1beta1_AzureMachinePoolMachineList_To_v1alpha4_AzureMachinePoolMachineList(in *v1beta1.AzureMachinePoolMachineList, out *AzureMachinePoolMachineList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        out.Items = *(*[]AzureMachinePoolMachine)(unsafe.Pointer(&amp;in.Items))
        return nil
}</span>

// Convert_v1beta1_AzureMachinePoolMachineList_To_v1alpha4_AzureMachinePoolMachineList is an autogenerated conversion function.
func Convert_v1beta1_AzureMachinePoolMachineList_To_v1alpha4_AzureMachinePoolMachineList(in *v1beta1.AzureMachinePoolMachineList, out *AzureMachinePoolMachineList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_AzureMachinePoolMachineList_To_v1alpha4_AzureMachinePoolMachineList(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureMachinePoolMachineSpec_To_v1beta1_AzureMachinePoolMachineSpec(in *AzureMachinePoolMachineSpec, out *v1beta1.AzureMachinePoolMachineSpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.ProviderID = in.ProviderID
        out.InstanceID = in.InstanceID
        return nil
}</span>

// Convert_v1alpha4_AzureMachinePoolMachineSpec_To_v1beta1_AzureMachinePoolMachineSpec is an autogenerated conversion function.
func Convert_v1alpha4_AzureMachinePoolMachineSpec_To_v1beta1_AzureMachinePoolMachineSpec(in *AzureMachinePoolMachineSpec, out *v1beta1.AzureMachinePoolMachineSpec, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_AzureMachinePoolMachineSpec_To_v1beta1_AzureMachinePoolMachineSpec(in, out, s)
}</span>

func autoConvert_v1beta1_AzureMachinePoolMachineSpec_To_v1alpha4_AzureMachinePoolMachineSpec(in *v1beta1.AzureMachinePoolMachineSpec, out *AzureMachinePoolMachineSpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.ProviderID = in.ProviderID
        out.InstanceID = in.InstanceID
        return nil
}</span>

// Convert_v1beta1_AzureMachinePoolMachineSpec_To_v1alpha4_AzureMachinePoolMachineSpec is an autogenerated conversion function.
func Convert_v1beta1_AzureMachinePoolMachineSpec_To_v1alpha4_AzureMachinePoolMachineSpec(in *v1beta1.AzureMachinePoolMachineSpec, out *AzureMachinePoolMachineSpec, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureMachinePoolMachineSpec_To_v1alpha4_AzureMachinePoolMachineSpec(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureMachinePoolMachineStatus_To_v1beta1_AzureMachinePoolMachineStatus(in *AzureMachinePoolMachineStatus, out *v1beta1.AzureMachinePoolMachineStatus, s conversion.Scope) error <span class="cov8" title="1">{
        out.NodeRef = (*v1.ObjectReference)(unsafe.Pointer(in.NodeRef))
        out.Version = in.Version
        out.ProvisioningState = (*clusterapiproviderazureapiv1beta1.ProvisioningState)(unsafe.Pointer(in.ProvisioningState))
        out.InstanceName = in.InstanceName
        out.FailureReason = (*errors.MachineStatusError)(unsafe.Pointer(in.FailureReason))
        out.FailureMessage = (*string)(unsafe.Pointer(in.FailureMessage))
        out.Conditions = *(*apiv1beta1.Conditions)(unsafe.Pointer(&amp;in.Conditions))
        out.LongRunningOperationStates = *(*clusterapiproviderazureapiv1beta1.Futures)(unsafe.Pointer(&amp;in.LongRunningOperationStates))
        out.LatestModelApplied = in.LatestModelApplied
        out.Ready = in.Ready
        return nil
}</span>

// Convert_v1alpha4_AzureMachinePoolMachineStatus_To_v1beta1_AzureMachinePoolMachineStatus is an autogenerated conversion function.
func Convert_v1alpha4_AzureMachinePoolMachineStatus_To_v1beta1_AzureMachinePoolMachineStatus(in *AzureMachinePoolMachineStatus, out *v1beta1.AzureMachinePoolMachineStatus, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_AzureMachinePoolMachineStatus_To_v1beta1_AzureMachinePoolMachineStatus(in, out, s)
}</span>

func autoConvert_v1beta1_AzureMachinePoolMachineStatus_To_v1alpha4_AzureMachinePoolMachineStatus(in *v1beta1.AzureMachinePoolMachineStatus, out *AzureMachinePoolMachineStatus, s conversion.Scope) error <span class="cov8" title="1">{
        out.NodeRef = (*v1.ObjectReference)(unsafe.Pointer(in.NodeRef))
        out.Version = in.Version
        out.ProvisioningState = (*clusterapiproviderazureapiv1alpha4.ProvisioningState)(unsafe.Pointer(in.ProvisioningState))
        out.InstanceName = in.InstanceName
        out.FailureReason = (*errors.MachineStatusError)(unsafe.Pointer(in.FailureReason))
        out.FailureMessage = (*string)(unsafe.Pointer(in.FailureMessage))
        out.Conditions = *(*apiv1alpha4.Conditions)(unsafe.Pointer(&amp;in.Conditions))
        out.LongRunningOperationStates = *(*clusterapiproviderazureapiv1alpha4.Futures)(unsafe.Pointer(&amp;in.LongRunningOperationStates))
        out.LatestModelApplied = in.LatestModelApplied
        out.Ready = in.Ready
        return nil
}</span>

// Convert_v1beta1_AzureMachinePoolMachineStatus_To_v1alpha4_AzureMachinePoolMachineStatus is an autogenerated conversion function.
func Convert_v1beta1_AzureMachinePoolMachineStatus_To_v1alpha4_AzureMachinePoolMachineStatus(in *v1beta1.AzureMachinePoolMachineStatus, out *AzureMachinePoolMachineStatus, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureMachinePoolMachineStatus_To_v1alpha4_AzureMachinePoolMachineStatus(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureMachinePoolMachineTemplate_To_v1beta1_AzureMachinePoolMachineTemplate(in *AzureMachinePoolMachineTemplate, out *v1beta1.AzureMachinePoolMachineTemplate, s conversion.Scope) error <span class="cov8" title="1">{
        out.VMSize = in.VMSize
        if in.Image != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Image, &amp;out.Image
                *out = new(clusterapiproviderazureapiv1beta1.Image)
                if err := Convert_v1alpha4_Image_To_v1beta1_Image(*in, *out, s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                out.Image = nil
        }</span>
        <span class="cov8" title="1">if err := Convert_v1alpha4_OSDisk_To_v1beta1_OSDisk(&amp;in.OSDisk, &amp;out.OSDisk, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">out.DataDisks = *(*[]clusterapiproviderazureapiv1beta1.DataDisk)(unsafe.Pointer(&amp;in.DataDisks))
        out.SSHPublicKey = in.SSHPublicKey
        out.AcceleratedNetworking = (*bool)(unsafe.Pointer(in.AcceleratedNetworking))
        out.TerminateNotificationTimeout = (*int)(unsafe.Pointer(in.TerminateNotificationTimeout))
        out.SecurityProfile = (*clusterapiproviderazureapiv1beta1.SecurityProfile)(unsafe.Pointer(in.SecurityProfile))
        out.SpotVMOptions = (*clusterapiproviderazureapiv1beta1.SpotVMOptions)(unsafe.Pointer(in.SpotVMOptions))
        out.SubnetName = in.SubnetName
        return nil</span>
}

// Convert_v1alpha4_AzureMachinePoolMachineTemplate_To_v1beta1_AzureMachinePoolMachineTemplate is an autogenerated conversion function.
func Convert_v1alpha4_AzureMachinePoolMachineTemplate_To_v1beta1_AzureMachinePoolMachineTemplate(in *AzureMachinePoolMachineTemplate, out *v1beta1.AzureMachinePoolMachineTemplate, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_AzureMachinePoolMachineTemplate_To_v1beta1_AzureMachinePoolMachineTemplate(in, out, s)
}</span>

func autoConvert_v1beta1_AzureMachinePoolMachineTemplate_To_v1alpha4_AzureMachinePoolMachineTemplate(in *v1beta1.AzureMachinePoolMachineTemplate, out *AzureMachinePoolMachineTemplate, s conversion.Scope) error <span class="cov8" title="1">{
        out.VMSize = in.VMSize
        if in.Image != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Image, &amp;out.Image
                *out = new(clusterapiproviderazureapiv1alpha4.Image)
                if err := Convert_v1beta1_Image_To_v1alpha4_Image(*in, *out, s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                out.Image = nil
        }</span>
        <span class="cov8" title="1">if err := Convert_v1beta1_OSDisk_To_v1alpha4_OSDisk(&amp;in.OSDisk, &amp;out.OSDisk, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">out.DataDisks = *(*[]clusterapiproviderazureapiv1alpha4.DataDisk)(unsafe.Pointer(&amp;in.DataDisks))
        out.SSHPublicKey = in.SSHPublicKey
        out.AcceleratedNetworking = (*bool)(unsafe.Pointer(in.AcceleratedNetworking))
        out.TerminateNotificationTimeout = (*int)(unsafe.Pointer(in.TerminateNotificationTimeout))
        out.SecurityProfile = (*clusterapiproviderazureapiv1alpha4.SecurityProfile)(unsafe.Pointer(in.SecurityProfile))
        out.SpotVMOptions = (*clusterapiproviderazureapiv1alpha4.SpotVMOptions)(unsafe.Pointer(in.SpotVMOptions))
        out.SubnetName = in.SubnetName
        return nil</span>
}

// Convert_v1beta1_AzureMachinePoolMachineTemplate_To_v1alpha4_AzureMachinePoolMachineTemplate is an autogenerated conversion function.
func Convert_v1beta1_AzureMachinePoolMachineTemplate_To_v1alpha4_AzureMachinePoolMachineTemplate(in *v1beta1.AzureMachinePoolMachineTemplate, out *AzureMachinePoolMachineTemplate, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureMachinePoolMachineTemplate_To_v1alpha4_AzureMachinePoolMachineTemplate(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureMachinePoolSpec_To_v1beta1_AzureMachinePoolSpec(in *AzureMachinePoolSpec, out *v1beta1.AzureMachinePoolSpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.Location = in.Location
        if err := Convert_v1alpha4_AzureMachinePoolMachineTemplate_To_v1beta1_AzureMachinePoolMachineTemplate(&amp;in.Template, &amp;out.Template, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">out.AdditionalTags = *(*clusterapiproviderazureapiv1beta1.Tags)(unsafe.Pointer(&amp;in.AdditionalTags))
        out.ProviderID = in.ProviderID
        out.ProviderIDList = *(*[]string)(unsafe.Pointer(&amp;in.ProviderIDList))
        out.Identity = clusterapiproviderazureapiv1beta1.VMIdentity(in.Identity)
        out.UserAssignedIdentities = *(*[]clusterapiproviderazureapiv1beta1.UserAssignedIdentity)(unsafe.Pointer(&amp;in.UserAssignedIdentities))
        out.RoleAssignmentName = in.RoleAssignmentName
        if err := Convert_v1alpha4_AzureMachinePoolDeploymentStrategy_To_v1beta1_AzureMachinePoolDeploymentStrategy(&amp;in.Strategy, &amp;out.Strategy, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">out.NodeDrainTimeout = (*metav1.Duration)(unsafe.Pointer(in.NodeDrainTimeout))
        return nil</span>
}

// Convert_v1alpha4_AzureMachinePoolSpec_To_v1beta1_AzureMachinePoolSpec is an autogenerated conversion function.
func Convert_v1alpha4_AzureMachinePoolSpec_To_v1beta1_AzureMachinePoolSpec(in *AzureMachinePoolSpec, out *v1beta1.AzureMachinePoolSpec, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_AzureMachinePoolSpec_To_v1beta1_AzureMachinePoolSpec(in, out, s)
}</span>

func autoConvert_v1beta1_AzureMachinePoolSpec_To_v1alpha4_AzureMachinePoolSpec(in *v1beta1.AzureMachinePoolSpec, out *AzureMachinePoolSpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.Location = in.Location
        if err := Convert_v1beta1_AzureMachinePoolMachineTemplate_To_v1alpha4_AzureMachinePoolMachineTemplate(&amp;in.Template, &amp;out.Template, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">out.AdditionalTags = *(*clusterapiproviderazureapiv1alpha4.Tags)(unsafe.Pointer(&amp;in.AdditionalTags))
        out.ProviderID = in.ProviderID
        out.ProviderIDList = *(*[]string)(unsafe.Pointer(&amp;in.ProviderIDList))
        out.Identity = clusterapiproviderazureapiv1alpha4.VMIdentity(in.Identity)
        out.UserAssignedIdentities = *(*[]clusterapiproviderazureapiv1alpha4.UserAssignedIdentity)(unsafe.Pointer(&amp;in.UserAssignedIdentities))
        out.RoleAssignmentName = in.RoleAssignmentName
        if err := Convert_v1beta1_AzureMachinePoolDeploymentStrategy_To_v1alpha4_AzureMachinePoolDeploymentStrategy(&amp;in.Strategy, &amp;out.Strategy, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">out.NodeDrainTimeout = (*metav1.Duration)(unsafe.Pointer(in.NodeDrainTimeout))
        return nil</span>
}

// Convert_v1beta1_AzureMachinePoolSpec_To_v1alpha4_AzureMachinePoolSpec is an autogenerated conversion function.
func Convert_v1beta1_AzureMachinePoolSpec_To_v1alpha4_AzureMachinePoolSpec(in *v1beta1.AzureMachinePoolSpec, out *AzureMachinePoolSpec, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureMachinePoolSpec_To_v1alpha4_AzureMachinePoolSpec(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureMachinePoolStatus_To_v1beta1_AzureMachinePoolStatus(in *AzureMachinePoolStatus, out *v1beta1.AzureMachinePoolStatus, s conversion.Scope) error <span class="cov8" title="1">{
        out.Ready = in.Ready
        out.Replicas = in.Replicas
        out.Instances = *(*[]*v1beta1.AzureMachinePoolInstanceStatus)(unsafe.Pointer(&amp;in.Instances))
        if in.Image != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Image, &amp;out.Image
                *out = new(clusterapiproviderazureapiv1beta1.Image)
                if err := Convert_v1alpha4_Image_To_v1beta1_Image(*in, *out, s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                out.Image = nil
        }</span>
        <span class="cov8" title="1">out.Version = in.Version
        out.ProvisioningState = (*clusterapiproviderazureapiv1beta1.ProvisioningState)(unsafe.Pointer(in.ProvisioningState))
        out.FailureReason = (*errors.MachineStatusError)(unsafe.Pointer(in.FailureReason))
        out.FailureMessage = (*string)(unsafe.Pointer(in.FailureMessage))
        out.Conditions = *(*apiv1beta1.Conditions)(unsafe.Pointer(&amp;in.Conditions))
        out.LongRunningOperationStates = *(*clusterapiproviderazureapiv1beta1.Futures)(unsafe.Pointer(&amp;in.LongRunningOperationStates))
        return nil</span>
}

// Convert_v1alpha4_AzureMachinePoolStatus_To_v1beta1_AzureMachinePoolStatus is an autogenerated conversion function.
func Convert_v1alpha4_AzureMachinePoolStatus_To_v1beta1_AzureMachinePoolStatus(in *AzureMachinePoolStatus, out *v1beta1.AzureMachinePoolStatus, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_AzureMachinePoolStatus_To_v1beta1_AzureMachinePoolStatus(in, out, s)
}</span>

func autoConvert_v1beta1_AzureMachinePoolStatus_To_v1alpha4_AzureMachinePoolStatus(in *v1beta1.AzureMachinePoolStatus, out *AzureMachinePoolStatus, s conversion.Scope) error <span class="cov8" title="1">{
        out.Ready = in.Ready
        out.Replicas = in.Replicas
        out.Instances = *(*[]*AzureMachinePoolInstanceStatus)(unsafe.Pointer(&amp;in.Instances))
        if in.Image != nil </span><span class="cov8" title="1">{
                in, out := &amp;in.Image, &amp;out.Image
                *out = new(clusterapiproviderazureapiv1alpha4.Image)
                if err := Convert_v1beta1_Image_To_v1alpha4_Image(*in, *out, s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                out.Image = nil
        }</span>
        <span class="cov8" title="1">out.Version = in.Version
        out.ProvisioningState = (*clusterapiproviderazureapiv1alpha4.ProvisioningState)(unsafe.Pointer(in.ProvisioningState))
        out.FailureReason = (*errors.MachineStatusError)(unsafe.Pointer(in.FailureReason))
        out.FailureMessage = (*string)(unsafe.Pointer(in.FailureMessage))
        out.Conditions = *(*apiv1alpha4.Conditions)(unsafe.Pointer(&amp;in.Conditions))
        out.LongRunningOperationStates = *(*clusterapiproviderazureapiv1alpha4.Futures)(unsafe.Pointer(&amp;in.LongRunningOperationStates))
        return nil</span>
}

// Convert_v1beta1_AzureMachinePoolStatus_To_v1alpha4_AzureMachinePoolStatus is an autogenerated conversion function.
func Convert_v1beta1_AzureMachinePoolStatus_To_v1alpha4_AzureMachinePoolStatus(in *v1beta1.AzureMachinePoolStatus, out *AzureMachinePoolStatus, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureMachinePoolStatus_To_v1alpha4_AzureMachinePoolStatus(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureManagedCluster_To_v1beta1_AzureManagedCluster(in *AzureManagedCluster, out *v1beta1.AzureManagedCluster, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1alpha4_AzureManagedClusterSpec_To_v1beta1_AzureManagedClusterSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1alpha4_AzureManagedClusterStatus_To_v1beta1_AzureManagedClusterStatus(&amp;in.Status, &amp;out.Status, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha4_AzureManagedCluster_To_v1beta1_AzureManagedCluster is an autogenerated conversion function.
func Convert_v1alpha4_AzureManagedCluster_To_v1beta1_AzureManagedCluster(in *AzureManagedCluster, out *v1beta1.AzureManagedCluster, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_AzureManagedCluster_To_v1beta1_AzureManagedCluster(in, out, s)
}</span>

func autoConvert_v1beta1_AzureManagedCluster_To_v1alpha4_AzureManagedCluster(in *v1beta1.AzureManagedCluster, out *AzureManagedCluster, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1beta1_AzureManagedClusterSpec_To_v1alpha4_AzureManagedClusterSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1beta1_AzureManagedClusterStatus_To_v1alpha4_AzureManagedClusterStatus(&amp;in.Status, &amp;out.Status, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1beta1_AzureManagedCluster_To_v1alpha4_AzureManagedCluster is an autogenerated conversion function.
func Convert_v1beta1_AzureManagedCluster_To_v1alpha4_AzureManagedCluster(in *v1beta1.AzureManagedCluster, out *AzureManagedCluster, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureManagedCluster_To_v1alpha4_AzureManagedCluster(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureManagedClusterList_To_v1beta1_AzureManagedClusterList(in *AzureManagedClusterList, out *v1beta1.AzureManagedClusterList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]v1beta1.AzureManagedCluster, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1alpha4_AzureManagedCluster_To_v1beta1_AzureManagedCluster(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1alpha4_AzureManagedClusterList_To_v1beta1_AzureManagedClusterList is an autogenerated conversion function.
func Convert_v1alpha4_AzureManagedClusterList_To_v1beta1_AzureManagedClusterList(in *AzureManagedClusterList, out *v1beta1.AzureManagedClusterList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_AzureManagedClusterList_To_v1beta1_AzureManagedClusterList(in, out, s)
}</span>

func autoConvert_v1beta1_AzureManagedClusterList_To_v1alpha4_AzureManagedClusterList(in *v1beta1.AzureManagedClusterList, out *AzureManagedClusterList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureManagedCluster, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1beta1_AzureManagedCluster_To_v1alpha4_AzureManagedCluster(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1beta1_AzureManagedClusterList_To_v1alpha4_AzureManagedClusterList is an autogenerated conversion function.
func Convert_v1beta1_AzureManagedClusterList_To_v1alpha4_AzureManagedClusterList(in *v1beta1.AzureManagedClusterList, out *AzureManagedClusterList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_AzureManagedClusterList_To_v1alpha4_AzureManagedClusterList(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureManagedClusterSpec_To_v1beta1_AzureManagedClusterSpec(in *AzureManagedClusterSpec, out *v1beta1.AzureManagedClusterSpec, s conversion.Scope) error <span class="cov8" title="1">{
        if err := Convert_v1alpha4_APIEndpoint_To_v1beta1_APIEndpoint(&amp;in.ControlPlaneEndpoint, &amp;out.ControlPlaneEndpoint, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha4_AzureManagedClusterSpec_To_v1beta1_AzureManagedClusterSpec is an autogenerated conversion function.
func Convert_v1alpha4_AzureManagedClusterSpec_To_v1beta1_AzureManagedClusterSpec(in *AzureManagedClusterSpec, out *v1beta1.AzureManagedClusterSpec, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_AzureManagedClusterSpec_To_v1beta1_AzureManagedClusterSpec(in, out, s)
}</span>

func autoConvert_v1beta1_AzureManagedClusterSpec_To_v1alpha4_AzureManagedClusterSpec(in *v1beta1.AzureManagedClusterSpec, out *AzureManagedClusterSpec, s conversion.Scope) error <span class="cov8" title="1">{
        if err := Convert_v1beta1_APIEndpoint_To_v1alpha4_APIEndpoint(&amp;in.ControlPlaneEndpoint, &amp;out.ControlPlaneEndpoint, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1beta1_AzureManagedClusterSpec_To_v1alpha4_AzureManagedClusterSpec is an autogenerated conversion function.
func Convert_v1beta1_AzureManagedClusterSpec_To_v1alpha4_AzureManagedClusterSpec(in *v1beta1.AzureManagedClusterSpec, out *AzureManagedClusterSpec, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureManagedClusterSpec_To_v1alpha4_AzureManagedClusterSpec(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureManagedClusterStatus_To_v1beta1_AzureManagedClusterStatus(in *AzureManagedClusterStatus, out *v1beta1.AzureManagedClusterStatus, s conversion.Scope) error <span class="cov8" title="1">{
        out.Ready = in.Ready
        return nil
}</span>

// Convert_v1alpha4_AzureManagedClusterStatus_To_v1beta1_AzureManagedClusterStatus is an autogenerated conversion function.
func Convert_v1alpha4_AzureManagedClusterStatus_To_v1beta1_AzureManagedClusterStatus(in *AzureManagedClusterStatus, out *v1beta1.AzureManagedClusterStatus, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_AzureManagedClusterStatus_To_v1beta1_AzureManagedClusterStatus(in, out, s)
}</span>

func autoConvert_v1beta1_AzureManagedClusterStatus_To_v1alpha4_AzureManagedClusterStatus(in *v1beta1.AzureManagedClusterStatus, out *AzureManagedClusterStatus, s conversion.Scope) error <span class="cov8" title="1">{
        out.Ready = in.Ready
        return nil
}</span>

// Convert_v1beta1_AzureManagedClusterStatus_To_v1alpha4_AzureManagedClusterStatus is an autogenerated conversion function.
func Convert_v1beta1_AzureManagedClusterStatus_To_v1alpha4_AzureManagedClusterStatus(in *v1beta1.AzureManagedClusterStatus, out *AzureManagedClusterStatus, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureManagedClusterStatus_To_v1alpha4_AzureManagedClusterStatus(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureManagedControlPlane_To_v1beta1_AzureManagedControlPlane(in *AzureManagedControlPlane, out *v1beta1.AzureManagedControlPlane, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1alpha4_AzureManagedControlPlaneSpec_To_v1beta1_AzureManagedControlPlaneSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1alpha4_AzureManagedControlPlaneStatus_To_v1beta1_AzureManagedControlPlaneStatus(&amp;in.Status, &amp;out.Status, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha4_AzureManagedControlPlane_To_v1beta1_AzureManagedControlPlane is an autogenerated conversion function.
func Convert_v1alpha4_AzureManagedControlPlane_To_v1beta1_AzureManagedControlPlane(in *AzureManagedControlPlane, out *v1beta1.AzureManagedControlPlane, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_AzureManagedControlPlane_To_v1beta1_AzureManagedControlPlane(in, out, s)
}</span>

func autoConvert_v1beta1_AzureManagedControlPlane_To_v1alpha4_AzureManagedControlPlane(in *v1beta1.AzureManagedControlPlane, out *AzureManagedControlPlane, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1beta1_AzureManagedControlPlaneSpec_To_v1alpha4_AzureManagedControlPlaneSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1beta1_AzureManagedControlPlaneStatus_To_v1alpha4_AzureManagedControlPlaneStatus(&amp;in.Status, &amp;out.Status, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1beta1_AzureManagedControlPlane_To_v1alpha4_AzureManagedControlPlane is an autogenerated conversion function.
func Convert_v1beta1_AzureManagedControlPlane_To_v1alpha4_AzureManagedControlPlane(in *v1beta1.AzureManagedControlPlane, out *AzureManagedControlPlane, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureManagedControlPlane_To_v1alpha4_AzureManagedControlPlane(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureManagedControlPlaneList_To_v1beta1_AzureManagedControlPlaneList(in *AzureManagedControlPlaneList, out *v1beta1.AzureManagedControlPlaneList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]v1beta1.AzureManagedControlPlane, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1alpha4_AzureManagedControlPlane_To_v1beta1_AzureManagedControlPlane(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1alpha4_AzureManagedControlPlaneList_To_v1beta1_AzureManagedControlPlaneList is an autogenerated conversion function.
func Convert_v1alpha4_AzureManagedControlPlaneList_To_v1beta1_AzureManagedControlPlaneList(in *AzureManagedControlPlaneList, out *v1beta1.AzureManagedControlPlaneList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_AzureManagedControlPlaneList_To_v1beta1_AzureManagedControlPlaneList(in, out, s)
}</span>

func autoConvert_v1beta1_AzureManagedControlPlaneList_To_v1alpha4_AzureManagedControlPlaneList(in *v1beta1.AzureManagedControlPlaneList, out *AzureManagedControlPlaneList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureManagedControlPlane, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1beta1_AzureManagedControlPlane_To_v1alpha4_AzureManagedControlPlane(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1beta1_AzureManagedControlPlaneList_To_v1alpha4_AzureManagedControlPlaneList is an autogenerated conversion function.
func Convert_v1beta1_AzureManagedControlPlaneList_To_v1alpha4_AzureManagedControlPlaneList(in *v1beta1.AzureManagedControlPlaneList, out *AzureManagedControlPlaneList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_AzureManagedControlPlaneList_To_v1alpha4_AzureManagedControlPlaneList(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureManagedControlPlaneSpec_To_v1beta1_AzureManagedControlPlaneSpec(in *AzureManagedControlPlaneSpec, out *v1beta1.AzureManagedControlPlaneSpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.Version = in.Version
        out.ResourceGroupName = in.ResourceGroupName
        out.NodeResourceGroupName = in.NodeResourceGroupName
        if err := Convert_v1alpha4_ManagedControlPlaneVirtualNetwork_To_v1beta1_ManagedControlPlaneVirtualNetwork(&amp;in.VirtualNetwork, &amp;out.VirtualNetwork, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">out.SubscriptionID = in.SubscriptionID
        out.Location = in.Location
        if err := Convert_v1alpha4_APIEndpoint_To_v1beta1_APIEndpoint(&amp;in.ControlPlaneEndpoint, &amp;out.ControlPlaneEndpoint, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">out.AdditionalTags = *(*clusterapiproviderazureapiv1beta1.Tags)(unsafe.Pointer(&amp;in.AdditionalTags))
        out.NetworkPlugin = (*string)(unsafe.Pointer(in.NetworkPlugin))
        out.NetworkPolicy = (*string)(unsafe.Pointer(in.NetworkPolicy))
        out.SSHPublicKey = in.SSHPublicKey
        out.DNSServiceIP = (*string)(unsafe.Pointer(in.DNSServiceIP))
        out.LoadBalancerSKU = (*string)(unsafe.Pointer(in.LoadBalancerSKU))
        out.IdentityRef = (*v1.ObjectReference)(unsafe.Pointer(in.IdentityRef))
        out.AADProfile = (*v1beta1.AADProfile)(unsafe.Pointer(in.AADProfile))
        out.SKU = (*v1beta1.SKU)(unsafe.Pointer(in.SKU))
        out.LoadBalancerProfile = (*v1beta1.LoadBalancerProfile)(unsafe.Pointer(in.LoadBalancerProfile))
        out.APIServerAccessProfile = (*v1beta1.APIServerAccessProfile)(unsafe.Pointer(in.APIServerAccessProfile))
        return nil</span>
}

// Convert_v1alpha4_AzureManagedControlPlaneSpec_To_v1beta1_AzureManagedControlPlaneSpec is an autogenerated conversion function.
func Convert_v1alpha4_AzureManagedControlPlaneSpec_To_v1beta1_AzureManagedControlPlaneSpec(in *AzureManagedControlPlaneSpec, out *v1beta1.AzureManagedControlPlaneSpec, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_AzureManagedControlPlaneSpec_To_v1beta1_AzureManagedControlPlaneSpec(in, out, s)
}</span>

func autoConvert_v1beta1_AzureManagedControlPlaneSpec_To_v1alpha4_AzureManagedControlPlaneSpec(in *v1beta1.AzureManagedControlPlaneSpec, out *AzureManagedControlPlaneSpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.Version = in.Version
        out.ResourceGroupName = in.ResourceGroupName
        out.NodeResourceGroupName = in.NodeResourceGroupName
        if err := Convert_v1beta1_ManagedControlPlaneVirtualNetwork_To_v1alpha4_ManagedControlPlaneVirtualNetwork(&amp;in.VirtualNetwork, &amp;out.VirtualNetwork, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">out.SubscriptionID = in.SubscriptionID
        out.Location = in.Location
        if err := Convert_v1beta1_APIEndpoint_To_v1alpha4_APIEndpoint(&amp;in.ControlPlaneEndpoint, &amp;out.ControlPlaneEndpoint, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">out.AdditionalTags = *(*clusterapiproviderazureapiv1alpha4.Tags)(unsafe.Pointer(&amp;in.AdditionalTags))
        out.NetworkPlugin = (*string)(unsafe.Pointer(in.NetworkPlugin))
        out.NetworkPolicy = (*string)(unsafe.Pointer(in.NetworkPolicy))
        out.SSHPublicKey = in.SSHPublicKey
        out.DNSServiceIP = (*string)(unsafe.Pointer(in.DNSServiceIP))
        out.LoadBalancerSKU = (*string)(unsafe.Pointer(in.LoadBalancerSKU))
        out.IdentityRef = (*v1.ObjectReference)(unsafe.Pointer(in.IdentityRef))
        out.AADProfile = (*AADProfile)(unsafe.Pointer(in.AADProfile))
        // WARNING: in.AddonProfiles requires manual conversion: does not exist in peer-type
        out.SKU = (*SKU)(unsafe.Pointer(in.SKU))
        out.LoadBalancerProfile = (*LoadBalancerProfile)(unsafe.Pointer(in.LoadBalancerProfile))
        out.APIServerAccessProfile = (*APIServerAccessProfile)(unsafe.Pointer(in.APIServerAccessProfile))
        return nil</span>
}

func autoConvert_v1alpha4_AzureManagedControlPlaneStatus_To_v1beta1_AzureManagedControlPlaneStatus(in *AzureManagedControlPlaneStatus, out *v1beta1.AzureManagedControlPlaneStatus, s conversion.Scope) error <span class="cov8" title="1">{
        out.Ready = in.Ready
        out.Initialized = in.Initialized
        out.LongRunningOperationStates = *(*clusterapiproviderazureapiv1beta1.Futures)(unsafe.Pointer(&amp;in.LongRunningOperationStates))
        return nil
}</span>

// Convert_v1alpha4_AzureManagedControlPlaneStatus_To_v1beta1_AzureManagedControlPlaneStatus is an autogenerated conversion function.
func Convert_v1alpha4_AzureManagedControlPlaneStatus_To_v1beta1_AzureManagedControlPlaneStatus(in *AzureManagedControlPlaneStatus, out *v1beta1.AzureManagedControlPlaneStatus, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_AzureManagedControlPlaneStatus_To_v1beta1_AzureManagedControlPlaneStatus(in, out, s)
}</span>

func autoConvert_v1beta1_AzureManagedControlPlaneStatus_To_v1alpha4_AzureManagedControlPlaneStatus(in *v1beta1.AzureManagedControlPlaneStatus, out *AzureManagedControlPlaneStatus, s conversion.Scope) error <span class="cov8" title="1">{
        out.Ready = in.Ready
        out.Initialized = in.Initialized
        // WARNING: in.Conditions requires manual conversion: does not exist in peer-type
        out.LongRunningOperationStates = *(*clusterapiproviderazureapiv1alpha4.Futures)(unsafe.Pointer(&amp;in.LongRunningOperationStates))
        return nil
}</span>

func autoConvert_v1alpha4_AzureManagedMachinePool_To_v1beta1_AzureManagedMachinePool(in *AzureManagedMachinePool, out *v1beta1.AzureManagedMachinePool, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1alpha4_AzureManagedMachinePoolSpec_To_v1beta1_AzureManagedMachinePoolSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1alpha4_AzureManagedMachinePoolStatus_To_v1beta1_AzureManagedMachinePoolStatus(&amp;in.Status, &amp;out.Status, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha4_AzureManagedMachinePool_To_v1beta1_AzureManagedMachinePool is an autogenerated conversion function.
func Convert_v1alpha4_AzureManagedMachinePool_To_v1beta1_AzureManagedMachinePool(in *AzureManagedMachinePool, out *v1beta1.AzureManagedMachinePool, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_AzureManagedMachinePool_To_v1beta1_AzureManagedMachinePool(in, out, s)
}</span>

func autoConvert_v1beta1_AzureManagedMachinePool_To_v1alpha4_AzureManagedMachinePool(in *v1beta1.AzureManagedMachinePool, out *AzureManagedMachinePool, s conversion.Scope) error <span class="cov8" title="1">{
        out.ObjectMeta = in.ObjectMeta
        if err := Convert_v1beta1_AzureManagedMachinePoolSpec_To_v1alpha4_AzureManagedMachinePoolSpec(&amp;in.Spec, &amp;out.Spec, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := Convert_v1beta1_AzureManagedMachinePoolStatus_To_v1alpha4_AzureManagedMachinePoolStatus(&amp;in.Status, &amp;out.Status, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1beta1_AzureManagedMachinePool_To_v1alpha4_AzureManagedMachinePool is an autogenerated conversion function.
func Convert_v1beta1_AzureManagedMachinePool_To_v1alpha4_AzureManagedMachinePool(in *v1beta1.AzureManagedMachinePool, out *AzureManagedMachinePool, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_AzureManagedMachinePool_To_v1alpha4_AzureManagedMachinePool(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureManagedMachinePoolList_To_v1beta1_AzureManagedMachinePoolList(in *AzureManagedMachinePoolList, out *v1beta1.AzureManagedMachinePoolList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]v1beta1.AzureManagedMachinePool, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1alpha4_AzureManagedMachinePool_To_v1beta1_AzureManagedMachinePool(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1alpha4_AzureManagedMachinePoolList_To_v1beta1_AzureManagedMachinePoolList is an autogenerated conversion function.
func Convert_v1alpha4_AzureManagedMachinePoolList_To_v1beta1_AzureManagedMachinePoolList(in *AzureManagedMachinePoolList, out *v1beta1.AzureManagedMachinePoolList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_AzureManagedMachinePoolList_To_v1beta1_AzureManagedMachinePoolList(in, out, s)
}</span>

func autoConvert_v1beta1_AzureManagedMachinePoolList_To_v1alpha4_AzureManagedMachinePoolList(in *v1beta1.AzureManagedMachinePoolList, out *AzureManagedMachinePoolList, s conversion.Scope) error <span class="cov0" title="0">{
        out.ListMeta = in.ListMeta
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureManagedMachinePool, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if err := Convert_v1beta1_AzureManagedMachinePool_To_v1alpha4_AzureManagedMachinePool(&amp;(*in)[i], &amp;(*out)[i], s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                out.Items = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Convert_v1beta1_AzureManagedMachinePoolList_To_v1alpha4_AzureManagedMachinePoolList is an autogenerated conversion function.
func Convert_v1beta1_AzureManagedMachinePoolList_To_v1alpha4_AzureManagedMachinePoolList(in *v1beta1.AzureManagedMachinePoolList, out *AzureManagedMachinePoolList, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_AzureManagedMachinePoolList_To_v1alpha4_AzureManagedMachinePoolList(in, out, s)
}</span>

func autoConvert_v1alpha4_AzureManagedMachinePoolSpec_To_v1beta1_AzureManagedMachinePoolSpec(in *AzureManagedMachinePoolSpec, out *v1beta1.AzureManagedMachinePoolSpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.Name = (*string)(unsafe.Pointer(in.Name))
        out.Mode = in.Mode
        out.SKU = in.SKU
        out.OSDiskSizeGB = (*int32)(unsafe.Pointer(in.OSDiskSizeGB))
        out.ProviderIDList = *(*[]string)(unsafe.Pointer(&amp;in.ProviderIDList))
        return nil
}</span>

// Convert_v1alpha4_AzureManagedMachinePoolSpec_To_v1beta1_AzureManagedMachinePoolSpec is an autogenerated conversion function.
func Convert_v1alpha4_AzureManagedMachinePoolSpec_To_v1beta1_AzureManagedMachinePoolSpec(in *AzureManagedMachinePoolSpec, out *v1beta1.AzureManagedMachinePoolSpec, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_AzureManagedMachinePoolSpec_To_v1beta1_AzureManagedMachinePoolSpec(in, out, s)
}</span>

func autoConvert_v1beta1_AzureManagedMachinePoolSpec_To_v1alpha4_AzureManagedMachinePoolSpec(in *v1beta1.AzureManagedMachinePoolSpec, out *AzureManagedMachinePoolSpec, s conversion.Scope) error <span class="cov8" title="1">{
        out.Name = (*string)(unsafe.Pointer(in.Name))
        out.Mode = in.Mode
        out.SKU = in.SKU
        out.OSDiskSizeGB = (*int32)(unsafe.Pointer(in.OSDiskSizeGB))
        // WARNING: in.AvailabilityZones requires manual conversion: does not exist in peer-type
        // WARNING: in.NodeLabels requires manual conversion: does not exist in peer-type
        // WARNING: in.Taints requires manual conversion: does not exist in peer-type
        out.ProviderIDList = *(*[]string)(unsafe.Pointer(&amp;in.ProviderIDList))
        // WARNING: in.Scaling requires manual conversion: does not exist in peer-type
        // WARNING: in.MaxPods requires manual conversion: does not exist in peer-type
        // WARNING: in.OsDiskType requires manual conversion: does not exist in peer-type
        // WARNING: in.EnableUltraSSD requires manual conversion: does not exist in peer-type
        // WARNING: in.OSType requires manual conversion: does not exist in peer-type
        // WARNING: in.EnableNodePublicIP requires manual conversion: does not exist in peer-type
        return nil
}</span>

func autoConvert_v1alpha4_AzureManagedMachinePoolStatus_To_v1beta1_AzureManagedMachinePoolStatus(in *AzureManagedMachinePoolStatus, out *v1beta1.AzureManagedMachinePoolStatus, s conversion.Scope) error <span class="cov8" title="1">{
        out.Ready = in.Ready
        out.Replicas = in.Replicas
        out.ErrorReason = (*errors.MachineStatusError)(unsafe.Pointer(in.ErrorReason))
        out.ErrorMessage = (*string)(unsafe.Pointer(in.ErrorMessage))
        return nil
}</span>

// Convert_v1alpha4_AzureManagedMachinePoolStatus_To_v1beta1_AzureManagedMachinePoolStatus is an autogenerated conversion function.
func Convert_v1alpha4_AzureManagedMachinePoolStatus_To_v1beta1_AzureManagedMachinePoolStatus(in *AzureManagedMachinePoolStatus, out *v1beta1.AzureManagedMachinePoolStatus, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_AzureManagedMachinePoolStatus_To_v1beta1_AzureManagedMachinePoolStatus(in, out, s)
}</span>

func autoConvert_v1beta1_AzureManagedMachinePoolStatus_To_v1alpha4_AzureManagedMachinePoolStatus(in *v1beta1.AzureManagedMachinePoolStatus, out *AzureManagedMachinePoolStatus, s conversion.Scope) error <span class="cov8" title="1">{
        out.Ready = in.Ready
        out.Replicas = in.Replicas
        out.ErrorReason = (*errors.MachineStatusError)(unsafe.Pointer(in.ErrorReason))
        out.ErrorMessage = (*string)(unsafe.Pointer(in.ErrorMessage))
        // WARNING: in.Conditions requires manual conversion: does not exist in peer-type
        // WARNING: in.LongRunningOperationStates requires manual conversion: does not exist in peer-type
        return nil
}</span>

func autoConvert_v1alpha4_LoadBalancerProfile_To_v1beta1_LoadBalancerProfile(in *LoadBalancerProfile, out *v1beta1.LoadBalancerProfile, s conversion.Scope) error <span class="cov0" title="0">{
        out.ManagedOutboundIPs = (*int32)(unsafe.Pointer(in.ManagedOutboundIPs))
        out.OutboundIPPrefixes = *(*[]string)(unsafe.Pointer(&amp;in.OutboundIPPrefixes))
        out.OutboundIPs = *(*[]string)(unsafe.Pointer(&amp;in.OutboundIPs))
        out.AllocatedOutboundPorts = (*int32)(unsafe.Pointer(in.AllocatedOutboundPorts))
        out.IdleTimeoutInMinutes = (*int32)(unsafe.Pointer(in.IdleTimeoutInMinutes))
        return nil
}</span>

// Convert_v1alpha4_LoadBalancerProfile_To_v1beta1_LoadBalancerProfile is an autogenerated conversion function.
func Convert_v1alpha4_LoadBalancerProfile_To_v1beta1_LoadBalancerProfile(in *LoadBalancerProfile, out *v1beta1.LoadBalancerProfile, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_LoadBalancerProfile_To_v1beta1_LoadBalancerProfile(in, out, s)
}</span>

func autoConvert_v1beta1_LoadBalancerProfile_To_v1alpha4_LoadBalancerProfile(in *v1beta1.LoadBalancerProfile, out *LoadBalancerProfile, s conversion.Scope) error <span class="cov0" title="0">{
        out.ManagedOutboundIPs = (*int32)(unsafe.Pointer(in.ManagedOutboundIPs))
        out.OutboundIPPrefixes = *(*[]string)(unsafe.Pointer(&amp;in.OutboundIPPrefixes))
        out.OutboundIPs = *(*[]string)(unsafe.Pointer(&amp;in.OutboundIPs))
        out.AllocatedOutboundPorts = (*int32)(unsafe.Pointer(in.AllocatedOutboundPorts))
        out.IdleTimeoutInMinutes = (*int32)(unsafe.Pointer(in.IdleTimeoutInMinutes))
        return nil
}</span>

// Convert_v1beta1_LoadBalancerProfile_To_v1alpha4_LoadBalancerProfile is an autogenerated conversion function.
func Convert_v1beta1_LoadBalancerProfile_To_v1alpha4_LoadBalancerProfile(in *v1beta1.LoadBalancerProfile, out *LoadBalancerProfile, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_LoadBalancerProfile_To_v1alpha4_LoadBalancerProfile(in, out, s)
}</span>

func autoConvert_v1alpha4_MachineRollingUpdateDeployment_To_v1beta1_MachineRollingUpdateDeployment(in *MachineRollingUpdateDeployment, out *v1beta1.MachineRollingUpdateDeployment, s conversion.Scope) error <span class="cov0" title="0">{
        out.MaxUnavailable = (*intstr.IntOrString)(unsafe.Pointer(in.MaxUnavailable))
        out.MaxSurge = (*intstr.IntOrString)(unsafe.Pointer(in.MaxSurge))
        out.DeletePolicy = v1beta1.AzureMachinePoolDeletePolicyType(in.DeletePolicy)
        return nil
}</span>

// Convert_v1alpha4_MachineRollingUpdateDeployment_To_v1beta1_MachineRollingUpdateDeployment is an autogenerated conversion function.
func Convert_v1alpha4_MachineRollingUpdateDeployment_To_v1beta1_MachineRollingUpdateDeployment(in *MachineRollingUpdateDeployment, out *v1beta1.MachineRollingUpdateDeployment, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_MachineRollingUpdateDeployment_To_v1beta1_MachineRollingUpdateDeployment(in, out, s)
}</span>

func autoConvert_v1beta1_MachineRollingUpdateDeployment_To_v1alpha4_MachineRollingUpdateDeployment(in *v1beta1.MachineRollingUpdateDeployment, out *MachineRollingUpdateDeployment, s conversion.Scope) error <span class="cov0" title="0">{
        out.MaxUnavailable = (*intstr.IntOrString)(unsafe.Pointer(in.MaxUnavailable))
        out.MaxSurge = (*intstr.IntOrString)(unsafe.Pointer(in.MaxSurge))
        out.DeletePolicy = AzureMachinePoolDeletePolicyType(in.DeletePolicy)
        return nil
}</span>

// Convert_v1beta1_MachineRollingUpdateDeployment_To_v1alpha4_MachineRollingUpdateDeployment is an autogenerated conversion function.
func Convert_v1beta1_MachineRollingUpdateDeployment_To_v1alpha4_MachineRollingUpdateDeployment(in *v1beta1.MachineRollingUpdateDeployment, out *MachineRollingUpdateDeployment, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_MachineRollingUpdateDeployment_To_v1alpha4_MachineRollingUpdateDeployment(in, out, s)
}</span>

func autoConvert_v1alpha4_ManagedControlPlaneSubnet_To_v1beta1_ManagedControlPlaneSubnet(in *ManagedControlPlaneSubnet, out *v1beta1.ManagedControlPlaneSubnet, s conversion.Scope) error <span class="cov8" title="1">{
        out.Name = in.Name
        out.CIDRBlock = in.CIDRBlock
        return nil
}</span>

// Convert_v1alpha4_ManagedControlPlaneSubnet_To_v1beta1_ManagedControlPlaneSubnet is an autogenerated conversion function.
func Convert_v1alpha4_ManagedControlPlaneSubnet_To_v1beta1_ManagedControlPlaneSubnet(in *ManagedControlPlaneSubnet, out *v1beta1.ManagedControlPlaneSubnet, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_ManagedControlPlaneSubnet_To_v1beta1_ManagedControlPlaneSubnet(in, out, s)
}</span>

func autoConvert_v1beta1_ManagedControlPlaneSubnet_To_v1alpha4_ManagedControlPlaneSubnet(in *v1beta1.ManagedControlPlaneSubnet, out *ManagedControlPlaneSubnet, s conversion.Scope) error <span class="cov8" title="1">{
        out.Name = in.Name
        out.CIDRBlock = in.CIDRBlock
        return nil
}</span>

// Convert_v1beta1_ManagedControlPlaneSubnet_To_v1alpha4_ManagedControlPlaneSubnet is an autogenerated conversion function.
func Convert_v1beta1_ManagedControlPlaneSubnet_To_v1alpha4_ManagedControlPlaneSubnet(in *v1beta1.ManagedControlPlaneSubnet, out *ManagedControlPlaneSubnet, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_ManagedControlPlaneSubnet_To_v1alpha4_ManagedControlPlaneSubnet(in, out, s)
}</span>

func autoConvert_v1alpha4_ManagedControlPlaneVirtualNetwork_To_v1beta1_ManagedControlPlaneVirtualNetwork(in *ManagedControlPlaneVirtualNetwork, out *v1beta1.ManagedControlPlaneVirtualNetwork, s conversion.Scope) error <span class="cov8" title="1">{
        out.Name = in.Name
        out.CIDRBlock = in.CIDRBlock
        if err := Convert_v1alpha4_ManagedControlPlaneSubnet_To_v1beta1_ManagedControlPlaneSubnet(&amp;in.Subnet, &amp;out.Subnet, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1alpha4_ManagedControlPlaneVirtualNetwork_To_v1beta1_ManagedControlPlaneVirtualNetwork is an autogenerated conversion function.
func Convert_v1alpha4_ManagedControlPlaneVirtualNetwork_To_v1beta1_ManagedControlPlaneVirtualNetwork(in *ManagedControlPlaneVirtualNetwork, out *v1beta1.ManagedControlPlaneVirtualNetwork, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1alpha4_ManagedControlPlaneVirtualNetwork_To_v1beta1_ManagedControlPlaneVirtualNetwork(in, out, s)
}</span>

func autoConvert_v1beta1_ManagedControlPlaneVirtualNetwork_To_v1alpha4_ManagedControlPlaneVirtualNetwork(in *v1beta1.ManagedControlPlaneVirtualNetwork, out *ManagedControlPlaneVirtualNetwork, s conversion.Scope) error <span class="cov8" title="1">{
        out.Name = in.Name
        out.CIDRBlock = in.CIDRBlock
        if err := Convert_v1beta1_ManagedControlPlaneSubnet_To_v1alpha4_ManagedControlPlaneSubnet(&amp;in.Subnet, &amp;out.Subnet, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Convert_v1beta1_ManagedControlPlaneVirtualNetwork_To_v1alpha4_ManagedControlPlaneVirtualNetwork is an autogenerated conversion function.
func Convert_v1beta1_ManagedControlPlaneVirtualNetwork_To_v1alpha4_ManagedControlPlaneVirtualNetwork(in *v1beta1.ManagedControlPlaneVirtualNetwork, out *ManagedControlPlaneVirtualNetwork, s conversion.Scope) error <span class="cov8" title="1">{
        return autoConvert_v1beta1_ManagedControlPlaneVirtualNetwork_To_v1alpha4_ManagedControlPlaneVirtualNetwork(in, out, s)
}</span>

func autoConvert_v1alpha4_SKU_To_v1beta1_SKU(in *SKU, out *v1beta1.SKU, s conversion.Scope) error <span class="cov0" title="0">{
        out.Tier = v1beta1.AzureManagedControlPlaneSkuTier(in.Tier)
        return nil
}</span>

// Convert_v1alpha4_SKU_To_v1beta1_SKU is an autogenerated conversion function.
func Convert_v1alpha4_SKU_To_v1beta1_SKU(in *SKU, out *v1beta1.SKU, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1alpha4_SKU_To_v1beta1_SKU(in, out, s)
}</span>

func autoConvert_v1beta1_SKU_To_v1alpha4_SKU(in *v1beta1.SKU, out *SKU, s conversion.Scope) error <span class="cov0" title="0">{
        out.Tier = string(in.Tier)
        return nil
}</span>

// Convert_v1beta1_SKU_To_v1alpha4_SKU is an autogenerated conversion function.
func Convert_v1beta1_SKU_To_v1alpha4_SKU(in *v1beta1.SKU, out *SKU, s conversion.Scope) error <span class="cov0" title="0">{
        return autoConvert_v1beta1_SKU_To_v1alpha4_SKU(in, out, s)
}</span>
</pre>
		
		<pre class="file" id="file190" style="display: none">//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha4

import (
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/util/intstr"
        apiv1alpha4 "sigs.k8s.io/cluster-api-provider-azure/api/v1alpha4"
        cluster_apiapiv1alpha4 "sigs.k8s.io/cluster-api/api/v1alpha4"
        "sigs.k8s.io/cluster-api/errors"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AADProfile) DeepCopyInto(out *AADProfile) <span class="cov0" title="0">{
        *out = *in
        if in.AdminGroupObjectIDs != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AdminGroupObjectIDs, &amp;out.AdminGroupObjectIDs
                *out = make([]string, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AADProfile.
func (in *AADProfile) DeepCopy() *AADProfile <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AADProfile)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *APIServerAccessProfile) DeepCopyInto(out *APIServerAccessProfile) <span class="cov0" title="0">{
        *out = *in
        if in.AuthorizedIPRanges != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AuthorizedIPRanges, &amp;out.AuthorizedIPRanges
                *out = make([]string, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov0" title="0">if in.EnablePrivateCluster != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.EnablePrivateCluster, &amp;out.EnablePrivateCluster
                *out = new(bool)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.PrivateDNSZone != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.PrivateDNSZone, &amp;out.PrivateDNSZone
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.EnablePrivateClusterPublicFQDN != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.EnablePrivateClusterPublicFQDN, &amp;out.EnablePrivateClusterPublicFQDN
                *out = new(bool)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new APIServerAccessProfile.
func (in *APIServerAccessProfile) DeepCopy() *APIServerAccessProfile <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(APIServerAccessProfile)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachinePool) DeepCopyInto(out *AzureMachinePool) <span class="cov8" title="1">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
        in.Status.DeepCopyInto(&amp;out.Status)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachinePool.
func (in *AzureMachinePool) DeepCopy() *AzureMachinePool <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">out := new(AzureMachinePool)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureMachinePool) DeepCopyObject() runtime.Object <span class="cov8" title="1">{
        if c := in.DeepCopy(); c != nil </span><span class="cov8" title="1">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachinePoolDeploymentStrategy) DeepCopyInto(out *AzureMachinePoolDeploymentStrategy) <span class="cov8" title="1">{
        *out = *in
        if in.RollingUpdate != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.RollingUpdate, &amp;out.RollingUpdate
                *out = new(MachineRollingUpdateDeployment)
                (*in).DeepCopyInto(*out)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachinePoolDeploymentStrategy.
func (in *AzureMachinePoolDeploymentStrategy) DeepCopy() *AzureMachinePoolDeploymentStrategy <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachinePoolDeploymentStrategy)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachinePoolInstanceStatus) DeepCopyInto(out *AzureMachinePoolInstanceStatus) <span class="cov0" title="0">{
        *out = *in
        if in.ProvisioningState != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ProvisioningState, &amp;out.ProvisioningState
                *out = new(apiv1alpha4.ProvisioningState)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachinePoolInstanceStatus.
func (in *AzureMachinePoolInstanceStatus) DeepCopy() *AzureMachinePoolInstanceStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachinePoolInstanceStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachinePoolList) DeepCopyInto(out *AzureMachinePoolList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureMachinePool, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachinePoolList.
func (in *AzureMachinePoolList) DeepCopy() *AzureMachinePoolList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachinePoolList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureMachinePoolList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachinePoolMachine) DeepCopyInto(out *AzureMachinePoolMachine) <span class="cov8" title="1">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        out.Spec = in.Spec
        in.Status.DeepCopyInto(&amp;out.Status)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachinePoolMachine.
func (in *AzureMachinePoolMachine) DeepCopy() *AzureMachinePoolMachine <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">out := new(AzureMachinePoolMachine)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureMachinePoolMachine) DeepCopyObject() runtime.Object <span class="cov8" title="1">{
        if c := in.DeepCopy(); c != nil </span><span class="cov8" title="1">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachinePoolMachineList) DeepCopyInto(out *AzureMachinePoolMachineList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureMachinePoolMachine, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachinePoolMachineList.
func (in *AzureMachinePoolMachineList) DeepCopy() *AzureMachinePoolMachineList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachinePoolMachineList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureMachinePoolMachineList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachinePoolMachineSpec) DeepCopyInto(out *AzureMachinePoolMachineSpec) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachinePoolMachineSpec.
func (in *AzureMachinePoolMachineSpec) DeepCopy() *AzureMachinePoolMachineSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachinePoolMachineSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachinePoolMachineStatus) DeepCopyInto(out *AzureMachinePoolMachineStatus) <span class="cov8" title="1">{
        *out = *in
        if in.NodeRef != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.NodeRef, &amp;out.NodeRef
                *out = new(corev1.ObjectReference)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.ProvisioningState != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ProvisioningState, &amp;out.ProvisioningState
                *out = new(apiv1alpha4.ProvisioningState)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.FailureReason != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.FailureReason, &amp;out.FailureReason
                *out = new(errors.MachineStatusError)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.FailureMessage != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.FailureMessage, &amp;out.FailureMessage
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.Conditions != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make(cluster_apiapiv1alpha4.Conditions, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov8" title="1">if in.LongRunningOperationStates != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.LongRunningOperationStates, &amp;out.LongRunningOperationStates
                *out = make(apiv1alpha4.Futures, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachinePoolMachineStatus.
func (in *AzureMachinePoolMachineStatus) DeepCopy() *AzureMachinePoolMachineStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachinePoolMachineStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachinePoolMachineTemplate) DeepCopyInto(out *AzureMachinePoolMachineTemplate) <span class="cov8" title="1">{
        *out = *in
        if in.Image != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Image, &amp;out.Image
                *out = new(apiv1alpha4.Image)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov8" title="1">in.OSDisk.DeepCopyInto(&amp;out.OSDisk)
        if in.DataDisks != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.DataDisks, &amp;out.DataDisks
                *out = make([]apiv1alpha4.DataDisk, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov8" title="1">if in.AcceleratedNetworking != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AcceleratedNetworking, &amp;out.AcceleratedNetworking
                *out = new(bool)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.TerminateNotificationTimeout != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.TerminateNotificationTimeout, &amp;out.TerminateNotificationTimeout
                *out = new(int)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.SecurityProfile != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.SecurityProfile, &amp;out.SecurityProfile
                *out = new(apiv1alpha4.SecurityProfile)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov8" title="1">if in.SpotVMOptions != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.SpotVMOptions, &amp;out.SpotVMOptions
                *out = new(apiv1alpha4.SpotVMOptions)
                (*in).DeepCopyInto(*out)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachinePoolMachineTemplate.
func (in *AzureMachinePoolMachineTemplate) DeepCopy() *AzureMachinePoolMachineTemplate <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachinePoolMachineTemplate)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachinePoolSpec) DeepCopyInto(out *AzureMachinePoolSpec) <span class="cov8" title="1">{
        *out = *in
        in.Template.DeepCopyInto(&amp;out.Template)
        if in.AdditionalTags != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AdditionalTags, &amp;out.AdditionalTags
                *out = make(apiv1alpha4.Tags, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
        <span class="cov8" title="1">if in.ProviderIDList != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ProviderIDList, &amp;out.ProviderIDList
                *out = make([]string, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov8" title="1">if in.UserAssignedIdentities != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.UserAssignedIdentities, &amp;out.UserAssignedIdentities
                *out = make([]apiv1alpha4.UserAssignedIdentity, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov8" title="1">in.Strategy.DeepCopyInto(&amp;out.Strategy)
        if in.NodeDrainTimeout != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.NodeDrainTimeout, &amp;out.NodeDrainTimeout
                *out = new(v1.Duration)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachinePoolSpec.
func (in *AzureMachinePoolSpec) DeepCopy() *AzureMachinePoolSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachinePoolSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachinePoolStatus) DeepCopyInto(out *AzureMachinePoolStatus) <span class="cov8" title="1">{
        *out = *in
        if in.Instances != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Instances, &amp;out.Instances
                *out = make([]*AzureMachinePoolInstanceStatus, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if (*in)[i] != nil </span><span class="cov0" title="0">{
                                in, out := &amp;(*in)[i], &amp;(*out)[i]
                                *out = new(AzureMachinePoolInstanceStatus)
                                (*in).DeepCopyInto(*out)
                        }</span>
                }
        }
        <span class="cov8" title="1">if in.Image != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Image, &amp;out.Image
                *out = new(apiv1alpha4.Image)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov8" title="1">if in.ProvisioningState != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ProvisioningState, &amp;out.ProvisioningState
                *out = new(apiv1alpha4.ProvisioningState)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.FailureReason != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.FailureReason, &amp;out.FailureReason
                *out = new(errors.MachineStatusError)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.FailureMessage != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.FailureMessage, &amp;out.FailureMessage
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.Conditions != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make(cluster_apiapiv1alpha4.Conditions, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov8" title="1">if in.LongRunningOperationStates != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.LongRunningOperationStates, &amp;out.LongRunningOperationStates
                *out = make(apiv1alpha4.Futures, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachinePoolStatus.
func (in *AzureMachinePoolStatus) DeepCopy() *AzureMachinePoolStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachinePoolStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedCluster) DeepCopyInto(out *AzureManagedCluster) <span class="cov8" title="1">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        out.Spec = in.Spec
        out.Status = in.Status
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedCluster.
func (in *AzureManagedCluster) DeepCopy() *AzureManagedCluster <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">out := new(AzureManagedCluster)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureManagedCluster) DeepCopyObject() runtime.Object <span class="cov8" title="1">{
        if c := in.DeepCopy(); c != nil </span><span class="cov8" title="1">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedClusterList) DeepCopyInto(out *AzureManagedClusterList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureManagedCluster, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedClusterList.
func (in *AzureManagedClusterList) DeepCopy() *AzureManagedClusterList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureManagedClusterList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureManagedClusterList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedClusterSpec) DeepCopyInto(out *AzureManagedClusterSpec) <span class="cov0" title="0">{
        *out = *in
        out.ControlPlaneEndpoint = in.ControlPlaneEndpoint
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedClusterSpec.
func (in *AzureManagedClusterSpec) DeepCopy() *AzureManagedClusterSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureManagedClusterSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedClusterStatus) DeepCopyInto(out *AzureManagedClusterStatus) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedClusterStatus.
func (in *AzureManagedClusterStatus) DeepCopy() *AzureManagedClusterStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureManagedClusterStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedControlPlane) DeepCopyInto(out *AzureManagedControlPlane) <span class="cov8" title="1">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
        in.Status.DeepCopyInto(&amp;out.Status)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedControlPlane.
func (in *AzureManagedControlPlane) DeepCopy() *AzureManagedControlPlane <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">out := new(AzureManagedControlPlane)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureManagedControlPlane) DeepCopyObject() runtime.Object <span class="cov8" title="1">{
        if c := in.DeepCopy(); c != nil </span><span class="cov8" title="1">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedControlPlaneList) DeepCopyInto(out *AzureManagedControlPlaneList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureManagedControlPlane, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedControlPlaneList.
func (in *AzureManagedControlPlaneList) DeepCopy() *AzureManagedControlPlaneList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureManagedControlPlaneList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureManagedControlPlaneList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedControlPlaneSpec) DeepCopyInto(out *AzureManagedControlPlaneSpec) <span class="cov8" title="1">{
        *out = *in
        out.VirtualNetwork = in.VirtualNetwork
        out.ControlPlaneEndpoint = in.ControlPlaneEndpoint
        if in.AdditionalTags != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AdditionalTags, &amp;out.AdditionalTags
                *out = make(apiv1alpha4.Tags, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
        <span class="cov8" title="1">if in.NetworkPlugin != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.NetworkPlugin, &amp;out.NetworkPlugin
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.NetworkPolicy != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.NetworkPolicy, &amp;out.NetworkPolicy
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.DNSServiceIP != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.DNSServiceIP, &amp;out.DNSServiceIP
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.LoadBalancerSKU != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.LoadBalancerSKU, &amp;out.LoadBalancerSKU
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.IdentityRef != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.IdentityRef, &amp;out.IdentityRef
                *out = new(corev1.ObjectReference)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.AADProfile != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AADProfile, &amp;out.AADProfile
                *out = new(AADProfile)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov8" title="1">if in.SKU != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.SKU, &amp;out.SKU
                *out = new(SKU)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.LoadBalancerProfile != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.LoadBalancerProfile, &amp;out.LoadBalancerProfile
                *out = new(LoadBalancerProfile)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov8" title="1">if in.APIServerAccessProfile != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.APIServerAccessProfile, &amp;out.APIServerAccessProfile
                *out = new(APIServerAccessProfile)
                (*in).DeepCopyInto(*out)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedControlPlaneSpec.
func (in *AzureManagedControlPlaneSpec) DeepCopy() *AzureManagedControlPlaneSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureManagedControlPlaneSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedControlPlaneStatus) DeepCopyInto(out *AzureManagedControlPlaneStatus) <span class="cov8" title="1">{
        *out = *in
        if in.LongRunningOperationStates != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.LongRunningOperationStates, &amp;out.LongRunningOperationStates
                *out = make(apiv1alpha4.Futures, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedControlPlaneStatus.
func (in *AzureManagedControlPlaneStatus) DeepCopy() *AzureManagedControlPlaneStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureManagedControlPlaneStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedMachinePool) DeepCopyInto(out *AzureManagedMachinePool) <span class="cov8" title="1">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
        in.Status.DeepCopyInto(&amp;out.Status)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedMachinePool.
func (in *AzureManagedMachinePool) DeepCopy() *AzureManagedMachinePool <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">out := new(AzureManagedMachinePool)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureManagedMachinePool) DeepCopyObject() runtime.Object <span class="cov8" title="1">{
        if c := in.DeepCopy(); c != nil </span><span class="cov8" title="1">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedMachinePoolList) DeepCopyInto(out *AzureManagedMachinePoolList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureManagedMachinePool, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedMachinePoolList.
func (in *AzureManagedMachinePoolList) DeepCopy() *AzureManagedMachinePoolList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureManagedMachinePoolList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureManagedMachinePoolList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedMachinePoolSpec) DeepCopyInto(out *AzureManagedMachinePoolSpec) <span class="cov8" title="1">{
        *out = *in
        if in.Name != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Name, &amp;out.Name
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.OSDiskSizeGB != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.OSDiskSizeGB, &amp;out.OSDiskSizeGB
                *out = new(int32)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.ProviderIDList != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ProviderIDList, &amp;out.ProviderIDList
                *out = make([]string, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedMachinePoolSpec.
func (in *AzureManagedMachinePoolSpec) DeepCopy() *AzureManagedMachinePoolSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureManagedMachinePoolSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedMachinePoolStatus) DeepCopyInto(out *AzureManagedMachinePoolStatus) <span class="cov8" title="1">{
        *out = *in
        if in.ErrorReason != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ErrorReason, &amp;out.ErrorReason
                *out = new(errors.MachineStatusError)
                **out = **in
        }</span>
        <span class="cov8" title="1">if in.ErrorMessage != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ErrorMessage, &amp;out.ErrorMessage
                *out = new(string)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedMachinePoolStatus.
func (in *AzureManagedMachinePoolStatus) DeepCopy() *AzureManagedMachinePoolStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureManagedMachinePoolStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LoadBalancerProfile) DeepCopyInto(out *LoadBalancerProfile) <span class="cov0" title="0">{
        *out = *in
        if in.ManagedOutboundIPs != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ManagedOutboundIPs, &amp;out.ManagedOutboundIPs
                *out = new(int32)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.OutboundIPPrefixes != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.OutboundIPPrefixes, &amp;out.OutboundIPPrefixes
                *out = make([]string, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov0" title="0">if in.OutboundIPs != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.OutboundIPs, &amp;out.OutboundIPs
                *out = make([]string, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov0" title="0">if in.AllocatedOutboundPorts != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AllocatedOutboundPorts, &amp;out.AllocatedOutboundPorts
                *out = new(int32)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.IdleTimeoutInMinutes != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.IdleTimeoutInMinutes, &amp;out.IdleTimeoutInMinutes
                *out = new(int32)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LoadBalancerProfile.
func (in *LoadBalancerProfile) DeepCopy() *LoadBalancerProfile <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(LoadBalancerProfile)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MachineRollingUpdateDeployment) DeepCopyInto(out *MachineRollingUpdateDeployment) <span class="cov0" title="0">{
        *out = *in
        if in.MaxUnavailable != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.MaxUnavailable, &amp;out.MaxUnavailable
                *out = new(intstr.IntOrString)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.MaxSurge != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.MaxSurge, &amp;out.MaxSurge
                *out = new(intstr.IntOrString)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MachineRollingUpdateDeployment.
func (in *MachineRollingUpdateDeployment) DeepCopy() *MachineRollingUpdateDeployment <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(MachineRollingUpdateDeployment)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ManagedControlPlaneSubnet) DeepCopyInto(out *ManagedControlPlaneSubnet) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ManagedControlPlaneSubnet.
func (in *ManagedControlPlaneSubnet) DeepCopy() *ManagedControlPlaneSubnet <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(ManagedControlPlaneSubnet)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ManagedControlPlaneVirtualNetwork) DeepCopyInto(out *ManagedControlPlaneVirtualNetwork) <span class="cov0" title="0">{
        *out = *in
        out.Subnet = in.Subnet
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ManagedControlPlaneVirtualNetwork.
func (in *ManagedControlPlaneVirtualNetwork) DeepCopy() *ManagedControlPlaneVirtualNetwork <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(ManagedControlPlaneVirtualNetwork)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SKU) DeepCopyInto(out *SKU) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SKU.
func (in *SKU) DeepCopy() *SKU <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(SKU)
        in.DeepCopyInto(out)
        return out</span>
}
</pre>
		
		<pre class="file" id="file191" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

// Hub marks AzureMachinePool as a conversion hub.
func (*AzureMachinePool) Hub() {<span class="cov0" title="0">}</span>

// Hub marks AzureMachinePoolList as a conversion hub.
func (*AzureMachinePoolList) Hub() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file192" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "encoding/base64"

        "golang.org/x/crypto/ssh"
        "k8s.io/apimachinery/pkg/util/uuid"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        utilSSH "sigs.k8s.io/cluster-api-provider-azure/util/ssh"
)

// SetDefaultSSHPublicKey sets the default SSHPublicKey for an AzureMachinePool.
func (amp *AzureMachinePool) SetDefaultSSHPublicKey() error <span class="cov8" title="1">{
        if sshKeyData := amp.Spec.Template.SSHPublicKey; sshKeyData == "" </span><span class="cov8" title="1">{
                _, publicRsaKey, err := utilSSH.GenerateSSHKey()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">amp.Spec.Template.SSHPublicKey = base64.StdEncoding.EncodeToString(ssh.MarshalAuthorizedKey(publicRsaKey))</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// SetIdentityDefaults sets the defaults for VMSS Identity.
func (amp *AzureMachinePool) SetIdentityDefaults() <span class="cov8" title="1">{
        if amp.Spec.Identity == infrav1.VMIdentitySystemAssigned </span><span class="cov8" title="1">{
                if amp.Spec.RoleAssignmentName == "" </span><span class="cov8" title="1">{
                        amp.Spec.RoleAssignmentName = string(uuid.NewUUID())
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file193" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/util/intstr"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        "sigs.k8s.io/cluster-api/errors"
)

const (
        // MachinePoolNameLabel indicates the AzureMachinePool name the AzureMachinePoolMachine belongs.
        MachinePoolNameLabel = "azuremachinepool.infrastructure.cluster.x-k8s.io/machine-pool"

        // RollingUpdateAzureMachinePoolDeploymentStrategyType replaces AzureMachinePoolMachines with older models with
        // AzureMachinePoolMachines based on the latest model.
        // i.e. gradually scale down the old AzureMachinePoolMachines and scale up the new ones.
        RollingUpdateAzureMachinePoolDeploymentStrategyType AzureMachinePoolDeploymentStrategyType = "RollingUpdate"

        // OldestDeletePolicyType will delete machines with the oldest creation date first.
        OldestDeletePolicyType AzureMachinePoolDeletePolicyType = "Oldest"
        // NewestDeletePolicyType will delete machines with the newest creation date first.
        NewestDeletePolicyType AzureMachinePoolDeletePolicyType = "Newest"
        // RandomDeletePolicyType will delete machines in random order.
        RandomDeletePolicyType AzureMachinePoolDeletePolicyType = "Random"
)

type (
        // AzureMachinePoolMachineTemplate defines the template for an AzureMachine.
        AzureMachinePoolMachineTemplate struct {
                // VMSize is the size of the Virtual Machine to build.
                // See https://docs.microsoft.com/en-us/rest/api/compute/virtualmachines/createorupdate#virtualmachinesizetypes
                VMSize string `json:"vmSize"`

                // Image is used to provide details of an image to use during VM creation.
                // If image details are omitted the image will default the Azure Marketplace "capi" offer,
                // which is based on Ubuntu.
                // +kubebuilder:validation:nullable
                // +optional
                Image *infrav1.Image `json:"image,omitempty"`

                // OSDisk contains the operating system disk information for a Virtual Machine
                OSDisk infrav1.OSDisk `json:"osDisk"`

                // DataDisks specifies the list of data disks to be created for a Virtual Machine
                // +optional
                DataDisks []infrav1.DataDisk `json:"dataDisks,omitempty"`

                // SSHPublicKey is the SSH public key string base64 encoded to add to a Virtual Machine
                SSHPublicKey string `json:"sshPublicKey"`

                // AcceleratedNetworking enables or disables Azure accelerated networking. If omitted, it will be set based on
                // whether the requested VMSize supports accelerated networking.
                // If AcceleratedNetworking is set to true with a VMSize that does not support it, Azure will return an error.
                // +optional
                AcceleratedNetworking *bool `json:"acceleratedNetworking,omitempty"`

                // TerminateNotificationTimeout enables or disables VMSS scheduled events termination notification with specified timeout
                // allowed values are between 5 and 15 (mins)
                // +optional
                TerminateNotificationTimeout *int `json:"terminateNotificationTimeout,omitempty"`

                // SecurityProfile specifies the Security profile settings for a virtual machine.
                // +optional
                SecurityProfile *infrav1.SecurityProfile `json:"securityProfile,omitempty"`

                // SpotVMOptions allows the ability to specify the Machine should use a Spot VM
                // +optional
                SpotVMOptions *infrav1.SpotVMOptions `json:"spotVMOptions,omitempty"`

                // SubnetName selects the Subnet where the VMSS will be placed
                // +optional
                SubnetName string `json:"subnetName,omitempty"`
        }

        // AzureMachinePoolSpec defines the desired state of AzureMachinePool.
        AzureMachinePoolSpec struct {
                // Location is the Azure region location e.g. westus2
                Location string `json:"location"`

                // Template contains the details used to build a replica virtual machine within the Machine Pool
                Template AzureMachinePoolMachineTemplate `json:"template"`

                // AdditionalTags is an optional set of tags to add to an instance, in addition to the ones added by default by the
                // Azure provider. If both the AzureCluster and the AzureMachine specify the same tag name with different values, the
                // AzureMachine's value takes precedence.
                // +optional
                AdditionalTags infrav1.Tags `json:"additionalTags,omitempty"`

                // ProviderID is the identification ID of the Virtual Machine Scale Set
                // +optional
                ProviderID string `json:"providerID,omitempty"`

                // ProviderIDList are the identification IDs of machine instances provided by the provider.
                // This field must match the provider IDs as seen on the node objects corresponding to a machine pool's machine instances.
                // +optional
                ProviderIDList []string `json:"providerIDList,omitempty"`

                // Identity is the type of identity used for the Virtual Machine Scale Set.
                // The type 'SystemAssigned' is an implicitly created identity.
                // The generated identity will be assigned a Subscription contributor role.
                // The type 'UserAssigned' is a standalone Azure resource provided by the user
                // and assigned to the VM
                // +kubebuilder:default=None
                // +optional
                Identity infrav1.VMIdentity `json:"identity,omitempty"`

                // UserAssignedIdentities is a list of standalone Azure identities provided by the user
                // The lifecycle of a user-assigned identity is managed separately from the lifecycle of
                // the AzureMachinePool.
                // See https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/how-to-manage-ua-identity-cli
                // +optional
                UserAssignedIdentities []infrav1.UserAssignedIdentity `json:"userAssignedIdentities,omitempty"`

                // RoleAssignmentName is the name of the role assignment to create for a system assigned identity. It can be any valid GUID.
                // If not specified, a random GUID will be generated.
                // +optional
                RoleAssignmentName string `json:"roleAssignmentName,omitempty"`

                // The deployment strategy to use to replace existing AzureMachinePoolMachines with new ones.
                // +optional
                // +kubebuilder:default={type: "RollingUpdate", rollingUpdate: {maxSurge: 1, maxUnavailable: 0, deletePolicy: Oldest}}
                Strategy AzureMachinePoolDeploymentStrategy `json:"strategy,omitempty"`

                // NodeDrainTimeout is the total amount of time that the controller will spend on draining a node.
                // The default value is 0, meaning that the node can be drained without any time limitations.
                // NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
                // +optional
                NodeDrainTimeout *metav1.Duration `json:"nodeDrainTimeout,omitempty"`
        }

        // AzureMachinePoolDeploymentStrategyType is the type of deployment strategy employed to rollout a new version of
        // the AzureMachinePool.
        AzureMachinePoolDeploymentStrategyType string

        // AzureMachinePoolDeploymentStrategy describes how to replace existing machines with new ones.
        AzureMachinePoolDeploymentStrategy struct {
                // Type of deployment. Currently the only supported strategy is RollingUpdate
                // +optional
                // +kubebuilder:validation:Enum=RollingUpdate
                // +optional
                // +kubebuilder:default=RollingUpdate
                Type AzureMachinePoolDeploymentStrategyType `json:"type,omitempty"`

                // Rolling update config params. Present only if
                // MachineDeploymentStrategyType = RollingUpdate.
                // +optional
                RollingUpdate *MachineRollingUpdateDeployment `json:"rollingUpdate,omitempty"`
        }

        // AzureMachinePoolDeletePolicyType is the type of DeletePolicy employed to select machines to be deleted during an
        // upgrade.
        AzureMachinePoolDeletePolicyType string

        // MachineRollingUpdateDeployment is used to control the desired behavior of rolling update.
        MachineRollingUpdateDeployment struct {
                // The maximum number of machines that can be unavailable during the update.
                // Value can be an absolute number (ex: 5) or a percentage of desired
                // machines (ex: 10%).
                // Absolute number is calculated from percentage by rounding down.
                // This can not be 0 if MaxSurge is 0.
                // Defaults to 0.
                // Example: when this is set to 30%, the old MachineSet can be scaled
                // down to 70% of desired machines immediately when the rolling update
                // starts. Once new machines are ready, old MachineSet can be scaled
                // down further, followed by scaling up the new MachineSet, ensuring
                // that the total number of machines available at all times
                // during the update is at least 70% of desired machines.
                // +optional
                // +kubebuilder:default:=0
                MaxUnavailable *intstr.IntOrString `json:"maxUnavailable,omitempty"`

                // The maximum number of machines that can be scheduled above the
                // desired number of machines.
                // Value can be an absolute number (ex: 5) or a percentage of
                // desired machines (ex: 10%).
                // This can not be 0 if MaxUnavailable is 0.
                // Absolute number is calculated from percentage by rounding up.
                // Defaults to 1.
                // Example: when this is set to 30%, the new MachineSet can be scaled
                // up immediately when the rolling update starts, such that the total
                // number of old and new machines do not exceed 130% of desired
                // machines. Once old machines have been killed, new MachineSet can
                // be scaled up further, ensuring that total number of machines running
                // at any time during the update is at most 130% of desired machines.
                // +optional
                // +kubebuilder:default:=1
                MaxSurge *intstr.IntOrString `json:"maxSurge,omitempty"`

                // DeletePolicy defines the policy used by the MachineDeployment to identify nodes to delete when downscaling.
                // Valid values are "Random, "Newest", "Oldest"
                // When no value is supplied, the default is Oldest
                // +optional
                // +kubebuilder:validation:Enum=Random;Newest;Oldest
                // +kubebuilder:default:=Oldest
                DeletePolicy AzureMachinePoolDeletePolicyType `json:"deletePolicy,omitempty"`
        }

        // AzureMachinePoolStatus defines the observed state of AzureMachinePool.
        AzureMachinePoolStatus struct {
                // Ready is true when the provider resource is ready.
                // +optional
                Ready bool `json:"ready"`

                // Replicas is the most recently observed number of replicas.
                // +optional
                Replicas int32 `json:"replicas"`

                // Instances is the VM instance status for each VM in the VMSS
                // +optional
                Instances []*AzureMachinePoolInstanceStatus `json:"instances,omitempty"`

                // Image is the current image used in the AzureMachinePool. When the spec image is nil, this image is populated
                // with the details of the defaulted Azure Marketplace "capi" offer.
                // +optional
                Image *infrav1.Image `json:"image,omitempty"`

                // Version is the Kubernetes version for the current VMSS model
                // +optional
                Version string `json:"version"`

                // ProvisioningState is the provisioning state of the Azure virtual machine.
                // +optional
                ProvisioningState *infrav1.ProvisioningState `json:"provisioningState,omitempty"`

                // FailureReason will be set in the event that there is a terminal problem
                // reconciling the MachinePool and will contain a succinct value suitable
                // for machine interpretation.
                //
                // This field should not be set for transitive errors that a controller
                // faces that are expected to be fixed automatically over
                // time (like service outages), but instead indicate that something is
                // fundamentally wrong with the MachinePool's spec or the configuration of
                // the controller, and that manual intervention is required. Examples
                // of terminal errors would be invalid combinations of settings in the
                // spec, values that are unsupported by the controller, or the
                // responsible controller itself being critically misconfigured.
                //
                // Any transient errors that occur during the reconciliation of MachinePools
                // can be added as events to the MachinePool object and/or logged in the
                // controller's output.
                // +optional
                FailureReason *errors.MachineStatusError `json:"failureReason,omitempty"`

                // FailureMessage will be set in the event that there is a terminal problem
                // reconciling the MachinePool and will contain a more verbose string suitable
                // for logging and human consumption.
                //
                // This field should not be set for transitive errors that a controller
                // faces that are expected to be fixed automatically over
                // time (like service outages), but instead indicate that something is
                // fundamentally wrong with the MachinePool's spec or the configuration of
                // the controller, and that manual intervention is required. Examples
                // of terminal errors would be invalid combinations of settings in the
                // spec, values that are unsupported by the controller, or the
                // responsible controller itself being critically misconfigured.
                //
                // Any transient errors that occur during the reconciliation of MachinePools
                // can be added as events to the MachinePool object and/or logged in the
                // controller's output.
                // +optional
                FailureMessage *string `json:"failureMessage,omitempty"`

                // Conditions defines current service state of the AzureMachinePool.
                // +optional
                Conditions clusterv1.Conditions `json:"conditions,omitempty"`

                // LongRunningOperationStates saves the state for Azure long-running operations so they can be continued on the
                // next reconciliation loop.
                // +optional
                LongRunningOperationStates infrav1.Futures `json:"longRunningOperationStates,omitempty"`
        }

        // AzureMachinePoolInstanceStatus provides status information for each instance in the VMSS.
        AzureMachinePoolInstanceStatus struct {
                // Version defines the Kubernetes version for the VM Instance
                // +optional
                Version string `json:"version"`

                // ProvisioningState is the provisioning state of the Azure virtual machine instance.
                // +optional
                ProvisioningState *infrav1.ProvisioningState `json:"provisioningState"`

                // ProviderID is the provider identification of the VMSS Instance
                // +optional
                ProviderID string `json:"providerID"`

                // InstanceID is the identification of the Machine Instance within the VMSS
                // +optional
                InstanceID string `json:"instanceID"`

                // InstanceName is the name of the Machine Instance within the VMSS
                // +optional
                InstanceName string `json:"instanceName"`

                // LatestModelApplied indicates the instance is running the most up-to-date VMSS model. A VMSS model describes
                // the image version the VM is running. If the instance is not running the latest model, it means the instance
                // may not be running the version of Kubernetes the Machine Pool has specified and needs to be updated.
                LatestModelApplied bool `json:"latestModelApplied"`
        }

        // +kubebuilder:object:root=true
        // +kubebuilder:subresource:status
        // +kubebuilder:resource:path=azuremachinepools,scope=Namespaced,categories=cluster-api,shortName=amp
        // +kubebuilder:storageversion
        // +kubebuilder:printcolumn:name="Replicas",type="string",JSONPath=".status.replicas",description="AzureMachinePool replicas count"
        // +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.ready",description="AzureMachinePool replicas count"
        // +kubebuilder:printcolumn:name="State",type="string",JSONPath=".status.provisioningState",description="Azure VMSS provisioning state"
        // +kubebuilder:printcolumn:name="Cluster",type="string",priority=1,JSONPath=".metadata.labels.cluster\\.x-k8s\\.io/cluster-name",description="Cluster to which this AzureMachinePool belongs"
        // +kubebuilder:printcolumn:name="MachinePool",type="string",priority=1,JSONPath=".metadata.ownerReferences[?(@.kind==\"MachinePool\")].name",description="MachinePool object to which this AzureMachinePool belongs"
        // +kubebuilder:printcolumn:name="VMSS ID",type="string",priority=1,JSONPath=".spec.providerID",description="Azure VMSS ID"
        // +kubebuilder:printcolumn:name="VM Size",type="string",priority=1,JSONPath=".spec.template.vmSize",description="Azure VM Size"

        // AzureMachinePool is the Schema for the azuremachinepools API.
        AzureMachinePool struct {
                metav1.TypeMeta   `json:",inline"`
                metav1.ObjectMeta `json:"metadata,omitempty"`

                Spec   AzureMachinePoolSpec   `json:"spec,omitempty"`
                Status AzureMachinePoolStatus `json:"status,omitempty"`
        }

        // +kubebuilder:object:root=true

        // AzureMachinePoolList contains a list of AzureMachinePools.
        AzureMachinePoolList struct {
                metav1.TypeMeta `json:",inline"`
                metav1.ListMeta `json:"metadata,omitempty"`
                Items           []AzureMachinePool `json:"items"`
        }
)

// GetConditions returns the list of conditions for an AzureMachinePool API object.
func (amp *AzureMachinePool) GetConditions() clusterv1.Conditions <span class="cov0" title="0">{
        return amp.Status.Conditions
}</span>

// SetConditions will set the given conditions on an AzureMachinePool object.
func (amp *AzureMachinePool) SetConditions(conditions clusterv1.Conditions) <span class="cov0" title="0">{
        amp.Status.Conditions = conditions
}</span>

// GetFutures returns the list of long running operation states for an AzureMachinePool API object.
func (amp *AzureMachinePool) GetFutures() infrav1.Futures <span class="cov0" title="0">{
        return amp.Status.LongRunningOperationStates
}</span>

// SetFutures will set the given long running operation states on an AzureMachinePool object.
func (amp *AzureMachinePool) SetFutures(futures infrav1.Futures) <span class="cov0" title="0">{
        amp.Status.LongRunningOperationStates = futures
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;AzureMachinePool{}, &amp;AzureMachinePoolList{})
}</span>
</pre>
		
		<pre class="file" id="file194" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "errors"
        "fmt"
        "reflect"

        "k8s.io/apimachinery/pkg/runtime"
        kerrors "k8s.io/apimachinery/pkg/util/errors"
        "k8s.io/apimachinery/pkg/util/intstr"
        "k8s.io/apimachinery/pkg/util/validation/field"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/feature"
        capifeature "sigs.k8s.io/cluster-api/feature"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/webhook"
)

// SetupWebhookWithManager sets up and registers the webhook with the manager.
func (amp *AzureMachinePool) SetupWebhookWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewWebhookManagedBy(mgr).
                For(amp).
                Complete()
}</span>

// +kubebuilder:webhook:path=/mutate-infrastructure-cluster-x-k8s-io-v1beta1-azuremachinepool,mutating=true,failurePolicy=fail,groups=infrastructure.cluster.x-k8s.io,resources=azuremachinepools,verbs=create;update,versions=v1beta1,name=default.azuremachinepool.infrastructure.cluster.x-k8s.io,sideEffects=None,admissionReviewVersions=v1;v1beta1

var _ webhook.Defaulter = &amp;AzureMachinePool{}

// Default implements webhook.Defaulter so a webhook will be registered for the type.
func (amp *AzureMachinePool) Default() <span class="cov8" title="1">{
        if err := amp.SetDefaultSSHPublicKey(); err != nil </span><span class="cov0" title="0">{
                ctrl.Log.WithName("AzureMachinePoolLogger").Error(err, "SetDefaultSshPublicKey failed")
        }</span>
        <span class="cov8" title="1">amp.SetIdentityDefaults()</span>
}

// +kubebuilder:webhook:verbs=create;update,path=/validate-infrastructure-cluster-x-k8s-io-v1beta1-azuremachinepool,mutating=false,failurePolicy=fail,groups=infrastructure.cluster.x-k8s.io,resources=azuremachinepools,versions=v1beta1,name=validation.azuremachinepool.infrastructure.cluster.x-k8s.io,sideEffects=None,admissionReviewVersions=v1;v1beta1

var _ webhook.Validator = &amp;AzureMachinePool{}

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type.
func (amp *AzureMachinePool) ValidateCreate() error <span class="cov8" title="1">{
        return amp.Validate(nil)
}</span>

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type.
func (amp *AzureMachinePool) ValidateUpdate(old runtime.Object) error <span class="cov8" title="1">{
        return amp.Validate(old)
}</span>

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type.
func (amp *AzureMachinePool) ValidateDelete() error <span class="cov0" title="0">{
        return nil
}</span>

// Validate the Azure Machine Pool and return an aggregate error.
func (amp *AzureMachinePool) Validate(old runtime.Object) error <span class="cov8" title="1">{
        // NOTE: AzureMachinePool is behind MachinePool feature gate flag; the web hook
        // must prevent creating new objects new case the feature flag is disabled.
        if !feature.Gates.Enabled(capifeature.MachinePool) </span><span class="cov0" title="0">{
                return field.Forbidden(
                        field.NewPath("spec"),
                        "can be set only if the MachinePool feature flag is enabled",
                )
        }</span>

        <span class="cov8" title="1">validators := []func() error{
                amp.ValidateImage,
                amp.ValidateTerminateNotificationTimeout,
                amp.ValidateSSHKey,
                amp.ValidateUserAssignedIdentity,
                amp.ValidateStrategy(),
                amp.ValidateSystemAssignedIdentity(old),
        }

        var errs []error
        for _, validator := range validators </span><span class="cov8" title="1">{
                if err := validator(); err != nil </span><span class="cov8" title="1">{
                        errs = append(errs, err)
                }</span>
        }

        <span class="cov8" title="1">return kerrors.NewAggregate(errs)</span>
}

// ValidateImage of an AzureMachinePool.
func (amp *AzureMachinePool) ValidateImage() error <span class="cov8" title="1">{
        if amp.Spec.Template.Image != nil </span><span class="cov8" title="1">{
                image := amp.Spec.Template.Image
                if errs := infrav1.ValidateImage(image, field.NewPath("image")); len(errs) &gt; 0 </span><span class="cov8" title="1">{
                        agg := kerrors.NewAggregate(errs.ToAggregate().Errors())
                        return agg
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateTerminateNotificationTimeout termination notification timeout to be between 5 and 15.
func (amp *AzureMachinePool) ValidateTerminateNotificationTimeout() error <span class="cov8" title="1">{
        if amp.Spec.Template.TerminateNotificationTimeout == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if *amp.Spec.Template.TerminateNotificationTimeout &lt; 5 </span><span class="cov8" title="1">{
                return errors.New("minimum timeout 5 is allowed for TerminateNotificationTimeout")
        }</span>

        <span class="cov8" title="1">if *amp.Spec.Template.TerminateNotificationTimeout &gt; 15 </span><span class="cov8" title="1">{
                return errors.New("maximum timeout 15 is allowed for TerminateNotificationTimeout")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateSSHKey validates an SSHKey.
func (amp *AzureMachinePool) ValidateSSHKey() error <span class="cov8" title="1">{
        if amp.Spec.Template.SSHPublicKey != "" </span><span class="cov8" title="1">{
                sshKey := amp.Spec.Template.SSHPublicKey
                if errs := infrav1.ValidateSSHKey(sshKey, field.NewPath("sshKey")); len(errs) &gt; 0 </span><span class="cov8" title="1">{
                        agg := kerrors.NewAggregate(errs.ToAggregate().Errors())
                        return agg
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateUserAssignedIdentity validates the user-assigned identities list.
func (amp *AzureMachinePool) ValidateUserAssignedIdentity() error <span class="cov8" title="1">{
        fldPath := field.NewPath("UserAssignedIdentities")
        if errs := infrav1.ValidateUserAssignedIdentity(amp.Spec.Identity, amp.Spec.UserAssignedIdentities, fldPath); len(errs) &gt; 0 </span><span class="cov8" title="1">{
                return kerrors.NewAggregate(errs.ToAggregate().Errors())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateStrategy validates the strategy.
func (amp *AzureMachinePool) ValidateStrategy() func() error <span class="cov8" title="1">{
        return func() error </span><span class="cov8" title="1">{
                if amp.Spec.Strategy.Type == RollingUpdateAzureMachinePoolDeploymentStrategyType &amp;&amp; amp.Spec.Strategy.RollingUpdate != nil </span><span class="cov8" title="1">{
                        rollingUpdateStrategy := amp.Spec.Strategy.RollingUpdate
                        maxSurge := rollingUpdateStrategy.MaxSurge
                        maxUnavailable := rollingUpdateStrategy.MaxUnavailable
                        if maxSurge.Type == intstr.Int &amp;&amp; maxSurge.IntVal == 0 &amp;&amp;
                                maxUnavailable.Type == intstr.Int &amp;&amp; maxUnavailable.IntVal == 0 </span><span class="cov8" title="1">{
                                return errors.New("rolling update strategy MaxUnavailable must not be 0 if MaxSurge is 0")
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        }
}

// ValidateSystemAssignedIdentity validates system-assigned identity role.
func (amp *AzureMachinePool) ValidateSystemAssignedIdentity(old runtime.Object) func() error <span class="cov8" title="1">{
        return func() error </span><span class="cov8" title="1">{
                var oldRole string
                if old != nil </span><span class="cov8" title="1">{
                        oldMachinePool, ok := old.(*AzureMachinePool)
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type for old azure machine pool object. Expected: %q, Got: %q",
                                        "AzureMachinePool", reflect.TypeOf(old))
                        }</span>
                        <span class="cov8" title="1">oldRole = oldMachinePool.Spec.RoleAssignmentName</span>
                }

                <span class="cov8" title="1">fldPath := field.NewPath("roleAssignmentName")
                if errs := infrav1.ValidateSystemAssignedIdentity(amp.Spec.Identity, oldRole, amp.Spec.RoleAssignmentName, fldPath); len(errs) &gt; 0 </span><span class="cov8" title="1">{
                        return kerrors.NewAggregate(errs.ToAggregate().Errors())
                }</span>

                <span class="cov8" title="1">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file195" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

// Hub marks AzureMachinePoolMachine as a conversion hub.
func (*AzureMachinePoolMachine) Hub() {<span class="cov0" title="0">}</span>

// Hub marks AzureMachinePoolMachineList as a conversion hub.
func (*AzureMachinePoolMachineList) Hub() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file196" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        "sigs.k8s.io/cluster-api/errors"
)

const (
        // AzureMachinePoolMachineFinalizer is used to ensure deletion of dependencies (nodes, infra).
        AzureMachinePoolMachineFinalizer = "azuremachinepoolmachine.infrastructure.cluster.x-k8s.io"
)

type (

        // AzureMachinePoolMachineSpec defines the desired state of AzureMachinePoolMachine.
        AzureMachinePoolMachineSpec struct {
                // ProviderID is the identification ID of the Virtual Machine Scale Set
                ProviderID string `json:"providerID"`

                // InstanceID is the identification of the Machine Instance within the VMSS
                InstanceID string `json:"instanceID"`
        }

        // AzureMachinePoolMachineStatus defines the observed state of AzureMachinePoolMachine.
        AzureMachinePoolMachineStatus struct {
                // NodeRef will point to the corresponding Node if it exists.
                // +optional
                NodeRef *corev1.ObjectReference `json:"nodeRef,omitempty"`

                // Version defines the Kubernetes version for the VM Instance
                // +optional
                Version string `json:"version"`

                // ProvisioningState is the provisioning state of the Azure virtual machine instance.
                // +optional
                ProvisioningState *infrav1.ProvisioningState `json:"provisioningState"`

                // InstanceName is the name of the Machine Instance within the VMSS
                // +optional
                InstanceName string `json:"instanceName"`

                // FailureReason will be set in the event that there is a terminal problem
                // reconciling the MachinePool machine and will contain a succinct value suitable
                // for machine interpretation.
                //
                // Any transient errors that occur during the reconciliation of MachinePools
                // can be added as events to the MachinePool object and/or logged in the
                // controller's output.
                // +optional
                FailureReason *errors.MachineStatusError `json:"failureReason,omitempty"`

                // FailureMessage will be set in the event that there is a terminal problem
                // reconciling the MachinePool and will contain a more verbose string suitable
                // for logging and human consumption.
                //
                // Any transient errors that occur during the reconciliation of MachinePools
                // can be added as events to the MachinePool object and/or logged in the
                // controller's output.
                // +optional
                FailureMessage *string `json:"failureMessage,omitempty"`

                // Conditions defines current service state of the AzureMachinePool.
                // +optional
                Conditions clusterv1.Conditions `json:"conditions,omitempty"`

                // LongRunningOperationStates saves the state for Azure long running operations so they can be continued on the
                // next reconciliation loop.
                // +optional
                LongRunningOperationStates infrav1.Futures `json:"longRunningOperationStates,omitempty"`

                // LatestModelApplied indicates the instance is running the most up-to-date VMSS model. A VMSS model describes
                // the image version the VM is running. If the instance is not running the latest model, it means the instance
                // may not be running the version of Kubernetes the Machine Pool has specified and needs to be updated.
                LatestModelApplied bool `json:"latestModelApplied"`

                // Ready is true when the provider resource is ready.
                // +optional
                Ready bool `json:"ready"`
        }

        // +kubebuilder:object:root=true
        // +kubebuilder:subresource:status
        // +kubebuilder:resource:path=azuremachinepoolmachines,scope=Namespaced,categories=cluster-api,shortName=ampm
        // +kubebuilder:printcolumn:name="Version",type="string",JSONPath=".status.version",description="Kubernetes version"
        // +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.ready",description="Flag indicating infrastructure is successfully provisioned"
        // +kubebuilder:printcolumn:name="State",type="string",JSONPath=".status.provisioningState",description="Azure VMSS VM provisioning state"
        // +kubebuilder:printcolumn:name="Cluster",type="string",priority=1,JSONPath=".metadata.labels.cluster\\.x-k8s\\.io/cluster-name",description="Cluster to which this AzureMachinePoolMachine belongs"
        // +kubebuilder:printcolumn:name="VMSS VM ID",type="string",priority=1,JSONPath=".spec.providerID",description="Azure VMSS VM ID"
        // +kubebuilder:storageversion

        // AzureMachinePoolMachine is the Schema for the azuremachinepoolmachines API.
        AzureMachinePoolMachine struct {
                metav1.TypeMeta   `json:",inline"`
                metav1.ObjectMeta `json:"metadata,omitempty"`

                Spec   AzureMachinePoolMachineSpec   `json:"spec,omitempty"`
                Status AzureMachinePoolMachineStatus `json:"status,omitempty"`
        }

        // +kubebuilder:object:root=true

        // AzureMachinePoolMachineList contains a list of AzureMachinePoolMachines.
        AzureMachinePoolMachineList struct {
                metav1.TypeMeta `json:",inline"`
                metav1.ListMeta `json:"metadata,omitempty"`
                Items           []AzureMachinePoolMachine `json:"items"`
        }
)

// GetConditions returns the list of conditions for an AzureMachinePool API object.
func (ampm *AzureMachinePoolMachine) GetConditions() clusterv1.Conditions <span class="cov0" title="0">{
        return ampm.Status.Conditions
}</span>

// SetConditions will set the given conditions on an AzureMachinePool object.
func (ampm *AzureMachinePoolMachine) SetConditions(conditions clusterv1.Conditions) <span class="cov0" title="0">{
        ampm.Status.Conditions = conditions
}</span>

// GetFutures returns the list of long running operation states for an AzureMachinePoolMachine API object.
func (ampm *AzureMachinePoolMachine) GetFutures() infrav1.Futures <span class="cov0" title="0">{
        return ampm.Status.LongRunningOperationStates
}</span>

// SetFutures will set the given long running operation states on an AzureMachinePoolMachine object.
func (ampm *AzureMachinePoolMachine) SetFutures(futures infrav1.Futures) <span class="cov0" title="0">{
        ampm.Status.LongRunningOperationStates = futures
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;AzureMachinePoolMachine{}, &amp;AzureMachinePoolMachineList{})
}</span>
</pre>
		
		<pre class="file" id="file197" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "github.com/pkg/errors"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/util/validation/field"
        "sigs.k8s.io/cluster-api-provider-azure/feature"
        capifeature "sigs.k8s.io/cluster-api/feature"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/webhook"
)

// SetupWebhookWithManager sets up and registers the webhook with the manager.
func (ampm *AzureMachinePoolMachine) SetupWebhookWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewWebhookManagedBy(mgr).
                For(ampm).
                Complete()
}</span>

// +kubebuilder:webhook:verbs=create;update,path=/validate-infrastructure-cluster-x-k8s-io-v1beta1-azuremachinepoolmachine,mutating=false,failurePolicy=fail,groups=infrastructure.cluster.x-k8s.io,resources=azuremachinepoolmachines,versions=v1beta1,name=azuremachinepoolmachine.kb.io,sideEffects=None,admissionReviewVersions=v1;v1beta1

var _ webhook.Validator = &amp;AzureMachinePoolMachine{}

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type.
func (ampm *AzureMachinePoolMachine) ValidateCreate() error <span class="cov0" title="0">{
        return nil
}</span>

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type.
func (ampm *AzureMachinePoolMachine) ValidateUpdate(old runtime.Object) error <span class="cov0" title="0">{
        // NOTE: AzureMachinePoolMachine is behind MachinePool feature gate flag; the web hook
        // must prevent creating new objects new case the feature flag is disabled.
        if !feature.Gates.Enabled(capifeature.MachinePool) </span><span class="cov0" title="0">{
                return field.Forbidden(
                        field.NewPath("spec"),
                        "can be set only if the MachinePool feature flag is enabled",
                )
        }</span>

        <span class="cov0" title="0">oldMachine, ok := old.(*AzureMachinePoolMachine)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("expected and AzureMachinePoolMachine")
        }</span>

        <span class="cov0" title="0">if oldMachine.Spec.ProviderID != "" &amp;&amp; ampm.Spec.ProviderID != oldMachine.Spec.ProviderID </span><span class="cov0" title="0">{
                return errors.New("providerID is immutable")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type.
func (ampm *AzureMachinePoolMachine) ValidateDelete() error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file198" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

// Hub marks AzureManagedCluster as a conversion hub.
func (*AzureManagedCluster) Hub() {<span class="cov0" title="0">}</span>

// Hub marks AzureManagedClusterList as a conversion hub.
func (*AzureManagedClusterList) Hub() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file199" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
)

// AzureManagedClusterSpec defines the desired state of AzureManagedCluster.
type AzureManagedClusterSpec struct {
        // ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
        // +optional
        ControlPlaneEndpoint clusterv1.APIEndpoint `json:"controlPlaneEndpoint"`
}

// AzureManagedClusterStatus defines the observed state of AzureManagedCluster.
type AzureManagedClusterStatus struct {
        // Ready is true when the provider resource is ready.
        // +optional
        Ready bool `json:"ready,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:path=azuremanagedclusters,scope=Namespaced,categories=cluster-api,shortName=amc
// +kubebuilder:storageversion
// +kubebuilder:subresource:status

// AzureManagedCluster is the Schema for the azuremanagedclusters API.
type AzureManagedCluster struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   AzureManagedClusterSpec   `json:"spec,omitempty"`
        Status AzureManagedClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AzureManagedClusterList contains a list of AzureManagedClusters.
type AzureManagedClusterList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []AzureManagedCluster `json:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;AzureManagedCluster{}, &amp;AzureManagedClusterList{})
}</span>
</pre>
		
		<pre class="file" id="file200" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "fmt"
        "reflect"

        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/util/validation/field"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/feature"
        "sigs.k8s.io/cluster-api-provider-azure/util/maps"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/webhook"
)

// SetupWebhookWithManager sets up and registers the webhook with the manager.
func (r *AzureManagedCluster) SetupWebhookWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewWebhookManagedBy(mgr).
                For(r).
                Complete()
}</span>

// +kubebuilder:webhook:verbs=update,path=/validate-infrastructure-cluster-x-k8s-io-v1beta1-azuremanagedcluster,mutating=false,failurePolicy=fail,groups=infrastructure.cluster.x-k8s.io,resources=azuremanagedclusters,versions=v1beta1,name=validation.azuremanagedclusters.infrastructure.cluster.x-k8s.io,sideEffects=None,admissionReviewVersions=v1;v1beta1

var _ webhook.Validator = &amp;AzureManagedCluster{}

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type.
func (r *AzureManagedCluster) ValidateCreate() error <span class="cov0" title="0">{
        return nil
}</span>

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type.
func (r *AzureManagedCluster) ValidateUpdate(oldRaw runtime.Object) error <span class="cov8" title="1">{
        // NOTE: AzureManagedCluster is behind AKS feature gate flag; the web hook
        // must prevent creating new objects new case the feature flag is disabled.
        if !feature.Gates.Enabled(feature.AKS) </span><span class="cov0" title="0">{
                return field.Forbidden(
                        field.NewPath("spec"),
                        "can be set only if the AKS feature flag is enabled",
                )
        }</span>

        <span class="cov8" title="1">old := oldRaw.(*AzureManagedCluster)
        var allErrs field.ErrorList

        // custom headers are immutable
        oldCustomHeaders := maps.FilterByKeyPrefix(old.ObjectMeta.Annotations, azure.CustomHeaderPrefix)
        newCustomHeaders := maps.FilterByKeyPrefix(r.ObjectMeta.Annotations, azure.CustomHeaderPrefix)
        if !reflect.DeepEqual(oldCustomHeaders, newCustomHeaders) </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(
                                field.NewPath("metadata", "annotations"),
                                r.ObjectMeta.Annotations,
                                fmt.Sprintf("annotations with '%s' prefix are immutable", azure.CustomHeaderPrefix)))
        }</span>

        <span class="cov8" title="1">if len(allErrs) != 0 </span><span class="cov8" title="1">{
                return apierrors.NewInvalid(GroupVersion.WithKind("AzureManagedCluster").GroupKind(), r.Name, allErrs)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type.
func (r *AzureManagedCluster) ValidateDelete() error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file201" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

// Hub marks AzureManagedControlPlane as a conversion hub.
func (*AzureManagedControlPlane) Hub() {<span class="cov0" title="0">}</span>

// Hub marks AzureManagedControlPlaneList as a conversion hub.
func (*AzureManagedControlPlaneList) Hub() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file202" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "encoding/base64"
        "fmt"

        "golang.org/x/crypto/ssh"
        utilSSH "sigs.k8s.io/cluster-api-provider-azure/util/ssh"
)

const (
        // defaultAKSVnetCIDR is the default Vnet CIDR.
        defaultAKSVnetCIDR = "10.0.0.0/8"
        // defaultAKSNodeSubnetCIDR is the default Node Subnet CIDR.
        defaultAKSNodeSubnetCIDR = "10.240.0.0/16"
)

// setDefaultSSHPublicKey sets the default SSHPublicKey for an AzureManagedControlPlane.
func (m *AzureManagedControlPlane) setDefaultSSHPublicKey() error <span class="cov8" title="1">{
        if sshKeyData := m.Spec.SSHPublicKey; sshKeyData == "" </span><span class="cov8" title="1">{
                _, publicRsaKey, err := utilSSH.GenerateSSHKey()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">m.Spec.SSHPublicKey = base64.StdEncoding.EncodeToString(ssh.MarshalAuthorizedKey(publicRsaKey))</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// setDefaultNodeResourceGroupName sets the default NodeResourceGroup for an AzureManagedControlPlane.
func (m *AzureManagedControlPlane) setDefaultNodeResourceGroupName() <span class="cov8" title="1">{
        if m.Spec.NodeResourceGroupName == "" </span><span class="cov8" title="1">{
                m.Spec.NodeResourceGroupName = fmt.Sprintf("MC_%s_%s_%s", m.Spec.ResourceGroupName, m.Name, m.Spec.Location)
        }</span>
}

// setDefaultVirtualNetwork sets the default VirtualNetwork for an AzureManagedControlPlane.
func (m *AzureManagedControlPlane) setDefaultVirtualNetwork() <span class="cov8" title="1">{
        if m.Spec.VirtualNetwork.Name == "" </span><span class="cov8" title="1">{
                m.Spec.VirtualNetwork.Name = m.Name
        }</span>
        <span class="cov8" title="1">if m.Spec.VirtualNetwork.CIDRBlock == "" </span><span class="cov8" title="1">{
                m.Spec.VirtualNetwork.CIDRBlock = defaultAKSVnetCIDR
        }</span>
}

// setDefaultSubnet sets the default Subnet for an AzureManagedControlPlane.
func (m *AzureManagedControlPlane) setDefaultSubnet() <span class="cov8" title="1">{
        if m.Spec.VirtualNetwork.Subnet.Name == "" </span><span class="cov8" title="1">{
                m.Spec.VirtualNetwork.Subnet.Name = m.Name
        }</span>
        <span class="cov8" title="1">if m.Spec.VirtualNetwork.Subnet.CIDRBlock == "" </span><span class="cov8" title="1">{
                m.Spec.VirtualNetwork.Subnet.CIDRBlock = defaultAKSNodeSubnetCIDR
        }</span>
}

func (m *AzureManagedControlPlane) setDefaultSku() <span class="cov8" title="1">{
        if m.Spec.SKU == nil </span><span class="cov8" title="1">{
                m.Spec.SKU = &amp;SKU{
                        Tier: FreeManagedControlPlaneTier,
                }
        }</span>
}
</pre>
		
		<pre class="file" id="file203" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
)

const (
        // ManagedClusterFinalizer allows Reconcile to clean up Azure resources associated with the AzureManagedControlPlane before
        // removing it from the apiserver.
        ManagedClusterFinalizer = "azuremanagedcontrolplane.infrastructure.cluster.x-k8s.io"

        // PrivateDNSZoneModeSystem represents mode System for azuremanagedcontrolplane.
        PrivateDNSZoneModeSystem string = "System"

        // PrivateDNSZoneModeNone represents mode None for azuremanagedcontrolplane.
        PrivateDNSZoneModeNone string = "None"
)

// AzureManagedControlPlaneSpec defines the desired state of AzureManagedControlPlane.
type AzureManagedControlPlaneSpec struct {
        // Version defines the desired Kubernetes version.
        // +kubebuilder:validation:MinLength:=2
        Version string `json:"version"`

        // ResourceGroupName is the name of the Azure resource group for this AKS Cluster.
        ResourceGroupName string `json:"resourceGroupName"`

        // NodeResourceGroupName is the name of the resource group
        // containing cluster IaaS resources. Will be populated to default
        // in webhook.
        // +optional
        NodeResourceGroupName string `json:"nodeResourceGroupName,omitempty"`

        // VirtualNetwork describes the vnet for the AKS cluster. Will be created if it does not exist.
        // +optional
        VirtualNetwork ManagedControlPlaneVirtualNetwork `json:"virtualNetwork,omitempty"`

        // SubscriptionID is the GUID of the Azure subscription to hold this cluster.
        // +optional
        SubscriptionID string `json:"subscriptionID,omitempty"`

        // Location is a string matching one of the canonical Azure region names. Examples: "westus2", "eastus".
        Location string `json:"location"`

        // ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
        // +optional
        ControlPlaneEndpoint clusterv1.APIEndpoint `json:"controlPlaneEndpoint,omitempty"`

        // AdditionalTags is an optional set of tags to add to Azure resources managed by the Azure provider, in addition to the
        // ones added by default.
        // +optional
        AdditionalTags infrav1.Tags `json:"additionalTags,omitempty"`

        // NetworkPlugin used for building Kubernetes network.
        // +kubebuilder:validation:Enum=azure;kubenet
        // +optional
        NetworkPlugin *string `json:"networkPlugin,omitempty"`

        // NetworkPolicy used for building Kubernetes network.
        // +kubebuilder:validation:Enum=azure;calico
        // +optional
        NetworkPolicy *string `json:"networkPolicy,omitempty"`

        // SSHPublicKey is a string literal containing an ssh public key base64 encoded.
        SSHPublicKey string `json:"sshPublicKey"`

        // DNSServiceIP is an IP address assigned to the Kubernetes DNS service.
        // It must be within the Kubernetes service address range specified in serviceCidr.
        // +optional
        DNSServiceIP *string `json:"dnsServiceIP,omitempty"`

        // LoadBalancerSKU is the SKU of the loadBalancer to be provisioned.
        // +kubebuilder:validation:Enum=Basic;Standard
        // +optional
        LoadBalancerSKU *string `json:"loadBalancerSKU,omitempty"`

        // IdentityRef is a reference to a AzureClusterIdentity to be used when reconciling this cluster
        // +optional
        IdentityRef *corev1.ObjectReference `json:"identityRef,omitempty"`

        // AadProfile is Azure Active Directory configuration to integrate with AKS for aad authentication.
        // +optional
        AADProfile *AADProfile `json:"aadProfile,omitempty"`

        // AddonProfiles are the profiles of managed cluster add-on.
        // +optional
        AddonProfiles []AddonProfile `json:"addonProfiles,omitempty"`

        // SKU is the SKU of the AKS to be provisioned.
        // +optional
        SKU *SKU `json:"sku,omitempty"`

        // LoadBalancerProfile is the profile of the cluster load balancer.
        // +optional
        LoadBalancerProfile *LoadBalancerProfile `json:"loadBalancerProfile,omitempty"`

        // APIServerAccessProfile is the access profile for AKS API server.
        // +optional
        APIServerAccessProfile *APIServerAccessProfile `json:"apiServerAccessProfile,omitempty"`
}

// AADProfile - AAD integration managed by AKS.
type AADProfile struct {
        // Managed - Whether to enable managed AAD.
        // +kubebuilder:validation:Required
        Managed bool `json:"managed"`

        // AdminGroupObjectIDs - AAD group object IDs that will have admin role of the cluster.
        // +kubebuilder:validation:Required
        AdminGroupObjectIDs []string `json:"adminGroupObjectIDs"`
}

// AddonProfile represents a managed cluster add-on.
type AddonProfile struct {
        // Name - The name of the managed cluster add-on.
        Name string `json:"name"`

        // Config - Key-value pairs for configuring the add-on.
        // +optional
        Config map[string]string `json:"config,omitempty"`

        // Enabled - Whether the add-on is enabled or not.
        Enabled bool `json:"enabled"`
}

// AzureManagedControlPlaneSkuTier - Tier of a managed cluster SKU.
// +kubebuilder:validation:Enum=Free;Paid
type AzureManagedControlPlaneSkuTier string

const (
        // FreeManagedControlPlaneTier is the free tier of AKS without corresponding SLAs.
        FreeManagedControlPlaneTier AzureManagedControlPlaneSkuTier = "Free"
        // PaidManagedControlPlaneTier is the paid tier of AKS with corresponding SLAs.
        PaidManagedControlPlaneTier AzureManagedControlPlaneSkuTier = "Paid"
)

// SKU - AKS SKU.
type SKU struct {
        // Tier - Tier of a managed cluster SKU.
        Tier AzureManagedControlPlaneSkuTier `json:"tier"`
}

// LoadBalancerProfile - Profile of the cluster load balancer.
type LoadBalancerProfile struct {
        // Load balancer profile must specify at most one of ManagedOutboundIPs, OutboundIPPrefixes and OutboundIPs.
        // By default the AKS cluster automatically creates a public IP in the AKS-managed infrastructure resource group and assigns it to the load balancer outbound pool.
        // Alternatively, you can assign your own custom public IP or public IP prefix at cluster creation time.
        // See https://docs.microsoft.com/en-us/azure/aks/load-balancer-standard#provide-your-own-outbound-public-ips-or-prefixes

        // ManagedOutboundIPs - Desired managed outbound IPs for the cluster load balancer.
        // +optional
        ManagedOutboundIPs *int32 `json:"managedOutboundIPs,omitempty"`

        // OutboundIPPrefixes - Desired outbound IP Prefix resources for the cluster load balancer.
        // +optional
        OutboundIPPrefixes []string `json:"outboundIPPrefixes,omitempty"`

        // OutboundIPs - Desired outbound IP resources for the cluster load balancer.
        // +optional
        OutboundIPs []string `json:"outboundIPs,omitempty"`

        // AllocatedOutboundPorts - Desired number of allocated SNAT ports per VM. Allowed values must be in the range of 0 to 64000 (inclusive). The default value is 0 which results in Azure dynamically allocating ports.
        // +optional
        AllocatedOutboundPorts *int32 `json:"allocatedOutboundPorts,omitempty"`

        // IdleTimeoutInMinutes - Desired outbound flow idle timeout in minutes. Allowed values must be in the range of 4 to 120 (inclusive). The default value is 30 minutes.
        // +optional
        IdleTimeoutInMinutes *int32 `json:"idleTimeoutInMinutes,omitempty"`
}

// APIServerAccessProfile - access profile for AKS API server.
type APIServerAccessProfile struct {
        // AuthorizedIPRanges - Authorized IP Ranges to kubernetes API server.
        // +optional
        AuthorizedIPRanges []string `json:"authorizedIPRanges,omitempty"`
        // EnablePrivateCluster - Whether to create the cluster as a private cluster or not.
        // +optional
        EnablePrivateCluster *bool `json:"enablePrivateCluster,omitempty"`
        // PrivateDNSZone - Private dns zone mode for private cluster.
        // +kubebuilder:validation:Enum=System;None
        // +optional
        PrivateDNSZone *string `json:"privateDNSZone,omitempty"`
        // EnablePrivateClusterPublicFQDN - Whether to create additional public FQDN for private cluster or not.
        // +optional
        EnablePrivateClusterPublicFQDN *bool `json:"enablePrivateClusterPublicFQDN,omitempty"`
}

// ManagedControlPlaneVirtualNetwork describes a virtual network required to provision AKS clusters.
type ManagedControlPlaneVirtualNetwork struct {
        Name      string `json:"name"`
        CIDRBlock string `json:"cidrBlock"`
        // +optional
        Subnet ManagedControlPlaneSubnet `json:"subnet,omitempty"`
}

// ManagedControlPlaneSubnet describes a subnet for an AKS cluster.
type ManagedControlPlaneSubnet struct {
        Name      string `json:"name"`
        CIDRBlock string `json:"cidrBlock"`
}

// AzureManagedControlPlaneStatus defines the observed state of AzureManagedControlPlane.
type AzureManagedControlPlaneStatus struct {
        // Ready is true when the provider resource is ready.
        // +optional
        Ready bool `json:"ready,omitempty"`

        // Initialized is true when the control plane is available for initial contact.
        // This may occur before the control plane is fully ready.
        // In the AzureManagedControlPlane implementation, these are identical.
        // +optional
        Initialized bool `json:"initialized,omitempty"`

        // Conditions defines current service state of the AzureManagedControlPlane.
        // +optional
        Conditions clusterv1.Conditions `json:"conditions,omitempty"`

        // LongRunningOperationStates saves the states for Azure long-running operations so they can be continued on the
        // next reconciliation loop.
        // +optional
        LongRunningOperationStates infrav1.Futures `json:"longRunningOperationStates,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:path=azuremanagedcontrolplanes,scope=Namespaced,categories=cluster-api,shortName=amcp
// +kubebuilder:storageversion
// +kubebuilder:subresource:status

// AzureManagedControlPlane is the Schema for the azuremanagedcontrolplanes API.
type AzureManagedControlPlane struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   AzureManagedControlPlaneSpec   `json:"spec,omitempty"`
        Status AzureManagedControlPlaneStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AzureManagedControlPlaneList contains a list of AzureManagedControlPlane.
type AzureManagedControlPlaneList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []AzureManagedControlPlane `json:"items"`
}

// GetConditions returns the list of conditions for an AzureManagedControlPlane API object.
func (m *AzureManagedControlPlane) GetConditions() clusterv1.Conditions <span class="cov0" title="0">{
        return m.Status.Conditions
}</span>

// SetConditions will set the given conditions on an AzureManagedControlPlane object.
func (m *AzureManagedControlPlane) SetConditions(conditions clusterv1.Conditions) <span class="cov0" title="0">{
        m.Status.Conditions = conditions
}</span>

// GetFutures returns the list of long running operation states for an AzureManagedControlPlane API object.
func (m *AzureManagedControlPlane) GetFutures() infrav1.Futures <span class="cov0" title="0">{
        return m.Status.LongRunningOperationStates
}</span>

// SetFutures will set the given long running operation states on an AzureManagedControlPlane object.
func (m *AzureManagedControlPlane) SetFutures(futures infrav1.Futures) <span class="cov0" title="0">{
        m.Status.LongRunningOperationStates = futures
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;AzureManagedControlPlane{}, &amp;AzureManagedControlPlaneList{})
}</span>
</pre>
		
		<pre class="file" id="file204" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "errors"
        "fmt"
        "net"
        "reflect"
        "regexp"
        "strings"

        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        kerrors "k8s.io/apimachinery/pkg/util/errors"
        "k8s.io/apimachinery/pkg/util/validation/field"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

var kubeSemver = regexp.MustCompile(`^v(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)([-0-9a-zA-Z_\.+]*)?$`)

// SetupWebhookWithManager sets up and registers the webhook with the manager.
func (m *AzureManagedControlPlane) SetupWebhookWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewWebhookManagedBy(mgr).
                For(m).
                Complete()
}</span>

// +kubebuilder:webhook:path=/mutate-infrastructure-cluster-x-k8s-io-v1beta1-azuremanagedcontrolplane,mutating=true,failurePolicy=fail,groups=infrastructure.cluster.x-k8s.io,resources=azuremanagedcontrolplanes,verbs=create;update,versions=v1beta1,name=default.azuremanagedcontrolplanes.infrastructure.cluster.x-k8s.io,sideEffects=None,admissionReviewVersions=v1;v1beta1

// Default implements webhook.Defaulter so a webhook will be registered for the type.
func (m *AzureManagedControlPlane) Default(_ client.Client) <span class="cov8" title="1">{
        if m.Spec.NetworkPlugin == nil </span><span class="cov8" title="1">{
                networkPlugin := "azure"
                m.Spec.NetworkPlugin = &amp;networkPlugin
        }</span>
        <span class="cov8" title="1">if m.Spec.LoadBalancerSKU == nil </span><span class="cov8" title="1">{
                loadBalancerSKU := "Standard"
                m.Spec.LoadBalancerSKU = &amp;loadBalancerSKU
        }</span>
        <span class="cov8" title="1">if m.Spec.NetworkPolicy == nil </span><span class="cov8" title="1">{
                NetworkPolicy := "calico"
                m.Spec.NetworkPolicy = &amp;NetworkPolicy
        }</span>

        <span class="cov8" title="1">if m.Spec.Version != "" &amp;&amp; !strings.HasPrefix(m.Spec.Version, "v") </span><span class="cov8" title="1">{
                normalizedVersion := "v" + m.Spec.Version
                m.Spec.Version = normalizedVersion
        }</span>

        <span class="cov8" title="1">if err := m.setDefaultSSHPublicKey(); err != nil </span><span class="cov0" title="0">{
                ctrl.Log.WithName("AzureManagedControlPlaneWebHookLogger").Error(err, "setDefaultSSHPublicKey failed")
        }</span>

        <span class="cov8" title="1">m.setDefaultNodeResourceGroupName()
        m.setDefaultVirtualNetwork()
        m.setDefaultSubnet()
        m.setDefaultSku()</span>
}

// +kubebuilder:webhook:verbs=create;update,path=/validate-infrastructure-cluster-x-k8s-io-v1beta1-azuremanagedcontrolplane,mutating=false,failurePolicy=fail,groups=infrastructure.cluster.x-k8s.io,resources=azuremanagedcontrolplanes,versions=v1beta1,name=validation.azuremanagedcontrolplanes.infrastructure.cluster.x-k8s.io,sideEffects=None,admissionReviewVersions=v1;v1beta1

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type.
func (m *AzureManagedControlPlane) ValidateCreate(client client.Client) error <span class="cov8" title="1">{
        return m.Validate(client)
}</span>

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type.
func (m *AzureManagedControlPlane) ValidateUpdate(oldRaw runtime.Object, client client.Client) error <span class="cov8" title="1">{
        var allErrs field.ErrorList
        old := oldRaw.(*AzureManagedControlPlane)

        if m.Name != old.Name </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(
                                field.NewPath("Name"),
                                m.Name,
                                "field is immutable"))
        }</span>

        <span class="cov8" title="1">if m.Spec.SubscriptionID != old.Spec.SubscriptionID </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(
                                field.NewPath("Spec", "SubscriptionID"),
                                m.Spec.SubscriptionID,
                                "field is immutable"))
        }</span>

        <span class="cov8" title="1">if m.Spec.ResourceGroupName != old.Spec.ResourceGroupName </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(
                                field.NewPath("Spec", "ResourceGroupName"),
                                m.Spec.ResourceGroupName,
                                "field is immutable"))
        }</span>

        <span class="cov8" title="1">if m.Spec.NodeResourceGroupName != old.Spec.NodeResourceGroupName </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(
                                field.NewPath("Spec", "NodeResourceGroupName"),
                                m.Spec.NodeResourceGroupName,
                                "field is immutable"))
        }</span>

        <span class="cov8" title="1">if m.Spec.Location != old.Spec.Location </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(
                                field.NewPath("Spec", "Location"),
                                m.Spec.Location,
                                "field is immutable"))
        }</span>

        <span class="cov8" title="1">if old.Spec.SSHPublicKey != "" </span><span class="cov8" title="1">{
                // Prevent SSH key modification if it was already set to some value
                if m.Spec.SSHPublicKey != old.Spec.SSHPublicKey </span><span class="cov8" title="1">{
                        allErrs = append(allErrs,
                                field.Invalid(
                                        field.NewPath("Spec", "SSHPublicKey"),
                                        m.Spec.SSHPublicKey,
                                        "field is immutable"))
                }</span>
        }

        <span class="cov8" title="1">if old.Spec.DNSServiceIP != nil </span><span class="cov8" title="1">{
                // Prevent DNSServiceIP modification if it was already set to some value
                if m.Spec.DNSServiceIP == nil </span><span class="cov8" title="1">{
                        // unsetting the field is not allowed
                        allErrs = append(allErrs,
                                field.Invalid(
                                        field.NewPath("Spec", "DNSServiceIP"),
                                        m.Spec.DNSServiceIP,
                                        "field is immutable, unsetting is not allowed"))
                }</span> else<span class="cov8" title="1"> if *m.Spec.DNSServiceIP != *old.Spec.DNSServiceIP </span><span class="cov8" title="1">{
                        // changing the field is not allowed
                        allErrs = append(allErrs,
                                field.Invalid(
                                        field.NewPath("Spec", "DNSServiceIP"),
                                        *m.Spec.DNSServiceIP,
                                        "field is immutable"))
                }</span>
        }

        <span class="cov8" title="1">if old.Spec.NetworkPlugin != nil </span><span class="cov8" title="1">{
                // Prevent NetworkPlugin modification if it was already set to some value
                if m.Spec.NetworkPlugin == nil </span><span class="cov8" title="1">{
                        // unsetting the field is not allowed
                        allErrs = append(allErrs,
                                field.Invalid(
                                        field.NewPath("Spec", "NetworkPlugin"),
                                        m.Spec.NetworkPlugin,
                                        "field is immutable, unsetting is not allowed"))
                }</span> else<span class="cov8" title="1"> if *m.Spec.NetworkPlugin != *old.Spec.NetworkPlugin </span><span class="cov8" title="1">{
                        // changing the field is not allowed
                        allErrs = append(allErrs,
                                field.Invalid(
                                        field.NewPath("Spec", "NetworkPlugin"),
                                        *m.Spec.NetworkPlugin,
                                        "field is immutable"))
                }</span>
        }

        <span class="cov8" title="1">if old.Spec.NetworkPolicy != nil </span><span class="cov8" title="1">{
                // Prevent NetworkPolicy modification if it was already set to some value
                if m.Spec.NetworkPolicy == nil </span><span class="cov8" title="1">{
                        // unsetting the field is not allowed
                        allErrs = append(allErrs,
                                field.Invalid(
                                        field.NewPath("Spec", "NetworkPolicy"),
                                        m.Spec.NetworkPolicy,
                                        "field is immutable, unsetting is not allowed"))
                }</span> else<span class="cov8" title="1"> if *m.Spec.NetworkPolicy != *old.Spec.NetworkPolicy </span><span class="cov8" title="1">{
                        // changing the field is not allowed
                        allErrs = append(allErrs,
                                field.Invalid(
                                        field.NewPath("Spec", "NetworkPolicy"),
                                        *m.Spec.NetworkPolicy,
                                        "field is immutable"))
                }</span>
        }

        <span class="cov8" title="1">if old.Spec.LoadBalancerSKU != nil </span><span class="cov8" title="1">{
                // Prevent LoadBalancerSKU modification if it was already set to some value
                if m.Spec.LoadBalancerSKU == nil </span><span class="cov8" title="1">{
                        // unsetting the field is not allowed
                        allErrs = append(allErrs,
                                field.Invalid(
                                        field.NewPath("Spec", "LoadBalancerSKU"),
                                        m.Spec.LoadBalancerSKU,
                                        "field is immutable, unsetting is not allowed"))
                }</span> else<span class="cov8" title="1"> if *m.Spec.LoadBalancerSKU != *old.Spec.LoadBalancerSKU </span><span class="cov8" title="1">{
                        // changing the field is not allowed
                        allErrs = append(allErrs,
                                field.Invalid(
                                        field.NewPath("Spec", "LoadBalancerSKU"),
                                        *m.Spec.LoadBalancerSKU,
                                        "field is immutable"))
                }</span>
        }

        <span class="cov8" title="1">if old.Spec.AADProfile != nil </span><span class="cov8" title="1">{
                if m.Spec.AADProfile == nil </span><span class="cov8" title="1">{
                        allErrs = append(allErrs,
                                field.Invalid(
                                        field.NewPath("Spec", "AADProfile"),
                                        m.Spec.AADProfile,
                                        "field cannot be nil, cannot disable AADProfile"))
                }</span> else<span class="cov8" title="1"> {
                        if !m.Spec.AADProfile.Managed &amp;&amp; old.Spec.AADProfile.Managed </span><span class="cov8" title="1">{
                                allErrs = append(allErrs,
                                        field.Invalid(
                                                field.NewPath("Spec", "AADProfile.Managed"),
                                                m.Spec.AADProfile.Managed,
                                                "cannot set AADProfile.Managed to false"))
                        }</span>
                        <span class="cov8" title="1">if len(m.Spec.AADProfile.AdminGroupObjectIDs) == 0 </span><span class="cov8" title="1">{
                                allErrs = append(allErrs,
                                        field.Invalid(
                                                field.NewPath("Spec", "AADProfile.AdminGroupObjectIDs"),
                                                m.Spec.AADProfile.AdminGroupObjectIDs,
                                                "length of AADProfile.AdminGroupObjectIDs cannot be zero"))
                        }</span>
                }
        }

        <span class="cov8" title="1">if errs := m.validateAPIServerAccessProfileUpdate(old); len(errs) &gt; 0 </span><span class="cov8" title="1">{
                allErrs = append(allErrs, errs...)
        }</span>

        <span class="cov8" title="1">if len(allErrs) == 0 </span><span class="cov8" title="1">{
                return m.Validate(client)
        }</span>

        <span class="cov8" title="1">return apierrors.NewInvalid(GroupVersion.WithKind("AzureManagedControlPlane").GroupKind(), m.Name, allErrs)</span>
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type.
func (m *AzureManagedControlPlane) ValidateDelete(_ client.Client) error <span class="cov0" title="0">{
        return nil
}</span>

// Validate the Azure Machine Pool and return an aggregate error.
func (m *AzureManagedControlPlane) Validate(cli client.Client) error <span class="cov8" title="1">{
        validators := []func(client client.Client) error{
                m.validateName,
                m.validateVersion,
                m.validateDNSServiceIP,
                m.validateSSHKey,
                m.validateLoadBalancerProfile,
                m.validateAPIServerAccessProfile,
                m.validateManagedClusterNetwork,
        }

        var errs []error
        for _, validator := range validators </span><span class="cov8" title="1">{
                if err := validator(cli); err != nil </span><span class="cov8" title="1">{
                        errs = append(errs, err)
                }</span>
        }

        <span class="cov8" title="1">return kerrors.NewAggregate(errs)</span>
}

// validateDNSServiceIP validates the DNSServiceIP.
func (m *AzureManagedControlPlane) validateDNSServiceIP(_ client.Client) error <span class="cov8" title="1">{
        if m.Spec.DNSServiceIP != nil </span><span class="cov8" title="1">{
                if net.ParseIP(*m.Spec.DNSServiceIP) == nil </span><span class="cov8" title="1">{
                        return errors.New("DNSServiceIP must be a valid IP")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateVersion validates the Kubernetes version.
func (m *AzureManagedControlPlane) validateVersion(_ client.Client) error <span class="cov8" title="1">{
        if !kubeSemver.MatchString(m.Spec.Version) </span><span class="cov8" title="1">{
                return errors.New("must be a valid semantic version")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateSSHKey validates an SSHKey.
func (m *AzureManagedControlPlane) validateSSHKey(_ client.Client) error <span class="cov8" title="1">{
        if m.Spec.SSHPublicKey != "" </span><span class="cov8" title="1">{
                sshKey := m.Spec.SSHPublicKey
                if errs := infrav1.ValidateSSHKey(sshKey, field.NewPath("sshKey")); len(errs) &gt; 0 </span><span class="cov8" title="1">{
                        return kerrors.NewAggregate(errs.ToAggregate().Errors())
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateLoadBalancerProfile validates a LoadBalancerProfile.
func (m *AzureManagedControlPlane) validateLoadBalancerProfile(_ client.Client) error <span class="cov8" title="1">{
        if m.Spec.LoadBalancerProfile != nil </span><span class="cov8" title="1">{
                var errs []error
                var allErrs field.ErrorList
                numOutboundIPTypes := 0

                if m.Spec.LoadBalancerProfile.ManagedOutboundIPs != nil </span><span class="cov8" title="1">{
                        if *m.Spec.LoadBalancerProfile.ManagedOutboundIPs &lt; 1 || *m.Spec.LoadBalancerProfile.ManagedOutboundIPs &gt; 100 </span><span class="cov8" title="1">{
                                allErrs = append(allErrs, field.Invalid(field.NewPath("Spec", "LoadBalancerProfile", "ManagedOutboundIPs"), *m.Spec.LoadBalancerProfile.ManagedOutboundIPs, "value should be in between 1 and 100"))
                        }</span>
                }

                <span class="cov8" title="1">if m.Spec.LoadBalancerProfile.AllocatedOutboundPorts != nil </span><span class="cov8" title="1">{
                        if *m.Spec.LoadBalancerProfile.AllocatedOutboundPorts &lt; 0 || *m.Spec.LoadBalancerProfile.AllocatedOutboundPorts &gt; 64000 </span><span class="cov8" title="1">{
                                allErrs = append(allErrs, field.Invalid(field.NewPath("Spec", "LoadBalancerProfile", "AllocatedOutboundPorts"), *m.Spec.LoadBalancerProfile.AllocatedOutboundPorts, "value should be in between 0 and 64000"))
                        }</span>
                }

                <span class="cov8" title="1">if m.Spec.LoadBalancerProfile.IdleTimeoutInMinutes != nil </span><span class="cov8" title="1">{
                        if *m.Spec.LoadBalancerProfile.IdleTimeoutInMinutes &lt; 4 || *m.Spec.LoadBalancerProfile.IdleTimeoutInMinutes &gt; 120 </span><span class="cov8" title="1">{
                                allErrs = append(allErrs, field.Invalid(field.NewPath("Spec", "LoadBalancerProfile", "IdleTimeoutInMinutes"), *m.Spec.LoadBalancerProfile.IdleTimeoutInMinutes, "value should be in between 4 and 120"))
                        }</span>
                }

                <span class="cov8" title="1">if m.Spec.LoadBalancerProfile.ManagedOutboundIPs != nil </span><span class="cov8" title="1">{
                        numOutboundIPTypes++
                }</span>
                <span class="cov8" title="1">if len(m.Spec.LoadBalancerProfile.OutboundIPPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                        numOutboundIPTypes++
                }</span>
                <span class="cov8" title="1">if len(m.Spec.LoadBalancerProfile.OutboundIPs) &gt; 0 </span><span class="cov8" title="1">{
                        numOutboundIPTypes++
                }</span>
                <span class="cov8" title="1">if numOutboundIPTypes &gt; 1 </span><span class="cov8" title="1">{
                        errs = append(errs, errors.New("load balancer profile must specify at most one of ManagedOutboundIPs, OutboundIPPrefixes and OutboundIPs"))
                }</span>

                <span class="cov8" title="1">if len(allErrs) &gt; 0 </span><span class="cov8" title="1">{
                        agg := kerrors.NewAggregate(allErrs.ToAggregate().Errors())
                        errs = append(errs, agg)
                }</span>

                <span class="cov8" title="1">return kerrors.NewAggregate(errs)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateAPIServerAccessProfile validates an APIServerAccessProfile.
func (m *AzureManagedControlPlane) validateAPIServerAccessProfile(_ client.Client) error <span class="cov8" title="1">{
        if m.Spec.APIServerAccessProfile != nil </span><span class="cov8" title="1">{
                var allErrs field.ErrorList
                for _, ipRange := range m.Spec.APIServerAccessProfile.AuthorizedIPRanges </span><span class="cov8" title="1">{
                        if _, _, err := net.ParseCIDR(ipRange); err != nil </span><span class="cov8" title="1">{
                                allErrs = append(allErrs, field.Invalid(field.NewPath("Spec", "APIServerAccessProfile", "AuthorizedIPRanges"), ipRange, "invalid CIDR format"))
                        }</span>
                }
                <span class="cov8" title="1">if len(allErrs) &gt; 0 </span><span class="cov8" title="1">{
                        return kerrors.NewAggregate(allErrs.ToAggregate().Errors())
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// validateManagedClusterNetwork validates the Cluster network values.
func (m *AzureManagedControlPlane) validateManagedClusterNetwork(cli client.Client) error <span class="cov8" title="1">{
        ctx := context.Background()

        // Fetch the Cluster.
        clusterName, ok := m.Labels[clusterv1.ClusterLabelName]
        if !ok </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">ownerCluster := &amp;clusterv1.Cluster{}
        key := client.ObjectKey{
                Namespace: m.Namespace,
                Name:      clusterName,
        }

        if err := cli.Get(ctx, key, ownerCluster); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var (
                allErrs     field.ErrorList
                serviceCIDR string
        )

        if clusterNetwork := ownerCluster.Spec.ClusterNetwork; clusterNetwork != nil </span><span class="cov0" title="0">{
                if clusterNetwork.Services != nil </span><span class="cov0" title="0">{
                        // A user may provide zero or one CIDR blocks. If they provide an empty array,
                        // we ignore it and use the default. AKS doesn't support &gt; 1 Service/Pod CIDR.
                        if len(clusterNetwork.Services.CIDRBlocks) &gt; 1 </span><span class="cov0" title="0">{
                                allErrs = append(allErrs, field.TooMany(field.NewPath("Cluster", "Spec", "ClusterNetwork", "Services", "CIDRBlocks"), len(clusterNetwork.Services.CIDRBlocks), 1))
                        }</span>
                        <span class="cov0" title="0">if len(clusterNetwork.Services.CIDRBlocks) == 1 </span><span class="cov0" title="0">{
                                serviceCIDR = clusterNetwork.Services.CIDRBlocks[0]
                        }</span>
                }
                <span class="cov0" title="0">if clusterNetwork.Pods != nil </span><span class="cov0" title="0">{
                        // A user may provide zero or one CIDR blocks. If they provide an empty array,
                        // we ignore it and use the default. AKS doesn't support &gt; 1 Service/Pod CIDR.
                        if len(clusterNetwork.Pods.CIDRBlocks) &gt; 1 </span><span class="cov0" title="0">{
                                allErrs = append(allErrs, field.TooMany(field.NewPath("Cluster", "Spec", "ClusterNetwork", "Pods", "CIDRBlocks"), len(clusterNetwork.Pods.CIDRBlocks), 1))
                        }</span>
                }
        }

        <span class="cov0" title="0">if m.Spec.DNSServiceIP != nil </span><span class="cov0" title="0">{
                if serviceCIDR == "" </span><span class="cov0" title="0">{
                        allErrs = append(allErrs, field.Required(field.NewPath("Cluster", "Spec", "ClusterNetwork", "Services", "CIDRBlocks"), "service CIDR must be specified if specifying DNSServiceIP"))
                }</span>
                <span class="cov0" title="0">_, cidr, err := net.ParseCIDR(serviceCIDR)
                if err != nil </span><span class="cov0" title="0">{
                        allErrs = append(allErrs, field.Invalid(field.NewPath("Cluster", "Spec", "ClusterNetwork", "Services", "CIDRBlocks"), serviceCIDR, fmt.Sprintf("failed to parse cluster service cidr: %v", err)))
                }</span>
                <span class="cov0" title="0">ip := net.ParseIP(*m.Spec.DNSServiceIP)
                if !cidr.Contains(ip) </span><span class="cov0" title="0">{
                        allErrs = append(allErrs, field.Invalid(field.NewPath("Cluster", "Spec", "ClusterNetwork", "Services", "CIDRBlocks"), serviceCIDR, "DNSServiceIP must reside within the associated cluster serviceCIDR"))
                }</span>
        }

        <span class="cov0" title="0">if len(allErrs) &gt; 0 </span><span class="cov0" title="0">{
                return kerrors.NewAggregate(allErrs.ToAggregate().Errors())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// validateAPIServerAccessProfileUpdate validates update to APIServerAccessProfile.
func (m *AzureManagedControlPlane) validateAPIServerAccessProfileUpdate(old *AzureManagedControlPlane) field.ErrorList <span class="cov8" title="1">{
        var allErrs field.ErrorList

        newAPIServerAccessProfileNormalized := &amp;APIServerAccessProfile{}
        oldAPIServerAccessProfileNormalized := &amp;APIServerAccessProfile{}
        if m.Spec.APIServerAccessProfile != nil </span><span class="cov8" title="1">{
                newAPIServerAccessProfileNormalized = &amp;APIServerAccessProfile{
                        EnablePrivateCluster:           m.Spec.APIServerAccessProfile.EnablePrivateCluster,
                        PrivateDNSZone:                 m.Spec.APIServerAccessProfile.PrivateDNSZone,
                        EnablePrivateClusterPublicFQDN: m.Spec.APIServerAccessProfile.EnablePrivateClusterPublicFQDN,
                }
        }</span>
        <span class="cov8" title="1">if old.Spec.APIServerAccessProfile != nil </span><span class="cov0" title="0">{
                oldAPIServerAccessProfileNormalized = &amp;APIServerAccessProfile{
                        EnablePrivateCluster:           old.Spec.APIServerAccessProfile.EnablePrivateCluster,
                        PrivateDNSZone:                 old.Spec.APIServerAccessProfile.PrivateDNSZone,
                        EnablePrivateClusterPublicFQDN: old.Spec.APIServerAccessProfile.EnablePrivateClusterPublicFQDN,
                }
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(newAPIServerAccessProfileNormalized, oldAPIServerAccessProfileNormalized) </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(field.NewPath("Spec", "APIServerAccessProfile"),
                                m.Spec.APIServerAccessProfile, "fields (except for AuthorizedIPRanges) are immutable"),
                )
        }</span>

        <span class="cov8" title="1">return allErrs</span>
}

func (m *AzureManagedControlPlane) validateName(_ client.Client) error <span class="cov8" title="1">{
        if lName := strings.ToLower(m.Name); strings.Contains(lName, "microsoft") ||
                strings.Contains(lName, "windows") </span><span class="cov8" title="1">{
                return field.Invalid(field.NewPath("Name"), m.Name,
                        "cluster name is invalid because 'MICROSOFT' and 'WINDOWS' can't be used as either a whole word or a substring in the name")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file205" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

// Hub marks AzureManagedMachinePool as a conversion hub.
func (*AzureManagedMachinePool) Hub() {<span class="cov0" title="0">}</span>

// Hub marks AzureManagedMachinePoolList as a conversion hub.
func (*AzureManagedMachinePoolList) Hub() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file206" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        capierrors "sigs.k8s.io/cluster-api/errors"
)

const (
        // LabelAgentPoolMode represents mode of an agent pool. Possible values include: System, User.
        LabelAgentPoolMode = "azuremanagedmachinepool.infrastructure.cluster.x-k8s.io/agentpoolmode"

        // NodePoolModeSystem represents mode system for azuremachinepool.
        NodePoolModeSystem NodePoolMode = "System"

        // NodePoolModeUser represents mode user for azuremachinepool.
        NodePoolModeUser NodePoolMode = "User"

        // DefaultOSType represents the default operating system for azmachinepool.
        DefaultOSType string = azure.LinuxOS
)

// NodePoolMode enumerates the values for agent pool mode.
type NodePoolMode string

// AzureManagedMachinePoolSpec defines the desired state of AzureManagedMachinePool.
type AzureManagedMachinePoolSpec struct {

        // Name - name of the agent pool. If not specified, CAPZ uses the name of the CR as the agent pool name.
        // +optional
        Name *string `json:"name,omitempty"`

        // Mode - represents mode of an agent pool. Possible values include: System, User.
        // +kubebuilder:validation:Enum=System;User
        Mode string `json:"mode"`

        // SKU is the size of the VMs in the node pool.
        SKU string `json:"sku"`

        // OSDiskSizeGB is the disk size for every machine in this agent pool.
        // If you specify 0, it will apply the default osDisk size according to the vmSize specified.
        // +optional
        OSDiskSizeGB *int32 `json:"osDiskSizeGB,omitempty"`

        // AvailabilityZones - Availability zones for nodes. Must use VirtualMachineScaleSets AgentPoolType.
        // +optional
        AvailabilityZones []string `json:"availabilityZones,omitempty"`

        // Node labels - labels for all of the nodes present in node pool
        // +optional
        NodeLabels map[string]string `json:"nodeLabels,omitempty"`

        // Taints specifies the taints for nodes present in this agent pool.
        // +optional
        Taints Taints `json:"taints,omitempty"`

        // ProviderIDList is the unique identifier as specified by the cloud provider.
        // +optional
        ProviderIDList []string `json:"providerIDList,omitempty"`

        // Scaling specifies the autoscaling parameters for the node pool.
        // +optional
        Scaling *ManagedMachinePoolScaling `json:"scaling,omitempty"`

        // MaxPods specifies the kubelet --max-pods configuration for the node pool.
        // +optional
        MaxPods *int32 `json:"maxPods,omitempty"`

        // OsDiskType specifies the OS disk type for each node in the pool. Allowed values are 'Ephemeral' and 'Managed'.
        // +kubebuilder:validation:Enum=Ephemeral;Managed
        // +kubebuilder:default=Managed
        // +optional
        OsDiskType *string `json:"osDiskType,omitempty"`

        // EnableUltraSSD enables the storage type UltraSSD_LRS for the agent pool.
        // +optional
        EnableUltraSSD *bool `json:"enableUltraSSD,omitempty"`

        // OSType specifies the virtual machine operating system. Default to Linux. Possible values include: 'Linux', 'Windows'
        // +kubebuilder:validation:Enum=Linux;Windows
        // +optional
        OSType *string `json:"osType,omitempty"`

        // EnableNodePublicIP controls whether or not nodes in the pool each have a public IP address.
        // +optional
        EnableNodePublicIP *bool `json:"enableNodePublicIP,omitempty"`
}

// ManagedMachinePoolScaling specifies scaling options.
type ManagedMachinePoolScaling struct {
        MinSize *int32 `json:"minSize,omitempty"`
        MaxSize *int32 `json:"maxSize,omitempty"`
}

// TaintEffect is the effect for a Kubernetes taint.
type TaintEffect string

// Taint represents a Kubernetes taint.
type Taint struct {
        // Effect specifies the effect for the taint
        // +kubebuilder:validation:Enum=NoSchedule;NoExecute;PreferNoSchedule
        Effect TaintEffect `json:"effect"`
        // Key is the key of the taint
        Key string `json:"key"`
        // Value is the value of the taint
        Value string `json:"value"`
}

// Taints is an array of Taints.
type Taints []Taint

// AzureManagedMachinePoolStatus defines the observed state of AzureManagedMachinePool.
type AzureManagedMachinePoolStatus struct {
        // Ready is true when the provider resource is ready.
        // +optional
        Ready bool `json:"ready"`

        // Replicas is the most recently observed number of replicas.
        // +optional
        Replicas int32 `json:"replicas"`

        // Any transient errors that occur during the reconciliation of Machines
        // can be added as events to the Machine object and/or logged in the
        // controller's output.
        // +optional
        ErrorReason *capierrors.MachineStatusError `json:"errorReason,omitempty"`

        // Any transient errors that occur during the reconciliation of Machines
        // can be added as events to the Machine object and/or logged in the
        // controller's output.
        // +optional
        ErrorMessage *string `json:"errorMessage,omitempty"`

        // Conditions defines current service state of the AzureManagedControlPlane.
        // +optional
        Conditions clusterv1.Conditions `json:"conditions,omitempty"`

        // LongRunningOperationStates saves the states for Azure long-running operations so they can be continued on the
        // next reconciliation loop.
        // +optional
        LongRunningOperationStates infrav1.Futures `json:"longRunningOperationStates,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:printcolumn:name="Mode",type="string",JSONPath=".spec.mode"
// +kubebuilder:resource:path=azuremanagedmachinepools,scope=Namespaced,categories=cluster-api,shortName=ammp
// +kubebuilder:storageversion
// +kubebuilder:subresource:status

// AzureManagedMachinePool is the Schema for the azuremanagedmachinepools API.
type AzureManagedMachinePool struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   AzureManagedMachinePoolSpec   `json:"spec,omitempty"`
        Status AzureManagedMachinePoolStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AzureManagedMachinePoolList contains a list of AzureManagedMachinePools.
type AzureManagedMachinePoolList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []AzureManagedMachinePool `json:"items"`
}

// GetConditions returns the list of conditions for an AzureManagedMachinePool API object.
func (m *AzureManagedMachinePool) GetConditions() clusterv1.Conditions <span class="cov0" title="0">{
        return m.Status.Conditions
}</span>

// SetConditions will set the given conditions on an AzureManagedMachinePool object.
func (m *AzureManagedMachinePool) SetConditions(conditions clusterv1.Conditions) <span class="cov0" title="0">{
        m.Status.Conditions = conditions
}</span>

// GetFutures returns the list of long running operation states for an AzureManagedMachinePool API object.
func (m *AzureManagedMachinePool) GetFutures() infrav1.Futures <span class="cov0" title="0">{
        return m.Status.LongRunningOperationStates
}</span>

// SetFutures will set the given long running operation states on an AzureManagedMachinePool object.
func (m *AzureManagedMachinePool) SetFutures(futures infrav1.Futures) <span class="cov0" title="0">{
        m.Status.LongRunningOperationStates = futures
}</span>

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;AzureManagedMachinePool{}, &amp;AzureManagedMachinePoolList{})
}</span>
</pre>
		
		<pre class="file" id="file207" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "fmt"
        "reflect"

        "github.com/Azure/go-autorest/autorest/to"
        "github.com/pkg/errors"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        kerrors "k8s.io/apimachinery/pkg/util/errors"
        "k8s.io/apimachinery/pkg/util/validation/field"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/maps"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

//+kubebuilder:webhook:path=/mutate-infrastructure-cluster-x-k8s-io-v1beta1-azuremanagedmachinepool,mutating=true,failurePolicy=fail,matchPolicy=Equivalent,groups=infrastructure.cluster.x-k8s.io,resources=azuremanagedmachinepools,verbs=create;update,versions=v1beta1,name=default.azuremanagedmachinepools.infrastructure.cluster.x-k8s.io,sideEffects=None,admissionReviewVersions=v1;v1beta1

// Default implements webhook.Defaulter so a webhook will be registered for the type.
func (m *AzureManagedMachinePool) Default(client client.Client) <span class="cov8" title="1">{
        if m.Labels == nil </span><span class="cov8" title="1">{
                m.Labels = make(map[string]string)
        }</span>
        <span class="cov8" title="1">m.Labels[LabelAgentPoolMode] = m.Spec.Mode

        if m.Spec.Name == nil || *m.Spec.Name == "" </span><span class="cov8" title="1">{
                m.Spec.Name = &amp;m.Name
        }</span>

        <span class="cov8" title="1">if m.Spec.OSType == nil </span><span class="cov8" title="1">{
                m.Spec.OSType = to.StringPtr(DefaultOSType)
        }</span>
}

//+kubebuilder:webhook:verbs=update;delete,path=/validate-infrastructure-cluster-x-k8s-io-v1beta1-azuremanagedmachinepool,mutating=false,failurePolicy=fail,matchPolicy=Equivalent,groups=infrastructure.cluster.x-k8s.io,resources=azuremanagedmachinepools,versions=v1beta1,name=validation.azuremanagedmachinepools.infrastructure.cluster.x-k8s.io,sideEffects=None,admissionReviewVersions=v1;v1beta1

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type.
func (m *AzureManagedMachinePool) ValidateCreate(client client.Client) error <span class="cov8" title="1">{
        validators := []func() error{
                m.validateMaxPods,
                m.validateOSType,
                m.validateName,
        }

        var errs []error
        for _, validator := range validators </span><span class="cov8" title="1">{
                if err := validator(); err != nil </span><span class="cov8" title="1">{
                        errs = append(errs, err)
                }</span>
        }

        <span class="cov8" title="1">return kerrors.NewAggregate(errs)</span>
}

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type.
func (m *AzureManagedMachinePool) ValidateUpdate(oldRaw runtime.Object, client client.Client) error <span class="cov8" title="1">{
        old := oldRaw.(*AzureManagedMachinePool)
        var allErrs field.ErrorList

        if old.Spec.OSType != nil </span><span class="cov8" title="1">{
                // Prevent OSType modification if it was already set to some value
                if m.Spec.OSType == nil </span><span class="cov0" title="0">{
                        // unsetting the field is not allowed
                        allErrs = append(allErrs,
                                field.Invalid(
                                        field.NewPath("Spec", "OSType"),
                                        m.Spec.OSType,
                                        "field is immutable, unsetting is not allowed"))
                }</span> else<span class="cov8" title="1"> if *m.Spec.OSType != *old.Spec.OSType </span><span class="cov8" title="1">{
                        // changing the field is not allowed
                        allErrs = append(allErrs,
                                field.Invalid(
                                        field.NewPath("Spec", "OSType"),
                                        *m.Spec.OSType,
                                        "field is immutable"))
                }</span>
        }

        <span class="cov8" title="1">if m.Spec.SKU != old.Spec.SKU </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(
                                field.NewPath("Spec", "SKU"),
                                m.Spec.SKU,
                                "field is immutable"))
        }</span>

        <span class="cov8" title="1">if old.Spec.OSDiskSizeGB != nil </span><span class="cov8" title="1">{
                // Prevent OSDiskSizeGB modification if it was already set to some value
                if m.Spec.OSDiskSizeGB == nil </span><span class="cov0" title="0">{
                        // unsetting the field is not allowed
                        allErrs = append(allErrs,
                                field.Invalid(
                                        field.NewPath("Spec", "OSDiskSizeGB"),
                                        m.Spec.OSDiskSizeGB,
                                        "field is immutable, unsetting is not allowed"))
                }</span> else<span class="cov8" title="1"> if *m.Spec.OSDiskSizeGB != *old.Spec.OSDiskSizeGB </span><span class="cov8" title="1">{
                        // changing the field is not allowed
                        allErrs = append(allErrs,
                                field.Invalid(
                                        field.NewPath("Spec", "OSDiskSizeGB"),
                                        *m.Spec.OSDiskSizeGB,
                                        "field is immutable"))
                }</span>
        }

        <span class="cov8" title="1">if !reflect.DeepEqual(m.Spec.Taints, old.Spec.Taints) </span><span class="cov0" title="0">{
                allErrs = append(allErrs,
                        field.Invalid(
                                field.NewPath("Spec", "Taints"),
                                m.Spec.Taints,
                                "field is immutable"))
        }</span>

        // custom headers are immutable
        <span class="cov8" title="1">oldCustomHeaders := maps.FilterByKeyPrefix(old.ObjectMeta.Annotations, azure.CustomHeaderPrefix)
        newCustomHeaders := maps.FilterByKeyPrefix(m.ObjectMeta.Annotations, azure.CustomHeaderPrefix)
        if !reflect.DeepEqual(oldCustomHeaders, newCustomHeaders) </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(
                                field.NewPath("metadata", "annotations"),
                                m.ObjectMeta.Annotations,
                                fmt.Sprintf("annotations with '%s' prefix are immutable", azure.CustomHeaderPrefix)))
        }</span>

        <span class="cov8" title="1">if !ensureStringSlicesAreEqual(m.Spec.AvailabilityZones, old.Spec.AvailabilityZones) </span><span class="cov8" title="1">{
                allErrs = append(allErrs,
                        field.Invalid(
                                field.NewPath("Spec", "AvailabilityZones"),
                                m.Spec.AvailabilityZones,
                                "field is immutable"))
        }</span>

        <span class="cov8" title="1">if m.Spec.Mode != string(NodePoolModeSystem) &amp;&amp; old.Spec.Mode == string(NodePoolModeSystem) </span><span class="cov0" title="0">{
                // validate for last system node pool
                if err := m.validateLastSystemNodePool(client); err != nil </span><span class="cov0" title="0">{
                        allErrs = append(allErrs, field.Invalid(
                                field.NewPath("Spec", "Mode"),
                                m.Spec.Mode,
                                "Last system node pool cannot be mutated to user node pool"))
                }</span>
        }

        <span class="cov8" title="1">if old.Spec.MaxPods != nil </span><span class="cov8" title="1">{
                // Prevent MaxPods modification if it was already set to some value
                if m.Spec.MaxPods == nil </span><span class="cov0" title="0">{
                        // unsetting the field is not allowed
                        allErrs = append(allErrs,
                                field.Invalid(
                                        field.NewPath("Spec", "MaxPods"),
                                        m.Spec.MaxPods,
                                        "field is immutable, unsetting is not allowed"))
                }</span> else<span class="cov8" title="1"> if *m.Spec.MaxPods != *old.Spec.MaxPods </span><span class="cov8" title="1">{
                        // changing the field is not allowed
                        allErrs = append(allErrs,
                                field.Invalid(
                                        field.NewPath("Spec", "MaxPods"),
                                        *m.Spec.MaxPods,
                                        "field is immutable"))
                }</span>
        }

        <span class="cov8" title="1">if old.Spec.OsDiskType != nil </span><span class="cov8" title="1">{
                // Prevent OSDiskType modification if it was already set to some value
                if m.Spec.OsDiskType == nil || to.String(m.Spec.OsDiskType) == "" </span><span class="cov0" title="0">{
                        // unsetting the field is not allowed
                        allErrs = append(allErrs,
                                field.Invalid(
                                        field.NewPath("Spec", "OsDiskType"),
                                        m.Spec.OsDiskType,
                                        "field is immutable, unsetting is not allowed"))
                }</span> else<span class="cov8" title="1"> if *m.Spec.OsDiskType != *old.Spec.OsDiskType </span><span class="cov8" title="1">{
                        // changing the field is not allowed
                        allErrs = append(allErrs,
                                field.Invalid(
                                        field.NewPath("Spec", "OsDiskType"),
                                        m.Spec.OsDiskType,
                                        "field is immutable"))
                }</span>
        }

        <span class="cov8" title="1">if err := validateBoolPtrImmutable(
                field.NewPath("Spec", "EnableUltraSSD"),
                old.Spec.EnableUltraSSD,
                m.Spec.EnableUltraSSD); err != nil </span><span class="cov8" title="1">{
                allErrs = append(allErrs, err)
        }</span>
        <span class="cov8" title="1">if err := validateBoolPtrImmutable(
                field.NewPath("Spec", "EnableNodePublicIP"),
                old.Spec.EnableNodePublicIP,
                m.Spec.EnableNodePublicIP); err != nil </span><span class="cov8" title="1">{
                allErrs = append(allErrs, err)
        }</span>

        <span class="cov8" title="1">if len(allErrs) != 0 </span><span class="cov8" title="1">{
                return apierrors.NewInvalid(GroupVersion.WithKind("AzureManagedMachinePool").GroupKind(), m.Name, allErrs)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type.
func (m *AzureManagedMachinePool) ValidateDelete(client client.Client) error <span class="cov0" title="0">{
        if m.Spec.Mode != string(NodePoolModeSystem) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return errors.Wrapf(m.validateLastSystemNodePool(client), "if the delete is triggered via owner MachinePool please refer to trouble shooting section in https://capz.sigs.k8s.io/topics/managedcluster.html")</span>
}

// validateLastSystemNodePool is used to check if the existing system node pool is the last system node pool.
// If it is a last system node pool it cannot be deleted or mutated to user node pool as AKS expects min 1 system node pool.
func (m *AzureManagedMachinePool) validateLastSystemNodePool(cli client.Client) error <span class="cov0" title="0">{
        ctx := context.Background()

        // Fetch the Cluster.
        clusterName, ok := m.Labels[clusterv1.ClusterLabelName]
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">ownerCluster := &amp;clusterv1.Cluster{}
        key := client.ObjectKey{
                Namespace: m.Namespace,
                Name:      clusterName,
        }

        if err := cli.Get(ctx, key, ownerCluster); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !ownerCluster.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">opt1 := client.InNamespace(m.Namespace)
        opt2 := client.MatchingLabels(map[string]string{
                clusterv1.ClusterLabelName: clusterName,
                LabelAgentPoolMode:         string(NodePoolModeSystem),
        })

        ammpList := &amp;AzureManagedMachinePoolList{}
        if err := cli.List(ctx, ammpList, opt1, opt2); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(ammpList.Items) &lt;= 1 </span><span class="cov0" title="0">{
                return errors.New("AKS Cluster must have at least one system pool")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *AzureManagedMachinePool) validateMaxPods() error <span class="cov8" title="1">{
        if m.Spec.MaxPods != nil </span><span class="cov8" title="1">{
                if to.Int32(m.Spec.MaxPods) &lt; 10 || to.Int32(m.Spec.MaxPods) &gt; 250 </span><span class="cov8" title="1">{
                        return field.Invalid(
                                field.NewPath("Spec", "MaxPods"),
                                m.Spec.MaxPods,
                                "MaxPods must be between 10 and 250")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (m *AzureManagedMachinePool) validateOSType() error <span class="cov8" title="1">{
        if m.Spec.Mode == string(NodePoolModeSystem) </span><span class="cov8" title="1">{
                if m.Spec.OSType != nil &amp;&amp; *m.Spec.OSType != azure.LinuxOS </span><span class="cov8" title="1">{
                        return field.Forbidden(
                                field.NewPath("Spec", "OSType"),
                                "System node pooll must have OSType 'Linux'")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (m *AzureManagedMachinePool) validateName() error <span class="cov8" title="1">{
        if m.Spec.OSType != nil &amp;&amp; *m.Spec.OSType == azure.WindowsOS </span><span class="cov8" title="1">{
                if len(m.Name) &gt; 6 </span><span class="cov8" title="1">{
                        return field.Invalid(
                                field.NewPath("Name"),
                                m.Name,
                                "Windows agent pool name can not be longer than 6 characters.")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func ensureStringSlicesAreEqual(a []string, b []string) bool <span class="cov8" title="1">{
        if len(a) != len(b) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">m := map[string]bool{}
        for _, v := range a </span><span class="cov8" title="1">{
                m[v] = true
        }</span>

        <span class="cov8" title="1">for _, v := range b </span><span class="cov8" title="1">{
                if _, ok := m[v]; !ok </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func validateBoolPtrImmutable(path *field.Path, oldVal, newVal *bool) *field.Error <span class="cov8" title="1">{
        if oldVal != nil </span><span class="cov8" title="1">{
                // Prevent modification if it was already set to some value
                if newVal == nil </span><span class="cov8" title="1">{
                        // unsetting the field is not allowed
                        return field.Invalid(path, newVal, "field is immutable, unsetting is not allowed")
                }</span>
                <span class="cov8" title="1">if *newVal != *oldVal </span><span class="cov8" title="1">{
                        // changing the field is not allowed
                        return field.Invalid(path, newVal, "field is immutable")
                }</span>
        } else<span class="cov8" title="1"> if newVal != nil </span><span class="cov8" title="1">{
                return field.Invalid(path, newVal, "field is immutable, setting is not allowed")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file208" style="display: none">//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by controller-gen. DO NOT EDIT.

package v1beta1

import (
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/util/intstr"
        apiv1beta1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        cluster_apiapiv1beta1 "sigs.k8s.io/cluster-api/api/v1beta1"
        "sigs.k8s.io/cluster-api/errors"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AADProfile) DeepCopyInto(out *AADProfile) <span class="cov0" title="0">{
        *out = *in
        if in.AdminGroupObjectIDs != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AdminGroupObjectIDs, &amp;out.AdminGroupObjectIDs
                *out = make([]string, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AADProfile.
func (in *AADProfile) DeepCopy() *AADProfile <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AADProfile)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *APIServerAccessProfile) DeepCopyInto(out *APIServerAccessProfile) <span class="cov0" title="0">{
        *out = *in
        if in.AuthorizedIPRanges != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AuthorizedIPRanges, &amp;out.AuthorizedIPRanges
                *out = make([]string, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov0" title="0">if in.EnablePrivateCluster != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.EnablePrivateCluster, &amp;out.EnablePrivateCluster
                *out = new(bool)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.PrivateDNSZone != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.PrivateDNSZone, &amp;out.PrivateDNSZone
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.EnablePrivateClusterPublicFQDN != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.EnablePrivateClusterPublicFQDN, &amp;out.EnablePrivateClusterPublicFQDN
                *out = new(bool)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new APIServerAccessProfile.
func (in *APIServerAccessProfile) DeepCopy() *APIServerAccessProfile <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(APIServerAccessProfile)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AddonProfile) DeepCopyInto(out *AddonProfile) <span class="cov0" title="0">{
        *out = *in
        if in.Config != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Config, &amp;out.Config
                *out = make(map[string]string, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AddonProfile.
func (in *AddonProfile) DeepCopy() *AddonProfile <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AddonProfile)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachinePool) DeepCopyInto(out *AzureMachinePool) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
        in.Status.DeepCopyInto(&amp;out.Status)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachinePool.
func (in *AzureMachinePool) DeepCopy() *AzureMachinePool <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachinePool)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureMachinePool) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachinePoolDeploymentStrategy) DeepCopyInto(out *AzureMachinePoolDeploymentStrategy) <span class="cov0" title="0">{
        *out = *in
        if in.RollingUpdate != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.RollingUpdate, &amp;out.RollingUpdate
                *out = new(MachineRollingUpdateDeployment)
                (*in).DeepCopyInto(*out)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachinePoolDeploymentStrategy.
func (in *AzureMachinePoolDeploymentStrategy) DeepCopy() *AzureMachinePoolDeploymentStrategy <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachinePoolDeploymentStrategy)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachinePoolInstanceStatus) DeepCopyInto(out *AzureMachinePoolInstanceStatus) <span class="cov0" title="0">{
        *out = *in
        if in.ProvisioningState != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ProvisioningState, &amp;out.ProvisioningState
                *out = new(apiv1beta1.ProvisioningState)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachinePoolInstanceStatus.
func (in *AzureMachinePoolInstanceStatus) DeepCopy() *AzureMachinePoolInstanceStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachinePoolInstanceStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachinePoolList) DeepCopyInto(out *AzureMachinePoolList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureMachinePool, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachinePoolList.
func (in *AzureMachinePoolList) DeepCopy() *AzureMachinePoolList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachinePoolList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureMachinePoolList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachinePoolMachine) DeepCopyInto(out *AzureMachinePoolMachine) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        out.Spec = in.Spec
        in.Status.DeepCopyInto(&amp;out.Status)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachinePoolMachine.
func (in *AzureMachinePoolMachine) DeepCopy() *AzureMachinePoolMachine <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachinePoolMachine)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureMachinePoolMachine) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachinePoolMachineList) DeepCopyInto(out *AzureMachinePoolMachineList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureMachinePoolMachine, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachinePoolMachineList.
func (in *AzureMachinePoolMachineList) DeepCopy() *AzureMachinePoolMachineList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachinePoolMachineList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureMachinePoolMachineList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachinePoolMachineSpec) DeepCopyInto(out *AzureMachinePoolMachineSpec) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachinePoolMachineSpec.
func (in *AzureMachinePoolMachineSpec) DeepCopy() *AzureMachinePoolMachineSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachinePoolMachineSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachinePoolMachineStatus) DeepCopyInto(out *AzureMachinePoolMachineStatus) <span class="cov0" title="0">{
        *out = *in
        if in.NodeRef != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.NodeRef, &amp;out.NodeRef
                *out = new(corev1.ObjectReference)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.ProvisioningState != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ProvisioningState, &amp;out.ProvisioningState
                *out = new(apiv1beta1.ProvisioningState)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.FailureReason != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.FailureReason, &amp;out.FailureReason
                *out = new(errors.MachineStatusError)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.FailureMessage != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.FailureMessage, &amp;out.FailureMessage
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.Conditions != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make(cluster_apiapiv1beta1.Conditions, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov0" title="0">if in.LongRunningOperationStates != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.LongRunningOperationStates, &amp;out.LongRunningOperationStates
                *out = make(apiv1beta1.Futures, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachinePoolMachineStatus.
func (in *AzureMachinePoolMachineStatus) DeepCopy() *AzureMachinePoolMachineStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachinePoolMachineStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachinePoolMachineTemplate) DeepCopyInto(out *AzureMachinePoolMachineTemplate) <span class="cov0" title="0">{
        *out = *in
        if in.Image != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Image, &amp;out.Image
                *out = new(apiv1beta1.Image)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov0" title="0">in.OSDisk.DeepCopyInto(&amp;out.OSDisk)
        if in.DataDisks != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.DataDisks, &amp;out.DataDisks
                *out = make([]apiv1beta1.DataDisk, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov0" title="0">if in.AcceleratedNetworking != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AcceleratedNetworking, &amp;out.AcceleratedNetworking
                *out = new(bool)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.TerminateNotificationTimeout != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.TerminateNotificationTimeout, &amp;out.TerminateNotificationTimeout
                *out = new(int)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.SecurityProfile != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.SecurityProfile, &amp;out.SecurityProfile
                *out = new(apiv1beta1.SecurityProfile)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov0" title="0">if in.SpotVMOptions != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.SpotVMOptions, &amp;out.SpotVMOptions
                *out = new(apiv1beta1.SpotVMOptions)
                (*in).DeepCopyInto(*out)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachinePoolMachineTemplate.
func (in *AzureMachinePoolMachineTemplate) DeepCopy() *AzureMachinePoolMachineTemplate <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachinePoolMachineTemplate)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachinePoolSpec) DeepCopyInto(out *AzureMachinePoolSpec) <span class="cov0" title="0">{
        *out = *in
        in.Template.DeepCopyInto(&amp;out.Template)
        if in.AdditionalTags != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AdditionalTags, &amp;out.AdditionalTags
                *out = make(apiv1beta1.Tags, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
        <span class="cov0" title="0">if in.ProviderIDList != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ProviderIDList, &amp;out.ProviderIDList
                *out = make([]string, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov0" title="0">if in.UserAssignedIdentities != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.UserAssignedIdentities, &amp;out.UserAssignedIdentities
                *out = make([]apiv1beta1.UserAssignedIdentity, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov0" title="0">in.Strategy.DeepCopyInto(&amp;out.Strategy)
        if in.NodeDrainTimeout != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.NodeDrainTimeout, &amp;out.NodeDrainTimeout
                *out = new(v1.Duration)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachinePoolSpec.
func (in *AzureMachinePoolSpec) DeepCopy() *AzureMachinePoolSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachinePoolSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureMachinePoolStatus) DeepCopyInto(out *AzureMachinePoolStatus) <span class="cov0" title="0">{
        *out = *in
        if in.Instances != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Instances, &amp;out.Instances
                *out = make([]*AzureMachinePoolInstanceStatus, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        if (*in)[i] != nil </span><span class="cov0" title="0">{
                                in, out := &amp;(*in)[i], &amp;(*out)[i]
                                *out = new(AzureMachinePoolInstanceStatus)
                                (*in).DeepCopyInto(*out)
                        }</span>
                }
        }
        <span class="cov0" title="0">if in.Image != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Image, &amp;out.Image
                *out = new(apiv1beta1.Image)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov0" title="0">if in.ProvisioningState != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ProvisioningState, &amp;out.ProvisioningState
                *out = new(apiv1beta1.ProvisioningState)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.FailureReason != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.FailureReason, &amp;out.FailureReason
                *out = new(errors.MachineStatusError)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.FailureMessage != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.FailureMessage, &amp;out.FailureMessage
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.Conditions != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make(cluster_apiapiv1beta1.Conditions, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov0" title="0">if in.LongRunningOperationStates != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.LongRunningOperationStates, &amp;out.LongRunningOperationStates
                *out = make(apiv1beta1.Futures, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureMachinePoolStatus.
func (in *AzureMachinePoolStatus) DeepCopy() *AzureMachinePoolStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureMachinePoolStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedCluster) DeepCopyInto(out *AzureManagedCluster) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        out.Spec = in.Spec
        out.Status = in.Status
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedCluster.
func (in *AzureManagedCluster) DeepCopy() *AzureManagedCluster <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureManagedCluster)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureManagedCluster) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedClusterList) DeepCopyInto(out *AzureManagedClusterList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureManagedCluster, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedClusterList.
func (in *AzureManagedClusterList) DeepCopy() *AzureManagedClusterList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureManagedClusterList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureManagedClusterList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedClusterSpec) DeepCopyInto(out *AzureManagedClusterSpec) <span class="cov0" title="0">{
        *out = *in
        out.ControlPlaneEndpoint = in.ControlPlaneEndpoint
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedClusterSpec.
func (in *AzureManagedClusterSpec) DeepCopy() *AzureManagedClusterSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureManagedClusterSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedClusterStatus) DeepCopyInto(out *AzureManagedClusterStatus) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedClusterStatus.
func (in *AzureManagedClusterStatus) DeepCopy() *AzureManagedClusterStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureManagedClusterStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedControlPlane) DeepCopyInto(out *AzureManagedControlPlane) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
        in.Status.DeepCopyInto(&amp;out.Status)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedControlPlane.
func (in *AzureManagedControlPlane) DeepCopy() *AzureManagedControlPlane <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureManagedControlPlane)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureManagedControlPlane) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedControlPlaneList) DeepCopyInto(out *AzureManagedControlPlaneList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureManagedControlPlane, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedControlPlaneList.
func (in *AzureManagedControlPlaneList) DeepCopy() *AzureManagedControlPlaneList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureManagedControlPlaneList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureManagedControlPlaneList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedControlPlaneSpec) DeepCopyInto(out *AzureManagedControlPlaneSpec) <span class="cov0" title="0">{
        *out = *in
        out.VirtualNetwork = in.VirtualNetwork
        out.ControlPlaneEndpoint = in.ControlPlaneEndpoint
        if in.AdditionalTags != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AdditionalTags, &amp;out.AdditionalTags
                *out = make(apiv1beta1.Tags, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
        <span class="cov0" title="0">if in.NetworkPlugin != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.NetworkPlugin, &amp;out.NetworkPlugin
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.NetworkPolicy != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.NetworkPolicy, &amp;out.NetworkPolicy
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.DNSServiceIP != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.DNSServiceIP, &amp;out.DNSServiceIP
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.LoadBalancerSKU != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.LoadBalancerSKU, &amp;out.LoadBalancerSKU
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.IdentityRef != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.IdentityRef, &amp;out.IdentityRef
                *out = new(corev1.ObjectReference)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.AADProfile != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AADProfile, &amp;out.AADProfile
                *out = new(AADProfile)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov0" title="0">if in.AddonProfiles != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AddonProfiles, &amp;out.AddonProfiles
                *out = make([]AddonProfile, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov0" title="0">if in.SKU != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.SKU, &amp;out.SKU
                *out = new(SKU)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.LoadBalancerProfile != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.LoadBalancerProfile, &amp;out.LoadBalancerProfile
                *out = new(LoadBalancerProfile)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov0" title="0">if in.APIServerAccessProfile != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.APIServerAccessProfile, &amp;out.APIServerAccessProfile
                *out = new(APIServerAccessProfile)
                (*in).DeepCopyInto(*out)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedControlPlaneSpec.
func (in *AzureManagedControlPlaneSpec) DeepCopy() *AzureManagedControlPlaneSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureManagedControlPlaneSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedControlPlaneStatus) DeepCopyInto(out *AzureManagedControlPlaneStatus) <span class="cov0" title="0">{
        *out = *in
        if in.Conditions != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make(cluster_apiapiv1beta1.Conditions, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov0" title="0">if in.LongRunningOperationStates != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.LongRunningOperationStates, &amp;out.LongRunningOperationStates
                *out = make(apiv1beta1.Futures, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedControlPlaneStatus.
func (in *AzureManagedControlPlaneStatus) DeepCopy() *AzureManagedControlPlaneStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureManagedControlPlaneStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedMachinePool) DeepCopyInto(out *AzureManagedMachinePool) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
        in.Status.DeepCopyInto(&amp;out.Status)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedMachinePool.
func (in *AzureManagedMachinePool) DeepCopy() *AzureManagedMachinePool <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureManagedMachinePool)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureManagedMachinePool) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedMachinePoolList) DeepCopyInto(out *AzureManagedMachinePoolList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]AzureManagedMachinePool, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedMachinePoolList.
func (in *AzureManagedMachinePoolList) DeepCopy() *AzureManagedMachinePoolList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureManagedMachinePoolList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AzureManagedMachinePoolList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedMachinePoolSpec) DeepCopyInto(out *AzureManagedMachinePoolSpec) <span class="cov0" title="0">{
        *out = *in
        if in.Name != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Name, &amp;out.Name
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.OSDiskSizeGB != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.OSDiskSizeGB, &amp;out.OSDiskSizeGB
                *out = new(int32)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.AvailabilityZones != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AvailabilityZones, &amp;out.AvailabilityZones
                *out = make([]string, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov0" title="0">if in.NodeLabels != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.NodeLabels, &amp;out.NodeLabels
                *out = make(map[string]string, len(*in))
                for key, val := range *in </span><span class="cov0" title="0">{
                        (*out)[key] = val
                }</span>
        }
        <span class="cov0" title="0">if in.Taints != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Taints, &amp;out.Taints
                *out = make(Taints, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov0" title="0">if in.ProviderIDList != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ProviderIDList, &amp;out.ProviderIDList
                *out = make([]string, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov0" title="0">if in.Scaling != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Scaling, &amp;out.Scaling
                *out = new(ManagedMachinePoolScaling)
                (*in).DeepCopyInto(*out)
        }</span>
        <span class="cov0" title="0">if in.MaxPods != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.MaxPods, &amp;out.MaxPods
                *out = new(int32)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.OsDiskType != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.OsDiskType, &amp;out.OsDiskType
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.EnableUltraSSD != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.EnableUltraSSD, &amp;out.EnableUltraSSD
                *out = new(bool)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.OSType != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.OSType, &amp;out.OSType
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.EnableNodePublicIP != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.EnableNodePublicIP, &amp;out.EnableNodePublicIP
                *out = new(bool)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedMachinePoolSpec.
func (in *AzureManagedMachinePoolSpec) DeepCopy() *AzureManagedMachinePoolSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureManagedMachinePoolSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureManagedMachinePoolStatus) DeepCopyInto(out *AzureManagedMachinePoolStatus) <span class="cov0" title="0">{
        *out = *in
        if in.ErrorReason != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ErrorReason, &amp;out.ErrorReason
                *out = new(errors.MachineStatusError)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.ErrorMessage != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ErrorMessage, &amp;out.ErrorMessage
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.Conditions != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make(cluster_apiapiv1beta1.Conditions, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
        <span class="cov0" title="0">if in.LongRunningOperationStates != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.LongRunningOperationStates, &amp;out.LongRunningOperationStates
                *out = make(apiv1beta1.Futures, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureManagedMachinePoolStatus.
func (in *AzureManagedMachinePoolStatus) DeepCopy() *AzureManagedMachinePoolStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(AzureManagedMachinePoolStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LoadBalancerProfile) DeepCopyInto(out *LoadBalancerProfile) <span class="cov0" title="0">{
        *out = *in
        if in.ManagedOutboundIPs != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ManagedOutboundIPs, &amp;out.ManagedOutboundIPs
                *out = new(int32)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.OutboundIPPrefixes != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.OutboundIPPrefixes, &amp;out.OutboundIPPrefixes
                *out = make([]string, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov0" title="0">if in.OutboundIPs != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.OutboundIPs, &amp;out.OutboundIPs
                *out = make([]string, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov0" title="0">if in.AllocatedOutboundPorts != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.AllocatedOutboundPorts, &amp;out.AllocatedOutboundPorts
                *out = new(int32)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.IdleTimeoutInMinutes != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.IdleTimeoutInMinutes, &amp;out.IdleTimeoutInMinutes
                *out = new(int32)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LoadBalancerProfile.
func (in *LoadBalancerProfile) DeepCopy() *LoadBalancerProfile <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(LoadBalancerProfile)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MachineRollingUpdateDeployment) DeepCopyInto(out *MachineRollingUpdateDeployment) <span class="cov0" title="0">{
        *out = *in
        if in.MaxUnavailable != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.MaxUnavailable, &amp;out.MaxUnavailable
                *out = new(intstr.IntOrString)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.MaxSurge != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.MaxSurge, &amp;out.MaxSurge
                *out = new(intstr.IntOrString)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MachineRollingUpdateDeployment.
func (in *MachineRollingUpdateDeployment) DeepCopy() *MachineRollingUpdateDeployment <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(MachineRollingUpdateDeployment)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ManagedControlPlaneSubnet) DeepCopyInto(out *ManagedControlPlaneSubnet) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ManagedControlPlaneSubnet.
func (in *ManagedControlPlaneSubnet) DeepCopy() *ManagedControlPlaneSubnet <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(ManagedControlPlaneSubnet)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ManagedControlPlaneVirtualNetwork) DeepCopyInto(out *ManagedControlPlaneVirtualNetwork) <span class="cov0" title="0">{
        *out = *in
        out.Subnet = in.Subnet
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ManagedControlPlaneVirtualNetwork.
func (in *ManagedControlPlaneVirtualNetwork) DeepCopy() *ManagedControlPlaneVirtualNetwork <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(ManagedControlPlaneVirtualNetwork)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ManagedMachinePoolScaling) DeepCopyInto(out *ManagedMachinePoolScaling) <span class="cov0" title="0">{
        *out = *in
        if in.MinSize != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.MinSize, &amp;out.MinSize
                *out = new(int32)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.MaxSize != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.MaxSize, &amp;out.MaxSize
                *out = new(int32)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ManagedMachinePoolScaling.
func (in *ManagedMachinePoolScaling) DeepCopy() *ManagedMachinePoolScaling <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(ManagedMachinePoolScaling)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SKU) DeepCopyInto(out *SKU) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SKU.
func (in *SKU) DeepCopy() *SKU <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(SKU)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Taint) DeepCopyInto(out *Taint) <span class="cov0" title="0">{
        *out = *in
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Taint.
func (in *Taint) DeepCopy() *Taint <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(Taint)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in Taints) DeepCopyInto(out *Taints) <span class="cov0" title="0">{
        </span><span class="cov0" title="0">{
                in := &amp;in
                *out = make(Taints, len(*in))
                copy(*out, *in)
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Taints.
func (in Taints) DeepCopy() Taints <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(Taints)
        in.DeepCopyInto(out)
        return *out</span>
}
</pre>
		
		<pre class="file" id="file209" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "encoding/json"
)

// AnnotationJSON returns a map[string]interface from a JSON annotation.
// This method gets the given `annotation` from an `annotationReaderWriter` and unmarshalls it
// from a JSON string into a `map[string]interface{}`.
func (ampr *AzureMachinePoolReconciler) AnnotationJSON(rw annotationReaderWriter, annotation string) (map[string]interface{}, error) <span class="cov0" title="0">{
        out := map[string]interface{}{}

        jsonAnnotation := ampr.Annotation(rw, annotation)
        if jsonAnnotation == "" </span><span class="cov0" title="0">{
                return out, nil
        }</span>

        <span class="cov0" title="0">err := json.Unmarshal([]byte(jsonAnnotation), &amp;out)
        if err != nil </span><span class="cov0" title="0">{
                return out, err
        }</span>

        <span class="cov0" title="0">return out, nil</span>
}

// Annotation fetches the specific machine annotation.
func (ampr *AzureMachinePoolReconciler) Annotation(rw annotationReaderWriter, annotation string) string <span class="cov0" title="0">{
        return rw.GetAnnotations()[annotation]
}</span>
</pre>
		
		<pre class="file" id="file210" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "time"

        "github.com/pkg/errors"
        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/client-go/tools/record"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/scope"
        infracontroller "sigs.k8s.io/cluster-api-provider-azure/controllers"
        infrav1exp "sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/pkg/coalescing"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        expv1 "sigs.k8s.io/cluster-api/exp/api/v1beta1"
        "sigs.k8s.io/cluster-api/util"
        "sigs.k8s.io/cluster-api/util/annotations"
        "sigs.k8s.io/cluster-api/util/predicates"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
        "sigs.k8s.io/controller-runtime/pkg/source"
)

type (
        // AzureMachinePoolReconciler reconciles an AzureMachinePool object.
        AzureMachinePoolReconciler struct {
                client.Client
                Scheme                        *runtime.Scheme
                Recorder                      record.EventRecorder
                ReconcileTimeout              time.Duration
                WatchFilterValue              string
                createAzureMachinePoolService azureMachinePoolServiceCreator
        }

        // annotationReaderWriter provides an interface to read and write annotations.
        annotationReaderWriter interface {
                GetAnnotations() map[string]string
                SetAnnotations(annotations map[string]string)
        }
)

type azureMachinePoolServiceCreator func(machinePoolScope *scope.MachinePoolScope) (*azureMachinePoolService, error)

// NewAzureMachinePoolReconciler returns a new AzureMachinePoolReconciler instance.
func NewAzureMachinePoolReconciler(client client.Client, recorder record.EventRecorder, reconcileTimeout time.Duration, watchFilterValue string) *AzureMachinePoolReconciler <span class="cov8" title="1">{
        ampr := &amp;AzureMachinePoolReconciler{
                Client:           client,
                Recorder:         recorder,
                ReconcileTimeout: reconcileTimeout,
                WatchFilterValue: watchFilterValue,
        }

        ampr.createAzureMachinePoolService = newAzureMachinePoolService

        return ampr
}</span>

// SetupWithManager initializes this controller with a manager.
func (ampr *AzureMachinePoolReconciler) SetupWithManager(ctx context.Context, mgr ctrl.Manager, options infracontroller.Options) error <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx,
                "controllers.AzureMachinePoolReconciler.SetupWithManager",
                tele.KVP("controller", "AzureMachinePool"),
        )
        defer done()

        var r reconcile.Reconciler = ampr
        if options.Cache != nil </span><span class="cov0" title="0">{
                r = coalescing.NewReconciler(ampr, options.Cache, log)
        }</span>

        // create mapper to transform incoming AzureClusters into AzureMachinePool requests
        <span class="cov8" title="1">azureClusterMapper, err := AzureClusterToAzureMachinePoolsMapper(ctx, ampr.Client, mgr.GetScheme(), log)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to create AzureCluster to AzureMachinePools mapper")
        }</span>

        <span class="cov8" title="1">c, err := ctrl.NewControllerManagedBy(mgr).
                WithOptions(options.Options).
                For(&amp;infrav1exp.AzureMachinePool{}).
                WithEventFilter(predicates.ResourceNotPausedAndHasFilterLabel(log, ampr.WatchFilterValue)).
                // watch for changes in CAPI MachinePool resources
                Watches(
                        &amp;source.Kind{Type: &amp;expv1.MachinePool{}},
                        handler.EnqueueRequestsFromMapFunc(MachinePoolToInfrastructureMapFunc(infrav1exp.GroupVersion.WithKind("AzureMachinePool"), log)),
                ).
                // watch for changes in AzureCluster resources
                Watches(
                        &amp;source.Kind{Type: &amp;infrav1.AzureCluster{}},
                        handler.EnqueueRequestsFromMapFunc(azureClusterMapper),
                ).
                Build(r)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "error creating controller")
        }</span>

        <span class="cov8" title="1">if err := c.Watch(
                &amp;source.Kind{Type: &amp;infrav1exp.AzureMachinePoolMachine{}},
                handler.EnqueueRequestsFromMapFunc(AzureMachinePoolMachineMapper(mgr.GetScheme(), log)),
                MachinePoolMachineHasStateOrVersionChange(log),
                predicates.ResourceNotPausedAndHasFilterLabel(log, ampr.WatchFilterValue),
        ); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed adding a watch for AzureMachinePoolMachine")
        }</span>

        <span class="cov8" title="1">azureMachinePoolMapper, err := util.ClusterToObjectsMapper(ampr.Client, &amp;infrav1exp.AzureMachinePoolList{}, mgr.GetScheme())
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to create mapper for Cluster to AzureMachines")
        }</span>

        // Add a watch on clusterv1.Cluster object for unpause &amp; ready notifications.
        <span class="cov8" title="1">if err := c.Watch(
                &amp;source.Kind{Type: &amp;clusterv1.Cluster{}},
                handler.EnqueueRequestsFromMapFunc(azureMachinePoolMapper),
                predicates.ClusterUnpausedAndInfrastructureReady(log),
                predicates.ResourceNotPausedAndHasFilterLabel(log, ampr.WatchFilterValue),
        ); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed adding a watch for ready clusters")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// +kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=azuremachinepools,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=azuremachinepools/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=azuremachinepoolmachines,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=azuremachinepoolmachines/status,verbs=get
// +kubebuilder:rbac:groups=cluster.x-k8s.io,resources=machinepools;machinepools/status,verbs=get;list;watch;update;patch
// +kubebuilder:rbac:groups="",resources=events,verbs=get;list;watch;create;update;patch
// +kubebuilder:rbac:groups="",resources=secrets;,verbs=get;list;watch
// +kubebuilder:rbac:groups=core,resources=nodes,verbs=get;list;watch

// Reconcile idempotently gets, creates, and updates a machine pool.
func (ampr *AzureMachinePoolReconciler) Reconcile(ctx context.Context, req ctrl.Request) (_ ctrl.Result, reterr error) <span class="cov8" title="1">{
        ctx, logger, done := tele.StartSpanWithLogger(
                ctx,
                "controllers.AzureMachinePoolReconciler.Reconcile",
                tele.KVP("namespace", req.Namespace),
                tele.KVP("name", req.Name),
                tele.KVP("kind", "AzureMachinePool"),
        )
        defer done()
        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultedLoopTimeout(ampr.ReconcileTimeout))
        defer cancel()

        logger = logger.WithValues("namespace", req.Namespace, "azureMachinePool", req.Name)

        azMachinePool := &amp;infrav1exp.AzureMachinePool{}
        err := ampr.Get(ctx, req.NamespacedName, azMachinePool)
        if err != nil </span><span class="cov8" title="1">{
                if apierrors.IsNotFound(err) </span><span class="cov8" title="1">{
                        return reconcile.Result{}, nil
                }</span>
                <span class="cov0" title="0">return reconcile.Result{}, err</span>
        }

        // Fetch the CAPI MachinePool.
        <span class="cov0" title="0">machinePool, err := infracontroller.GetOwnerMachinePool(ctx, ampr.Client, azMachinePool.ObjectMeta)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov0" title="0">if machinePool == nil </span><span class="cov0" title="0">{
                logger.V(2).Info("MachinePool Controller has not yet set OwnerRef")
                return reconcile.Result{}, nil
        }</span>

        <span class="cov0" title="0">logger = logger.WithValues("machinePool", machinePool.Name)

        // Fetch the Cluster.
        cluster, err := util.GetClusterFromMetadata(ctx, ampr.Client, machinePool.ObjectMeta)
        if err != nil </span><span class="cov0" title="0">{
                logger.V(2).Info("MachinePool is missing cluster label or cluster does not exist")
                return reconcile.Result{}, nil
        }</span>

        <span class="cov0" title="0">logger = logger.WithValues("cluster", cluster.Name)

        // Return early if the object or Cluster is paused.
        if annotations.IsPaused(cluster, azMachinePool) </span><span class="cov0" title="0">{
                logger.V(2).Info("AzureMachinePool or linked Cluster is marked as paused. Won't reconcile")
                return ctrl.Result{}, nil
        }</span>

        <span class="cov0" title="0">logger = logger.WithValues("AzureCluster", cluster.Spec.InfrastructureRef.Name)
        azureClusterName := client.ObjectKey{
                Namespace: azMachinePool.Namespace,
                Name:      cluster.Spec.InfrastructureRef.Name,
        }
        azureCluster := &amp;infrav1.AzureCluster{}
        if err := ampr.Client.Get(ctx, azureClusterName, azureCluster); err != nil </span><span class="cov0" title="0">{
                logger.V(2).Info("AzureCluster is not available yet")
                return reconcile.Result{}, nil
        }</span>

        // Create the cluster scope
        <span class="cov0" title="0">clusterScope, err := scope.NewClusterScope(ctx, scope.ClusterScopeParams{
                Client:       ampr.Client,
                Cluster:      cluster,
                AzureCluster: azureCluster,
        })
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>

        // Create the machine pool scope
        <span class="cov0" title="0">machinePoolScope, err := scope.NewMachinePoolScope(scope.MachinePoolScopeParams{
                Client:           ampr.Client,
                MachinePool:      machinePool,
                AzureMachinePool: azMachinePool,
                ClusterScope:     clusterScope,
        })
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, errors.Wrap(err, "failed to create scope")
        }</span>

        // Always close the scope when exiting this function so we can persist any AzureMachine changes.
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := machinePoolScope.Close(ctx); err != nil &amp;&amp; reterr == nil </span><span class="cov0" title="0">{
                        reterr = err
                }</span>
        }()

        // Handle deleted machine pools
        <span class="cov0" title="0">if !azMachinePool.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                return ampr.reconcileDelete(ctx, machinePoolScope, clusterScope)
        }</span>

        // Handle non-deleted machine pools
        <span class="cov0" title="0">return ampr.reconcileNormal(ctx, machinePoolScope, clusterScope)</span>
}

func (ampr *AzureMachinePoolReconciler) reconcileNormal(ctx context.Context, machinePoolScope *scope.MachinePoolScope, clusterScope *scope.ClusterScope) (_ reconcile.Result, reterr error) <span class="cov0" title="0">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "controllers.AzureMachinePoolReconciler.reconcileNormal")
        defer done()

        log.Info("Reconciling AzureMachinePool")
        // If the AzureMachine is in an error state, return early.
        if machinePoolScope.AzureMachinePool.Status.FailureReason != nil || machinePoolScope.AzureMachinePool.Status.FailureMessage != nil </span><span class="cov0" title="0">{
                log.Info("Error state detected, skipping reconciliation")
                return reconcile.Result{}, nil
        }</span>

        // If the AzureMachine doesn't have our finalizer, add it.
        <span class="cov0" title="0">controllerutil.AddFinalizer(machinePoolScope.AzureMachinePool, expv1.MachinePoolFinalizer)
        // Register the finalizer immediately to avoid orphaning Azure resources on delete
        if err := machinePoolScope.PatchObject(ctx); err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov0" title="0">if !clusterScope.Cluster.Status.InfrastructureReady </span><span class="cov0" title="0">{
                log.Info("Cluster infrastructure is not ready yet")
                return reconcile.Result{}, nil
        }</span>

        // Make sure bootstrap data is available and populated.
        <span class="cov0" title="0">if machinePoolScope.MachinePool.Spec.Template.Spec.Bootstrap.DataSecretName == nil </span><span class="cov0" title="0">{
                log.Info("Bootstrap data secret reference is not yet available")
                return reconcile.Result{}, nil
        }</span>

        <span class="cov0" title="0">ams, err := ampr.createAzureMachinePoolService(machinePoolScope)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, errors.Wrap(err, "failed creating a newAzureMachinePoolService")
        }</span>

        <span class="cov0" title="0">if err := ams.Reconcile(ctx); err != nil </span><span class="cov0" title="0">{
                // Handle transient and terminal errors
                var reconcileError azure.ReconcileError
                if errors.As(err, &amp;reconcileError) </span><span class="cov0" title="0">{
                        if reconcileError.IsTerminal() </span><span class="cov0" title="0">{
                                log.Error(err, "failed to reconcile AzureMachinePool", "name", machinePoolScope.Name())
                                return reconcile.Result{}, nil
                        }</span>

                        <span class="cov0" title="0">if reconcileError.IsTransient() </span><span class="cov0" title="0">{
                                log.Error(err, "failed to reconcile AzureMachinePool", "name", machinePoolScope.Name())
                                return reconcile.Result{RequeueAfter: reconcileError.RequeueAfter()}, nil
                        }</span>

                        <span class="cov0" title="0">return reconcile.Result{}, errors.Wrap(err, "failed to reconcile AzureMachinePool")</span>
                }

                <span class="cov0" title="0">return reconcile.Result{}, err</span>
        }

        <span class="cov0" title="0">log.V(2).Info("Scale Set reconciled", "id",
                machinePoolScope.ProviderID(), "state", machinePoolScope.ProvisioningState())

        switch machinePoolScope.ProvisioningState() </span>{
        case infrav1.Deleting:<span class="cov0" title="0">
                log.Info("Unexpected scale set deletion", "id", machinePoolScope.ProviderID())
                ampr.Recorder.Eventf(machinePoolScope.AzureMachinePool, corev1.EventTypeWarning, "UnexpectedVMDeletion", "Unexpected Azure scale set deletion")</span>
        case infrav1.Failed:<span class="cov0" title="0">
                err := ams.Delete(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, errors.Wrap(err, "failed to delete scale set in a failed state")
                }</span>
                <span class="cov0" title="0">return reconcile.Result{}, errors.Wrap(err, "Scale set deleted, retry creating in next reconcile")</span>
        }

        <span class="cov0" title="0">if machinePoolScope.NeedsRequeue() </span><span class="cov0" title="0">{
                return reconcile.Result{
                        RequeueAfter: 30 * time.Second,
                }, nil
        }</span>

        <span class="cov0" title="0">return reconcile.Result{}, nil</span>
}

func (ampr *AzureMachinePoolReconciler) reconcileDelete(ctx context.Context, machinePoolScope *scope.MachinePoolScope, clusterScope *scope.ClusterScope) (reconcile.Result, error) <span class="cov0" title="0">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "controllers.AzureMachinePoolReconciler.reconcileDelete")
        defer done()

        log.V(2).Info("handling deleted AzureMachinePool")

        if infracontroller.ShouldDeleteIndividualResources(ctx, clusterScope) </span><span class="cov0" title="0">{
                amps, err := ampr.createAzureMachinePoolService(machinePoolScope)
                if err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, errors.Wrap(err, "failed creating a new AzureMachinePoolService")
                }</span>

                <span class="cov0" title="0">log.V(4).Info("deleting AzureMachinePool resource individually")
                if err := amps.Delete(ctx); err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, errors.Wrapf(err, "error deleting AzureMachinePool %s/%s", clusterScope.Namespace(), machinePoolScope.Name())
                }</span>
        }

        // Delete succeeded, remove finalizer
        <span class="cov0" title="0">log.V(4).Info("removing finalizer for AzureMachinePool")
        controllerutil.RemoveFinalizer(machinePoolScope.AzureMachinePool, expv1.MachinePoolFinalizer)
        return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file211" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"

        "github.com/pkg/errors"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/scope"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/resourceskus"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/roleassignments"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/scalesets"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

// azureMachinePoolService is the group of services called by the AzureMachinePool controller.
type azureMachinePoolService struct {
        scope    *scope.MachinePoolScope
        skuCache *resourceskus.Cache
        services []azure.ServiceReconciler
}

// newAzureMachinePoolService populates all the services based on input scope.
func newAzureMachinePoolService(machinePoolScope *scope.MachinePoolScope) (*azureMachinePoolService, error) <span class="cov8" title="1">{
        cache, err := resourceskus.GetCache(machinePoolScope, machinePoolScope.Location())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to create a NewCache")
        }</span>

        <span class="cov8" title="1">return &amp;azureMachinePoolService{
                scope: machinePoolScope,
                services: []azure.ServiceReconciler{
                        scalesets.New(machinePoolScope, cache),
                        roleassignments.New(machinePoolScope),
                },
                skuCache: cache,
        }, nil</span>
}

// Reconcile reconciles all the services in pre determined order.
func (s *azureMachinePoolService) Reconcile(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "controllers.azureMachinePoolService.Reconcile")
        defer done()

        if err := s.scope.SetSubnetName(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed defaulting subnet name")
        }</span>

        <span class="cov8" title="1">for _, service := range s.services </span><span class="cov8" title="1">{
                if err := service.Reconcile(ctx); err != nil </span><span class="cov8" title="1">{
                        return errors.Wrapf(err, "failed to reconcile AzureMachinePool service %s", service.Name())
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Delete reconciles all the services in pre determined order.
func (s *azureMachinePoolService) Delete(ctx context.Context) error <span class="cov8" title="1">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "controllers.azureMachinePoolService.Delete")
        defer done()

        // Delete services in reverse order of creation.
        for i := len(s.services) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if err := s.services[i].Delete(ctx); err != nil </span><span class="cov8" title="1">{
                        return errors.Wrapf(err, "failed to delete AzureMachinePool service %s", s.services[i].Name())
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file212" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "time"

        "github.com/pkg/errors"
        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/client-go/tools/record"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/scope"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/scalesetvms"
        infracontroller "sigs.k8s.io/cluster-api-provider-azure/controllers"
        infrav1exp "sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/pkg/coalescing"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
        capierrors "sigs.k8s.io/cluster-api/errors"
        "sigs.k8s.io/cluster-api/util"
        "sigs.k8s.io/cluster-api/util/annotations"
        "sigs.k8s.io/cluster-api/util/predicates"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
        "sigs.k8s.io/controller-runtime/pkg/source"
)

type (
        azureMachinePoolMachineReconcilerFactory func(*scope.MachinePoolMachineScope) azure.Reconciler

        // AzureMachinePoolMachineController handles Kubernetes change events for AzureMachinePoolMachine resources.
        AzureMachinePoolMachineController struct {
                client.Client
                Scheme            *runtime.Scheme
                Recorder          record.EventRecorder
                ReconcileTimeout  time.Duration
                WatchFilterValue  string
                reconcilerFactory azureMachinePoolMachineReconcilerFactory
        }

        azureMachinePoolMachineReconciler struct {
                Scope              *scope.MachinePoolMachineScope
                scalesetVMsService *scalesetvms.Service
        }
)

// NewAzureMachinePoolMachineController creates a new AzureMachinePoolMachineController to handle updates to Azure Machine Pool Machines.
func NewAzureMachinePoolMachineController(c client.Client, recorder record.EventRecorder, reconcileTimeout time.Duration, watchFilterValue string) *AzureMachinePoolMachineController <span class="cov8" title="1">{
        return &amp;AzureMachinePoolMachineController{
                Client:            c,
                Recorder:          recorder,
                ReconcileTimeout:  reconcileTimeout,
                WatchFilterValue:  watchFilterValue,
                reconcilerFactory: newAzureMachinePoolMachineReconciler,
        }
}</span>

// SetupWithManager initializes this controller with a manager.
func (ampmr *AzureMachinePoolMachineController) SetupWithManager(ctx context.Context, mgr ctrl.Manager, options infracontroller.Options) error <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx,
                "controllers.AzureMachinePoolMachineController.SetupWithManager",
                tele.KVP("controller", "AzureMachinePoolMachine"),
        )
        defer done()

        var r reconcile.Reconciler = ampmr
        if options.Cache != nil </span><span class="cov0" title="0">{
                r = coalescing.NewReconciler(ampmr, options.Cache, log)
        }</span>

        <span class="cov8" title="1">c, err := ctrl.NewControllerManagedBy(mgr).
                WithOptions(options.Options).
                For(&amp;infrav1exp.AzureMachinePoolMachine{}).
                WithEventFilter(predicates.ResourceNotPausedAndHasFilterLabel(log, ampmr.WatchFilterValue)).
                Build(r)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "error creating controller")
        }</span>

        // Add a watch on AzureMachinePool for model changes
        <span class="cov8" title="1">if err := c.Watch(
                &amp;source.Kind{Type: &amp;infrav1exp.AzureMachinePool{}},
                handler.EnqueueRequestsFromMapFunc(AzureMachinePoolToAzureMachinePoolMachines(ctx, mgr.GetClient(), log)),
                MachinePoolModelHasChanged(log),
                predicates.ResourceNotPausedAndHasFilterLabel(log, ampmr.WatchFilterValue),
        ); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed adding a watch for AzureMachinePool model changes")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// +kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=azuremachinepools,verbs=get;list;watch
// +kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=azuremachinepools/status,verbs=get
// +kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=azuremachinepoolmachines,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=azuremachinepoolmachines/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=cluster.x-k8s.io,resources=machinepools;machinepools/status,verbs=get
// +kubebuilder:rbac:groups="",resources=events,verbs=get;list;watch;create;update;patch
// +kubebuilder:rbac:groups="",resources=secrets;,verbs=get;list;watch
// +kubebuilder:rbac:groups=core,resources=nodes,verbs=get;list;watch

// Reconcile idempotently gets, creates, and updates a machine pool.
func (ampmr *AzureMachinePoolMachineController) Reconcile(ctx context.Context, req ctrl.Request) (_ ctrl.Result, reterr error) <span class="cov8" title="1">{
        ctx, logger, done := tele.StartSpanWithLogger(
                ctx,
                "controllers.AzureMachinePoolMachineController.Reconcile",
                tele.KVP("namespace", req.Namespace),
                tele.KVP("name", req.Name),
                tele.KVP("kind", "AzureMachinePoolMachine"),
        )
        defer done()

        logger = logger.WithValues("namespace", req.Namespace, "azureMachinePoolMachine", req.Name)

        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultedLoopTimeout(ampmr.ReconcileTimeout))
        defer cancel()

        machine := &amp;infrav1exp.AzureMachinePoolMachine{}
        err := ampmr.Get(ctx, req.NamespacedName, machine)
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return reconcile.Result{}, nil
                }</span>
                <span class="cov0" title="0">return reconcile.Result{}, err</span>
        }

        // Fetch the owning AzureMachinePool (VMSS)
        <span class="cov8" title="1">azureMachinePool, err := infracontroller.GetOwnerAzureMachinePool(ctx, ampmr.Client, machine.ObjectMeta)
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        controllerutil.RemoveFinalizer(machine, infrav1exp.AzureMachinePoolMachineFinalizer)
                        return reconcile.Result{}, ampmr.Client.Update(ctx, machine)
                }</span>
                <span class="cov0" title="0">return reconcile.Result{}, err</span>
        }

        <span class="cov8" title="1">if azureMachinePool != nil </span><span class="cov8" title="1">{
                logger = logger.WithValues("azureMachinePool", azureMachinePool.Name)
        }</span>

        // Fetch the CAPI MachinePool.
        <span class="cov8" title="1">machinePool, err := infracontroller.GetOwnerMachinePool(ctx, ampmr.Client, azureMachinePool.ObjectMeta)
        if err != nil &amp;&amp; !apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov8" title="1">if machinePool != nil </span><span class="cov8" title="1">{
                logger = logger.WithValues("machinePool", machinePool.Name)
        }</span>

        // Fetch the Cluster.
        <span class="cov8" title="1">cluster, err := util.GetClusterFromMetadata(ctx, ampmr.Client, machinePool.ObjectMeta)
        if err != nil </span><span class="cov0" title="0">{
                logger.Info("MachinePool is missing cluster label or cluster does not exist")
                return reconcile.Result{}, nil
        }</span>

        <span class="cov8" title="1">logger = logger.WithValues("cluster", cluster.Name)

        // Return early if the object or Cluster is paused.
        if annotations.IsPaused(cluster, machine) </span><span class="cov0" title="0">{
                logger.Info("AzureMachinePoolMachine or linked Cluster is marked as paused. Won't reconcile")
                return ctrl.Result{}, nil
        }</span>

        <span class="cov8" title="1">azureClusterName := client.ObjectKey{
                Namespace: machine.Namespace,
                Name:      cluster.Spec.InfrastructureRef.Name,
        }

        azureCluster := &amp;infrav1.AzureCluster{}
        if err := ampmr.Client.Get(ctx, azureClusterName, azureCluster); err != nil </span><span class="cov0" title="0">{
                logger.Info("AzureCluster is not available yet")
                return reconcile.Result{}, nil
        }</span>

        <span class="cov8" title="1">logger = logger.WithValues("AzureCluster", azureCluster.Name)

        // Create the cluster scope
        clusterScope, err := scope.NewClusterScope(ctx, scope.ClusterScopeParams{
                Client:       ampmr.Client,
                Cluster:      cluster,
                AzureCluster: azureCluster,
        })
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>

        // Create the machine pool scope
        <span class="cov8" title="1">machineScope, err := scope.NewMachinePoolMachineScope(scope.MachinePoolMachineScopeParams{
                Client:                  ampmr.Client,
                MachinePool:             machinePool,
                AzureMachinePool:        azureMachinePool,
                AzureMachinePoolMachine: machine,
                ClusterScope:            clusterScope,
        })
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, errors.Wrap(err, "failed to create scope")
        }</span>

        // Always close the scope when exiting this function so we can persist any AzureMachine changes.
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := machineScope.Close(ctx); err != nil &amp;&amp; reterr == nil </span><span class="cov0" title="0">{
                        reterr = err
                }</span>
        }()

        // Handle deleted machine pools machine
        <span class="cov8" title="1">if !machine.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov8" title="1">{
                return ampmr.reconcileDelete(ctx, machineScope)
        }</span>

        <span class="cov8" title="1">if !clusterScope.Cluster.Status.InfrastructureReady </span><span class="cov0" title="0">{
                logger.Info("Cluster infrastructure is not ready yet")
                return reconcile.Result{}, nil
        }</span>

        // Handle non-deleted machine pools
        <span class="cov8" title="1">return ampmr.reconcileNormal(ctx, machineScope)</span>
}

func (ampmr *AzureMachinePoolMachineController) reconcileNormal(ctx context.Context, machineScope *scope.MachinePoolMachineScope) (_ reconcile.Result, reterr error) <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "controllers.AzureMachinePoolMachineController.reconcileNormal")
        defer done()

        log.Info("Reconciling AzureMachinePoolMachine")
        // If the AzureMachine is in an error state, return early.
        if machineScope.AzureMachinePool.Status.FailureReason != nil || machineScope.AzureMachinePool.Status.FailureMessage != nil </span><span class="cov0" title="0">{
                log.Info("Error state detected, skipping reconciliation")
                return reconcile.Result{}, nil
        }</span>

        <span class="cov8" title="1">ampms := ampmr.reconcilerFactory(machineScope)
        if err := ampms.Reconcile(ctx); err != nil </span><span class="cov0" title="0">{
                // Handle transient and terminal errors
                var reconcileError azure.ReconcileError
                if errors.As(err, &amp;reconcileError) </span><span class="cov0" title="0">{
                        if reconcileError.IsTerminal() </span><span class="cov0" title="0">{
                                log.Error(err, "failed to reconcile AzureMachinePool", "name", machineScope.Name())
                                return reconcile.Result{}, nil
                        }</span>

                        <span class="cov0" title="0">if reconcileError.IsTransient() </span><span class="cov0" title="0">{
                                log.V(4).Info("failed to reconcile AzureMachinePoolMachine", "name", machineScope.Name(), "transient_error", err)
                                return reconcile.Result{RequeueAfter: reconcileError.RequeueAfter()}, nil
                        }</span>

                        <span class="cov0" title="0">return reconcile.Result{}, errors.Wrapf(err, "failed to reconcile AzureMachinePool")</span>
                }

                <span class="cov0" title="0">return reconcile.Result{}, err</span>
        }

        <span class="cov8" title="1">state := machineScope.ProvisioningState()
        switch state </span>{
        case infrav1.Failed:<span class="cov0" title="0">
                ampmr.Recorder.Eventf(machineScope.AzureMachinePoolMachine, corev1.EventTypeWarning, "FailedVMState", "Azure scale set VM is in failed state")
                machineScope.SetFailureReason(capierrors.UpdateMachineError)
                machineScope.SetFailureMessage(errors.Errorf("Azure VM state is %s", state))</span>
        case infrav1.Deleting:<span class="cov0" title="0">
                if err := ampmr.Client.Delete(ctx, machineScope.AzureMachinePoolMachine); err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, errors.Wrap(err, "machine pool machine failed to be deleted when deleting")
                }</span>
        }

        <span class="cov8" title="1">log.V(2).Info(fmt.Sprintf("Scale Set VM is %s", state), "id", machineScope.ProviderID())

        if !infrav1.IsTerminalProvisioningState(state) || !machineScope.IsReady() </span><span class="cov8" title="1">{
                log.V(2).Info("Requeuing", "state", state, "ready", machineScope.IsReady())
                // we are in a non-terminal state, retry in a bit
                return reconcile.Result{
                        RequeueAfter: 30 * time.Second,
                }, nil
        }</span>

        <span class="cov0" title="0">return reconcile.Result{}, nil</span>
}

func (ampmr *AzureMachinePoolMachineController) reconcileDelete(ctx context.Context, machineScope *scope.MachinePoolMachineScope) (_ reconcile.Result, reterr error) <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "controllers.AzureMachinePoolMachineController.reconcileDelete")
        defer done()

        log.Info("Handling deleted AzureMachinePoolMachine")

        if machineScope.AzureMachinePool == nil || !machineScope.AzureMachinePool.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                // deleting the entire VMSS, so just remove finalizer and VMSS delete remove the underlying infrastructure.
                controllerutil.RemoveFinalizer(machineScope.AzureMachinePoolMachine, infrav1exp.AzureMachinePoolMachineFinalizer)
                return reconcile.Result{}, nil
        }</span>

        // deleting a single machine
        // 1) drain the node (TODO: @devigned)
        // 2) after drained, delete the infrastructure
        // 3) remove finalizer

        <span class="cov8" title="1">ampms := ampmr.reconcilerFactory(machineScope)
        if err := ampms.Delete(ctx); err != nil </span><span class="cov0" title="0">{
                // Handle transient and terminal errors
                var reconcileError azure.ReconcileError
                if errors.As(err, &amp;reconcileError) </span><span class="cov0" title="0">{
                        if reconcileError.IsTerminal() </span><span class="cov0" title="0">{
                                log.Error(err, "failed to delete AzureMachinePoolMachine", "name", machineScope.Name())
                                return reconcile.Result{}, nil
                        }</span>

                        <span class="cov0" title="0">if reconcileError.IsTransient() </span><span class="cov0" title="0">{
                                log.V(4).Info("failed to delete AzureMachinePoolMachine", "name", machineScope.Name(), "transient_error", err)
                                return reconcile.Result{RequeueAfter: reconcileError.RequeueAfter()}, nil
                        }</span>

                        <span class="cov0" title="0">return reconcile.Result{}, errors.Wrapf(err, "failed to reconcile AzureMachinePool")</span>
                }

                <span class="cov0" title="0">return reconcile.Result{}, err</span>
        }

        <span class="cov8" title="1">return reconcile.Result{}, nil</span>
}

func newAzureMachinePoolMachineReconciler(scope *scope.MachinePoolMachineScope) azure.Reconciler <span class="cov0" title="0">{
        return &amp;azureMachinePoolMachineReconciler{
                Scope:              scope,
                scalesetVMsService: scalesetvms.NewService(scope),
        }
}</span>

// Reconcile will reconcile the state of the Machine Pool Machine with the state of the Azure VMSS VM.
func (r *azureMachinePoolMachineReconciler) Reconcile(ctx context.Context) error <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "controllers.azureMachinePoolMachineReconciler.Reconcile")
        defer done()

        if err := r.scalesetVMsService.Reconcile(ctx); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to reconcile scalesetVMs")
        }</span>

        <span class="cov0" title="0">if err := r.Scope.UpdateNodeStatus(ctx); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to update VMSS VM node status")
        }</span>

        <span class="cov0" title="0">if err := r.Scope.UpdateInstanceStatus(ctx); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to update VMSS VM instance status")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete will attempt to drain and delete the Azure VMSS VM.
func (r *azureMachinePoolMachineReconciler) Delete(ctx context.Context) error <span class="cov0" title="0">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "controllers.azureMachinePoolMachineReconciler.Delete")
        defer done()

        defer func() </span><span class="cov0" title="0">{
                if err := r.Scope.UpdateNodeStatus(ctx); err != nil </span><span class="cov0" title="0">{
                        log.V(4).Info("failed to update VMSS VM node status during delete")
                }</span>

                <span class="cov0" title="0">if err := r.Scope.UpdateInstanceStatus(ctx); err != nil </span><span class="cov0" title="0">{
                        log.V(4).Info("failed to update VMSS VM instanace status during delete")
                }</span>
        }()

        // cordon and drain stuff
        <span class="cov0" title="0">if err := r.Scope.CordonAndDrain(ctx); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to cordon and drain the scalesetVMs")
        }</span>

        <span class="cov0" title="0">if err := r.scalesetVMsService.Delete(ctx); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to reconcile scalesetVMs")
        }</span>

        // no long running operation, so we are finished deleting the resource. Remove the finalizer.
        <span class="cov0" title="0">controllerutil.RemoveFinalizer(r.Scope.AzureMachinePoolMachine, infrav1exp.AzureMachinePoolMachineFinalizer)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file213" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "time"

        "github.com/pkg/errors"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/tools/record"
        infracontroller "sigs.k8s.io/cluster-api-provider-azure/controllers"
        infrav1exp "sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/pkg/coalescing"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        "sigs.k8s.io/cluster-api/util"
        "sigs.k8s.io/cluster-api/util/annotations"
        "sigs.k8s.io/cluster-api/util/patch"
        "sigs.k8s.io/cluster-api/util/predicates"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
        "sigs.k8s.io/controller-runtime/pkg/source"
)

// AzureManagedClusterReconciler reconciles an AzureManagedCluster object.
type AzureManagedClusterReconciler struct {
        client.Client
        Recorder         record.EventRecorder
        ReconcileTimeout time.Duration
        WatchFilterValue string
}

// SetupWithManager initializes this controller with a manager.
func (amcr *AzureManagedClusterReconciler) SetupWithManager(ctx context.Context, mgr ctrl.Manager, options infracontroller.Options) error <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx,
                "controllers.AzureManagedClusterReconciler.SetupWithManager",
                tele.KVP("controller", "AzureManagedCluster"),
        )
        defer done()

        var r reconcile.Reconciler = amcr
        if options.Cache != nil </span><span class="cov0" title="0">{
                r = coalescing.NewReconciler(amcr, options.Cache, log)
        }</span>

        <span class="cov8" title="1">azManagedCluster := &amp;infrav1exp.AzureManagedCluster{}
        // create mapper to transform incoming AzureManagedControlPlanes into AzureManagedCluster requests
        azureManagedControlPlaneMapper, err := AzureManagedControlPlaneToAzureManagedClusterMapper(ctx, amcr.Client, log)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to create AzureManagedControlPlane to AzureManagedClusters mapper")
        }</span>

        <span class="cov8" title="1">c, err := ctrl.NewControllerManagedBy(mgr).
                WithOptions(options.Options).
                For(azManagedCluster).
                WithEventFilter(predicates.ResourceNotPausedAndHasFilterLabel(log, amcr.WatchFilterValue)).
                // watch AzureManagedControlPlane resources
                Watches(
                        &amp;source.Kind{Type: &amp;infrav1exp.AzureManagedControlPlane{}},
                        handler.EnqueueRequestsFromMapFunc(azureManagedControlPlaneMapper),
                ).
                Build(r)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "error creating controller")
        }</span>

        // Add a watch on clusterv1.Cluster object for unpause notifications.
        <span class="cov8" title="1">if err = c.Watch(
                &amp;source.Kind{Type: &amp;clusterv1.Cluster{}},
                handler.EnqueueRequestsFromMapFunc(util.ClusterToInfrastructureMapFunc(ctx, infrav1exp.GroupVersion.WithKind("AzureManagedCluster"), mgr.GetClient(), &amp;infrav1exp.AzureManagedCluster{})),
                predicates.ClusterUnpaused(log),
                predicates.ResourceNotPausedAndHasFilterLabel(log, amcr.WatchFilterValue),
        ); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed adding a watch for ready clusters")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// +kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=azuremanagedclusters,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=azuremanagedclusters/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=cluster.x-k8s.io,resources=clusters;clusters/status,verbs=get;list;watch
// +kubebuilder:rbac:groups="",resources=secrets,verbs=get;list;watch;create;update;patch;delete

// Reconcile idempotently gets, creates, and updates a managed cluster.
func (amcr *AzureManagedClusterReconciler) Reconcile(ctx context.Context, req ctrl.Request) (_ ctrl.Result, reterr error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultedLoopTimeout(amcr.ReconcileTimeout))
        defer cancel()

        ctx, log, done := tele.StartSpanWithLogger(
                ctx,
                "controllers.AzureManagedClusterReconciler.Reconcile",
                tele.KVP("namespace", req.Namespace),
                tele.KVP("name", req.Name),
                tele.KVP("kind", "AzureManagedCluster"),
        )
        defer done()

        // Fetch the AzureManagedCluster instance
        aksCluster := &amp;infrav1exp.AzureManagedCluster{}
        err := amcr.Get(ctx, req.NamespacedName, aksCluster)
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return reconcile.Result{}, nil
                }</span>
                <span class="cov0" title="0">return reconcile.Result{}, err</span>
        }

        // Fetch the Cluster.
        <span class="cov0" title="0">cluster, err := util.GetOwnerCluster(ctx, amcr.Client, aksCluster.ObjectMeta)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                log.Info("Cluster Controller has not yet set OwnerRef")
                return reconcile.Result{}, nil
        }</span>

        <span class="cov0" title="0">controlPlane := &amp;infrav1exp.AzureManagedControlPlane{}
        controlPlaneRef := types.NamespacedName{
                Name:      cluster.Spec.ControlPlaneRef.Name,
                Namespace: cluster.Namespace,
        }

        log = log.WithValues("cluster", cluster.Name)

        // Return early if the object or Cluster is paused.
        if annotations.IsPaused(cluster, aksCluster) </span><span class="cov0" title="0">{
                log.Info("AzureManagedCluster or linked Cluster is marked as paused. Won't reconcile")
                return ctrl.Result{}, nil
        }</span>

        <span class="cov0" title="0">if err := amcr.Get(ctx, controlPlaneRef, controlPlane); err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, errors.Wrap(err, "failed to get control plane ref")
        }</span>

        <span class="cov0" title="0">log = log.WithValues("controlPlane", controlPlaneRef.Name)

        patchhelper, err := patch.NewHelper(aksCluster, amcr.Client)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, errors.Wrap(err, "failed to init patch helper")
        }</span>

        // Infrastructure must be ready before control plane. We should also enqueue
        // requests from control plane to infra cluster to keep control plane endpoint accurate.
        <span class="cov0" title="0">aksCluster.Status.Ready = true
        aksCluster.Spec.ControlPlaneEndpoint = controlPlane.Spec.ControlPlaneEndpoint

        if err := patchhelper.Patch(ctx, aksCluster); err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov0" title="0">log.Info("Successfully reconciled")

        return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file214" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "time"

        "github.com/pkg/errors"
        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/client-go/tools/record"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/scope"
        infracontroller "sigs.k8s.io/cluster-api-provider-azure/controllers"
        infrav1exp "sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/pkg/coalescing"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        expv1 "sigs.k8s.io/cluster-api/exp/api/v1beta1"
        capiexputil "sigs.k8s.io/cluster-api/exp/util"
        "sigs.k8s.io/cluster-api/util"
        "sigs.k8s.io/cluster-api/util/annotations"
        "sigs.k8s.io/cluster-api/util/predicates"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
        "sigs.k8s.io/controller-runtime/pkg/source"
)

// AzureManagedControlPlaneReconciler reconciles an AzureManagedControlPlane object.
type AzureManagedControlPlaneReconciler struct {
        client.Client
        Recorder         record.EventRecorder
        ReconcileTimeout time.Duration
        WatchFilterValue string
}

// SetupWithManager initializes this controller with a manager.
func (amcpr *AzureManagedControlPlaneReconciler) SetupWithManager(ctx context.Context, mgr ctrl.Manager, options infracontroller.Options) error <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx,
                "controllers.AzureManagedControlPlaneReconciler.SetupWithManager",
                tele.KVP("controller", "AzureManagedControlPlane"),
        )
        defer done()

        var r reconcile.Reconciler = amcpr
        if options.Cache != nil </span><span class="cov0" title="0">{
                r = coalescing.NewReconciler(amcpr, options.Cache, log)
        }</span>

        <span class="cov8" title="1">azManagedControlPlane := &amp;infrav1exp.AzureManagedControlPlane{}
        // create mapper to transform incoming AzureManagedClusters into AzureManagedControlPlane requests
        azureManagedClusterMapper, err := AzureManagedClusterToAzureManagedControlPlaneMapper(ctx, amcpr.Client, log)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to create AzureManagedCluster to AzureManagedControlPlane mapper")
        }</span>

        // map requests for machine pools corresponding to AzureManagedControlPlane's defaultPool back to the corresponding AzureManagedControlPlane.
        <span class="cov8" title="1">azureManagedMachinePoolMapper := MachinePoolToAzureManagedControlPlaneMapFunc(ctx, amcpr.Client, infrav1exp.GroupVersion.WithKind("AzureManagedControlPlane"), log)

        c, err := ctrl.NewControllerManagedBy(mgr).
                WithOptions(options.Options).
                For(azManagedControlPlane).
                WithEventFilter(predicates.ResourceNotPausedAndHasFilterLabel(log, amcpr.WatchFilterValue)).
                // watch AzureManagedCluster resources
                Watches(
                        &amp;source.Kind{Type: &amp;infrav1exp.AzureManagedCluster{}},
                        handler.EnqueueRequestsFromMapFunc(azureManagedClusterMapper),
                ).
                // watch MachinePool resources
                Watches(
                        &amp;source.Kind{Type: &amp;expv1.MachinePool{}},
                        handler.EnqueueRequestsFromMapFunc(azureManagedMachinePoolMapper),
                ).
                Build(r)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "error creating controller")
        }</span>

        // Add a watch on clusterv1.Cluster object for unpause &amp; ready notifications.
        <span class="cov8" title="1">if err = c.Watch(
                &amp;source.Kind{Type: &amp;clusterv1.Cluster{}},
                handler.EnqueueRequestsFromMapFunc(util.ClusterToInfrastructureMapFunc(ctx, infrav1exp.GroupVersion.WithKind("AzureManagedControlPlane"), mgr.GetClient(), &amp;infrav1exp.AzureManagedControlPlane{})),
                predicates.ClusterUnpausedAndInfrastructureReady(log),
                predicates.ResourceNotPausedAndHasFilterLabel(log, amcpr.WatchFilterValue),
        ); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed adding a watch for ready clusters")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// +kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=azuremanagedcontrolplanes,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=azuremanagedcontrolplanes/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=cluster.x-k8s.io,resources=clusters;clusters/status,verbs=get;list;watch

// Reconcile idempotently gets, creates, and updates a managed control plane.
func (amcpr *AzureManagedControlPlaneReconciler) Reconcile(ctx context.Context, req ctrl.Request) (_ ctrl.Result, reterr error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultedLoopTimeout(amcpr.ReconcileTimeout))
        defer cancel()

        ctx, log, done := tele.StartSpanWithLogger(ctx, "controllers.AzureManagedControlPlaneReconciler.Reconcile",
                tele.KVP("namespace", req.Namespace),
                tele.KVP("name", req.Name),
                tele.KVP("kind", "AzureManagedControlPlane"),
        )
        defer done()

        // Fetch the AzureManagedControlPlane instance
        azureControlPlane := &amp;infrav1exp.AzureManagedControlPlane{}
        err := amcpr.Get(ctx, req.NamespacedName, azureControlPlane)
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return reconcile.Result{}, nil
                }</span>
                <span class="cov0" title="0">return reconcile.Result{}, err</span>
        }

        // Fetch the Cluster.
        <span class="cov0" title="0">cluster, err := util.GetOwnerCluster(ctx, amcpr.Client, azureControlPlane.ObjectMeta)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov0" title="0">if cluster == nil </span><span class="cov0" title="0">{
                log.Info("Cluster Controller has not yet set OwnerRef")
                return reconcile.Result{}, nil
        }</span>

        <span class="cov0" title="0">log = log.WithValues("cluster", cluster.Name)

        // Return early if the object or Cluster is paused.
        if annotations.IsPaused(cluster, azureControlPlane) </span><span class="cov0" title="0">{
                log.Info("AzureManagedControlPlane or linked Cluster is marked as paused. Won't reconcile")
                return ctrl.Result{}, nil
        }</span>

        // Fetch all the ManagedMachinePools owned by this Cluster.
        <span class="cov0" title="0">opt1 := client.InNamespace(azureControlPlane.Namespace)
        opt2 := client.MatchingLabels(map[string]string{
                clusterv1.ClusterLabelName: cluster.Name,
        })

        ammpList := &amp;infrav1exp.AzureManagedMachinePoolList{}
        if err := amcpr.List(ctx, ammpList, opt1, opt2); err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov0" title="0">var pools = make([]scope.ManagedMachinePool, len(ammpList.Items))

        for i, ammp := range ammpList.Items </span><span class="cov0" title="0">{
                // Fetch the owner MachinePool.
                ownerPool, err := capiexputil.GetOwnerMachinePool(ctx, amcpr.Client, ammp.ObjectMeta)
                if err != nil || ownerPool == nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, errors.Wrapf(err, "failed to fetch owner MachinePool for AzureManagedMachinePool: %s", ammp.Name)
                }</span>
                <span class="cov0" title="0">pools[i] = scope.ManagedMachinePool{
                        InfraMachinePool: &amp;ammpList.Items[i],
                        MachinePool:      ownerPool,
                }</span>
        }

        // check if the control plane's namespace is allowed for this identity and update owner references for the identity.
        <span class="cov0" title="0">if azureControlPlane.Spec.IdentityRef != nil </span><span class="cov0" title="0">{
                err := infracontroller.EnsureClusterIdentity(ctx, amcpr.Client, azureControlPlane, azureControlPlane.Spec.IdentityRef, infrav1exp.ManagedClusterFinalizer)
                if err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, err
                }</span>
        } else<span class="cov0" title="0"> {
                warningMessage := ("You're using deprecated functionality: ")
                warningMessage += ("Using Azure credentials from the manager environment is deprecated and will be removed in future releases. ")
                warningMessage += ("Please specify an AzureClusterIdentity for the AzureManagedControlPlane instead, see: https://capz.sigs.k8s.io/topics/multitenancy.html ")
                log.Info(fmt.Sprintf("WARNING, %s", warningMessage))
                amcpr.Recorder.Eventf(azureControlPlane, corev1.EventTypeWarning, "AzureClusterIdentity", warningMessage)
        }</span>

        // Create the scope.
        <span class="cov0" title="0">mcpScope, err := scope.NewManagedControlPlaneScope(ctx, scope.ManagedControlPlaneScopeParams{
                Client:              amcpr.Client,
                Cluster:             cluster,
                ControlPlane:        azureControlPlane,
                ManagedMachinePools: pools,
        })
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, errors.Wrap(err, "failed to create scope")
        }</span>

        // Always patch when exiting so we can persist changes to finalizers and status
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := mcpScope.Close(ctx); err != nil &amp;&amp; reterr == nil </span><span class="cov0" title="0">{
                        reterr = err
                }</span>
        }()

        // Handle deleted clusters
        <span class="cov0" title="0">if !azureControlPlane.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                return amcpr.reconcileDelete(ctx, mcpScope)
        }</span>
        // Handle non-deleted clusters
        <span class="cov0" title="0">return amcpr.reconcileNormal(ctx, mcpScope)</span>
}

func (amcpr *AzureManagedControlPlaneReconciler) reconcileNormal(ctx context.Context, scope *scope.ManagedControlPlaneScope) (reconcile.Result, error) <span class="cov0" title="0">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "controllers.AzureManagedControlPlaneReconciler.reconcileNormal")
        defer done()

        log.Info("Reconciling AzureManagedControlPlane")

        // Remove deprecated Cluster finalizer if it exists.
        controllerutil.RemoveFinalizer(scope.ControlPlane, infrav1.ClusterFinalizer)
        // If the AzureManagedControlPlane doesn't have our finalizer, add it.
        controllerutil.AddFinalizer(scope.ControlPlane, infrav1exp.ManagedClusterFinalizer)
        // Register the finalizer immediately to avoid orphaning Azure resources on delete
        if err := scope.PatchObject(ctx); err != nil </span><span class="cov0" title="0">{
                amcpr.Recorder.Eventf(scope.ControlPlane, corev1.EventTypeWarning, "AzureManagedControlPlane unavailable", "failed to patch resource: %s", err)
                return reconcile.Result{}, err
        }</span>

        <span class="cov0" title="0">if err := newAzureManagedControlPlaneReconciler(scope).Reconcile(ctx); err != nil </span><span class="cov0" title="0">{
                // Handle transient and terminal errors
                log := log.WithValues("name", scope.ControlPlane.Name, "namespace", scope.ControlPlane.Namespace)
                var reconcileError azure.ReconcileError
                if errors.As(err, &amp;reconcileError) </span><span class="cov0" title="0">{
                        if reconcileError.IsTerminal() </span><span class="cov0" title="0">{
                                log.Error(err, "failed to reconcile AzureManagedControlPlane")
                                return reconcile.Result{}, nil
                        }</span>

                        <span class="cov0" title="0">if reconcileError.IsTransient() </span><span class="cov0" title="0">{
                                log.V(4).Info("requeuing due to transient transient failure", "error", err)
                                return reconcile.Result{RequeueAfter: reconcileError.RequeueAfter()}, nil
                        }</span>

                        <span class="cov0" title="0">return reconcile.Result{}, errors.Wrap(err, "failed to reconcile AzureManagedControlPlane")</span>
                }

                <span class="cov0" title="0">return reconcile.Result{}, errors.Wrapf(err, "error creating AzureManagedControlPlane %s/%s", scope.ControlPlane.Namespace, scope.ControlPlane.Name)</span>
        }

        // No errors, so mark us ready so the Cluster API Cluster Controller can pull it
        <span class="cov0" title="0">scope.ControlPlane.Status.Ready = true
        scope.ControlPlane.Status.Initialized = true
        return reconcile.Result{}, nil</span>
}

func (amcpr *AzureManagedControlPlaneReconciler) reconcileDelete(ctx context.Context, scope *scope.ManagedControlPlaneScope) (reconcile.Result, error) <span class="cov0" title="0">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "controllers.AzureManagedControlPlaneReconciler.reconcileDelete")
        defer done()

        log.Info("Reconciling AzureManagedControlPlane delete")

        if err := newAzureManagedControlPlaneReconciler(scope).Delete(ctx); err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, errors.Wrapf(err, "error deleting AzureManagedControlPlane %s/%s", scope.ControlPlane.Namespace, scope.ControlPlane.Name)
        }</span>

        // Cluster is deleted so remove the finalizer.
        <span class="cov0" title="0">controllerutil.RemoveFinalizer(scope.ControlPlane, infrav1exp.ManagedClusterFinalizer)

        if scope.ControlPlane.Spec.IdentityRef != nil </span><span class="cov0" title="0">{
                err := infracontroller.RemoveClusterIdentityFinalizer(ctx, amcpr.Client, scope.ControlPlane, scope.ControlPlane.Spec.IdentityRef, infrav1exp.ManagedClusterFinalizer)
                if err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, err
                }</span>
        }

        <span class="cov0" title="0">return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file215" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"

        "github.com/pkg/errors"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/scope"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/groups"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/managedclusters"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/subnets"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/tags"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/virtualnetworks"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
        "sigs.k8s.io/cluster-api/util/secret"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
)

// azureManagedControlPlaneService contains the services required by the cluster controller.
type azureManagedControlPlaneService struct {
        kubeclient client.Client
        scope      managedclusters.ManagedClusterScope
        services   []azure.ServiceReconciler
}

// newAzureManagedControlPlaneReconciler populates all the services based on input scope.
func newAzureManagedControlPlaneReconciler(scope *scope.ManagedControlPlaneScope) *azureManagedControlPlaneService <span class="cov0" title="0">{
        return &amp;azureManagedControlPlaneService{
                kubeclient: scope.Client,
                scope:      scope,
                services: []azure.ServiceReconciler{
                        groups.New(scope),
                        virtualnetworks.New(scope),
                        subnets.New(scope),
                        managedclusters.New(scope),
                        tags.New(scope),
                },
        }
}</span>

// Reconcile reconciles all the services in a predetermined order.
func (r *azureManagedControlPlaneService) Reconcile(ctx context.Context) error <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "controllers.azureManagedControlPlaneService.Reconcile")
        defer done()

        for _, service := range r.services </span><span class="cov0" title="0">{
                if err := service.Reconcile(ctx); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrapf(err, "failed to reconcile AzureManagedControlPlane service %s", service.Name())
                }</span>
        }

        <span class="cov0" title="0">if err := r.reconcileKubeconfig(ctx); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to reconcile kubeconfig secret")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete reconciles all the services in a predetermined order.
func (r *azureManagedControlPlaneService) Delete(ctx context.Context) error <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "controllers.azureManagedControlPlaneService.Delete")
        defer done()

        // Delete services in reverse order of creation.
        for i := len(r.services) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                if err := r.services[i].Delete(ctx); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrapf(err, "failed to delete AzureManagedControlPlane service %s", r.services[i].Name())
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (r *azureManagedControlPlaneService) reconcileKubeconfig(ctx context.Context) error <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "controllers.azureManagedControlPlaneService.reconcileKubeconfig")
        defer done()

        kubeConfigData := r.scope.GetKubeConfigData()
        if kubeConfigData == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">kubeConfigSecret := r.scope.MakeEmptyKubeConfigSecret()

        // Always update credentials in case of rotation
        if _, err := controllerutil.CreateOrUpdate(ctx, r.kubeclient, &amp;kubeConfigSecret, func() error </span><span class="cov0" title="0">{
                kubeConfigSecret.Data = map[string][]byte{
                        secret.KubeconfigDataName: kubeConfigData,
                }
                return nil
        }</span>); err != nil <span class="cov0" title="0">{
                return errors.Wrap(err, "failed to kubeconfig secret for cluster")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file216" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "time"

        "github.com/pkg/errors"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/client-go/tools/record"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/scope"
        infracontroller "sigs.k8s.io/cluster-api-provider-azure/controllers"
        infrav1exp "sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/pkg/coalescing"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        expv1 "sigs.k8s.io/cluster-api/exp/api/v1beta1"
        "sigs.k8s.io/cluster-api/util"
        "sigs.k8s.io/cluster-api/util/annotations"
        "sigs.k8s.io/cluster-api/util/predicates"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
        "sigs.k8s.io/controller-runtime/pkg/source"
)

// AzureManagedMachinePoolReconciler reconciles an AzureManagedMachinePool object.
type AzureManagedMachinePoolReconciler struct {
        client.Client
        Recorder                             record.EventRecorder
        ReconcileTimeout                     time.Duration
        WatchFilterValue                     string
        createAzureManagedMachinePoolService azureManagedMachinePoolServiceCreator
}

type azureManagedMachinePoolServiceCreator func(managedMachinePoolScope *scope.ManagedMachinePoolScope) (*azureManagedMachinePoolService, error)

// NewAzureManagedMachinePoolReconciler returns a new AzureManagedMachinePoolReconciler instance.
func NewAzureManagedMachinePoolReconciler(client client.Client, recorder record.EventRecorder, reconcileTimeout time.Duration, watchFilterValue string) *AzureManagedMachinePoolReconciler <span class="cov8" title="1">{
        ampr := &amp;AzureManagedMachinePoolReconciler{
                Client:           client,
                Recorder:         recorder,
                ReconcileTimeout: reconcileTimeout,
                WatchFilterValue: watchFilterValue,
        }

        ampr.createAzureManagedMachinePoolService = newAzureManagedMachinePoolService

        return ampr
}</span>

// SetupWithManager initializes this controller with a manager.
func (ammpr *AzureManagedMachinePoolReconciler) SetupWithManager(ctx context.Context, mgr ctrl.Manager, options infracontroller.Options) error <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx,
                "controllers.AzureManagedMachinePoolReconciler.SetupWithManager",
                tele.KVP("controller", "AzureManagedMachinePool"),
        )
        defer done()

        var r reconcile.Reconciler = ammpr
        if options.Cache != nil </span><span class="cov0" title="0">{
                r = coalescing.NewReconciler(ammpr, options.Cache, log)
        }</span>

        <span class="cov8" title="1">azManagedMachinePool := &amp;infrav1exp.AzureManagedMachinePool{}
        // create mapper to transform incoming AzureManagedControlPlanes into AzureManagedMachinePool requests
        azureManagedControlPlaneMapper, err := AzureManagedControlPlaneToAzureManagedMachinePoolsMapper(ctx, ammpr.Client, mgr.GetScheme(), log)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to create AzureManagedControlPlane to AzureManagedMachinePools mapper")
        }</span>

        <span class="cov8" title="1">c, err := ctrl.NewControllerManagedBy(mgr).
                WithOptions(options.Options).
                For(azManagedMachinePool).
                WithEventFilter(predicates.ResourceNotPausedAndHasFilterLabel(log, ammpr.WatchFilterValue)).
                // watch for changes in CAPI MachinePool resources
                Watches(
                        &amp;source.Kind{Type: &amp;expv1.MachinePool{}},
                        handler.EnqueueRequestsFromMapFunc(MachinePoolToInfrastructureMapFunc(infrav1exp.GroupVersion.WithKind("AzureManagedMachinePool"), log)),
                ).
                // watch for changes in AzureManagedControlPlanes
                Watches(
                        &amp;source.Kind{Type: &amp;infrav1exp.AzureManagedControlPlane{}},
                        handler.EnqueueRequestsFromMapFunc(azureManagedControlPlaneMapper),
                ).
                Build(r)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "error creating controller")
        }</span>

        // Add a watch on clusterv1.Cluster object for unpause &amp; ready notifications.
        <span class="cov8" title="1">if err = c.Watch(
                &amp;source.Kind{Type: &amp;clusterv1.Cluster{}},
                handler.EnqueueRequestsFromMapFunc(util.ClusterToInfrastructureMapFunc(ctx, infrav1exp.GroupVersion.WithKind("AzureManagedMachinePool"), mgr.GetClient(), &amp;infrav1exp.AzureManagedMachinePool{})),
                predicates.ClusterUnpausedAndInfrastructureReady(log),
                predicates.ResourceNotPausedAndHasFilterLabel(log, ammpr.WatchFilterValue),
        ); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed adding a watch for ready clusters")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// +kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=azuremanagedmachinepools,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=infrastructure.cluster.x-k8s.io,resources=azuremanagedmachinepools/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=cluster.x-k8s.io,resources=clusters;clusters/status,verbs=get;list;watch;patch
// +kubebuilder:rbac:groups=cluster.x-k8s.io,resources=machinepools;machinepools/status,verbs=get;list;watch

// Reconcile idempotently gets, creates, and updates a machine pool.
func (ammpr *AzureManagedMachinePoolReconciler) Reconcile(ctx context.Context, req ctrl.Request) (_ ctrl.Result, reterr error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultedLoopTimeout(ammpr.ReconcileTimeout))
        defer cancel()

        ctx, log, done := tele.StartSpanWithLogger(ctx, "controllers.AzureManagedMachinePoolReconciler.Reconcile",
                tele.KVP("namespace", req.Namespace),
                tele.KVP("name", req.Name),
                tele.KVP("kind", "AzureManagedMachinePool"),
        )
        defer done()

        // Fetch the AzureManagedMachinePool instance
        infraPool := &amp;infrav1exp.AzureManagedMachinePool{}
        err := ammpr.Get(ctx, req.NamespacedName, infraPool)
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return reconcile.Result{}, nil
                }</span>
                <span class="cov0" title="0">return reconcile.Result{}, err</span>
        }

        // Fetch the owning MachinePool.
        <span class="cov0" title="0">ownerPool, err := infracontroller.GetOwnerMachinePool(ctx, ammpr.Client, infraPool.ObjectMeta)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov0" title="0">if ownerPool == nil </span><span class="cov0" title="0">{
                log.Info("MachinePool Controller has not yet set OwnerRef")
                return reconcile.Result{}, nil
        }</span>

        // Fetch the Cluster.
        <span class="cov0" title="0">ownerCluster, err := util.GetOwnerCluster(ctx, ammpr.Client, ownerPool.ObjectMeta)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>
        <span class="cov0" title="0">if ownerCluster == nil </span><span class="cov0" title="0">{
                log.Info("Cluster Controller has not yet set OwnerRef")
                return reconcile.Result{}, nil
        }</span>

        <span class="cov0" title="0">log = log.WithValues("ownerCluster", ownerCluster.Name)

        // Return early if the object or Cluster is paused.
        if annotations.IsPaused(ownerCluster, infraPool) </span><span class="cov0" title="0">{
                log.Info("AzureManagedMachinePool or linked Cluster is marked as paused. Won't reconcile")
                return ctrl.Result{}, nil
        }</span>

        // Fetch the corresponding control plane which has all the interesting data.
        <span class="cov0" title="0">controlPlane := &amp;infrav1exp.AzureManagedControlPlane{}
        controlPlaneName := client.ObjectKey{
                Namespace: ownerCluster.Spec.ControlPlaneRef.Namespace,
                Name:      ownerCluster.Spec.ControlPlaneRef.Name,
        }
        if err := ammpr.Client.Get(ctx, controlPlaneName, controlPlane); err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>

        // Upon first create of an AKS service, the node pools are provided to the CreateOrUpdate call. After the initial
        // create of the control plane and node pools, the control plane will transition to initialized. After the control
        // plane is initialized, we can proceed to reconcile managed machine pools.
        <span class="cov0" title="0">if !controlPlane.Status.Initialized </span><span class="cov0" title="0">{
                log.Info("AzureManagedControlPlane is not initialized")
                return reconcile.Result{}, nil
        }</span>

        // create the managed control plane scope
        <span class="cov0" title="0">managedControlPlaneScope, err := scope.NewManagedControlPlaneScope(ctx, scope.ManagedControlPlaneScopeParams{
                Client:       ammpr.Client,
                ControlPlane: controlPlane,
                Cluster:      ownerCluster,
        })
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, errors.Wrap(err, "failed to create ManagedControlPlane scope")
        }</span>

        // Create the scope.
        <span class="cov0" title="0">mcpScope, err := scope.NewManagedMachinePoolScope(ctx, scope.ManagedMachinePoolScopeParams{
                Client:       ammpr.Client,
                ControlPlane: controlPlane,
                Cluster:      ownerCluster,
                ManagedMachinePool: scope.ManagedMachinePool{
                        MachinePool:      ownerPool,
                        InfraMachinePool: infraPool,
                },
                ManagedControlPlaneScope: managedControlPlaneScope,
        })
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, errors.Wrap(err, "failed to create ManagedMachinePool scope")
        }</span>

        // Always patch when exiting so we can persist changes to finalizers and status
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := mcpScope.PatchObject(ctx); err != nil &amp;&amp; reterr == nil </span><span class="cov0" title="0">{
                        reterr = err
                }</span>
                <span class="cov0" title="0">if err := mcpScope.PatchCAPIMachinePoolObject(ctx); err != nil &amp;&amp; reterr == nil </span><span class="cov0" title="0">{
                        reterr = err
                }</span>
        }()

        // Handle deleted clusters
        <span class="cov0" title="0">if !infraPool.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                return ammpr.reconcileDelete(ctx, mcpScope)
        }</span>

        // Handle non-deleted clusters
        <span class="cov0" title="0">return ammpr.reconcileNormal(ctx, mcpScope)</span>
}

func (ammpr *AzureManagedMachinePoolReconciler) reconcileNormal(ctx context.Context, scope *scope.ManagedMachinePoolScope) (reconcile.Result, error) <span class="cov0" title="0">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "controllers.AzureManagedMachinePoolReconciler.reconcileNormal")
        defer done()

        log.Info("Reconciling AzureManagedMachinePool")

        // If the AzureManagedMachinePool doesn't have our finalizer, add it.
        controllerutil.AddFinalizer(scope.InfraMachinePool, infrav1.ClusterFinalizer)
        // Register the finalizer immediately to avoid orphaning Azure resources on delete
        if err := scope.PatchObject(ctx); err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov0" title="0">svc, err := ammpr.createAzureManagedMachinePoolService(scope)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, errors.Wrap(err, "failed to create an AzureManageMachinePoolService")
        }</span>

        <span class="cov0" title="0">if err := svc.Reconcile(ctx); err != nil </span><span class="cov0" title="0">{
                scope.SetAgentPoolReady(false)

                // Handle transient and terminal errors
                log := log.WithValues("name", scope.InfraMachinePool.Name, "namespace", scope.InfraMachinePool.Namespace)
                var reconcileError azure.ReconcileError
                if errors.As(err, &amp;reconcileError) </span><span class="cov0" title="0">{
                        if reconcileError.IsTerminal() </span><span class="cov0" title="0">{
                                log.Error(err, "failed to reconcile AzureManagedMachinePool")
                                return reconcile.Result{}, nil
                        }</span>

                        <span class="cov0" title="0">if reconcileError.IsTransient() </span><span class="cov0" title="0">{
                                log.V(4).Info("requeuing due to transient transient failure", "error", err)
                                return reconcile.Result{RequeueAfter: reconcileError.RequeueAfter()}, nil
                        }</span>

                        <span class="cov0" title="0">return reconcile.Result{}, errors.Wrap(err, "failed to reconcile AzureManagedMachinePool")</span>
                }

                <span class="cov0" title="0">return reconcile.Result{}, errors.Wrapf(err, "error creating AzureManagedMachinePool %s/%s", scope.InfraMachinePool.Namespace, scope.InfraMachinePool.Name)</span>
        }

        // No errors, so mark us ready so the Cluster API Cluster Controller can pull it
        <span class="cov0" title="0">scope.SetAgentPoolReady(true)
        return reconcile.Result{}, nil</span>
}

func (ammpr *AzureManagedMachinePoolReconciler) reconcileDelete(ctx context.Context, scope *scope.ManagedMachinePoolScope) (reconcile.Result, error) <span class="cov0" title="0">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "controllers.AzureManagedMachinePoolReconciler.reconcileDelete")
        defer done()

        log.Info("Reconciling AzureManagedMachinePool delete")

        if !scope.Cluster.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                // Cluster was deleted, skip machine pool deletion and let AKS delete the whole cluster.
                // So, remove the finalizer.
                controllerutil.RemoveFinalizer(scope.InfraMachinePool, infrav1.ClusterFinalizer)
        }</span> else<span class="cov0" title="0"> {
                svc, err := ammpr.createAzureManagedMachinePoolService(scope)
                if err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, errors.Wrap(err, "failed to create an AzureManageMachinePoolService")
                }</span>

                <span class="cov0" title="0">if err := svc.Delete(ctx); err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, errors.Wrapf(err, "error deleting AzureManagedMachinePool %s/%s", scope.InfraMachinePool.Namespace, scope.InfraMachinePool.Name)
                }</span>
                // Machine pool successfully deleted, remove the finalizer.
                <span class="cov0" title="0">controllerutil.RemoveFinalizer(scope.InfraMachinePool, infrav1.ClusterFinalizer)</span>
        }

        <span class="cov0" title="0">if err := scope.PatchObject(ctx); err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov0" title="0">return reconcile.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file217" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "time"

        "github.com/Azure/azure-sdk-for-go/services/compute/mgmt/2021-11-01/compute"
        "github.com/pkg/errors"
        "sigs.k8s.io/cluster-api-provider-azure/azure"
        "sigs.k8s.io/cluster-api-provider-azure/azure/scope"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/agentpools"
        "sigs.k8s.io/cluster-api-provider-azure/azure/services/scalesets"
        azureutil "sigs.k8s.io/cluster-api-provider-azure/util/azure"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
)

type (
        // azureManagedMachinePoolService contains the services required by the cluster controller.
        azureManagedMachinePoolService struct {
                scope         agentpools.AgentPoolScope
                agentPoolsSvc azure.Reconciler
                scaleSetsSvc  NodeLister
        }

        // AgentPoolVMSSNotFoundError represents a reconcile error when the VMSS for an agent pool can't be found.
        AgentPoolVMSSNotFoundError struct {
                NodeResourceGroup string
                PoolName          string
        }

        // NodeLister is a service interface for returning generic lists.
        NodeLister interface {
                ListInstances(context.Context, string, string) ([]compute.VirtualMachineScaleSetVM, error)
                List(context.Context, string) ([]compute.VirtualMachineScaleSet, error)
        }
)

// NewAgentPoolVMSSNotFoundError creates a new AgentPoolVMSSNotFoundError.
func NewAgentPoolVMSSNotFoundError(nodeResourceGroup, poolName string) *AgentPoolVMSSNotFoundError <span class="cov8" title="1">{
        return &amp;AgentPoolVMSSNotFoundError{
                NodeResourceGroup: nodeResourceGroup,
                PoolName:          poolName,
        }
}</span>

func (a *AgentPoolVMSSNotFoundError) Error() string <span class="cov0" title="0">{
        msgFmt := "failed to find vm scale set in resource group %s matching pool named %s"
        return fmt.Sprintf(msgFmt, a.NodeResourceGroup, a.PoolName)
}</span>

// Is returns true if the target error is an `AgentPoolVMSSNotFoundError`.
func (a *AgentPoolVMSSNotFoundError) Is(target error) bool <span class="cov8" title="1">{
        var err *AgentPoolVMSSNotFoundError
        ok := errors.As(target, &amp;err)
        return ok
}</span>

// newAzureManagedMachinePoolService populates all the services based on input scope.
func newAzureManagedMachinePoolService(scope *scope.ManagedMachinePoolScope) (*azureManagedMachinePoolService, error) <span class="cov0" title="0">{
        var authorizer azure.Authorizer = scope
        if scope.Location() != "" </span><span class="cov0" title="0">{
                regionalAuthorizer, err := azure.WithRegionalBaseURI(scope, scope.Location())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to create a regional authorizer")
                }</span>
                <span class="cov0" title="0">authorizer = regionalAuthorizer</span>
        }

        <span class="cov0" title="0">return &amp;azureManagedMachinePoolService{
                scope:         scope,
                agentPoolsSvc: agentpools.New(scope),
                scaleSetsSvc:  scalesets.NewClient(authorizer),
        }, nil</span>
}

// Reconcile reconciles all the services in a predetermined order.
func (s *azureManagedMachinePoolService) Reconcile(ctx context.Context) error <span class="cov0" title="0">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "controllers.azureManagedMachinePoolService.Reconcile")
        defer done()

        log.Info("reconciling managed machine pool")
        agentPoolName := s.scope.Name()

        if err := s.agentPoolsSvc.Reconcile(ctx); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to reconcile machine pool %s", agentPoolName)
        }</span>

        <span class="cov0" title="0">nodeResourceGroup := s.scope.NodeResourceGroup()
        vmss, err := s.scaleSetsSvc.List(ctx, nodeResourceGroup)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to list vmss in resource group %s", nodeResourceGroup)
        }</span>

        <span class="cov0" title="0">var match *compute.VirtualMachineScaleSet
        for _, ss := range vmss </span><span class="cov0" title="0">{
                ss := ss
                if ss.Tags["poolName"] != nil &amp;&amp; *ss.Tags["poolName"] == agentPoolName </span><span class="cov0" title="0">{
                        match = &amp;ss
                        break</span>
                }

                <span class="cov0" title="0">if ss.Tags["aks-managed-poolName"] != nil &amp;&amp; *ss.Tags["aks-managed-poolName"] == agentPoolName </span><span class="cov0" title="0">{
                        match = &amp;ss
                        break</span>
                }
        }

        <span class="cov0" title="0">if match == nil </span><span class="cov0" title="0">{
                return azure.WithTransientError(NewAgentPoolVMSSNotFoundError(nodeResourceGroup, agentPoolName), 20*time.Second)
        }</span>

        <span class="cov0" title="0">instances, err := s.scaleSetsSvc.ListInstances(ctx, nodeResourceGroup, *match.Name)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to reconcile machine pool %s", agentPoolName)
        }</span>

        <span class="cov0" title="0">var providerIDs = make([]string, len(instances))
        for i := 0; i &lt; len(instances); i++ </span><span class="cov0" title="0">{
                // Transform the VMSS instance resource representation to conform to the cloud-provider-azure representation
                providerID, err := azureutil.ConvertResourceGroupNameToLower(azure.ProviderIDPrefix + *instances[i].ID)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrapf(err, "failed to parse instance ID %s", *instances[i].ID)
                }</span>
                <span class="cov0" title="0">providerIDs[i] = providerID</span>
        }

        <span class="cov0" title="0">s.scope.SetAgentPoolProviderIDList(providerIDs)
        s.scope.SetAgentPoolReplicas(int32(len(providerIDs)))
        s.scope.SetAgentPoolReady(true)

        log.Info("reconciled managed machine pool successfully")
        return nil</span>
}

// Delete reconciles all the services in a predetermined order.
func (s *azureManagedMachinePoolService) Delete(ctx context.Context) error <span class="cov0" title="0">{
        ctx, _, done := tele.StartSpanWithLogger(ctx, "controllers.azureManagedMachinePoolService.Delete")
        defer done()

        if err := s.agentPoolsSvc.Delete(ctx); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to delete machine pool %s", s.scope.Name())
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file218" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"

        "github.com/go-logr/logr"
        "github.com/google/go-cmp/cmp"
        "github.com/pkg/errors"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/types"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/controllers"
        infrav1exp "sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/util/reconciler"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        expv1 "sigs.k8s.io/cluster-api/exp/api/v1beta1"
        "sigs.k8s.io/cluster-api/util"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/client/apiutil"
        "sigs.k8s.io/controller-runtime/pkg/event"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        "sigs.k8s.io/controller-runtime/pkg/predicate"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// AzureClusterToAzureMachinePoolsMapper creates a mapping handler to transform AzureClusters into AzureMachinePools. The transform
// requires AzureCluster to map to the owning Cluster, then from the Cluster, collect the MachinePools belonging to the cluster,
// then finally projecting the infrastructure reference to the AzureMachinePool.
func AzureClusterToAzureMachinePoolsMapper(ctx context.Context, c client.Client, scheme *runtime.Scheme, log logr.Logger) (handler.MapFunc, error) <span class="cov8" title="1">{
        gvk, err := apiutil.GVKForObject(new(infrav1exp.AzureMachinePool), scheme)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to find GVK for AzureMachinePool")
        }</span>

        <span class="cov8" title="1">return func(o client.Object) []ctrl.Request </span><span class="cov8" title="1">{
                ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultMappingTimeout)
                defer cancel()

                azCluster, ok := o.(*infrav1.AzureCluster)
                if !ok </span><span class="cov0" title="0">{
                        log.Error(errors.Errorf("expected an AzureCluster, got %T instead", o.GetObjectKind()), "failed to map AzureCluster")
                        return nil
                }</span>

                <span class="cov8" title="1">log = log.WithValues("AzureCluster", azCluster.Name, "Namespace", azCluster.Namespace)

                // Don't handle deleted AzureClusters
                if !azCluster.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                        log.V(4).Info("AzureCluster has a deletion timestamp, skipping mapping.")
                        return nil
                }</span>

                <span class="cov8" title="1">clusterName, ok := controllers.GetOwnerClusterName(azCluster.ObjectMeta)
                if !ok </span><span class="cov0" title="0">{
                        log.V(4).Info("unable to get the owner cluster")
                        return nil
                }</span>

                <span class="cov8" title="1">machineList := &amp;expv1.MachinePoolList{}
                machineList.SetGroupVersionKind(gvk)
                // list all of the requested objects within the cluster namespace with the cluster name label
                if err := c.List(ctx, machineList, client.InNamespace(azCluster.Namespace), client.MatchingLabels{clusterv1.ClusterLabelName: clusterName}); err != nil </span><span class="cov0" title="0">{
                        log.V(4).Info(fmt.Sprintf("unable to list machine pools in cluster %s", clusterName))
                        return nil
                }</span>

                <span class="cov8" title="1">mapFunc := MachinePoolToInfrastructureMapFunc(gvk, log)
                var results []ctrl.Request
                for _, machine := range machineList.Items </span><span class="cov8" title="1">{
                        m := machine
                        azureMachines := mapFunc(&amp;m)
                        results = append(results, azureMachines...)
                }</span>

                <span class="cov8" title="1">return results</span>
        }, nil
}

// AzureMachinePoolMachineMapper creates a mapping handler to transform AzureMachinePoolMachine to AzureMachinePools.
func AzureMachinePoolMachineMapper(scheme *runtime.Scheme, log logr.Logger) handler.MapFunc <span class="cov8" title="1">{
        return func(o client.Object) []ctrl.Request </span><span class="cov0" title="0">{
                gvk, err := apiutil.GVKForObject(new(infrav1exp.AzureMachinePool), scheme)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(errors.WithStack(err), "failed to find GVK for AzureMachinePool")
                        return nil
                }</span>

                <span class="cov0" title="0">azureMachinePoolMachine, ok := o.(*infrav1exp.AzureMachinePoolMachine)
                if !ok </span><span class="cov0" title="0">{
                        log.Error(errors.Errorf("expected an AzureCluster, got %T instead", o), "failed to map AzureMachinePoolMachine")
                        return nil
                }</span>

                <span class="cov0" title="0">log = log.WithValues("AzureMachinePoolMachine", azureMachinePoolMachine.Name, "Namespace", azureMachinePoolMachine.Namespace)
                for _, ref := range azureMachinePoolMachine.OwnerReferences </span><span class="cov0" title="0">{
                        if ref.Kind != gvk.Kind </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">gv, err := schema.ParseGroupVersion(ref.APIVersion)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error(errors.WithStack(err), "unable to parse group version", "APIVersion", ref.APIVersion)
                                return nil
                        }</span>

                        <span class="cov0" title="0">if gv.Group == gvk.Group </span><span class="cov0" title="0">{
                                return []ctrl.Request{
                                        {
                                                NamespacedName: types.NamespacedName{
                                                        Name:      ref.Name,
                                                        Namespace: azureMachinePoolMachine.Namespace,
                                                },
                                        },
                                }
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        }
}

// AzureManagedClusterToAzureManagedMachinePoolsMapper creates a mapping handler to transform AzureManagedClusters into
// AzureManagedMachinePools. The transform requires AzureManagedCluster to map to the owning Cluster, then from the
// Cluster, collect the MachinePools belonging to the cluster, then finally projecting the infrastructure reference
// to the AzureManagedMachinePools.
func AzureManagedClusterToAzureManagedMachinePoolsMapper(ctx context.Context, c client.Client, scheme *runtime.Scheme, log logr.Logger) (handler.MapFunc, error) <span class="cov8" title="1">{
        gvk, err := apiutil.GVKForObject(new(infrav1exp.AzureManagedMachinePool), scheme)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to find GVK for AzureManagedMachinePool")
        }</span>

        <span class="cov8" title="1">return func(o client.Object) []ctrl.Request </span><span class="cov8" title="1">{
                ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultMappingTimeout)
                defer cancel()

                azCluster, ok := o.(*infrav1exp.AzureManagedCluster)
                if !ok </span><span class="cov0" title="0">{
                        log.Error(errors.Errorf("expected an AzureManagedCluster, got %T instead", o.GetObjectKind()), "failed to map AzureManagedCluster")
                        return nil
                }</span>

                <span class="cov8" title="1">log = log.WithValues("AzureManagedCluster", azCluster.Name, "Namespace", azCluster.Namespace)

                // Don't handle deleted AzureManagedClusters
                if !azCluster.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                        log.V(4).Info("AzureManagedCluster has a deletion timestamp, skipping mapping.")
                        return nil
                }</span>

                <span class="cov8" title="1">clusterName, ok := controllers.GetOwnerClusterName(azCluster.ObjectMeta)
                if !ok </span><span class="cov0" title="0">{
                        log.V(4).Info("unable to get the owner cluster")
                        return nil
                }</span>

                <span class="cov8" title="1">machineList := &amp;expv1.MachinePoolList{}
                machineList.SetGroupVersionKind(gvk)
                // list all of the requested objects within the cluster namespace with the cluster name label
                if err := c.List(ctx, machineList, client.InNamespace(azCluster.Namespace), client.MatchingLabels{clusterv1.ClusterLabelName: clusterName}); err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">mapFunc := MachinePoolToInfrastructureMapFunc(gvk, log)
                var results []ctrl.Request
                for _, machine := range machineList.Items </span><span class="cov8" title="1">{
                        m := machine
                        azureMachines := mapFunc(&amp;m)
                        results = append(results, azureMachines...)
                }</span>

                <span class="cov8" title="1">return results</span>
        }, nil
}

// AzureManagedControlPlaneToAzureManagedMachinePoolsMapper creates a mapping handler to transform AzureManagedControlPlanes into
// AzureManagedMachinePools. The transform requires AzureManagedControlPlane to map to the owning Cluster, then from the
// Cluster, collect the MachinePools belonging to the cluster, then finally projecting the infrastructure reference
// to the AzureManagedMachinePools.
func AzureManagedControlPlaneToAzureManagedMachinePoolsMapper(ctx context.Context, c client.Client, scheme *runtime.Scheme, log logr.Logger) (handler.MapFunc, error) <span class="cov8" title="1">{
        gvk, err := apiutil.GVKForObject(new(infrav1exp.AzureManagedMachinePool), scheme)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to find GVK for AzureManagedMachinePool")
        }</span>

        <span class="cov8" title="1">return func(o client.Object) []ctrl.Request </span><span class="cov8" title="1">{
                ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultMappingTimeout)
                defer cancel()

                azControlPlane, ok := o.(*infrav1exp.AzureManagedControlPlane)
                if !ok </span><span class="cov0" title="0">{
                        log.Error(errors.Errorf("expected an AzureManagedControlPlane, got %T instead", o.GetObjectKind()), "failed to map AzureManagedControlPlane")
                        return nil
                }</span>

                <span class="cov8" title="1">log = log.WithValues("AzureManagedControlPlane", azControlPlane.Name, "Namespace", azControlPlane.Namespace)

                // Don't handle deleted AzureManagedControlPlanes
                if !azControlPlane.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                        log.V(4).Info("AzureManagedControlPlane has a deletion timestamp, skipping mapping.")
                        return nil
                }</span>

                <span class="cov8" title="1">clusterName, ok := controllers.GetOwnerClusterName(azControlPlane.ObjectMeta)
                if !ok </span><span class="cov0" title="0">{
                        log.Info("unable to get the owner cluster")
                        return nil
                }</span>

                <span class="cov8" title="1">machineList := &amp;expv1.MachinePoolList{}
                machineList.SetGroupVersionKind(gvk)
                // list all of the requested objects within the cluster namespace with the cluster name label
                if err := c.List(ctx, machineList, client.InNamespace(azControlPlane.Namespace), client.MatchingLabels{clusterv1.ClusterLabelName: clusterName}); err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">mapFunc := MachinePoolToInfrastructureMapFunc(gvk, log)
                var results []ctrl.Request
                for _, machine := range machineList.Items </span><span class="cov8" title="1">{
                        m := machine
                        azureMachines := mapFunc(&amp;m)
                        results = append(results, azureMachines...)
                }</span>

                <span class="cov8" title="1">return results</span>
        }, nil
}

// AzureManagedClusterToAzureManagedControlPlaneMapper creates a mapping handler to transform AzureManagedClusters into
// AzureManagedControlPlane. The transform requires AzureManagedCluster to map to the owning Cluster, then from the
// Cluster, collect the control plane infrastructure reference.
func AzureManagedClusterToAzureManagedControlPlaneMapper(ctx context.Context, c client.Client, log logr.Logger) (handler.MapFunc, error) <span class="cov8" title="1">{
        return func(o client.Object) []ctrl.Request </span><span class="cov8" title="1">{
                ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultMappingTimeout)
                defer cancel()

                azCluster, ok := o.(*infrav1exp.AzureManagedCluster)
                if !ok </span><span class="cov0" title="0">{
                        log.Error(errors.Errorf("expected an AzureManagedCluster, got %T instead", o), "failed to map AzureManagedCluster")
                        return nil
                }</span>

                <span class="cov8" title="1">log = log.WithValues("AzureManagedCluster", azCluster.Name, "Namespace", azCluster.Namespace)

                // Don't handle deleted AzureManagedClusters
                if !azCluster.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                        log.V(4).Info("AzureManagedCluster has a deletion timestamp, skipping mapping.")
                        return nil
                }</span>

                <span class="cov8" title="1">cluster, err := util.GetOwnerCluster(ctx, c, azCluster.ObjectMeta)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to get the owning cluster")
                        return nil
                }</span>

                <span class="cov8" title="1">if cluster == nil </span><span class="cov0" title="0">{
                        log.Error(err, "cluster has not set owner ref yet")
                        return nil
                }</span>

                <span class="cov8" title="1">ref := cluster.Spec.ControlPlaneRef
                if ref == nil || ref.Name == "" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">return []ctrl.Request{
                        {
                                NamespacedName: types.NamespacedName{
                                        Namespace: ref.Namespace,
                                        Name:      ref.Name,
                                },
                        },
                }</span>
        }, nil
}

// AzureManagedControlPlaneToAzureManagedClusterMapper creates a mapping handler to transform AzureManagedClusters into
// AzureManagedControlPlane. The transform requires AzureManagedCluster to map to the owning Cluster, then from the
// Cluster, collect the control plane infrastructure reference.
func AzureManagedControlPlaneToAzureManagedClusterMapper(ctx context.Context, c client.Client, log logr.Logger) (handler.MapFunc, error) <span class="cov8" title="1">{
        return func(o client.Object) []ctrl.Request </span><span class="cov8" title="1">{
                ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultMappingTimeout)
                defer cancel()

                azManagedControlPlane, ok := o.(*infrav1exp.AzureManagedControlPlane)
                if !ok </span><span class="cov0" title="0">{
                        log.Error(errors.Errorf("expected an AzureManagedControlPlane, got %T instead", o), "failed to map AzureManagedControlPlane")
                        return nil
                }</span>

                <span class="cov8" title="1">log = log.WithValues("AzureManagedControlPlane", azManagedControlPlane.Name, "Namespace", azManagedControlPlane.Namespace)

                // Don't handle deleted AzureManagedControlPlanes
                if !azManagedControlPlane.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                        log.V(4).Info("AzureManagedControlPlane has a deletion timestamp, skipping mapping.")
                        return nil
                }</span>

                <span class="cov8" title="1">cluster, err := util.GetOwnerCluster(ctx, c, azManagedControlPlane.ObjectMeta)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to get the owning cluster")
                        return nil
                }</span>

                <span class="cov8" title="1">if cluster == nil </span><span class="cov0" title="0">{
                        log.Error(err, "cluster has not set owner ref yet")
                        return nil
                }</span>

                <span class="cov8" title="1">ref := cluster.Spec.InfrastructureRef
                if ref == nil || ref.Name == "" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">return []ctrl.Request{
                        {
                                NamespacedName: types.NamespacedName{
                                        Namespace: ref.Namespace,
                                        Name:      ref.Name,
                                },
                        },
                }</span>
        }, nil
}

// MachinePoolToAzureManagedControlPlaneMapFunc returns a handler.MapFunc that watches for
// MachinePool events and returns reconciliation requests for a control plane object.
func MachinePoolToAzureManagedControlPlaneMapFunc(ctx context.Context, c client.Client, gvk schema.GroupVersionKind, log logr.Logger) handler.MapFunc <span class="cov8" title="1">{
        return func(o client.Object) []reconcile.Request </span><span class="cov8" title="1">{
                ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultMappingTimeout)
                defer cancel()

                machinePool, ok := o.(*expv1.MachinePool)
                if !ok </span><span class="cov0" title="0">{
                        log.Info("expected a MachinePool, got wrong type", "type", fmt.Sprintf("%T", o))
                        return nil
                }</span>

                <span class="cov8" title="1">cluster, err := util.GetClusterByName(ctx, c, machinePool.ObjectMeta.Namespace, machinePool.Spec.ClusterName)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to get the owning cluster")
                        return nil
                }</span>

                <span class="cov8" title="1">gk := gvk.GroupKind()
                ref := cluster.Spec.ControlPlaneRef
                // Return early if the GroupKind doesn't match what we expect.
                controlPlaneGK := ref.GroupVersionKind().GroupKind()
                if gk != controlPlaneGK </span><span class="cov0" title="0">{
                        log.Info("gk does not match", "gk", gk, "controlPlaneGK", controlPlaneGK)
                        return nil
                }</span>

                <span class="cov8" title="1">controlPlaneKey := client.ObjectKey{
                        Name:      ref.Name,
                        Namespace: ref.Namespace,
                }
                controlPlane := &amp;infrav1exp.AzureManagedControlPlane{}
                if err := c.Get(ctx, controlPlaneKey, controlPlane); err != nil </span><span class="cov8" title="1">{
                        log.Error(err, "failed to fetch default pool reference")
                        // If we get here, we might want to reconcile but aren't sure.
                        // Do it anyway to be safe. Worst case we reconcile a few extra times with no-ops.
                        return []reconcile.Request{
                                {
                                        NamespacedName: client.ObjectKey{
                                                Namespace: ref.Namespace,
                                                Name:      ref.Name,
                                        },
                                },
                        }
                }</span>

                <span class="cov8" title="1">infraMachinePoolRef := machinePool.Spec.Template.Spec.InfrastructureRef

                gv, err := schema.ParseGroupVersion(infraMachinePoolRef.APIVersion)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to parse group version")
                        // If we get here, we might want to reconcile but aren't sure.
                        // Do it anyway to be safe. Worst case we reconcile a few extra times with no-ops.
                        return []reconcile.Request{
                                {
                                        NamespacedName: client.ObjectKey{
                                                Namespace: ref.Namespace,
                                                Name:      ref.Name,
                                        },
                                },
                        }
                }</span>

                <span class="cov8" title="1">kindMatches := infraMachinePoolRef.Kind == "AzureManagedMachinePool"
                groupMatches := controlPlaneGK.Group == gv.Group

                ammp := &amp;infrav1exp.AzureManagedMachinePool{}
                key := types.NamespacedName{Namespace: infraMachinePoolRef.Namespace, Name: infraMachinePoolRef.Name}
                if err := c.Get(ctx, key, ammp); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, fmt.Sprintf("failed to fetch azure managed machine pool for Machinepool: %s", infraMachinePoolRef.Name))
                        // If we get here, we might want to reconcile but aren't sure.
                        // Do it anyway to be safe. Worst case we reconcile a few extra times with no-ops.
                        return []reconcile.Request{
                                {
                                        NamespacedName: client.ObjectKey{
                                                Namespace: ref.Namespace,
                                                Name:      ref.Name,
                                        },
                                },
                        }
                }</span>

                <span class="cov8" title="1">isSystemNodePool := ammp.Spec.Mode == string(infrav1exp.NodePoolModeSystem)

                if groupMatches &amp;&amp; kindMatches &amp;&amp; isSystemNodePool </span><span class="cov8" title="1">{
                        return []reconcile.Request{
                                {
                                        NamespacedName: client.ObjectKey{
                                                Namespace: ref.Namespace,
                                                Name:      ref.Name,
                                        },
                                },
                        }
                }</span>

                // By default, return nothing for a machine pool which is not the default pool for a control plane.
                <span class="cov8" title="1">return nil</span>
        }
}

// MachinePoolToInfrastructureMapFunc returns a handler.MapFunc that watches for
// MachinePool events and returns reconciliation requests for an infrastructure provider object.
func MachinePoolToInfrastructureMapFunc(gvk schema.GroupVersionKind, log logr.Logger) handler.MapFunc <span class="cov8" title="1">{
        return func(o client.Object) []reconcile.Request </span><span class="cov8" title="1">{
                m, ok := o.(*expv1.MachinePool)
                if !ok </span><span class="cov8" title="1">{
                        log.V(4).Info("attempt to map incorrect type", "type", fmt.Sprintf("%T", o))
                        return nil
                }</span>

                <span class="cov8" title="1">gk := gvk.GroupKind()
                ref := m.Spec.Template.Spec.InfrastructureRef
                // Return early if the GroupKind doesn't match what we expect.
                infraGK := ref.GroupVersionKind().GroupKind()
                if gk != infraGK </span><span class="cov8" title="1">{
                        log.V(4).Info("gk does not match", "gk", gk, "infraGK", infraGK)
                        return nil
                }</span>

                <span class="cov8" title="1">return []reconcile.Request{
                        {
                                NamespacedName: client.ObjectKey{
                                        Namespace: m.Namespace,
                                        Name:      ref.Name,
                                },
                        },
                }</span>
        }
}

// AzureClusterToAzureMachinePoolsFunc is a handler.MapFunc to be used to enqueue
// requests for reconciliation of AzureMachinePools.
func AzureClusterToAzureMachinePoolsFunc(ctx context.Context, c client.Client, log logr.Logger) handler.MapFunc <span class="cov8" title="1">{
        return func(o client.Object) []reconcile.Request </span><span class="cov8" title="1">{
                ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultMappingTimeout)
                defer cancel()

                ac, ok := o.(*infrav1.AzureCluster)
                if !ok </span><span class="cov8" title="1">{
                        log.Error(errors.Errorf("expected a AzureCluster but got a %T", o), "failed to get AzureCluster")
                        return nil
                }</span>
                <span class="cov8" title="1">logWithValues := log.WithValues("AzureCluster", ac.Name, "Namespace", ac.Namespace)

                cluster, err := util.GetOwnerCluster(ctx, c, ac.ObjectMeta)
                switch </span>{
                case apierrors.IsNotFound(err) || cluster == nil:<span class="cov8" title="1">
                        logWithValues.V(4).Info("owning cluster not found")
                        return nil</span>
                case err != nil:<span class="cov0" title="0">
                        logWithValues.Error(err, "failed to get owning cluster")
                        return nil</span>
                }

                <span class="cov8" title="1">labels := map[string]string{clusterv1.ClusterLabelName: cluster.Name}
                ampl := &amp;infrav1exp.AzureMachinePoolList{}
                if err := c.List(ctx, ampl, client.InNamespace(ac.Namespace), client.MatchingLabels(labels)); err != nil </span><span class="cov0" title="0">{
                        logWithValues.Error(err, "failed to list AzureMachinePools")
                        return nil
                }</span>

                <span class="cov8" title="1">var result []reconcile.Request
                for _, m := range ampl.Items </span><span class="cov8" title="1">{
                        result = append(result, reconcile.Request{
                                NamespacedName: client.ObjectKey{
                                        Namespace: m.Namespace,
                                        Name:      m.Name,
                                },
                        })
                }</span>

                <span class="cov8" title="1">return result</span>
        }
}

// AzureMachinePoolToAzureMachinePoolMachines maps an AzureMachinePool to its child AzureMachinePoolMachines through
// Cluster and MachinePool labels.
func AzureMachinePoolToAzureMachinePoolMachines(ctx context.Context, c client.Client, log logr.Logger) handler.MapFunc <span class="cov8" title="1">{
        return func(o client.Object) []reconcile.Request </span><span class="cov0" title="0">{
                ctx, cancel := context.WithTimeout(ctx, reconciler.DefaultMappingTimeout)
                defer cancel()

                amp, ok := o.(*infrav1exp.AzureMachinePool)
                if !ok </span><span class="cov0" title="0">{
                        log.Error(errors.Errorf("expected a AzureMachinePool but got a %T", o), "failed to get AzureMachinePool")
                        return nil
                }</span>
                <span class="cov0" title="0">logWithValues := log.WithValues("AzureMachinePool", amp.Name, "Namespace", amp.Namespace)

                labels := map[string]string{
                        clusterv1.ClusterLabelName:      amp.Labels[clusterv1.ClusterLabelName],
                        infrav1exp.MachinePoolNameLabel: amp.Name,
                }
                ampml := &amp;infrav1exp.AzureMachinePoolMachineList{}
                if err := c.List(ctx, ampml, client.InNamespace(amp.Namespace), client.MatchingLabels(labels)); err != nil </span><span class="cov0" title="0">{
                        logWithValues.Error(err, "failed to list AzureMachinePoolMachines")
                        return nil
                }</span>

                <span class="cov0" title="0">logWithValues.Info("mapping from AzureMachinePool", "count", len(ampml.Items))
                var result []reconcile.Request
                for _, m := range ampml.Items </span><span class="cov0" title="0">{
                        result = append(result, reconcile.Request{
                                NamespacedName: client.ObjectKey{
                                        Namespace: m.Namespace,
                                        Name:      m.Name,
                                },
                        })
                }</span>

                <span class="cov0" title="0">return result</span>
        }
}

// MachinePoolModelHasChanged predicates any events based on changes to the AzureMachinePool model.
func MachinePoolModelHasChanged(logger logr.Logger) predicate.Funcs <span class="cov8" title="1">{
        return predicate.Funcs{
                UpdateFunc: func(e event.UpdateEvent) bool </span><span class="cov0" title="0">{
                        log := logger.WithValues("predicate", "MachinePoolModelHasChanged", "eventType", "update")

                        oldAmp, ok := e.ObjectOld.(*infrav1exp.AzureMachinePool)
                        if !ok </span><span class="cov0" title="0">{
                                log.V(4).Info("Expected AzureMachinePool", "type", e.ObjectOld.GetObjectKind().GroupVersionKind().String())
                                return false
                        }</span>
                        <span class="cov0" title="0">log = log.WithValues("namespace", oldAmp.Namespace, "azureMachinePool", oldAmp.Name)

                        newAmp := e.ObjectNew.(*infrav1exp.AzureMachinePool)

                        // if any of these are not equal, run the update
                        shouldUpdate := !cmp.Equal(oldAmp.Spec.Identity, newAmp.Spec.Identity) ||
                                !cmp.Equal(oldAmp.Spec.Template, newAmp.Spec.Template) ||
                                !cmp.Equal(oldAmp.Spec.UserAssignedIdentities, newAmp.Spec.UserAssignedIdentities) ||
                                !cmp.Equal(oldAmp.Status.ProvisioningState, newAmp.Status.ProvisioningState)

                        // if shouldUpdate {
                        log.Info("machine pool predicate", "shouldUpdate", shouldUpdate)
                        //}
                        return shouldUpdate</span>
                },
                CreateFunc:  func(e event.CreateEvent) bool <span class="cov0" title="0">{ return false }</span>,
                DeleteFunc:  func(e event.DeleteEvent) bool <span class="cov0" title="0">{ return false }</span>,
                GenericFunc: func(e event.GenericEvent) bool <span class="cov0" title="0">{ return false }</span>,
        }
}

// MachinePoolMachineHasStateOrVersionChange predicates any events based on changes to the AzureMachinePoolMachine status
// relevant for the AzureMachinePool controller.
func MachinePoolMachineHasStateOrVersionChange(logger logr.Logger) predicate.Funcs <span class="cov8" title="1">{
        return predicate.Funcs{
                UpdateFunc: func(e event.UpdateEvent) bool </span><span class="cov0" title="0">{
                        log := logger.WithValues("predicate", "MachinePoolModelHasChanged", "eventType", "update")

                        oldAmp, ok := e.ObjectOld.(*infrav1exp.AzureMachinePoolMachine)
                        if !ok </span><span class="cov0" title="0">{
                                log.V(4).Info("Expected AzureMachinePoolMachine", "type", e.ObjectOld.GetObjectKind().GroupVersionKind().String())
                                return false
                        }</span>
                        <span class="cov0" title="0">log = log.WithValues("namespace", oldAmp.Namespace, "machinePoolMachine", oldAmp.Name)

                        newAmp := e.ObjectNew.(*infrav1exp.AzureMachinePoolMachine)

                        // if any of these are not equal, run the update
                        shouldUpdate := oldAmp.Status.LatestModelApplied != newAmp.Status.LatestModelApplied ||
                                oldAmp.Status.Version != newAmp.Status.Version ||
                                oldAmp.Status.ProvisioningState != newAmp.Status.ProvisioningState ||
                                oldAmp.Status.Ready != newAmp.Status.Ready

                        if shouldUpdate </span><span class="cov0" title="0">{
                                log.Info("machine pool machine predicate", "shouldUpdate", shouldUpdate)
                        }</span>
                        <span class="cov0" title="0">return shouldUpdate</span>
                },
                CreateFunc:  func(e event.CreateEvent) bool <span class="cov0" title="0">{ return false }</span>,
                DeleteFunc:  func(e event.DeleteEvent) bool <span class="cov0" title="0">{ return false }</span>,
                GenericFunc: func(e event.GenericEvent) bool <span class="cov0" title="0">{ return false }</span>,
        }
}
</pre>
		
		<pre class="file" id="file219" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package env

import (
        "context"
        "fmt"
        "go/build"
        "os"
        "path"
        "path/filepath"
        "regexp"
        goruntime "runtime"
        "strings"

        "github.com/Azure/go-autorest/autorest/to"
        "github.com/go-logr/logr"
        "github.com/onsi/ginkgo"
        "k8s.io/apimachinery/pkg/runtime"
        utilruntime "k8s.io/apimachinery/pkg/util/runtime"
        clientgoscheme "k8s.io/client-go/kubernetes/scheme"
        "k8s.io/client-go/rest"
        "k8s.io/klog/v2"
        infrav1alpha3 "sigs.k8s.io/cluster-api-provider-azure/api/v1alpha3"
        infrav1alpha4 "sigs.k8s.io/cluster-api-provider-azure/api/v1alpha4"
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        infrav1exp "sigs.k8s.io/cluster-api-provider-azure/exp/api/v1beta1"
        "sigs.k8s.io/cluster-api-provider-azure/internal/test/record"
        clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
        expv1 "sigs.k8s.io/cluster-api/exp/api/v1beta1"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/envtest"
        "sigs.k8s.io/controller-runtime/pkg/manager"
)

var (
        logger                 = record.NewLogger(record.WithThreshold(to.IntPtr(1)), record.WithWriter(ginkgo.GinkgoWriter))
        scheme                 = runtime.NewScheme()
        env                    *envtest.Environment
        clusterAPIVersionRegex = regexp.MustCompile(`^(\W)sigs.k8s.io/cluster-api v(.+)`)
)

func init() <span class="cov8" title="1">{
        // Calculate the scheme.
        utilruntime.Must(clientgoscheme.AddToScheme(scheme))
        utilruntime.Must(clusterv1.AddToScheme(scheme))
        utilruntime.Must(expv1.AddToScheme(scheme))
        utilruntime.Must(infrav1.AddToScheme(scheme))
        utilruntime.Must(infrav1exp.AddToScheme(scheme))
        utilruntime.Must(infrav1alpha3.AddToScheme(scheme))
        utilruntime.Must(infrav1alpha4.AddToScheme(scheme))

        // Get the root of the current file to use in CRD paths.
        _, filename, _, _ := goruntime.Caller(0) //nolint:dogsled // Ignore "declaration has 3 blank identifiers" check.
        root := path.Join(path.Dir(filename), "..", "..", "..")

        crdPaths := []string{
                filepath.Join(root, "config", "crd", "bases"),
        }

        if capiPath := getFilePathToCAPICRDs(root); capiPath != "" </span><span class="cov8" title="1">{
                crdPaths = append(crdPaths, capiPath)
        }</span>

        // Create the test environment.
        <span class="cov8" title="1">env = &amp;envtest.Environment{
                ErrorIfCRDPathMissing: true,
                CRDDirectoryPaths:     crdPaths,
        }</span>
}

type (
        // TestEnvironment encapsulates a Kubernetes local test environment.
        TestEnvironment struct {
                manager.Manager
                client.Client
                Config      *rest.Config
                Log         logr.LogSink
                LogRecorder *record.Logger
                doneMgr     chan struct{}
        }
)

// NewTestEnvironment creates a new environment spinning up a local api-server.
//
// This function should be called only once for each package you're running tests within,
// usually the environment is initialized in a suite_test.go file within a `BeforeSuite` ginkgo block.
func NewTestEnvironment() *TestEnvironment <span class="cov0" title="0">{
        if _, err := env.Start(); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">mgr, err := manager.New(env.Config, manager.Options{
                Scheme:             scheme,
                MetricsBindAddress: "0",
        })
        if err != nil </span><span class="cov0" title="0">{
                klog.Fatalf("Failed to start testenv manager: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;TestEnvironment{
                Manager:     mgr,
                Client:      mgr.GetClient(),
                Config:      mgr.GetConfig(),
                LogRecorder: logger,
                Log:         logger,
                doneMgr:     make(chan struct{}),
        }</span>
}

// StartManager starts the test environment manager and blocks until the context is canceled.
func (t *TestEnvironment) StartManager() error <span class="cov0" title="0">{
        return t.Manager.Start(context.Background())
}</span>

// Stop stops the test environment.
func (t *TestEnvironment) Stop() error <span class="cov0" title="0">{
        return env.Stop()
}</span>

func getFilePathToCAPICRDs(root string) string <span class="cov8" title="1">{
        modBits, err := os.ReadFile(filepath.Join(root, "go.mod"))
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">var clusterAPIVersion string
        for _, line := range strings.Split(string(modBits), "\n") </span><span class="cov8" title="1">{
                matches := clusterAPIVersionRegex.FindStringSubmatch(line)
                if len(matches) == 3 </span><span class="cov8" title="1">{
                        clusterAPIVersion = matches[2]
                }</span>
        }

        <span class="cov8" title="1">if clusterAPIVersion == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">gopath := envOr("GOPATH", build.Default.GOPATH)
        return filepath.Join(gopath, "pkg", "mod", "sigs.k8s.io", fmt.Sprintf("cluster-api@v%s", clusterAPIVersion), "config", "crd", "bases")</span>
}

func envOr(envKey, defaultValue string) string <span class="cov8" title="1">{
        if value, ok := os.LookupEnv(envKey); ok </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file220" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package gomega

import (
        "fmt"
        "strings"

        "github.com/google/go-cmp/cmp"
        "github.com/onsi/gomega/matchers"
        "github.com/onsi/gomega/types"
        "sigs.k8s.io/cluster-api-provider-azure/internal/test/record"
)

type (
        logEntryMatcher struct {
                level   *int
                logFunc *string
                values  []interface{}
        }

        // LogMatcher is a Gomega matcher for logs.
        LogMatcher interface {
                types.GomegaMatcher
                WithLevel(int) LogMatcher
                WithLogFunc(string) LogMatcher
        }

        cmpMatcher struct {
                x    interface{}
                diff string
        }
)

// DiffEq will verify cmp.Diff(expected, actual) == "" using github.com/google/go-cmp/cmp.
func DiffEq(x interface{}) types.GomegaMatcher <span class="cov0" title="0">{
        return &amp;cmpMatcher{
                x: x,
        }
}</span>

// Match returns whether the actual value matches the expected value.
func (c *cmpMatcher) Match(actual interface{}) (bool, error) <span class="cov0" title="0">{
        c.diff = cmp.Diff(actual, c.x)
        return c.diff == "", nil
}</span>

// FailWithMessage returns the matcher's diff as the failure message.
func (c *cmpMatcher) FailureMessage(_ interface{}) string <span class="cov0" title="0">{
        return c.diff
}</span>

// NegatedFailureMessage return the matcher's diff as the negated failure message.
func (c *cmpMatcher) NegatedFailureMessage(_ interface{}) string <span class="cov0" title="0">{
        return c.diff
}</span>

// LogContains verifies that LogEntry matches the specified values.
func LogContains(values ...interface{}) LogMatcher <span class="cov8" title="1">{
        return &amp;logEntryMatcher{
                values: values,
        }
}</span>

// WithLevel sets the log level to that specified.
func (l *logEntryMatcher) WithLevel(level int) LogMatcher <span class="cov8" title="1">{
        l.level = &amp;level
        return l
}</span>

// WithLogFunc sets the log function to that specified.
func (l *logEntryMatcher) WithLogFunc(logFunc string) LogMatcher <span class="cov8" title="1">{
        l.logFunc = &amp;logFunc
        return l
}</span>

// Match returns whether the actual value matches the expected value.
func (l *logEntryMatcher) Match(actual interface{}) (bool, error) <span class="cov8" title="1">{
        logEntry, ok := actual.(record.LogEntry)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("LogContains matcher expects an record.LogEntry")
        }</span>
        <span class="cov8" title="1">return len(l.validate(logEntry)) == 0, nil</span>
}

// FailureMessage returns the specified value as a failure message.
func (l *logEntryMatcher) FailureMessage(actual interface{}) string <span class="cov0" title="0">{
        return failMessage(l.validate(actual))
}</span>

// NegatedFailureMessage returns the specified value as a negated failure message.
func (l *logEntryMatcher) NegatedFailureMessage(actual interface{}) string <span class="cov0" title="0">{
        return failMessage(l.validate(actual))
}</span>

func (l *logEntryMatcher) validate(actual interface{}) []error <span class="cov8" title="1">{
        logEntry, ok := actual.(record.LogEntry)
        if !ok </span><span class="cov0" title="0">{
                return []error{fmt.Errorf("expected record.LogEntry, but got %T", actual)}
        }</span>

        <span class="cov8" title="1">var errs []error
        containsValues := matchers.ContainElementsMatcher{Elements: l.values}
        ok, err := containsValues.Match(logEntry.Values)
        if err != nil || !ok </span><span class="cov8" title="1">{
                errs = append(errs, fmt.Errorf("actual log values %q didn't match expected %q", logEntry.Values, l.values))
        }</span>

        <span class="cov8" title="1">if l.logFunc != nil &amp;&amp; *l.logFunc != logEntry.LogFunc </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("actual log Func %q didn't match expected %q", logEntry.LogFunc, *l.logFunc))
        }</span>

        <span class="cov8" title="1">if l.level != nil &amp;&amp; *l.level != logEntry.Level </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("actual log level %q didn't match expected %q", logEntry.Level, *l.level))
        }</span>

        <span class="cov8" title="1">return errs</span>
}

func failMessage(errs []error) string <span class="cov0" title="0">{
        errMsgs := make([]string, len(errs))
        for i, err := range errs </span><span class="cov0" title="0">{
                errMsgs[i] = err.Error()
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("LogEntry errors: %s", strings.Join(errMsgs, ", "))</span>
}
</pre>
		
		<pre class="file" id="file221" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package coalescing

import (
        "context"
        "time"

        "github.com/go-logr/logr"
        "github.com/pkg/errors"
        "sigs.k8s.io/cluster-api-provider-azure/util/cache/ttllru"
        "sigs.k8s.io/cluster-api-provider-azure/util/tele"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

type (
        // ReconcileCache uses and underlying time to live last recently used cache to track high frequency requests.
        // A reconciler should call ShouldProcess to determine if the key has expired. If the key has expired, a zero value
        // time.Time and true is returned. If the key has not expired, the expiration and false is returned. Upon successful
        // reconciliation a reconciler should call Reconciled to update the cache expiry.
        ReconcileCache struct {
                lastSuccessfulReconciliationCache ttllru.PeekingCacher
        }

        // ReconcileCacher describes an interface for determining if a request should be reconciled through a call to
        // ShouldProcess and if ok, reset the cool down through a call to Reconciled.
        ReconcileCacher interface {
                ShouldProcess(key string) (expiration time.Time, ok bool)
                Reconciled(key string)
        }

        // reconciler is the caching reconciler middleware that uses the cache.
        reconciler struct {
                upstream reconcile.Reconciler
                cache    ReconcileCacher
                log      logr.Logger
        }
)

// NewRequestCache creates a new instance of a ReconcileCache given a specified window of expiration.
func NewRequestCache(window time.Duration) (*ReconcileCache, error) <span class="cov0" title="0">{
        cache, err := ttllru.New(1024, window)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to build ttllru cache")
        }</span>

        <span class="cov0" title="0">return &amp;ReconcileCache{
                lastSuccessfulReconciliationCache: cache,
        }, nil</span>
}

// ShouldProcess determines if the key has expired. If the key has expired, a zero value
// time.Time and true is returned. If the key has not expired, the expiration and false is returned.
func (cache *ReconcileCache) ShouldProcess(key string) (time.Time, bool) <span class="cov0" title="0">{
        _, expiration, ok := cache.lastSuccessfulReconciliationCache.Peek(key)
        return expiration, !ok
}</span>

// Reconciled updates the cache expiry for a given key.
func (cache *ReconcileCache) Reconciled(key string) <span class="cov0" title="0">{
        cache.lastSuccessfulReconciliationCache.Add(key, nil)
}</span>

// NewReconciler returns a reconcile wrapper that will delay new reconcile.Requests
// after the cache expiry of the request string key.
// A successful reconciliation is defined as as one where no error is returned.
func NewReconciler(upstream reconcile.Reconciler, cache ReconcileCacher, log logr.Logger) reconcile.Reconciler <span class="cov8" title="1">{
        return &amp;reconciler{
                upstream: upstream,
                cache:    cache,
                log:      log.WithName("CoalescingReconciler"),
        }
}</span>

// Reconcile sends a request to the upstream reconciler if the request is outside of the debounce window.
func (rc *reconciler) Reconcile(ctx context.Context, r reconcile.Request) (reconcile.Result, error) <span class="cov8" title="1">{
        ctx, log, done := tele.StartSpanWithLogger(ctx, "controllers.reconciler.Reconcile",
                tele.KVP("namespace", r.Namespace),
                tele.KVP("name", r.Name),
        )
        defer done()

        log = log.WithValues("request", r.String())

        if expiration, ok := rc.cache.ShouldProcess(r.String()); !ok </span><span class="cov8" title="1">{
                log.V(4).Info("not processing", "expiration", expiration, "timeUntil", time.Until(expiration))
                var requeueAfter = time.Until(expiration)
                if requeueAfter &lt; 1*time.Second </span><span class="cov0" title="0">{
                        requeueAfter = 1 * time.Second
                }</span>
                <span class="cov8" title="1">return reconcile.Result{RequeueAfter: requeueAfter}, nil</span>
        }

        <span class="cov8" title="1">log.V(4).Info("processing")
        result, err := rc.upstream.Reconcile(ctx, r)
        if err != nil </span><span class="cov8" title="1">{
                log.V(4).Info("not successful")
                return result, err
        }</span>

        <span class="cov8" title="1">log.V(4).Info("successful")
        rc.cache.Reconciled(r.String())
        return result, nil</span>
}
</pre>
		
		<pre class="file" id="file222" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package azure

import (
        "fmt"
        "regexp"
        "strings"
)

var azureResourceGroupNameRE = regexp.MustCompile(`.*/subscriptions/(?:.*)/resourceGroups/(.+)/providers/(?:.*)`)

// ConvertResourceGroupNameToLower converts the resource group name in the resource ID to be lowered.
// Inspired by https://github.com/kubernetes-sigs/cloud-provider-azure/blob/88c9b89611e7c1fcbd39266928cce8406eb0e728/pkg/provider/azure_wrap.go#L409
func ConvertResourceGroupNameToLower(resourceID string) (string, error) <span class="cov8" title="1">{
        matches := azureResourceGroupNameRE.FindStringSubmatch(resourceID)
        if len(matches) != 2 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("%q isn't in Azure resource ID format %q", resourceID, azureResourceGroupNameRE.String())
        }</span>

        <span class="cov8" title="1">resourceGroup := matches[1]
        return strings.Replace(resourceID, resourceGroup, strings.ToLower(resourceGroup), 1), nil</span>
}
</pre>
		
		<pre class="file" id="file223" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package ttllru

import (
        "sync"
        "time"

        lru "github.com/hashicorp/golang-lru"
        "github.com/pkg/errors"
)

type (
        // Cache is a TTL LRU cache which caches items with a max time to live and with
        // bounded length.
        Cache struct {
                Cacher
                TimeToLive time.Duration
                mu         sync.Mutex
        }

        // Cacher describes a basic cache.
        Cacher interface {
                Get(key interface{}) (value interface{}, ok bool)
                Add(key interface{}, value interface{}) (evicted bool)
                Remove(key interface{}) (ok bool)
        }

        // PeekingCacher describes a basic cache with the ability to peek.
        PeekingCacher interface {
                Cacher
                Peek(key interface{}) (value interface{}, expiration time.Time, ok bool)
        }

        timeToLiveItem struct {
                LastTouch time.Time
                Value     interface{}
        }
)

// New creates a new TTL LRU cache which caches items with a max time to live and with
// bounded length.
func New(size int, timeToLive time.Duration) (PeekingCacher, error) <span class="cov8" title="1">{
        c, err := lru.New(size)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to build new LRU cache")
        }</span>

        <span class="cov8" title="1">return newCache(timeToLive, c)</span>
}

func newCache(timeToLive time.Duration, cache Cacher) (PeekingCacher, error) <span class="cov8" title="1">{
        return &amp;Cache{
                Cacher:     cache,
                TimeToLive: timeToLive,
        }, nil
}</span>

// Get returns a value and a bool indicating the value was found for a given key.
func (ttlCache *Cache) Get(key interface{}) (value interface{}, ok bool) <span class="cov8" title="1">{
        ttlItem, ok := ttlCache.peekItem(key)
        if !ok </span><span class="cov8" title="1">{
                return nil, false
        }</span>

        <span class="cov8" title="1">ttlItem.LastTouch = time.Now()
        return ttlItem.Value, true</span>
}

// Add will add a value for a given key.
func (ttlCache *Cache) Add(key interface{}, val interface{}) bool <span class="cov8" title="1">{
        ttlCache.mu.Lock()
        defer ttlCache.mu.Unlock()

        return ttlCache.Cacher.Add(key, &amp;timeToLiveItem{
                Value:     val,
                LastTouch: time.Now(),
        })
}</span>

// Peek will fetch an item from the cache, but will not update the expiration time.
func (ttlCache *Cache) Peek(key interface{}) (value interface{}, expiration time.Time, ok bool) <span class="cov0" title="0">{
        ttlItem, ok := ttlCache.peekItem(key)
        if !ok </span><span class="cov0" title="0">{
                return nil, time.Time{}, false
        }</span>

        <span class="cov0" title="0">expirationTime := time.Now().Add(ttlCache.TimeToLive - time.Since(ttlItem.LastTouch))
        return ttlItem.Value, expirationTime, true</span>
}

func (ttlCache *Cache) peekItem(key interface{}) (value *timeToLiveItem, ok bool) <span class="cov8" title="1">{
        ttlCache.mu.Lock()
        defer ttlCache.mu.Unlock()

        val, ok := ttlCache.Cacher.Get(key)
        if !ok </span><span class="cov8" title="1">{
                return nil, false
        }</span>

        <span class="cov8" title="1">ttlItem, ok := val.(*timeToLiveItem)
        if !ok </span><span class="cov8" title="1">{
                return nil, false
        }</span>

        <span class="cov8" title="1">if time.Since(ttlItem.LastTouch) &gt; ttlCache.TimeToLive </span><span class="cov8" title="1">{
                ttlCache.Cacher.Remove(key)
                return nil, false
        }</span>

        <span class="cov8" title="1">return ttlItem, true</span>
}
</pre>
		
		<pre class="file" id="file224" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package futures

import (
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// Getter interface defines methods that an object should implement in order to
// use the futures package for getting long running operation states.
type Getter interface {
        client.Object

        // GetFutures returns the list of long running operation states for an object.
        GetFutures() infrav1.Futures
}

// Get returns the future with the given name, if the future does not exists,
// it returns nil.
func Get(from Getter, name, service string) *infrav1.Future <span class="cov8" title="1">{
        futures := from.GetFutures()
        if futures == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, f := range futures </span><span class="cov8" title="1">{
                if f.Name == name &amp;&amp; f.ServiceName == service </span><span class="cov8" title="1">{
                        return &amp;f
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Has returns true if a future with the given name exists.
func Has(from Getter, name, service string) bool <span class="cov8" title="1">{
        return Get(from, name, service) != nil
}</span>
</pre>
		
		<pre class="file" id="file225" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package futures

import (
        infrav1 "sigs.k8s.io/cluster-api-provider-azure/api/v1beta1"
)

// Setter interface defines methods that an object should implement in order to
// use the futures package for setting futures.
type Setter interface {
        Getter
        SetFutures(infrav1.Futures)
}

// Set sets the given future.
//
// NOTE: If a future already exists, we update it.
func Set(to Setter, future *infrav1.Future) <span class="cov8" title="1">{
        if to == nil || future == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Check if the new future already exists, and update it if it does.
        <span class="cov8" title="1">futures := to.GetFutures()
        exists := false
        for i, f := range futures </span><span class="cov8" title="1">{
                if f.Name == future.Name &amp;&amp; f.ServiceName == future.ServiceName </span><span class="cov8" title="1">{
                        exists = true
                        futures[i] = *future
                        break</span>
                }
        }

        // If the future does not exist, add it.
        <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                futures = append(futures, *future)
        }</span>

        <span class="cov8" title="1">to.SetFutures(futures)</span>
}

// Delete deletes the specified future.
func Delete(to Setter, name, service string) <span class="cov8" title="1">{
        if to == nil || name == "" || service == "" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">futures := to.GetFutures()
        for i, f := range futures </span><span class="cov8" title="1">{
                if f.Name == name &amp;&amp; f.ServiceName == service </span><span class="cov8" title="1">{
                        futures = append(futures[:i], futures[i+1:]...)
                        break</span>
                }
        }

        <span class="cov8" title="1">to.SetFutures(futures)</span>
}
</pre>
		
		<pre class="file" id="file226" style="display: none">/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package maps

import (
        "strings"
)

// FilterByKeyPrefix returns a sub-map of the input that only contains keys starting with 'prefix'.
func FilterByKeyPrefix(input map[string]string, prefix string) map[string]string <span class="cov8" title="1">{
        var result = map[string]string{}
        for key, value := range input </span><span class="cov8" title="1">{
                if strings.HasPrefix(key, prefix) </span><span class="cov8" title="1">{
                        remainingKey := strings.TrimPrefix(key, prefix)
                        if len(remainingKey) &gt; 0 </span><span class="cov8" title="1">{
                                result[remainingKey] = value
                        }</span>
                }
        }
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file227" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package reconciler

import (
        "time"
)

const (
        // DefaultLoopTimeout is the default timeout for a reconcile loop (defaulted to the max ARM template duration).
        DefaultLoopTimeout = 90 * time.Minute
        // DefaultMappingTimeout is the default timeout for a controller request mapping func.
        DefaultMappingTimeout = 60 * time.Second
        // DefaultAzureServiceReconcileTimeout is the default timeout for an Azure service reconcile.
        DefaultAzureServiceReconcileTimeout = 12 * time.Second
        // DefaultAzureCallTimeout is the default timeout for an Azure request after which an Azure operation is considered long running.
        DefaultAzureCallTimeout = 2 * time.Second
        // DefaultReconcilerRequeue is the default value for the reconcile retry.
        DefaultReconcilerRequeue = 15 * time.Second
)

// DefaultedLoopTimeout will default the timeout if it is zero-valued.
func DefaultedLoopTimeout(timeout time.Duration) time.Duration <span class="cov8" title="1">{
        if timeout &lt;= 0 </span><span class="cov8" title="1">{
                return DefaultLoopTimeout
        }</span>

        <span class="cov8" title="1">return timeout</span>
}
</pre>
		
		<pre class="file" id="file228" style="display: none">/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package ssh

import (
        "crypto/rand"
        "crypto/rsa"

        "github.com/pkg/errors"
        "golang.org/x/crypto/ssh"
)

// GenerateSSHKey generates a private and public ssh key.
func GenerateSSHKey() (*rsa.PrivateKey, ssh.PublicKey, error) <span class="cov8" title="1">{
        privateKey, perr := rsa.GenerateKey(rand.Reader, 2048)
        if perr != nil </span><span class="cov0" title="0">{
                return nil, nil, errors.Wrap(perr, "Failed to generate private key")
        }</span>

        <span class="cov8" title="1">publicRsaKey, perr := ssh.NewPublicKey(&amp;privateKey.PublicKey)
        if perr != nil </span><span class="cov0" title="0">{
                return nil, nil, errors.Wrap(perr, "Failed to generate public key")
        }</span>

        <span class="cov8" title="1">return privateKey, publicRsaKey, nil</span>
}
</pre>
		
		<pre class="file" id="file229" style="display: none">/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package system

import "os"

const (
        // NamespaceEnvVarName is the env var coming from DownwardAPI in the manager manifest.
        NamespaceEnvVarName = "POD_NAMESPACE"
        // DefaultNamespace is the default value from manifest.
        DefaultNamespace = "capz-system"
)

// GetManagerNamespace returns the namespace where the controller is running.
func GetManagerNamespace() string <span class="cov8" title="1">{
        managerNamespace := os.Getenv(NamespaceEnvVarName)
        if managerNamespace == "" </span><span class="cov8" title="1">{
                managerNamespace = DefaultNamespace
        }</span>
        <span class="cov8" title="1">return managerNamespace</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
